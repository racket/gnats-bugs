From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Tue Nov 18 07:43:56 2014
Received: from mail-ig0-f179.google.com (mail-ig0-f179.google.com [209.85.213.179])
	by winooski.ccs.neu.edu (8.14.7/8.14.7) with ESMTP id sAIChkjJ029085
	for <bugs@bugs.plt-scheme.org>; Tue, 18 Nov 2014 07:43:46 -0500
Message-Id: <201411181243.sAIChgIR029078@winooski.ccs.neu.edu>
Date: Tue, 18 Nov 2014 07:43:42 -0500
From: gustavo@oma.org.ar
To: bugs@racket-lang.org
Subject: Future visualizer is crashing very frequently

>Number:         14840
>Category:       all
>Synopsis:       Future visualizer is crashing very frequently
>Class:          sw-bug
>Responsible:    nobody
>Severity:       serious
>Priority:       medium
>State:          open
>Confidential:   no
>Arrival-Date:   Tue Nov 18 07:44:01 -0500 2014
>Last-Modified:  Wed Nov 19 08:12:02 -0500 2014
>Originator:     Gustavo Massaccesi
>Organization:
plt
>Submitter-Id:   unknown
>Release:        6.1.1
>Environment:
windows "Windows NT 6.1 (Build 7601) Service Pack 1" (win32\i386\3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 206643796
raco pkg (show):
Installation-wide:
 Package              Checksum                                    Source
 main-distribution    84a366a8c2b2908babe6c2811b0ada036bb159df    (catalog main-distribution)
 racket-lib           436f0928598fc1a8abf27422e8e6588bef45f652    (catalog racket-lib)
 [187 auto-installed packages not shown]
User-specific for installation "6.1.1":
 [none]



Collections:
("C:\\Users\\Nadie\\AppData\\Roaming\\Racket\\6.1.1\\collects"
 (non-existent-path))
("C:\\Program Files\\Racket\\collects"
 (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))

Recent Internal Errors: 
Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t none) (default) #() "#lang racket\n" #f #t ((test) (main)) #t))
>Description:
The future-visualizer is crashing very frequently. I'm using Win7.

Usually it simply crash, but once I got this backtrace. I'm not sure if the problem is here or there is a wrong pointer elsewhere. I couldn't find an example where the crash is easy to reproduce.
>How-To-Repeat:
1) Open DrRacket
2) Copy this program
3) Run
4) Close the future-visualizer
5) Repeat 3) and 4) a few times until it crash.

;;; Program: ------------------
#lang racket
(require racket/future 
         future-visualizer) 

(visualize-futures 
 (let* ([z (random 1)]
        [f (future (lambda () (display z)))]
        [g (future (lambda () (display z)))]) 
   (display z) 
   (touch f)
   (touch g)))

;;; Error: ------------------
event-user-data: contract violation
  expected: event?
  given: 'runtime-thread

C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt: 131:0   
(define (find-fid-for-coords x y nodes vregion)
  (define n (find-node-for-coords x y nodes))
  (if n
      (event-user-data (node-data (drawable-node-node n)))
      #f))

C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-gui.rkt: 243:48   
                                 [click-handler (位 (x y vregion)
                                                  (define fid (find-fid-for-coords 
                                                               x y (graph-layout-nodes creation-tree-layout)
                                                               vregion))
                                                  (cond 
                                                    [(not fid) #f] 
                                                    [else
                                                     (define seg (first-seg-for-fid fid segments))
                                                     (set! tacked-seg seg) 
                                                     (send timeline-panel redraw-everything)
                                                     (post-event listener-table 'segment-click timeline-panel seg) 
                                                     #t]))]

C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\pict-canvas.rkt: 100:4   
    (define/override (on-event event) 
      (define vregion (get-viewable-region)) 
      (define x (+ (viewable-region-x vregion) (/ (send event get-x) scale-factor))) 
      (define y (+ (viewable-region-y vregion) (/ (send event get-y) scale-factor))) 
      (case (send event get-event-type) 
        [(motion) 
         (when mh 
           (when (mh x y vregion) ;Mouse handler returns non-false if a state change requiring redraw occurred 
             (redraw-the-bitmap/maybe-delayed! vregion #:delay 0 #:only-the-overlay? #t)))]
        [(left-up) 
         (when ch (ch x y vregion)) ;Ditto for click handler
         (redraw-the-bitmap/maybe-delayed! vregion #:only-the-overlay? #t)]))

C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2   
  (define (call-with-break-parameterization paramz thunk)
    (unless (break-paramz? paramz)
      (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
    (unless (and (procedure? thunk)
		 (procedure-arity-includes? thunk 0))
      (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
    (begin0
     (with-continuation-mark
	 break-enabled-key
	 (break-paramz-ref paramz 0)
       (begin
	 (check-for-break)
	 (thunk)))
     (check-for-break)))

C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 264:2   
  (define (call-with-exception-handler exnh thunk)
    ;; The `begin0' ensures that we don't overwrite an enclosing
    ;;  exception handler.
    (begin0
     (with-continuation-mark
         exception-handler-key
         exnh
       (thunk))
     (void)))

C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\win32\window.rkt: 767:2   
  (define/public (dispatch-on-event e just-pre?) 
    (cond
     [(other-modal? this e) #t]
     [(call-pre-on-event this e) #t]
     [just-pre? #f]
     [else (when (is-enabled-to-root?) (on-event e)) #t]))

C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2   
  (define (call-with-break-parameterization paramz thunk)
    (unless (break-paramz? paramz)
      (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
    (unless (and (procedure? thunk)
		 (procedure-arity-includes? thunk 0))
      (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
    (begin0
     (with-continuation-mark
	 break-enabled-key
	 (break-paramz-ref paramz 0)
       (begin
	 (check-for-break)
	 (thunk)))
     (check-for-break)))

C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1641:30                                 (位 ()
                                ; =No-Breaks=
                                (send context reset-offer-kill)
                                (send context set-breakables (get-user-thread) (get-user-custodian))
                                (call-with-continuation-prompt
                                 (位 () ; =User=, =Handler=, =No-Breaks=
                                   (call-with-break-parameterization
                                    user-break-parameterization
                                    (位 () (primitive-dispatch-handler eventspace)))))
                                
                                ;; in principle, the line below might cause
                                ;; "race conditions" in the GUI. That is, there might
                                ;; be many little events that the user won't quite
                                ;; be able to break.
                                (send context set-breakables #f #f)))]

C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2   
  (define (call-with-break-parameterization paramz thunk)
    (unless (break-paramz? paramz)
      (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
    (unless (and (procedure? thunk)
		 (procedure-arity-includes? thunk 0))
      (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
    (begin0
     (with-continuation-mark
	 break-enabled-key
	 (break-paramz-ref paramz 0)
       (begin
	 (check-for-break)
	 (thunk)))
     (check-for-break)))

C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6   
      (lambda ()
        ;; communicate the thunk to `really-dispatch-event':
        (define before (current-inexact-milliseconds))
        (when (log-level? event-logger 'debug)
          (log-message event-logger 'debug 
                       (format "starting to handle an event from ~a" (object-name thunk))
                       (gui-event before #f (object-name thunk))))
        (let ([b (box thunk)])
          ;; use the event-dispatch handler:
          (with-continuation-mark dispatch-event-key b
            ((event-dispatch-handler) e))
          ;; if the event-dispatch handler doesn't chain
          ;; to the original one, then do so now:
          (when (unbox b)
            (set-box! b #f)
            (thunk)))
        (define after (current-inexact-milliseconds))
        (when (log-level? event-logger 'debug)
          (log-message event-logger 'debug 
                       (format "handled an event: ~a msec"  
                               (- after before))
                       (gui-event before after (object-name thunk)))))

C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32   
                                (lambda (v)
                                  (when v (handle-event v e))
                                  (yield evt))))

C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1414:17   
                 (let loop () ; =User=, =Handler=, =No-Breaks=
                   ; Wait for something to do
                   (unless (semaphore-try-wait? eval-thread-queue-sema)
                     ; User event callbacks run here; we turn on
                     ;  breaks in the dispatch handler.
                     (yield eval-thread-queue-sema))
                   ; About to eval something
                   (semaphore-wait eval-thread-state-sema)
                   (let ([thunk (car eval-thread-thunks)])
                     (set! eval-thread-thunks (cdr eval-thread-thunks))
                     (semaphore-post eval-thread-state-sema)
                     ; This thunk evals the user's expressions with appropriate
                     ;   protections.
                     (thunk))
                   (loop)))))

C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6   
      (lambda ()
        ;; communicate the thunk to `really-dispatch-event':
        (define before (current-inexact-milliseconds))
        (when (log-level? event-logger 'debug)
          (log-message event-logger 'debug 
                       (format "starting to handle an event from ~a" (object-name thunk))
                       (gui-event before #f (object-name thunk))))
        (let ([b (box thunk)])
          ;; use the event-dispatch handler:
          (with-continuation-mark dispatch-event-key b
            ((event-dispatch-handler) e))
          ;; if the event-dispatch handler doesn't chain
          ;; to the original one, then do so now:
          (when (unbox b)
            (set-box! b #f)
            (thunk)))
        (define after (current-inexact-milliseconds))
        (when (log-level? event-logger 'debug)
          (log-message event-logger 'debug 
                       (format "handled an event: ~a msec"  
                               (- after before))
                       (gui-event before after (object-name thunk)))))

C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32   
                                (lambda (v)
                                  (when v (handle-event v e))
                                  (yield evt))))

C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2   
  (define (call-with-break-parameterization paramz thunk)
    (unless (break-paramz? paramz)
      (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
    (unless (and (procedure? thunk)
		 (procedure-arity-includes? thunk 0))
      (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
    (begin0
     (with-continuation-mark
	 break-enabled-key
	 (break-paramz-ref paramz 0)
       (begin
	 (check-for-break)
	 (thunk)))
     (check-for-break)))

C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 397:18   
                  (let loop ()
                    (call-with-continuation-prompt
                     (lambda ()
                       ;; re-enable breaks (if they are supposed to be enabled):
                       (call-with-break-parameterization
                        break-paramz
                        (lambda () 
                          ;; yield; any abort (including a break exception)
                          ;; will get caught and the loop will yield again
                          (yield (make-semaphore))))))
                    (loop)))))))
>Fix:
>Audit-Trail:
From: Robby Findler <robby@eecs.northwestern.edu>
To: Gustavo Massaccesi <gustavo@oma.org.ar>, bugs <bugs@racket-lang.org>
Cc: nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14840: Future visualizer is crashing very frequently
Date: Tue, 18 Nov 2014 12:46:14 -0600

 I managed to make this happen twice under windows 32bit, but not at
 all under mac os x 64 bit. The crash comes for me when I click on the
 debug backtrace icon next to the error "inexact->exact: no exact
 representation". It opens up something in the visualizer and then
 crashes before finishing the opening.
 
 
 > libracket3mxxxxxxx.dll!sch_vsprintf(char * s=0x0d29c4f0, int maxlen=14040, const char * msg=0x102a7c14, char * args=0x00038514, char * * _s=0x00c3ec4c, Scheme_Object * * _errno_val=0x00000000)  Line 577 + 0x5 bytes C
   libracket3mxxxxxxx.dll!scheme_log_w_data(Scheme_Logger *
 logger=0x11a00748, int level=5, int flags=0, Scheme_Object *
 data=0x0d29c4b8, const char * msg=0x102a7c14, ...)  Line 1082 C
   libracket3mxxxxxxx.dll!log_place_event(const char * what=0x102a7c14,
 const char * tag=0x102a7c34, int has_amount=1, int amount=230676)
 Line 2414 + 0x19 bytes C
   libracket3mxxxxxxx.dll!place_async_send(Scheme_Place_Async_Channel *
 ch=0x03380128, Scheme_Object * uo=0x0d29c490)  Line 3628 + 0x18 bytes
 C
   libracket3mxxxxxxx.dll!place_send(int argc=2, Scheme_Object * *
 args=0x2f543f7c)  Line 3071 + 0x2b bytes C
   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native_fast(Scheme_Object
 * rator=0x00000000, int argc=0, Scheme_Object * * argv=0x00000000)
 Line 1436 + 0x5 bytes C
   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native(Scheme_Object
 * rator=0x00ceb828, int argc=2, Scheme_Object * * argv=0x2f543f7c)
 Line 1445 + 0xc bytes C
   003e098c()
   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 obj=0x00000000, int num_rands=0, Scheme_Object * * rands=0x00000000,
 int get_value=-1)  Line 3147 + 0x26 bytes C
   libracket3mxxxxxxx.dll!apply_k()  Line 1092 + 0x10 bytes C
   libracket3mxxxxxxx.dll!scheme_top_level_do_worker(void * (void)*
 k=0x1008d320, int eb=1, int new_thread=1, Scheme_Dynamic_State *
 dyn_state=0x00000000)  Line 882 + 0x3 bytes C
   libracket3mxxxxxxx.dll!scheme_apply_thread_thunk(Scheme_Object *
 rator=0x0d18b298)  Line 1123 + 0x25 bytes C
   libracket3mxxxxxxx.dll!start_child(Scheme_Thread * volatile
 child=0x0d18b9f8, Scheme_Object * volatile child_eval=0x0d18b298)
 Line 3330 + 0xc bytes C
   libracket3mxxxxxxx.dll!make_subprocess(Scheme_Object *
 child_thunk=0x0d18b298, void * child_start=0x00c3f06c, Scheme_Config *
 config=0x11a006a8, Scheme_Bucket_Table * cells=0x0d18b2d0,
 Scheme_Object * break_cell=0x11a04fc0, Scheme_Custodian *
 mgr=0x00000000, int normal_kill=1)  Line 3429 C
   libracket3mxxxxxxx.dll!scheme_thread_w_details(Scheme_Object *
 thunk=0x00000000, Scheme_Config * config=0x00000000,
 Scheme_Bucket_Table * cells=0x00000000, Scheme_Object *
 break_cell=0x00c3f254, Scheme_Custodian * mgr=0x00000010, int
 suspend_to_kill=12841268)  Line 3714 + 0x2d bytes C
 
 On Tue, Nov 18, 2014 at 6:44 AM,  <gustavo@oma.org.ar> wrote:
 > A new problem report is waiting at
 >   http://bugs.racket-lang.org/query/?cmd=view&pr=14840
 >
 > Reported by Gustavo Massaccesi for release: 6.1.1
 >
 > *** Description:
 > The future-visualizer is crashing very frequently. I'm using Win7.
 >
 > Usually it simply crash, but once I got this backtrace. I'm not sure if the problem is here or there is a wrong pointer elsewhere. I couldn't find an example where the crash is easy to reproduce.
 >
 > *** How to repeat:
 > 1) Open DrRacket
 > 2) Copy this program
 > 3) Run
 > 4) Close the future-visualizer
 > 5) Repeat 3) and 4) a few times until it crash.
 >
 > ;;; Program: ------------------
 > #lang racket
 > (require racket/future
 >          future-visualizer)
 >
 > (visualize-futures
 >  (let* ([z (random 1)]
 >         [f (future (lambda () (display z)))]
 >         [g (future (lambda () (display z)))])
 >    (display z)
 >    (touch f)
 >    (touch g)))
 >
 > ;;; Error: ------------------
 > event-user-data: contract violation
 >   expected: event?
 >   given: 'runtime-thread
 >
 > C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt: 131:0
 > (define (find-fid-for-coords x y nodes vregion)
 >   (define n (find-node-for-coords x y nodes))
 >   (if n
 >       (event-user-data (node-data (drawable-node-node n)))
 >       #f))
 >
 > C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-gui.rkt: 243:48
 >                                  [click-handler (位 (x y vregion)
 >                                                   (define fid (find-fid-for-coords
 >                                                                x y (graph-layout-nodes creation-tree-layout)
 >                                                                vregion))
 >                                                   (cond
 >                                                     [(not fid) #f]
 >                                                     [else
 >                                                      (define seg (first-seg-for-fid fid segments))
 >                                                      (set! tacked-seg seg)
 >                                                      (send timeline-panel redraw-everything)
 >                                                      (post-event listener-table 'segment-click timeline-panel seg)
 >                                                      #t]))]
 >
 > C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\pict-canvas.rkt: 100:4
 >     (define/override (on-event event)
 >       (define vregion (get-viewable-region))
 >       (define x (+ (viewable-region-x vregion) (/ (send event get-x) scale-factor)))
 >       (define y (+ (viewable-region-y vregion) (/ (send event get-y) scale-factor)))
 >       (case (send event get-event-type)
 >         [(motion)
 >          (when mh
 >            (when (mh x y vregion) ;Mouse handler returns non-false if a state change requiring redraw occurred
 >              (redraw-the-bitmap/maybe-delayed! vregion #:delay 0 #:only-the-overlay? #t)))]
 >         [(left-up)
 >          (when ch (ch x y vregion)) ;Ditto for click handler
 >          (redraw-the-bitmap/maybe-delayed! vregion #:only-the-overlay? #t)]))
 >
 > C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >   (define (call-with-break-parameterization paramz thunk)
 >     (unless (break-paramz? paramz)
 >       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >     (unless (and (procedure? thunk)
 >                  (procedure-arity-includes? thunk 0))
 >       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >     (begin0
 >      (with-continuation-mark
 >          break-enabled-key
 >          (break-paramz-ref paramz 0)
 >        (begin
 >          (check-for-break)
 >          (thunk)))
 >      (check-for-break)))
 >
 > C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 264:2
 >   (define (call-with-exception-handler exnh thunk)
 >     ;; The `begin0' ensures that we don't overwrite an enclosing
 >     ;;  exception handler.
 >     (begin0
 >      (with-continuation-mark
 >          exception-handler-key
 >          exnh
 >        (thunk))
 >      (void)))
 >
 > C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\win32\window.rkt: 767:2
 >   (define/public (dispatch-on-event e just-pre?)
 >     (cond
 >      [(other-modal? this e) #t]
 >      [(call-pre-on-event this e) #t]
 >      [just-pre? #f]
 >      [else (when (is-enabled-to-root?) (on-event e)) #t]))
 >
 > C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >   (define (call-with-break-parameterization paramz thunk)
 >     (unless (break-paramz? paramz)
 >       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >     (unless (and (procedure? thunk)
 >                  (procedure-arity-includes? thunk 0))
 >       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >     (begin0
 >      (with-continuation-mark
 >          break-enabled-key
 >          (break-paramz-ref paramz 0)
 >        (begin
 >          (check-for-break)
 >          (thunk)))
 >      (check-for-break)))
 >
 > C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1641:30                                 (位 ()
 >                                 ; =No-Breaks=
 >                                 (send context reset-offer-kill)
 >                                 (send context set-breakables (get-user-thread) (get-user-custodian))
 >                                 (call-with-continuation-prompt
 >                                  (位 () ; =User=, =Handler=, =No-Breaks=
 >                                    (call-with-break-parameterization
 >                                     user-break-parameterization
 >                                     (位 () (primitive-dispatch-handler eventspace)))))
 >
 >                                 ;; in principle, the line below might cause
 >                                 ;; "race conditions" in the GUI. That is, there might
 >                                 ;; be many little events that the user won't quite
 >                                 ;; be able to break.
 >                                 (send context set-breakables #f #f)))]
 >
 > C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >   (define (call-with-break-parameterization paramz thunk)
 >     (unless (break-paramz? paramz)
 >       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >     (unless (and (procedure? thunk)
 >                  (procedure-arity-includes? thunk 0))
 >       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >     (begin0
 >      (with-continuation-mark
 >          break-enabled-key
 >          (break-paramz-ref paramz 0)
 >        (begin
 >          (check-for-break)
 >          (thunk)))
 >      (check-for-break)))
 >
 > C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >       (lambda ()
 >         ;; communicate the thunk to `really-dispatch-event':
 >         (define before (current-inexact-milliseconds))
 >         (when (log-level? event-logger 'debug)
 >           (log-message event-logger 'debug
 >                        (format "starting to handle an event from ~a" (object-name thunk))
 >                        (gui-event before #f (object-name thunk))))
 >         (let ([b (box thunk)])
 >           ;; use the event-dispatch handler:
 >           (with-continuation-mark dispatch-event-key b
 >             ((event-dispatch-handler) e))
 >           ;; if the event-dispatch handler doesn't chain
 >           ;; to the original one, then do so now:
 >           (when (unbox b)
 >             (set-box! b #f)
 >             (thunk)))
 >         (define after (current-inexact-milliseconds))
 >         (when (log-level? event-logger 'debug)
 >           (log-message event-logger 'debug
 >                        (format "handled an event: ~a msec"
 >                                (- after before))
 >                        (gui-event before after (object-name thunk)))))
 >
 > C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >                                 (lambda (v)
 >                                   (when v (handle-event v e))
 >                                   (yield evt))))
 >
 > C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1414:17
 >                  (let loop () ; =User=, =Handler=, =No-Breaks=
 >                    ; Wait for something to do
 >                    (unless (semaphore-try-wait? eval-thread-queue-sema)
 >                      ; User event callbacks run here; we turn on
 >                      ;  breaks in the dispatch handler.
 >                      (yield eval-thread-queue-sema))
 >                    ; About to eval something
 >                    (semaphore-wait eval-thread-state-sema)
 >                    (let ([thunk (car eval-thread-thunks)])
 >                      (set! eval-thread-thunks (cdr eval-thread-thunks))
 >                      (semaphore-post eval-thread-state-sema)
 >                      ; This thunk evals the user's expressions with appropriate
 >                      ;   protections.
 >                      (thunk))
 >                    (loop)))))
 >
 > C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >       (lambda ()
 >         ;; communicate the thunk to `really-dispatch-event':
 >         (define before (current-inexact-milliseconds))
 >         (when (log-level? event-logger 'debug)
 >           (log-message event-logger 'debug
 >                        (format "starting to handle an event from ~a" (object-name thunk))
 >                        (gui-event before #f (object-name thunk))))
 >         (let ([b (box thunk)])
 >           ;; use the event-dispatch handler:
 >           (with-continuation-mark dispatch-event-key b
 >             ((event-dispatch-handler) e))
 >           ;; if the event-dispatch handler doesn't chain
 >           ;; to the original one, then do so now:
 >           (when (unbox b)
 >             (set-box! b #f)
 >             (thunk)))
 >         (define after (current-inexact-milliseconds))
 >         (when (log-level? event-logger 'debug)
 >           (log-message event-logger 'debug
 >                        (format "handled an event: ~a msec"
 >                                (- after before))
 >                        (gui-event before after (object-name thunk)))))
 >
 > C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >                                 (lambda (v)
 >                                   (when v (handle-event v e))
 >                                   (yield evt))))
 >
 > C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >   (define (call-with-break-parameterization paramz thunk)
 >     (unless (break-paramz? paramz)
 >       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >     (unless (and (procedure? thunk)
 >                  (procedure-arity-includes? thunk 0))
 >       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >     (begin0
 >      (with-continuation-mark
 >          break-enabled-key
 >          (break-paramz-ref paramz 0)
 >        (begin
 >          (check-for-break)
 >          (thunk)))
 >      (check-for-break)))
 >
 > C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 397:18
 >                   (let loop ()
 >                     (call-with-continuation-prompt
 >                      (lambda ()
 >                        ;; re-enable breaks (if they are supposed to be enabled):
 >                        (call-with-break-parameterization
 >                         break-paramz
 >                         (lambda ()
 >                           ;; yield; any abort (including a break exception)
 >                           ;; will get caught and the loop will yield again
 >                           (yield (make-semaphore))))))
 >                     (loop)))))))
 >
 > *** Environment:
 > windows "Windows NT 6.1 (Build 7601) Service Pack 1" (win32\i386\3m) (get-display-depth) = 32
 > Human Language: english
 > (current-memory-use) 206643796
 > raco pkg (show):
 > Installation-wide:
 >  Package              Checksum                                    Source
 >  main-distribution    84a366a8c2b2908babe6c2811b0ada036bb159df    (catalog main-distribution)
 >  racket-lib           436f0928598fc1a8abf27422e8e6588bef45f652    (catalog racket-lib)
 >  [187 auto-installed packages not shown]
 > User-specific for installation "6.1.1":
 >  [none]
 >
 >
 >
 > Collections:
 > ("C:\\Users\\Nadie\\AppData\\Roaming\\Racket\\6.1.1\\collects"
 >  (non-existent-path))
 > ("C:\\Program Files\\Racket\\collects"
 >  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))
 >
 > Recent Internal Errors:
 > Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t none) (default) #() "#lang racket\n" #f #t ((test) (main)) #t))
 >
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Gustavo Massaccesi <gustavo@oma.org.ar>, bugs <bugs@racket-lang.org>
Cc: nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14840: Future visualizer is crashing very frequently
Date: Tue, 18 Nov 2014 12:46:40 -0600

 The second stacktrace is here, looks the same I think:
 
 > libracket3mxxxxxxx.dll!sch_vsprintf(char * s=0x0291d5e8, int maxlen=14040, const char * msg=0x102a7c14, char * args=0x00038664, char * * _s=0x00c3ec00, Scheme_Object * * _errno_val=0x00000000)  Line 577 + 0x5 bytes C
   libracket3mxxxxxxx.dll!scheme_log_w_data(Scheme_Logger *
 logger=0x11a00748, int level=5, int flags=0, Scheme_Object *
 data=0x0291d5b0, const char * msg=0x102a7c14, ...)  Line 1082 C
   libracket3mxxxxxxx.dll!log_place_event(const char * what=0x102a7c14,
 const char * tag=0x102a7c34, int has_amount=1, int amount=231012)
 Line 2414 + 0x19 bytes C
   libracket3mxxxxxxx.dll!place_async_send(Scheme_Place_Async_Channel *
 ch=0x03380128, Scheme_Object * uo=0x0291d588)  Line 3628 + 0x18 bytes
 C
   libracket3mxxxxxxx.dll!place_send(int argc=2, Scheme_Object * *
 args=0x35543f7c)  Line 3071 + 0x2b bytes C
   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native_fast(Scheme_Object
 * rator=0x00000000, int argc=0, Scheme_Object * * argv=0x00000000)
 Line 1436 + 0x5 bytes C
   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native(Scheme_Object
 * rator=0x0261b828, int argc=2, Scheme_Object * * argv=0x35543f7c)
 Line 1445 + 0xc bytes C
   00c7098c()
   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 obj=0x00000000, int num_rands=0, Scheme_Object * * rands=0x00000000,
 int get_value=-1)  Line 3147 + 0x26 bytes C
   libracket3mxxxxxxx.dll!apply_k()  Line 1092 + 0x10 bytes C
   libracket3mxxxxxxx.dll!scheme_top_level_do_worker(void * (void)*
 k=0x1008d320, int eb=1, int new_thread=1, Scheme_Dynamic_State *
 dyn_state=0x00000000)  Line 882 + 0x3 bytes C
   libracket3mxxxxxxx.dll!scheme_apply_thread_thunk(Scheme_Object *
 rator=0x029004d8)  Line 1123 + 0x25 bytes C
   libracket3mxxxxxxx.dll!start_child(Scheme_Thread * volatile
 child=0x02900c38, Scheme_Object * volatile child_eval=0x029004d8)
 Line 3330 + 0xc bytes C
   libracket3mxxxxxxx.dll!make_subprocess(Scheme_Object *
 child_thunk=0x029004d8, void * child_start=0x00c3f020, Scheme_Config *
 config=0x11a006a8, Scheme_Bucket_Table * cells=0x02900510,
 Scheme_Object * break_cell=0x11a04fc0, Scheme_Custodian *
 mgr=0x00000000, int normal_kill=1)  Line 3429 C
   libracket3mxxxxxxx.dll!scheme_thread_w_details(Scheme_Object *
 thunk=0x00000000, Scheme_Config * config=0x00000000,
 Scheme_Bucket_Table * cells=0x00c3f0f4, Scheme_Object *
 break_cell=0x00000000, Scheme_Custodian * mgr=0x00000003, int
 suspend_to_kill=12841088)  Line 3714 + 0x2d bytes C
   00000026()
   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native_fast(Scheme_Object
 * rator=0x00000000, int argc=0, Scheme_Object * * argv=0x00000000)
 Line 1436 + 0x5 bytes C
   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native(Scheme_Object
 * rator=0x00d1dd58, int argc=3, Scheme_Object * * argv=0x001a0f08)
 Line 1445 + 0xc bytes C
   00c7098c()
   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 obj=0x00000000, int num_rands=1, Scheme_Object * * rands=0x001a0f1c,
 int get_value=-1)  Line 3147 + 0x26 bytes C
   libracket3mxxxxxxx.dll!_scheme_apply_multi_from_native(Scheme_Object
 * rator=0x0a3518c0, int argc=1, Scheme_Object * * argv=0x001a0f1c)
 Line 1420 + 0x17 bytes C
   033c13a5()
   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 obj=0x00000000, int num_rands=0, Scheme_Object * * rands=0x00000000,
 int get_value=-1)  Line 3147 + 0x26 bytes C
   libracket3mxxxxxxx.dll!scheme_finish_apply_for_prompt(Scheme_Prompt
 * prompt=0x029052c8, Scheme_Object * _prompt_tag=0x11a003e0,
 Scheme_Object * proc=0x029052b0, int argc=0, Scheme_Object * *
 argv=0x00000000)  Line 6768 + 0x1a bytes C
   libracket3mxxxxxxx.dll!scheme_apply_for_prompt(Scheme_Prompt *
 prompt=0x029052c8, Scheme_Object * prompt_tag=0x07c42cb8,
 Scheme_Object * proc=0x029052b0, int argc=0, Scheme_Object * *
 argv=0x00000000)  Line 6839 + 0x20 bytes C
   libracket3mxxxxxxx.dll!call_with_prompt(int in_argc=0, Scheme_Object
 * * in_argv=0x001a0f70)  Line 7319 + 0x1c bytes C
   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native_fast(Scheme_Object
 * rator=0x00000000, int argc=0, Scheme_Object * * argv=0x00000000)
 Line 1436 + 0x5 bytes C
   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native(Scheme_Object
 * rator=0x00d1dd58, int argc=2, Scheme_Object * * argv=0x001a0f70)
 Line 1445 + 0xc bytes C
   00c7098c()
   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 obj=0x00000000, int num_rands=0, Scheme_Object * * rands=0x00000000,
 int get_value=-1)  Line 3147 + 0x26 bytes C
   libracket3mxxxxxxx.dll!scheme_finish_apply_for_prompt(Scheme_Prompt
 * prompt=0x02904790, Scheme_Object * _prompt_tag=0x11a003e0,
 Scheme_Object * proc=0x02905298, int argc=0, Scheme_Object * *
 argv=0x00000000)  Line 6768 + 0x1a bytes C
   libracket3mxxxxxxx.dll!scheme_apply_for_prompt(Scheme_Prompt *
 prompt=0x02904790, Scheme_Object * prompt_tag=0x00140eb0,
 Scheme_Object * proc=0x02905298, int argc=0, Scheme_Object * *
 argv=0x00000000)  Line 6839 + 0x20 bytes C
   libracket3mxxxxxxx.dll!call_with_prompt(int in_argc=0, Scheme_Object
 * * in_argv=0x001a0f88)  Line 7319 + 0x1c bytes C
   033c11ee()
   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 obj=0x00000000, int num_rands=0, Scheme_Object * * rands=0x001a0f9c,
 int get_value=-1)  Line 3147 + 0x26 bytes C
   libracket3mxxxxxxx.dll!force_values(Scheme_Object * obj=0x00000004,
 int multi_ok=0)  Line 999 + 0x29 bytes C
   libracket3mxxxxxxx.dll!scheme_force_value_same_mark(Scheme_Object *
 obj=0x00000004)  Line 1043 + 0x15 bytes C
   00c77af4()
   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 obj=0x00000000, int num_rands=1, Scheme_Object * * rands=0x00c3fc44,
 int get_value=-1)  Line 3147 + 0x26 bytes C
   libracket3mxxxxxxx.dll!_scheme_apply_multi_from_native(Scheme_Object
 * rator=0x086cc7e8, int argc=1, Scheme_Object * * argv=0x00c3fc44)
 Line 1420 + 0x17 bytes C
   00c7092b()
   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 obj=0x00000000, int num_rands=1, Scheme_Object * * rands=0x00c3fc44,
 int get_value=1)  Line 3147 + 0x26 bytes C
   libracket3mxxxxxxx.dll!apply_k()  Line 1093 + 0x26 bytes C
   libracket3mxxxxxxx.dll!scheme_top_level_do_worker(void * (void)*
 k=0x1008d320, int eb=1, int new_thread=0, Scheme_Dynamic_State *
 dyn_state=0x00000000)  Line 882 + 0x3 bytes C
   libracket3mxxxxxxx.dll!scheme_apply(Scheme_Object *
 rator=0x086cc7e8, int num_rands=1, Scheme_Object * * rands=0x00c3fc44)
  Line 1110 + 0x4b bytes C
   DrRacket.exe!finish_cmd_line_run(FinishArgs * fa=0x11a61490, void
 (Scheme_Env *, FinishArgs *)* repl=0x00404890)  Line 23278 + 0x2a
 bytes C
   DrRacket.exe!cont_run(FinishArgs * f=0x03278a30)  Line 24361 + 0xe bytes C
   DrRacket.exe!run_from_cmd_line(int argc=0, char * *
 _argv=0x00d22d98, Scheme_Env * (void)* mk_basic_env=0x0040730b, int
 (FinishArgs *)* cont_run=0x00406ac0)  Line 24157 + 0x14 bytes C
   DrRacket.exe!main_after_stack(void * data=0x00c3feec)  Line 24353 C
   libracket3mxxxxxxx.dll!do_main_stack_setup(int no_auto_statics=1,
 int (void *)* _main=0x00406ae0, void * data=0x00c3feec)  Line 78 + 0x7
 bytes C
   libracket3mxxxxxxx.dll!scheme_main_stack_setup(int
 no_auto_statics=1, int (void *)* _main=0x00406ae0, void *
 data=0x00c3feec)  Line 107 + 0x13 bytes C
   DrRacket.exe!WinMain(HINSTANCE__ * hInstance=0x00400000, HINSTANCE__
 * hPrevInstance=0x00000000, char * ignored=0x00d346a3, int
 nCmdShow=10)  Line 24997 + 0x1f bytes C
   DrRacket.exe!__tmainCRTStartup()  Line 263 + 0x1b bytes C
   kernel32.dll!75eb338a()
   [Frames below may be incorrect and/or missing, no symbols loaded for
 kernel32.dll]
   ntdll.dll!77219f72()
   ntdll.dll!77219f45()
From: Gustavo Massaccesi <gustavo@oma.org.ar>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14840: Future visualizer is crashing very frequently
Date: Tue, 18 Nov 2014 17:28:24 -0300

 I'm using Win 7, 32 bits.
 
 I got a reproducible error (that most of the times don't produce a
 direct crash).
 
 1) Open DrRacket
 2) Copy "the" program
 3) Run
 4) In the future-visualizer, go to the "Future Creation Tree" and
 click in the topmost circle (labeled "RTT")
 5) An error appears in the DrRacket interaction window:
 
 ..\..\..\Program
 Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt:131:0:
 
 event-user-data: contract violation
   expected: event?
   given: 'runtime-thread
 
 Gustavo
 
 
 On Tue, Nov 18, 2014 at 3:46 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > I managed to make this happen twice under windows 32bit, but not at
 > all under mac os x 64 bit. The crash comes for me when I click on the
 > debug backtrace icon next to the error "inexact->exact: no exact
 > representation". It opens up something in the visualizer and then
 > crashes before finishing the opening.
 >
 >
 >> libracket3mxxxxxxx.dll!sch_vsprintf(char * s=0x0d29c4f0, int maxlen=14040, const char * msg=0x102a7c14, char * args=0x00038514, char * * _s=0x00c3ec4c, Scheme_Object * * _errno_val=0x00000000)  Line 577 + 0x5 bytes C
 >   libracket3mxxxxxxx.dll!scheme_log_w_data(Scheme_Logger *
 > logger=0x11a00748, int level=5, int flags=0, Scheme_Object *
 > data=0x0d29c4b8, const char * msg=0x102a7c14, ...)  Line 1082 C
 >   libracket3mxxxxxxx.dll!log_place_event(const char * what=0x102a7c14,
 > const char * tag=0x102a7c34, int has_amount=1, int amount=230676)
 > Line 2414 + 0x19 bytes C
 >   libracket3mxxxxxxx.dll!place_async_send(Scheme_Place_Async_Channel *
 > ch=0x03380128, Scheme_Object * uo=0x0d29c490)  Line 3628 + 0x18 bytes
 > C
 >   libracket3mxxxxxxx.dll!place_send(int argc=2, Scheme_Object * *
 > args=0x2f543f7c)  Line 3071 + 0x2b bytes C
 >   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native_fast(Scheme_Object
 > * rator=0x00000000, int argc=0, Scheme_Object * * argv=0x00000000)
 > Line 1436 + 0x5 bytes C
 >   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native(Scheme_Object
 > * rator=0x00ceb828, int argc=2, Scheme_Object * * argv=0x2f543f7c)
 > Line 1445 + 0xc bytes C
 >   003e098c()
 >   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 > obj=0x00000000, int num_rands=0, Scheme_Object * * rands=0x00000000,
 > int get_value=-1)  Line 3147 + 0x26 bytes C
 >   libracket3mxxxxxxx.dll!apply_k()  Line 1092 + 0x10 bytes C
 >   libracket3mxxxxxxx.dll!scheme_top_level_do_worker(void * (void)*
 > k=0x1008d320, int eb=1, int new_thread=1, Scheme_Dynamic_State *
 > dyn_state=0x00000000)  Line 882 + 0x3 bytes C
 >   libracket3mxxxxxxx.dll!scheme_apply_thread_thunk(Scheme_Object *
 > rator=0x0d18b298)  Line 1123 + 0x25 bytes C
 >   libracket3mxxxxxxx.dll!start_child(Scheme_Thread * volatile
 > child=0x0d18b9f8, Scheme_Object * volatile child_eval=0x0d18b298)
 > Line 3330 + 0xc bytes C
 >   libracket3mxxxxxxx.dll!make_subprocess(Scheme_Object *
 > child_thunk=0x0d18b298, void * child_start=0x00c3f06c, Scheme_Config *
 > config=0x11a006a8, Scheme_Bucket_Table * cells=0x0d18b2d0,
 > Scheme_Object * break_cell=0x11a04fc0, Scheme_Custodian *
 > mgr=0x00000000, int normal_kill=1)  Line 3429 C
 >   libracket3mxxxxxxx.dll!scheme_thread_w_details(Scheme_Object *
 > thunk=0x00000000, Scheme_Config * config=0x00000000,
 > Scheme_Bucket_Table * cells=0x00000000, Scheme_Object *
 > break_cell=0x00c3f254, Scheme_Custodian * mgr=0x00000010, int
 > suspend_to_kill=12841268)  Line 3714 + 0x2d bytes C
 >
 > On Tue, Nov 18, 2014 at 6:44 AM,  <gustavo@oma.org.ar> wrote:
 >> A new problem report is waiting at
 >>   http://bugs.racket-lang.org/query/?cmd=view&pr=14840
 >>
 >> Reported by Gustavo Massaccesi for release: 6.1.1
 >>
 >> *** Description:
 >> The future-visualizer is crashing very frequently. I'm using Win7.
 >>
 >> Usually it simply crash, but once I got this backtrace. I'm not sure if the problem is here or there is a wrong pointer elsewhere. I couldn't find an example where the crash is easy to reproduce.
 >>
 >> *** How to repeat:
 >> 1) Open DrRacket
 >> 2) Copy this program
 >> 3) Run
 >> 4) Close the future-visualizer
 >> 5) Repeat 3) and 4) a few times until it crash.
 >>
 >> ;;; Program: ------------------
 >> #lang racket
 >> (require racket/future
 >>          future-visualizer)
 >>
 >> (visualize-futures
 >>  (let* ([z (random 1)]
 >>         [f (future (lambda () (display z)))]
 >>         [g (future (lambda () (display z)))])
 >>    (display z)
 >>    (touch f)
 >>    (touch g)))
 >>
 >> ;;; Error: ------------------
 >> event-user-data: contract violation
 >>   expected: event?
 >>   given: 'runtime-thread
 >>
 >> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt: 131:0
 >> (define (find-fid-for-coords x y nodes vregion)
 >>   (define n (find-node-for-coords x y nodes))
 >>   (if n
 >>       (event-user-data (node-data (drawable-node-node n)))
 >>       #f))
 >>
 >> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-gui.rkt: 243:48
 >>                                  [click-handler (位 (x y vregion)
 >>                                                   (define fid (find-fid-for-coords
 >>                                                                x y (graph-layout-nodes creation-tree-layout)
 >>                                                                vregion))
 >>                                                   (cond
 >>                                                     [(not fid) #f]
 >>                                                     [else
 >>                                                      (define seg (first-seg-for-fid fid segments))
 >>                                                      (set! tacked-seg seg)
 >>                                                      (send timeline-panel redraw-everything)
 >>                                                      (post-event listener-table 'segment-click timeline-panel seg)
 >>                                                      #t]))]
 >>
 >> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\pict-canvas.rkt: 100:4
 >>     (define/override (on-event event)
 >>       (define vregion (get-viewable-region))
 >>       (define x (+ (viewable-region-x vregion) (/ (send event get-x) scale-factor)))
 >>       (define y (+ (viewable-region-y vregion) (/ (send event get-y) scale-factor)))
 >>       (case (send event get-event-type)
 >>         [(motion)
 >>          (when mh
 >>            (when (mh x y vregion) ;Mouse handler returns non-false if a state change requiring redraw occurred
 >>              (redraw-the-bitmap/maybe-delayed! vregion #:delay 0 #:only-the-overlay? #t)))]
 >>         [(left-up)
 >>          (when ch (ch x y vregion)) ;Ditto for click handler
 >>          (redraw-the-bitmap/maybe-delayed! vregion #:only-the-overlay? #t)]))
 >>
 >> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>   (define (call-with-break-parameterization paramz thunk)
 >>     (unless (break-paramz? paramz)
 >>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>     (unless (and (procedure? thunk)
 >>                  (procedure-arity-includes? thunk 0))
 >>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>     (begin0
 >>      (with-continuation-mark
 >>          break-enabled-key
 >>          (break-paramz-ref paramz 0)
 >>        (begin
 >>          (check-for-break)
 >>          (thunk)))
 >>      (check-for-break)))
 >>
 >> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 264:2
 >>   (define (call-with-exception-handler exnh thunk)
 >>     ;; The `begin0' ensures that we don't overwrite an enclosing
 >>     ;;  exception handler.
 >>     (begin0
 >>      (with-continuation-mark
 >>          exception-handler-key
 >>          exnh
 >>        (thunk))
 >>      (void)))
 >>
 >> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\win32\window.rkt: 767:2
 >>   (define/public (dispatch-on-event e just-pre?)
 >>     (cond
 >>      [(other-modal? this e) #t]
 >>      [(call-pre-on-event this e) #t]
 >>      [just-pre? #f]
 >>      [else (when (is-enabled-to-root?) (on-event e)) #t]))
 >>
 >> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>   (define (call-with-break-parameterization paramz thunk)
 >>     (unless (break-paramz? paramz)
 >>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>     (unless (and (procedure? thunk)
 >>                  (procedure-arity-includes? thunk 0))
 >>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>     (begin0
 >>      (with-continuation-mark
 >>          break-enabled-key
 >>          (break-paramz-ref paramz 0)
 >>        (begin
 >>          (check-for-break)
 >>          (thunk)))
 >>      (check-for-break)))
 >>
 >> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1641:30                                 (位 ()
 >>                                 ; =No-Breaks=
 >>                                 (send context reset-offer-kill)
 >>                                 (send context set-breakables (get-user-thread) (get-user-custodian))
 >>                                 (call-with-continuation-prompt
 >>                                  (位 () ; =User=, =Handler=, =No-Breaks=
 >>                                    (call-with-break-parameterization
 >>                                     user-break-parameterization
 >>                                     (位 () (primitive-dispatch-handler eventspace)))))
 >>
 >>                                 ;; in principle, the line below might cause
 >>                                 ;; "race conditions" in the GUI. That is, there might
 >>                                 ;; be many little events that the user won't quite
 >>                                 ;; be able to break.
 >>                                 (send context set-breakables #f #f)))]
 >>
 >> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>   (define (call-with-break-parameterization paramz thunk)
 >>     (unless (break-paramz? paramz)
 >>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>     (unless (and (procedure? thunk)
 >>                  (procedure-arity-includes? thunk 0))
 >>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>     (begin0
 >>      (with-continuation-mark
 >>          break-enabled-key
 >>          (break-paramz-ref paramz 0)
 >>        (begin
 >>          (check-for-break)
 >>          (thunk)))
 >>      (check-for-break)))
 >>
 >> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >>       (lambda ()
 >>         ;; communicate the thunk to `really-dispatch-event':
 >>         (define before (current-inexact-milliseconds))
 >>         (when (log-level? event-logger 'debug)
 >>           (log-message event-logger 'debug
 >>                        (format "starting to handle an event from ~a" (object-name thunk))
 >>                        (gui-event before #f (object-name thunk))))
 >>         (let ([b (box thunk)])
 >>           ;; use the event-dispatch handler:
 >>           (with-continuation-mark dispatch-event-key b
 >>             ((event-dispatch-handler) e))
 >>           ;; if the event-dispatch handler doesn't chain
 >>           ;; to the original one, then do so now:
 >>           (when (unbox b)
 >>             (set-box! b #f)
 >>             (thunk)))
 >>         (define after (current-inexact-milliseconds))
 >>         (when (log-level? event-logger 'debug)
 >>           (log-message event-logger 'debug
 >>                        (format "handled an event: ~a msec"
 >>                                (- after before))
 >>                        (gui-event before after (object-name thunk)))))
 >>
 >> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >>                                 (lambda (v)
 >>                                   (when v (handle-event v e))
 >>                                   (yield evt))))
 >>
 >> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1414:17
 >>                  (let loop () ; =User=, =Handler=, =No-Breaks=
 >>                    ; Wait for something to do
 >>                    (unless (semaphore-try-wait? eval-thread-queue-sema)
 >>                      ; User event callbacks run here; we turn on
 >>                      ;  breaks in the dispatch handler.
 >>                      (yield eval-thread-queue-sema))
 >>                    ; About to eval something
 >>                    (semaphore-wait eval-thread-state-sema)
 >>                    (let ([thunk (car eval-thread-thunks)])
 >>                      (set! eval-thread-thunks (cdr eval-thread-thunks))
 >>                      (semaphore-post eval-thread-state-sema)
 >>                      ; This thunk evals the user's expressions with appropriate
 >>                      ;   protections.
 >>                      (thunk))
 >>                    (loop)))))
 >>
 >> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >>       (lambda ()
 >>         ;; communicate the thunk to `really-dispatch-event':
 >>         (define before (current-inexact-milliseconds))
 >>         (when (log-level? event-logger 'debug)
 >>           (log-message event-logger 'debug
 >>                        (format "starting to handle an event from ~a" (object-name thunk))
 >>                        (gui-event before #f (object-name thunk))))
 >>         (let ([b (box thunk)])
 >>           ;; use the event-dispatch handler:
 >>           (with-continuation-mark dispatch-event-key b
 >>             ((event-dispatch-handler) e))
 >>           ;; if the event-dispatch handler doesn't chain
 >>           ;; to the original one, then do so now:
 >>           (when (unbox b)
 >>             (set-box! b #f)
 >>             (thunk)))
 >>         (define after (current-inexact-milliseconds))
 >>         (when (log-level? event-logger 'debug)
 >>           (log-message event-logger 'debug
 >>                        (format "handled an event: ~a msec"
 >>                                (- after before))
 >>                        (gui-event before after (object-name thunk)))))
 >>
 >> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >>                                 (lambda (v)
 >>                                   (when v (handle-event v e))
 >>                                   (yield evt))))
 >>
 >> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>   (define (call-with-break-parameterization paramz thunk)
 >>     (unless (break-paramz? paramz)
 >>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>     (unless (and (procedure? thunk)
 >>                  (procedure-arity-includes? thunk 0))
 >>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>     (begin0
 >>      (with-continuation-mark
 >>          break-enabled-key
 >>          (break-paramz-ref paramz 0)
 >>        (begin
 >>          (check-for-break)
 >>          (thunk)))
 >>      (check-for-break)))
 >>
 >> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 397:18
 >>                   (let loop ()
 >>                     (call-with-continuation-prompt
 >>                      (lambda ()
 >>                        ;; re-enable breaks (if they are supposed to be enabled):
 >>                        (call-with-break-parameterization
 >>                         break-paramz
 >>                         (lambda ()
 >>                           ;; yield; any abort (including a break exception)
 >>                           ;; will get caught and the loop will yield again
 >>                           (yield (make-semaphore))))))
 >>                     (loop)))))))
 >>
 >> *** Environment:
 >> windows "Windows NT 6.1 (Build 7601) Service Pack 1" (win32\i386\3m) (get-display-depth) = 32
 >> Human Language: english
 >> (current-memory-use) 206643796
 >> raco pkg (show):
 >> Installation-wide:
 >>  Package              Checksum                                    Source
 >>  main-distribution    84a366a8c2b2908babe6c2811b0ada036bb159df    (catalog main-distribution)
 >>  racket-lib           436f0928598fc1a8abf27422e8e6588bef45f652    (catalog racket-lib)
 >>  [187 auto-installed packages not shown]
 >> User-specific for installation "6.1.1":
 >>  [none]
 >>
 >>
 >>
 >> Collections:
 >> ("C:\\Users\\Nadie\\AppData\\Roaming\\Racket\\6.1.1\\collects"
 >>  (non-existent-path))
 >> ("C:\\Program Files\\Racket\\collects"
 >>  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))
 >>
 >> Recent Internal Errors:
 >> Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t none) (default) #() "#lang racket\n" #f #t ((test) (main)) #t))
 >>
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Gustavo Massaccesi <gustavo@oma.org.ar>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14840: Future visualizer is crashing very frequently
Date: Tue, 18 Nov 2014 14:36:34 -0600

 I can't get that one. I did keep getting an inexact->exact error, however.
 
 If this looks like a memory corruption bug, then I guess that these
 errors are red herrings. But I can't really tell in this case.
 
 Robby
 
 On Tue, Nov 18, 2014 at 2:28 PM, Gustavo Massaccesi <gustavo@oma.org.ar> wrote:
 > I'm using Win 7, 32 bits.
 >
 > I got a reproducible error (that most of the times don't produce a
 > direct crash).
 >
 > 1) Open DrRacket
 > 2) Copy "the" program
 > 3) Run
 > 4) In the future-visualizer, go to the "Future Creation Tree" and
 > click in the topmost circle (labeled "RTT")
 > 5) An error appears in the DrRacket interaction window:
 >
 > ..\..\..\Program
 > Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt:131:0:
 >
 > event-user-data: contract violation
 >   expected: event?
 >   given: 'runtime-thread
 >
 > Gustavo
 >
 >
 > On Tue, Nov 18, 2014 at 3:46 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> I managed to make this happen twice under windows 32bit, but not at
 >> all under mac os x 64 bit. The crash comes for me when I click on the
 >> debug backtrace icon next to the error "inexact->exact: no exact
 >> representation". It opens up something in the visualizer and then
 >> crashes before finishing the opening.
 >>
 >>
 >>> libracket3mxxxxxxx.dll!sch_vsprintf(char * s=0x0d29c4f0, int maxlen=14040, const char * msg=0x102a7c14, char * args=0x00038514, char * * _s=0x00c3ec4c, Scheme_Object * * _errno_val=0x00000000)  Line 577 + 0x5 bytes C
 >>   libracket3mxxxxxxx.dll!scheme_log_w_data(Scheme_Logger *
 >> logger=0x11a00748, int level=5, int flags=0, Scheme_Object *
 >> data=0x0d29c4b8, const char * msg=0x102a7c14, ...)  Line 1082 C
 >>   libracket3mxxxxxxx.dll!log_place_event(const char * what=0x102a7c14,
 >> const char * tag=0x102a7c34, int has_amount=1, int amount=230676)
 >> Line 2414 + 0x19 bytes C
 >>   libracket3mxxxxxxx.dll!place_async_send(Scheme_Place_Async_Channel *
 >> ch=0x03380128, Scheme_Object * uo=0x0d29c490)  Line 3628 + 0x18 bytes
 >> C
 >>   libracket3mxxxxxxx.dll!place_send(int argc=2, Scheme_Object * *
 >> args=0x2f543f7c)  Line 3071 + 0x2b bytes C
 >>   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native_fast(Scheme_Object
 >> * rator=0x00000000, int argc=0, Scheme_Object * * argv=0x00000000)
 >> Line 1436 + 0x5 bytes C
 >>   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native(Scheme_Object
 >> * rator=0x00ceb828, int argc=2, Scheme_Object * * argv=0x2f543f7c)
 >> Line 1445 + 0xc bytes C
 >>   003e098c()
 >>   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 >> obj=0x00000000, int num_rands=0, Scheme_Object * * rands=0x00000000,
 >> int get_value=-1)  Line 3147 + 0x26 bytes C
 >>   libracket3mxxxxxxx.dll!apply_k()  Line 1092 + 0x10 bytes C
 >>   libracket3mxxxxxxx.dll!scheme_top_level_do_worker(void * (void)*
 >> k=0x1008d320, int eb=1, int new_thread=1, Scheme_Dynamic_State *
 >> dyn_state=0x00000000)  Line 882 + 0x3 bytes C
 >>   libracket3mxxxxxxx.dll!scheme_apply_thread_thunk(Scheme_Object *
 >> rator=0x0d18b298)  Line 1123 + 0x25 bytes C
 >>   libracket3mxxxxxxx.dll!start_child(Scheme_Thread * volatile
 >> child=0x0d18b9f8, Scheme_Object * volatile child_eval=0x0d18b298)
 >> Line 3330 + 0xc bytes C
 >>   libracket3mxxxxxxx.dll!make_subprocess(Scheme_Object *
 >> child_thunk=0x0d18b298, void * child_start=0x00c3f06c, Scheme_Config *
 >> config=0x11a006a8, Scheme_Bucket_Table * cells=0x0d18b2d0,
 >> Scheme_Object * break_cell=0x11a04fc0, Scheme_Custodian *
 >> mgr=0x00000000, int normal_kill=1)  Line 3429 C
 >>   libracket3mxxxxxxx.dll!scheme_thread_w_details(Scheme_Object *
 >> thunk=0x00000000, Scheme_Config * config=0x00000000,
 >> Scheme_Bucket_Table * cells=0x00000000, Scheme_Object *
 >> break_cell=0x00c3f254, Scheme_Custodian * mgr=0x00000010, int
 >> suspend_to_kill=12841268)  Line 3714 + 0x2d bytes C
 >>
 >> On Tue, Nov 18, 2014 at 6:44 AM,  <gustavo@oma.org.ar> wrote:
 >>> A new problem report is waiting at
 >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14840
 >>>
 >>> Reported by Gustavo Massaccesi for release: 6.1.1
 >>>
 >>> *** Description:
 >>> The future-visualizer is crashing very frequently. I'm using Win7.
 >>>
 >>> Usually it simply crash, but once I got this backtrace. I'm not sure if the problem is here or there is a wrong pointer elsewhere. I couldn't find an example where the crash is easy to reproduce.
 >>>
 >>> *** How to repeat:
 >>> 1) Open DrRacket
 >>> 2) Copy this program
 >>> 3) Run
 >>> 4) Close the future-visualizer
 >>> 5) Repeat 3) and 4) a few times until it crash.
 >>>
 >>> ;;; Program: ------------------
 >>> #lang racket
 >>> (require racket/future
 >>>          future-visualizer)
 >>>
 >>> (visualize-futures
 >>>  (let* ([z (random 1)]
 >>>         [f (future (lambda () (display z)))]
 >>>         [g (future (lambda () (display z)))])
 >>>    (display z)
 >>>    (touch f)
 >>>    (touch g)))
 >>>
 >>> ;;; Error: ------------------
 >>> event-user-data: contract violation
 >>>   expected: event?
 >>>   given: 'runtime-thread
 >>>
 >>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt: 131:0
 >>> (define (find-fid-for-coords x y nodes vregion)
 >>>   (define n (find-node-for-coords x y nodes))
 >>>   (if n
 >>>       (event-user-data (node-data (drawable-node-node n)))
 >>>       #f))
 >>>
 >>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-gui.rkt: 243:48
 >>>                                  [click-handler (位 (x y vregion)
 >>>                                                   (define fid (find-fid-for-coords
 >>>                                                                x y (graph-layout-nodes creation-tree-layout)
 >>>                                                                vregion))
 >>>                                                   (cond
 >>>                                                     [(not fid) #f]
 >>>                                                     [else
 >>>                                                      (define seg (first-seg-for-fid fid segments))
 >>>                                                      (set! tacked-seg seg)
 >>>                                                      (send timeline-panel redraw-everything)
 >>>                                                      (post-event listener-table 'segment-click timeline-panel seg)
 >>>                                                      #t]))]
 >>>
 >>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\pict-canvas.rkt: 100:4
 >>>     (define/override (on-event event)
 >>>       (define vregion (get-viewable-region))
 >>>       (define x (+ (viewable-region-x vregion) (/ (send event get-x) scale-factor)))
 >>>       (define y (+ (viewable-region-y vregion) (/ (send event get-y) scale-factor)))
 >>>       (case (send event get-event-type)
 >>>         [(motion)
 >>>          (when mh
 >>>            (when (mh x y vregion) ;Mouse handler returns non-false if a state change requiring redraw occurred
 >>>              (redraw-the-bitmap/maybe-delayed! vregion #:delay 0 #:only-the-overlay? #t)))]
 >>>         [(left-up)
 >>>          (when ch (ch x y vregion)) ;Ditto for click handler
 >>>          (redraw-the-bitmap/maybe-delayed! vregion #:only-the-overlay? #t)]))
 >>>
 >>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>   (define (call-with-break-parameterization paramz thunk)
 >>>     (unless (break-paramz? paramz)
 >>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>     (unless (and (procedure? thunk)
 >>>                  (procedure-arity-includes? thunk 0))
 >>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>     (begin0
 >>>      (with-continuation-mark
 >>>          break-enabled-key
 >>>          (break-paramz-ref paramz 0)
 >>>        (begin
 >>>          (check-for-break)
 >>>          (thunk)))
 >>>      (check-for-break)))
 >>>
 >>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 264:2
 >>>   (define (call-with-exception-handler exnh thunk)
 >>>     ;; The `begin0' ensures that we don't overwrite an enclosing
 >>>     ;;  exception handler.
 >>>     (begin0
 >>>      (with-continuation-mark
 >>>          exception-handler-key
 >>>          exnh
 >>>        (thunk))
 >>>      (void)))
 >>>
 >>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\win32\window.rkt: 767:2
 >>>   (define/public (dispatch-on-event e just-pre?)
 >>>     (cond
 >>>      [(other-modal? this e) #t]
 >>>      [(call-pre-on-event this e) #t]
 >>>      [just-pre? #f]
 >>>      [else (when (is-enabled-to-root?) (on-event e)) #t]))
 >>>
 >>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>   (define (call-with-break-parameterization paramz thunk)
 >>>     (unless (break-paramz? paramz)
 >>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>     (unless (and (procedure? thunk)
 >>>                  (procedure-arity-includes? thunk 0))
 >>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>     (begin0
 >>>      (with-continuation-mark
 >>>          break-enabled-key
 >>>          (break-paramz-ref paramz 0)
 >>>        (begin
 >>>          (check-for-break)
 >>>          (thunk)))
 >>>      (check-for-break)))
 >>>
 >>> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1641:30                                 (位 ()
 >>>                                 ; =No-Breaks=
 >>>                                 (send context reset-offer-kill)
 >>>                                 (send context set-breakables (get-user-thread) (get-user-custodian))
 >>>                                 (call-with-continuation-prompt
 >>>                                  (位 () ; =User=, =Handler=, =No-Breaks=
 >>>                                    (call-with-break-parameterization
 >>>                                     user-break-parameterization
 >>>                                     (位 () (primitive-dispatch-handler eventspace)))))
 >>>
 >>>                                 ;; in principle, the line below might cause
 >>>                                 ;; "race conditions" in the GUI. That is, there might
 >>>                                 ;; be many little events that the user won't quite
 >>>                                 ;; be able to break.
 >>>                                 (send context set-breakables #f #f)))]
 >>>
 >>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>   (define (call-with-break-parameterization paramz thunk)
 >>>     (unless (break-paramz? paramz)
 >>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>     (unless (and (procedure? thunk)
 >>>                  (procedure-arity-includes? thunk 0))
 >>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>     (begin0
 >>>      (with-continuation-mark
 >>>          break-enabled-key
 >>>          (break-paramz-ref paramz 0)
 >>>        (begin
 >>>          (check-for-break)
 >>>          (thunk)))
 >>>      (check-for-break)))
 >>>
 >>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >>>       (lambda ()
 >>>         ;; communicate the thunk to `really-dispatch-event':
 >>>         (define before (current-inexact-milliseconds))
 >>>         (when (log-level? event-logger 'debug)
 >>>           (log-message event-logger 'debug
 >>>                        (format "starting to handle an event from ~a" (object-name thunk))
 >>>                        (gui-event before #f (object-name thunk))))
 >>>         (let ([b (box thunk)])
 >>>           ;; use the event-dispatch handler:
 >>>           (with-continuation-mark dispatch-event-key b
 >>>             ((event-dispatch-handler) e))
 >>>           ;; if the event-dispatch handler doesn't chain
 >>>           ;; to the original one, then do so now:
 >>>           (when (unbox b)
 >>>             (set-box! b #f)
 >>>             (thunk)))
 >>>         (define after (current-inexact-milliseconds))
 >>>         (when (log-level? event-logger 'debug)
 >>>           (log-message event-logger 'debug
 >>>                        (format "handled an event: ~a msec"
 >>>                                (- after before))
 >>>                        (gui-event before after (object-name thunk)))))
 >>>
 >>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >>>                                 (lambda (v)
 >>>                                   (when v (handle-event v e))
 >>>                                   (yield evt))))
 >>>
 >>> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1414:17
 >>>                  (let loop () ; =User=, =Handler=, =No-Breaks=
 >>>                    ; Wait for something to do
 >>>                    (unless (semaphore-try-wait? eval-thread-queue-sema)
 >>>                      ; User event callbacks run here; we turn on
 >>>                      ;  breaks in the dispatch handler.
 >>>                      (yield eval-thread-queue-sema))
 >>>                    ; About to eval something
 >>>                    (semaphore-wait eval-thread-state-sema)
 >>>                    (let ([thunk (car eval-thread-thunks)])
 >>>                      (set! eval-thread-thunks (cdr eval-thread-thunks))
 >>>                      (semaphore-post eval-thread-state-sema)
 >>>                      ; This thunk evals the user's expressions with appropriate
 >>>                      ;   protections.
 >>>                      (thunk))
 >>>                    (loop)))))
 >>>
 >>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >>>       (lambda ()
 >>>         ;; communicate the thunk to `really-dispatch-event':
 >>>         (define before (current-inexact-milliseconds))
 >>>         (when (log-level? event-logger 'debug)
 >>>           (log-message event-logger 'debug
 >>>                        (format "starting to handle an event from ~a" (object-name thunk))
 >>>                        (gui-event before #f (object-name thunk))))
 >>>         (let ([b (box thunk)])
 >>>           ;; use the event-dispatch handler:
 >>>           (with-continuation-mark dispatch-event-key b
 >>>             ((event-dispatch-handler) e))
 >>>           ;; if the event-dispatch handler doesn't chain
 >>>           ;; to the original one, then do so now:
 >>>           (when (unbox b)
 >>>             (set-box! b #f)
 >>>             (thunk)))
 >>>         (define after (current-inexact-milliseconds))
 >>>         (when (log-level? event-logger 'debug)
 >>>           (log-message event-logger 'debug
 >>>                        (format "handled an event: ~a msec"
 >>>                                (- after before))
 >>>                        (gui-event before after (object-name thunk)))))
 >>>
 >>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >>>                                 (lambda (v)
 >>>                                   (when v (handle-event v e))
 >>>                                   (yield evt))))
 >>>
 >>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>   (define (call-with-break-parameterization paramz thunk)
 >>>     (unless (break-paramz? paramz)
 >>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>     (unless (and (procedure? thunk)
 >>>                  (procedure-arity-includes? thunk 0))
 >>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>     (begin0
 >>>      (with-continuation-mark
 >>>          break-enabled-key
 >>>          (break-paramz-ref paramz 0)
 >>>        (begin
 >>>          (check-for-break)
 >>>          (thunk)))
 >>>      (check-for-break)))
 >>>
 >>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 397:18
 >>>                   (let loop ()
 >>>                     (call-with-continuation-prompt
 >>>                      (lambda ()
 >>>                        ;; re-enable breaks (if they are supposed to be enabled):
 >>>                        (call-with-break-parameterization
 >>>                         break-paramz
 >>>                         (lambda ()
 >>>                           ;; yield; any abort (including a break exception)
 >>>                           ;; will get caught and the loop will yield again
 >>>                           (yield (make-semaphore))))))
 >>>                     (loop)))))))
 >>>
 >>> *** Environment:
 >>> windows "Windows NT 6.1 (Build 7601) Service Pack 1" (win32\i386\3m) (get-display-depth) = 32
 >>> Human Language: english
 >>> (current-memory-use) 206643796
 >>> raco pkg (show):
 >>> Installation-wide:
 >>>  Package              Checksum                                    Source
 >>>  main-distribution    84a366a8c2b2908babe6c2811b0ada036bb159df    (catalog main-distribution)
 >>>  racket-lib           436f0928598fc1a8abf27422e8e6588bef45f652    (catalog racket-lib)
 >>>  [187 auto-installed packages not shown]
 >>> User-specific for installation "6.1.1":
 >>>  [none]
 >>>
 >>>
 >>>
 >>> Collections:
 >>> ("C:\\Users\\Nadie\\AppData\\Roaming\\Racket\\6.1.1\\collects"
 >>>  (non-existent-path))
 >>> ("C:\\Program Files\\Racket\\collects"
 >>>  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))
 >>>
 >>> Recent Internal Errors:
 >>> Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t none) (default) #() "#lang racket\n" #f #t ((test) (main)) #t))
 >>>
 
From: Gustavo Massaccesi <gustavo@oma.org.ar>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14840: Future visualizer is crashing very frequently
Date: Tue, 18 Nov 2014 21:47:09 -0300

 New program:
 
 ;---
 #lang racket
 (require future-visualizer/trace
          future-visualizer)
 
 (start-future-tracing!)
 (stop-future-tracing!)
 :---
 
 1) Open DrRacket
 2) Verify that background expansion is enabled
 3) Copy the new program
 3) Run
 4) Make an irrelevant change. For example add a space.
 5) Wait while the background expansion work
 6) Crash!
 
 None of the identifiers from the future-visualizer module are used
 here, but if you remove it the program don't crash.
 
 Is it possible to run the code of the background expansion inside the program?
 
 Gustavo
 
 
 On Tue, Nov 18, 2014 at 5:36 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > I can't get that one. I did keep getting an inexact->exact error, however.
 >
 > If this looks like a memory corruption bug, then I guess that these
 > errors are red herrings. But I can't really tell in this case.
 >
 > Robby
 >
 > On Tue, Nov 18, 2014 at 2:28 PM, Gustavo Massaccesi <gustavo@oma.org.ar> wrote:
 >> I'm using Win 7, 32 bits.
 >>
 >> I got a reproducible error (that most of the times don't produce a
 >> direct crash).
 >>
 >> 1) Open DrRacket
 >> 2) Copy "the" program
 >> 3) Run
 >> 4) In the future-visualizer, go to the "Future Creation Tree" and
 >> click in the topmost circle (labeled "RTT")
 >> 5) An error appears in the DrRacket interaction window:
 >>
 >> ..\..\..\Program
 >> Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt:131:0:
 >>
 >> event-user-data: contract violation
 >>   expected: event?
 >>   given: 'runtime-thread
 >>
 >> Gustavo
 >>
 >>
 >> On Tue, Nov 18, 2014 at 3:46 PM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >>> I managed to make this happen twice under windows 32bit, but not at
 >>> all under mac os x 64 bit. The crash comes for me when I click on the
 >>> debug backtrace icon next to the error "inexact->exact: no exact
 >>> representation". It opens up something in the visualizer and then
 >>> crashes before finishing the opening.
 >>>
 >>>
 >>>> libracket3mxxxxxxx.dll!sch_vsprintf(char * s=0x0d29c4f0, int maxlen=14040, const char * msg=0x102a7c14, char * args=0x00038514, char * * _s=0x00c3ec4c, Scheme_Object * * _errno_val=0x00000000)  Line 577 + 0x5 bytes C
 >>>   libracket3mxxxxxxx.dll!scheme_log_w_data(Scheme_Logger *
 >>> logger=0x11a00748, int level=5, int flags=0, Scheme_Object *
 >>> data=0x0d29c4b8, const char * msg=0x102a7c14, ...)  Line 1082 C
 >>>   libracket3mxxxxxxx.dll!log_place_event(const char * what=0x102a7c14,
 >>> const char * tag=0x102a7c34, int has_amount=1, int amount=230676)
 >>> Line 2414 + 0x19 bytes C
 >>>   libracket3mxxxxxxx.dll!place_async_send(Scheme_Place_Async_Channel *
 >>> ch=0x03380128, Scheme_Object * uo=0x0d29c490)  Line 3628 + 0x18 bytes
 >>> C
 >>>   libracket3mxxxxxxx.dll!place_send(int argc=2, Scheme_Object * *
 >>> args=0x2f543f7c)  Line 3071 + 0x2b bytes C
 >>>   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native_fast(Scheme_Object
 >>> * rator=0x00000000, int argc=0, Scheme_Object * * argv=0x00000000)
 >>> Line 1436 + 0x5 bytes C
 >>>   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native(Scheme_Object
 >>> * rator=0x00ceb828, int argc=2, Scheme_Object * * argv=0x2f543f7c)
 >>> Line 1445 + 0xc bytes C
 >>>   003e098c()
 >>>   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 >>> obj=0x00000000, int num_rands=0, Scheme_Object * * rands=0x00000000,
 >>> int get_value=-1)  Line 3147 + 0x26 bytes C
 >>>   libracket3mxxxxxxx.dll!apply_k()  Line 1092 + 0x10 bytes C
 >>>   libracket3mxxxxxxx.dll!scheme_top_level_do_worker(void * (void)*
 >>> k=0x1008d320, int eb=1, int new_thread=1, Scheme_Dynamic_State *
 >>> dyn_state=0x00000000)  Line 882 + 0x3 bytes C
 >>>   libracket3mxxxxxxx.dll!scheme_apply_thread_thunk(Scheme_Object *
 >>> rator=0x0d18b298)  Line 1123 + 0x25 bytes C
 >>>   libracket3mxxxxxxx.dll!start_child(Scheme_Thread * volatile
 >>> child=0x0d18b9f8, Scheme_Object * volatile child_eval=0x0d18b298)
 >>> Line 3330 + 0xc bytes C
 >>>   libracket3mxxxxxxx.dll!make_subprocess(Scheme_Object *
 >>> child_thunk=0x0d18b298, void * child_start=0x00c3f06c, Scheme_Config *
 >>> config=0x11a006a8, Scheme_Bucket_Table * cells=0x0d18b2d0,
 >>> Scheme_Object * break_cell=0x11a04fc0, Scheme_Custodian *
 >>> mgr=0x00000000, int normal_kill=1)  Line 3429 C
 >>>   libracket3mxxxxxxx.dll!scheme_thread_w_details(Scheme_Object *
 >>> thunk=0x00000000, Scheme_Config * config=0x00000000,
 >>> Scheme_Bucket_Table * cells=0x00000000, Scheme_Object *
 >>> break_cell=0x00c3f254, Scheme_Custodian * mgr=0x00000010, int
 >>> suspend_to_kill=12841268)  Line 3714 + 0x2d bytes C
 >>>
 >>> On Tue, Nov 18, 2014 at 6:44 AM,  <gustavo@oma.org.ar> wrote:
 >>>> A new problem report is waiting at
 >>>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14840
 >>>>
 >>>> Reported by Gustavo Massaccesi for release: 6.1.1
 >>>>
 >>>> *** Description:
 >>>> The future-visualizer is crashing very frequently. I'm using Win7.
 >>>>
 >>>> Usually it simply crash, but once I got this backtrace. I'm not sure if the problem is here or there is a wrong pointer elsewhere. I couldn't find an example where the crash is easy to reproduce.
 >>>>
 >>>> *** How to repeat:
 >>>> 1) Open DrRacket
 >>>> 2) Copy this program
 >>>> 3) Run
 >>>> 4) Close the future-visualizer
 >>>> 5) Repeat 3) and 4) a few times until it crash.
 >>>>
 >>>> ;;; Program: ------------------
 >>>> #lang racket
 >>>> (require racket/future
 >>>>          future-visualizer)
 >>>>
 >>>> (visualize-futures
 >>>>  (let* ([z (random 1)]
 >>>>         [f (future (lambda () (display z)))]
 >>>>         [g (future (lambda () (display z)))])
 >>>>    (display z)
 >>>>    (touch f)
 >>>>    (touch g)))
 >>>>
 >>>> ;;; Error: ------------------
 >>>> event-user-data: contract violation
 >>>>   expected: event?
 >>>>   given: 'runtime-thread
 >>>>
 >>>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt: 131:0
 >>>> (define (find-fid-for-coords x y nodes vregion)
 >>>>   (define n (find-node-for-coords x y nodes))
 >>>>   (if n
 >>>>       (event-user-data (node-data (drawable-node-node n)))
 >>>>       #f))
 >>>>
 >>>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-gui.rkt: 243:48
 >>>>                                  [click-handler (位 (x y vregion)
 >>>>                                                   (define fid (find-fid-for-coords
 >>>>                                                                x y (graph-layout-nodes creation-tree-layout)
 >>>>                                                                vregion))
 >>>>                                                   (cond
 >>>>                                                     [(not fid) #f]
 >>>>                                                     [else
 >>>>                                                      (define seg (first-seg-for-fid fid segments))
 >>>>                                                      (set! tacked-seg seg)
 >>>>                                                      (send timeline-panel redraw-everything)
 >>>>                                                      (post-event listener-table 'segment-click timeline-panel seg)
 >>>>                                                      #t]))]
 >>>>
 >>>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\pict-canvas.rkt: 100:4
 >>>>     (define/override (on-event event)
 >>>>       (define vregion (get-viewable-region))
 >>>>       (define x (+ (viewable-region-x vregion) (/ (send event get-x) scale-factor)))
 >>>>       (define y (+ (viewable-region-y vregion) (/ (send event get-y) scale-factor)))
 >>>>       (case (send event get-event-type)
 >>>>         [(motion)
 >>>>          (when mh
 >>>>            (when (mh x y vregion) ;Mouse handler returns non-false if a state change requiring redraw occurred
 >>>>              (redraw-the-bitmap/maybe-delayed! vregion #:delay 0 #:only-the-overlay? #t)))]
 >>>>         [(left-up)
 >>>>          (when ch (ch x y vregion)) ;Ditto for click handler
 >>>>          (redraw-the-bitmap/maybe-delayed! vregion #:only-the-overlay? #t)]))
 >>>>
 >>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>     (unless (break-paramz? paramz)
 >>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>     (unless (and (procedure? thunk)
 >>>>                  (procedure-arity-includes? thunk 0))
 >>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>     (begin0
 >>>>      (with-continuation-mark
 >>>>          break-enabled-key
 >>>>          (break-paramz-ref paramz 0)
 >>>>        (begin
 >>>>          (check-for-break)
 >>>>          (thunk)))
 >>>>      (check-for-break)))
 >>>>
 >>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 264:2
 >>>>   (define (call-with-exception-handler exnh thunk)
 >>>>     ;; The `begin0' ensures that we don't overwrite an enclosing
 >>>>     ;;  exception handler.
 >>>>     (begin0
 >>>>      (with-continuation-mark
 >>>>          exception-handler-key
 >>>>          exnh
 >>>>        (thunk))
 >>>>      (void)))
 >>>>
 >>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\win32\window.rkt: 767:2
 >>>>   (define/public (dispatch-on-event e just-pre?)
 >>>>     (cond
 >>>>      [(other-modal? this e) #t]
 >>>>      [(call-pre-on-event this e) #t]
 >>>>      [just-pre? #f]
 >>>>      [else (when (is-enabled-to-root?) (on-event e)) #t]))
 >>>>
 >>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>     (unless (break-paramz? paramz)
 >>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>     (unless (and (procedure? thunk)
 >>>>                  (procedure-arity-includes? thunk 0))
 >>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>     (begin0
 >>>>      (with-continuation-mark
 >>>>          break-enabled-key
 >>>>          (break-paramz-ref paramz 0)
 >>>>        (begin
 >>>>          (check-for-break)
 >>>>          (thunk)))
 >>>>      (check-for-break)))
 >>>>
 >>>> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1641:30                                 (位 ()
 >>>>                                 ; =No-Breaks=
 >>>>                                 (send context reset-offer-kill)
 >>>>                                 (send context set-breakables (get-user-thread) (get-user-custodian))
 >>>>                                 (call-with-continuation-prompt
 >>>>                                  (位 () ; =User=, =Handler=, =No-Breaks=
 >>>>                                    (call-with-break-parameterization
 >>>>                                     user-break-parameterization
 >>>>                                     (位 () (primitive-dispatch-handler eventspace)))))
 >>>>
 >>>>                                 ;; in principle, the line below might cause
 >>>>                                 ;; "race conditions" in the GUI. That is, there might
 >>>>                                 ;; be many little events that the user won't quite
 >>>>                                 ;; be able to break.
 >>>>                                 (send context set-breakables #f #f)))]
 >>>>
 >>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>     (unless (break-paramz? paramz)
 >>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>     (unless (and (procedure? thunk)
 >>>>                  (procedure-arity-includes? thunk 0))
 >>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>     (begin0
 >>>>      (with-continuation-mark
 >>>>          break-enabled-key
 >>>>          (break-paramz-ref paramz 0)
 >>>>        (begin
 >>>>          (check-for-break)
 >>>>          (thunk)))
 >>>>      (check-for-break)))
 >>>>
 >>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >>>>       (lambda ()
 >>>>         ;; communicate the thunk to `really-dispatch-event':
 >>>>         (define before (current-inexact-milliseconds))
 >>>>         (when (log-level? event-logger 'debug)
 >>>>           (log-message event-logger 'debug
 >>>>                        (format "starting to handle an event from ~a" (object-name thunk))
 >>>>                        (gui-event before #f (object-name thunk))))
 >>>>         (let ([b (box thunk)])
 >>>>           ;; use the event-dispatch handler:
 >>>>           (with-continuation-mark dispatch-event-key b
 >>>>             ((event-dispatch-handler) e))
 >>>>           ;; if the event-dispatch handler doesn't chain
 >>>>           ;; to the original one, then do so now:
 >>>>           (when (unbox b)
 >>>>             (set-box! b #f)
 >>>>             (thunk)))
 >>>>         (define after (current-inexact-milliseconds))
 >>>>         (when (log-level? event-logger 'debug)
 >>>>           (log-message event-logger 'debug
 >>>>                        (format "handled an event: ~a msec"
 >>>>                                (- after before))
 >>>>                        (gui-event before after (object-name thunk)))))
 >>>>
 >>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >>>>                                 (lambda (v)
 >>>>                                   (when v (handle-event v e))
 >>>>                                   (yield evt))))
 >>>>
 >>>> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1414:17
 >>>>                  (let loop () ; =User=, =Handler=, =No-Breaks=
 >>>>                    ; Wait for something to do
 >>>>                    (unless (semaphore-try-wait? eval-thread-queue-sema)
 >>>>                      ; User event callbacks run here; we turn on
 >>>>                      ;  breaks in the dispatch handler.
 >>>>                      (yield eval-thread-queue-sema))
 >>>>                    ; About to eval something
 >>>>                    (semaphore-wait eval-thread-state-sema)
 >>>>                    (let ([thunk (car eval-thread-thunks)])
 >>>>                      (set! eval-thread-thunks (cdr eval-thread-thunks))
 >>>>                      (semaphore-post eval-thread-state-sema)
 >>>>                      ; This thunk evals the user's expressions with appropriate
 >>>>                      ;   protections.
 >>>>                      (thunk))
 >>>>                    (loop)))))
 >>>>
 >>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >>>>       (lambda ()
 >>>>         ;; communicate the thunk to `really-dispatch-event':
 >>>>         (define before (current-inexact-milliseconds))
 >>>>         (when (log-level? event-logger 'debug)
 >>>>           (log-message event-logger 'debug
 >>>>                        (format "starting to handle an event from ~a" (object-name thunk))
 >>>>                        (gui-event before #f (object-name thunk))))
 >>>>         (let ([b (box thunk)])
 >>>>           ;; use the event-dispatch handler:
 >>>>           (with-continuation-mark dispatch-event-key b
 >>>>             ((event-dispatch-handler) e))
 >>>>           ;; if the event-dispatch handler doesn't chain
 >>>>           ;; to the original one, then do so now:
 >>>>           (when (unbox b)
 >>>>             (set-box! b #f)
 >>>>             (thunk)))
 >>>>         (define after (current-inexact-milliseconds))
 >>>>         (when (log-level? event-logger 'debug)
 >>>>           (log-message event-logger 'debug
 >>>>                        (format "handled an event: ~a msec"
 >>>>                                (- after before))
 >>>>                        (gui-event before after (object-name thunk)))))
 >>>>
 >>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >>>>                                 (lambda (v)
 >>>>                                   (when v (handle-event v e))
 >>>>                                   (yield evt))))
 >>>>
 >>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>     (unless (break-paramz? paramz)
 >>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>     (unless (and (procedure? thunk)
 >>>>                  (procedure-arity-includes? thunk 0))
 >>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>     (begin0
 >>>>      (with-continuation-mark
 >>>>          break-enabled-key
 >>>>          (break-paramz-ref paramz 0)
 >>>>        (begin
 >>>>          (check-for-break)
 >>>>          (thunk)))
 >>>>      (check-for-break)))
 >>>>
 >>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 397:18
 >>>>                   (let loop ()
 >>>>                     (call-with-continuation-prompt
 >>>>                      (lambda ()
 >>>>                        ;; re-enable breaks (if they are supposed to be enabled):
 >>>>                        (call-with-break-parameterization
 >>>>                         break-paramz
 >>>>                         (lambda ()
 >>>>                           ;; yield; any abort (including a break exception)
 >>>>                           ;; will get caught and the loop will yield again
 >>>>                           (yield (make-semaphore))))))
 >>>>                     (loop)))))))
 >>>>
 >>>> *** Environment:
 >>>> windows "Windows NT 6.1 (Build 7601) Service Pack 1" (win32\i386\3m) (get-display-depth) = 32
 >>>> Human Language: english
 >>>> (current-memory-use) 206643796
 >>>> raco pkg (show):
 >>>> Installation-wide:
 >>>>  Package              Checksum                                    Source
 >>>>  main-distribution    84a366a8c2b2908babe6c2811b0ada036bb159df    (catalog main-distribution)
 >>>>  racket-lib           436f0928598fc1a8abf27422e8e6588bef45f652    (catalog racket-lib)
 >>>>  [187 auto-installed packages not shown]
 >>>> User-specific for installation "6.1.1":
 >>>>  [none]
 >>>>
 >>>>
 >>>>
 >>>> Collections:
 >>>> ("C:\\Users\\Nadie\\AppData\\Roaming\\Racket\\6.1.1\\collects"
 >>>>  (non-existent-path))
 >>>> ("C:\\Program Files\\Racket\\collects"
 >>>>  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))
 >>>>
 >>>> Recent Internal Errors:
 >>>> Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t none) (default) #() "#lang racket\n" #f #t ((test) (main)) #t))
 >>>>
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Gustavo Massaccesi <gustavo@oma.org.ar>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14840: Future visualizer is crashing very frequently
Date: Tue, 18 Nov 2014 20:04:45 -0600

 When you say "crash", are you talking about the entire DrRacket
 disappearing or a runtime error at the racket level?
 
 Robby
 
 On Tue, Nov 18, 2014 at 6:47 PM, Gustavo Massaccesi <gustavo@oma.org.ar> wrote:
 > New program:
 >
 > ;---
 > #lang racket
 > (require future-visualizer/trace
 >          future-visualizer)
 >
 > (start-future-tracing!)
 > (stop-future-tracing!)
 > :---
 >
 > 1) Open DrRacket
 > 2) Verify that background expansion is enabled
 > 3) Copy the new program
 > 3) Run
 > 4) Make an irrelevant change. For example add a space.
 > 5) Wait while the background expansion work
 > 6) Crash!
 >
 > None of the identifiers from the future-visualizer module are used
 > here, but if you remove it the program don't crash.
 >
 > Is it possible to run the code of the background expansion inside the program?
 >
 > Gustavo
 >
 >
 > On Tue, Nov 18, 2014 at 5:36 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> I can't get that one. I did keep getting an inexact->exact error, however.
 >>
 >> If this looks like a memory corruption bug, then I guess that these
 >> errors are red herrings. But I can't really tell in this case.
 >>
 >> Robby
 >>
 >> On Tue, Nov 18, 2014 at 2:28 PM, Gustavo Massaccesi <gustavo@oma.org.ar> wrote:
 >>> I'm using Win 7, 32 bits.
 >>>
 >>> I got a reproducible error (that most of the times don't produce a
 >>> direct crash).
 >>>
 >>> 1) Open DrRacket
 >>> 2) Copy "the" program
 >>> 3) Run
 >>> 4) In the future-visualizer, go to the "Future Creation Tree" and
 >>> click in the topmost circle (labeled "RTT")
 >>> 5) An error appears in the DrRacket interaction window:
 >>>
 >>> ..\..\..\Program
 >>> Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt:131:0:
 >>>
 >>> event-user-data: contract violation
 >>>   expected: event?
 >>>   given: 'runtime-thread
 >>>
 >>> Gustavo
 >>>
 >>>
 >>> On Tue, Nov 18, 2014 at 3:46 PM, Robby Findler
 >>> <robby@eecs.northwestern.edu> wrote:
 >>>> I managed to make this happen twice under windows 32bit, but not at
 >>>> all under mac os x 64 bit. The crash comes for me when I click on the
 >>>> debug backtrace icon next to the error "inexact->exact: no exact
 >>>> representation". It opens up something in the visualizer and then
 >>>> crashes before finishing the opening.
 >>>>
 >>>>
 >>>>> libracket3mxxxxxxx.dll!sch_vsprintf(char * s=0x0d29c4f0, int maxlen=14040, const char * msg=0x102a7c14, char * args=0x00038514, char * * _s=0x00c3ec4c, Scheme_Object * * _errno_val=0x00000000)  Line 577 + 0x5 bytes C
 >>>>   libracket3mxxxxxxx.dll!scheme_log_w_data(Scheme_Logger *
 >>>> logger=0x11a00748, int level=5, int flags=0, Scheme_Object *
 >>>> data=0x0d29c4b8, const char * msg=0x102a7c14, ...)  Line 1082 C
 >>>>   libracket3mxxxxxxx.dll!log_place_event(const char * what=0x102a7c14,
 >>>> const char * tag=0x102a7c34, int has_amount=1, int amount=230676)
 >>>> Line 2414 + 0x19 bytes C
 >>>>   libracket3mxxxxxxx.dll!place_async_send(Scheme_Place_Async_Channel *
 >>>> ch=0x03380128, Scheme_Object * uo=0x0d29c490)  Line 3628 + 0x18 bytes
 >>>> C
 >>>>   libracket3mxxxxxxx.dll!place_send(int argc=2, Scheme_Object * *
 >>>> args=0x2f543f7c)  Line 3071 + 0x2b bytes C
 >>>>   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native_fast(Scheme_Object
 >>>> * rator=0x00000000, int argc=0, Scheme_Object * * argv=0x00000000)
 >>>> Line 1436 + 0x5 bytes C
 >>>>   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native(Scheme_Object
 >>>> * rator=0x00ceb828, int argc=2, Scheme_Object * * argv=0x2f543f7c)
 >>>> Line 1445 + 0xc bytes C
 >>>>   003e098c()
 >>>>   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 >>>> obj=0x00000000, int num_rands=0, Scheme_Object * * rands=0x00000000,
 >>>> int get_value=-1)  Line 3147 + 0x26 bytes C
 >>>>   libracket3mxxxxxxx.dll!apply_k()  Line 1092 + 0x10 bytes C
 >>>>   libracket3mxxxxxxx.dll!scheme_top_level_do_worker(void * (void)*
 >>>> k=0x1008d320, int eb=1, int new_thread=1, Scheme_Dynamic_State *
 >>>> dyn_state=0x00000000)  Line 882 + 0x3 bytes C
 >>>>   libracket3mxxxxxxx.dll!scheme_apply_thread_thunk(Scheme_Object *
 >>>> rator=0x0d18b298)  Line 1123 + 0x25 bytes C
 >>>>   libracket3mxxxxxxx.dll!start_child(Scheme_Thread * volatile
 >>>> child=0x0d18b9f8, Scheme_Object * volatile child_eval=0x0d18b298)
 >>>> Line 3330 + 0xc bytes C
 >>>>   libracket3mxxxxxxx.dll!make_subprocess(Scheme_Object *
 >>>> child_thunk=0x0d18b298, void * child_start=0x00c3f06c, Scheme_Config *
 >>>> config=0x11a006a8, Scheme_Bucket_Table * cells=0x0d18b2d0,
 >>>> Scheme_Object * break_cell=0x11a04fc0, Scheme_Custodian *
 >>>> mgr=0x00000000, int normal_kill=1)  Line 3429 C
 >>>>   libracket3mxxxxxxx.dll!scheme_thread_w_details(Scheme_Object *
 >>>> thunk=0x00000000, Scheme_Config * config=0x00000000,
 >>>> Scheme_Bucket_Table * cells=0x00000000, Scheme_Object *
 >>>> break_cell=0x00c3f254, Scheme_Custodian * mgr=0x00000010, int
 >>>> suspend_to_kill=12841268)  Line 3714 + 0x2d bytes C
 >>>>
 >>>> On Tue, Nov 18, 2014 at 6:44 AM,  <gustavo@oma.org.ar> wrote:
 >>>>> A new problem report is waiting at
 >>>>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14840
 >>>>>
 >>>>> Reported by Gustavo Massaccesi for release: 6.1.1
 >>>>>
 >>>>> *** Description:
 >>>>> The future-visualizer is crashing very frequently. I'm using Win7.
 >>>>>
 >>>>> Usually it simply crash, but once I got this backtrace. I'm not sure if the problem is here or there is a wrong pointer elsewhere. I couldn't find an example where the crash is easy to reproduce.
 >>>>>
 >>>>> *** How to repeat:
 >>>>> 1) Open DrRacket
 >>>>> 2) Copy this program
 >>>>> 3) Run
 >>>>> 4) Close the future-visualizer
 >>>>> 5) Repeat 3) and 4) a few times until it crash.
 >>>>>
 >>>>> ;;; Program: ------------------
 >>>>> #lang racket
 >>>>> (require racket/future
 >>>>>          future-visualizer)
 >>>>>
 >>>>> (visualize-futures
 >>>>>  (let* ([z (random 1)]
 >>>>>         [f (future (lambda () (display z)))]
 >>>>>         [g (future (lambda () (display z)))])
 >>>>>    (display z)
 >>>>>    (touch f)
 >>>>>    (touch g)))
 >>>>>
 >>>>> ;;; Error: ------------------
 >>>>> event-user-data: contract violation
 >>>>>   expected: event?
 >>>>>   given: 'runtime-thread
 >>>>>
 >>>>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt: 131:0
 >>>>> (define (find-fid-for-coords x y nodes vregion)
 >>>>>   (define n (find-node-for-coords x y nodes))
 >>>>>   (if n
 >>>>>       (event-user-data (node-data (drawable-node-node n)))
 >>>>>       #f))
 >>>>>
 >>>>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-gui.rkt: 243:48
 >>>>>                                  [click-handler (位 (x y vregion)
 >>>>>                                                   (define fid (find-fid-for-coords
 >>>>>                                                                x y (graph-layout-nodes creation-tree-layout)
 >>>>>                                                                vregion))
 >>>>>                                                   (cond
 >>>>>                                                     [(not fid) #f]
 >>>>>                                                     [else
 >>>>>                                                      (define seg (first-seg-for-fid fid segments))
 >>>>>                                                      (set! tacked-seg seg)
 >>>>>                                                      (send timeline-panel redraw-everything)
 >>>>>                                                      (post-event listener-table 'segment-click timeline-panel seg)
 >>>>>                                                      #t]))]
 >>>>>
 >>>>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\pict-canvas.rkt: 100:4
 >>>>>     (define/override (on-event event)
 >>>>>       (define vregion (get-viewable-region))
 >>>>>       (define x (+ (viewable-region-x vregion) (/ (send event get-x) scale-factor)))
 >>>>>       (define y (+ (viewable-region-y vregion) (/ (send event get-y) scale-factor)))
 >>>>>       (case (send event get-event-type)
 >>>>>         [(motion)
 >>>>>          (when mh
 >>>>>            (when (mh x y vregion) ;Mouse handler returns non-false if a state change requiring redraw occurred
 >>>>>              (redraw-the-bitmap/maybe-delayed! vregion #:delay 0 #:only-the-overlay? #t)))]
 >>>>>         [(left-up)
 >>>>>          (when ch (ch x y vregion)) ;Ditto for click handler
 >>>>>          (redraw-the-bitmap/maybe-delayed! vregion #:only-the-overlay? #t)]))
 >>>>>
 >>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>>     (unless (break-paramz? paramz)
 >>>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>>     (unless (and (procedure? thunk)
 >>>>>                  (procedure-arity-includes? thunk 0))
 >>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>>     (begin0
 >>>>>      (with-continuation-mark
 >>>>>          break-enabled-key
 >>>>>          (break-paramz-ref paramz 0)
 >>>>>        (begin
 >>>>>          (check-for-break)
 >>>>>          (thunk)))
 >>>>>      (check-for-break)))
 >>>>>
 >>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 264:2
 >>>>>   (define (call-with-exception-handler exnh thunk)
 >>>>>     ;; The `begin0' ensures that we don't overwrite an enclosing
 >>>>>     ;;  exception handler.
 >>>>>     (begin0
 >>>>>      (with-continuation-mark
 >>>>>          exception-handler-key
 >>>>>          exnh
 >>>>>        (thunk))
 >>>>>      (void)))
 >>>>>
 >>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\win32\window.rkt: 767:2
 >>>>>   (define/public (dispatch-on-event e just-pre?)
 >>>>>     (cond
 >>>>>      [(other-modal? this e) #t]
 >>>>>      [(call-pre-on-event this e) #t]
 >>>>>      [just-pre? #f]
 >>>>>      [else (when (is-enabled-to-root?) (on-event e)) #t]))
 >>>>>
 >>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>>     (unless (break-paramz? paramz)
 >>>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>>     (unless (and (procedure? thunk)
 >>>>>                  (procedure-arity-includes? thunk 0))
 >>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>>     (begin0
 >>>>>      (with-continuation-mark
 >>>>>          break-enabled-key
 >>>>>          (break-paramz-ref paramz 0)
 >>>>>        (begin
 >>>>>          (check-for-break)
 >>>>>          (thunk)))
 >>>>>      (check-for-break)))
 >>>>>
 >>>>> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1641:30                                 (位 ()
 >>>>>                                 ; =No-Breaks=
 >>>>>                                 (send context reset-offer-kill)
 >>>>>                                 (send context set-breakables (get-user-thread) (get-user-custodian))
 >>>>>                                 (call-with-continuation-prompt
 >>>>>                                  (位 () ; =User=, =Handler=, =No-Breaks=
 >>>>>                                    (call-with-break-parameterization
 >>>>>                                     user-break-parameterization
 >>>>>                                     (位 () (primitive-dispatch-handler eventspace)))))
 >>>>>
 >>>>>                                 ;; in principle, the line below might cause
 >>>>>                                 ;; "race conditions" in the GUI. That is, there might
 >>>>>                                 ;; be many little events that the user won't quite
 >>>>>                                 ;; be able to break.
 >>>>>                                 (send context set-breakables #f #f)))]
 >>>>>
 >>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>>     (unless (break-paramz? paramz)
 >>>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>>     (unless (and (procedure? thunk)
 >>>>>                  (procedure-arity-includes? thunk 0))
 >>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>>     (begin0
 >>>>>      (with-continuation-mark
 >>>>>          break-enabled-key
 >>>>>          (break-paramz-ref paramz 0)
 >>>>>        (begin
 >>>>>          (check-for-break)
 >>>>>          (thunk)))
 >>>>>      (check-for-break)))
 >>>>>
 >>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >>>>>       (lambda ()
 >>>>>         ;; communicate the thunk to `really-dispatch-event':
 >>>>>         (define before (current-inexact-milliseconds))
 >>>>>         (when (log-level? event-logger 'debug)
 >>>>>           (log-message event-logger 'debug
 >>>>>                        (format "starting to handle an event from ~a" (object-name thunk))
 >>>>>                        (gui-event before #f (object-name thunk))))
 >>>>>         (let ([b (box thunk)])
 >>>>>           ;; use the event-dispatch handler:
 >>>>>           (with-continuation-mark dispatch-event-key b
 >>>>>             ((event-dispatch-handler) e))
 >>>>>           ;; if the event-dispatch handler doesn't chain
 >>>>>           ;; to the original one, then do so now:
 >>>>>           (when (unbox b)
 >>>>>             (set-box! b #f)
 >>>>>             (thunk)))
 >>>>>         (define after (current-inexact-milliseconds))
 >>>>>         (when (log-level? event-logger 'debug)
 >>>>>           (log-message event-logger 'debug
 >>>>>                        (format "handled an event: ~a msec"
 >>>>>                                (- after before))
 >>>>>                        (gui-event before after (object-name thunk)))))
 >>>>>
 >>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >>>>>                                 (lambda (v)
 >>>>>                                   (when v (handle-event v e))
 >>>>>                                   (yield evt))))
 >>>>>
 >>>>> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1414:17
 >>>>>                  (let loop () ; =User=, =Handler=, =No-Breaks=
 >>>>>                    ; Wait for something to do
 >>>>>                    (unless (semaphore-try-wait? eval-thread-queue-sema)
 >>>>>                      ; User event callbacks run here; we turn on
 >>>>>                      ;  breaks in the dispatch handler.
 >>>>>                      (yield eval-thread-queue-sema))
 >>>>>                    ; About to eval something
 >>>>>                    (semaphore-wait eval-thread-state-sema)
 >>>>>                    (let ([thunk (car eval-thread-thunks)])
 >>>>>                      (set! eval-thread-thunks (cdr eval-thread-thunks))
 >>>>>                      (semaphore-post eval-thread-state-sema)
 >>>>>                      ; This thunk evals the user's expressions with appropriate
 >>>>>                      ;   protections.
 >>>>>                      (thunk))
 >>>>>                    (loop)))))
 >>>>>
 >>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >>>>>       (lambda ()
 >>>>>         ;; communicate the thunk to `really-dispatch-event':
 >>>>>         (define before (current-inexact-milliseconds))
 >>>>>         (when (log-level? event-logger 'debug)
 >>>>>           (log-message event-logger 'debug
 >>>>>                        (format "starting to handle an event from ~a" (object-name thunk))
 >>>>>                        (gui-event before #f (object-name thunk))))
 >>>>>         (let ([b (box thunk)])
 >>>>>           ;; use the event-dispatch handler:
 >>>>>           (with-continuation-mark dispatch-event-key b
 >>>>>             ((event-dispatch-handler) e))
 >>>>>           ;; if the event-dispatch handler doesn't chain
 >>>>>           ;; to the original one, then do so now:
 >>>>>           (when (unbox b)
 >>>>>             (set-box! b #f)
 >>>>>             (thunk)))
 >>>>>         (define after (current-inexact-milliseconds))
 >>>>>         (when (log-level? event-logger 'debug)
 >>>>>           (log-message event-logger 'debug
 >>>>>                        (format "handled an event: ~a msec"
 >>>>>                                (- after before))
 >>>>>                        (gui-event before after (object-name thunk)))))
 >>>>>
 >>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >>>>>                                 (lambda (v)
 >>>>>                                   (when v (handle-event v e))
 >>>>>                                   (yield evt))))
 >>>>>
 >>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>>     (unless (break-paramz? paramz)
 >>>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>>     (unless (and (procedure? thunk)
 >>>>>                  (procedure-arity-includes? thunk 0))
 >>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>>     (begin0
 >>>>>      (with-continuation-mark
 >>>>>          break-enabled-key
 >>>>>          (break-paramz-ref paramz 0)
 >>>>>        (begin
 >>>>>          (check-for-break)
 >>>>>          (thunk)))
 >>>>>      (check-for-break)))
 >>>>>
 >>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 397:18
 >>>>>                   (let loop ()
 >>>>>                     (call-with-continuation-prompt
 >>>>>                      (lambda ()
 >>>>>                        ;; re-enable breaks (if they are supposed to be enabled):
 >>>>>                        (call-with-break-parameterization
 >>>>>                         break-paramz
 >>>>>                         (lambda ()
 >>>>>                           ;; yield; any abort (including a break exception)
 >>>>>                           ;; will get caught and the loop will yield again
 >>>>>                           (yield (make-semaphore))))))
 >>>>>                     (loop)))))))
 >>>>>
 >>>>> *** Environment:
 >>>>> windows "Windows NT 6.1 (Build 7601) Service Pack 1" (win32\i386\3m) (get-display-depth) = 32
 >>>>> Human Language: english
 >>>>> (current-memory-use) 206643796
 >>>>> raco pkg (show):
 >>>>> Installation-wide:
 >>>>>  Package              Checksum                                    Source
 >>>>>  main-distribution    84a366a8c2b2908babe6c2811b0ada036bb159df    (catalog main-distribution)
 >>>>>  racket-lib           436f0928598fc1a8abf27422e8e6588bef45f652    (catalog racket-lib)
 >>>>>  [187 auto-installed packages not shown]
 >>>>> User-specific for installation "6.1.1":
 >>>>>  [none]
 >>>>>
 >>>>>
 >>>>>
 >>>>> Collections:
 >>>>> ("C:\\Users\\Nadie\\AppData\\Roaming\\Racket\\6.1.1\\collects"
 >>>>>  (non-existent-path))
 >>>>> ("C:\\Program Files\\Racket\\collects"
 >>>>>  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))
 >>>>>
 >>>>> Recent Internal Errors:
 >>>>> Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t none) (default) #() "#lang racket\n" #f #t ((test) (main)) #t))
 >>>>>
 
From: Gustavo Massaccesi <gustavo@oma.org.ar>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14840: Future visualizer is crashing very frequently
Date: Wed, 19 Nov 2014 08:30:50 -0300

 Windows open a small white dialog with some text like "Racket GUI
 stopped working, Windows is looking for a solution for the problem
 ...". When you close the dialog the entire DrRacket environment
 disappears.
 
 I just removed the future-visualizer from the dependency list. I
 replaced it with a few primitives in #%futures. This program also
 crash during the second background expansion in DrRacket.
 
 ;---
 #lang racket
 (require framework
          (only-in '#%futures
                   reset-future-logs-for-tracing!
                   mark-future-trace-end!))
 
 (reset-future-logs-for-tracing!)
 (void (make-log-receiver (current-logger) 'debug))
 (mark-future-trace-end!)
 ;---
 
 On Tue, Nov 18, 2014 at 11:04 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > When you say "crash", are you talking about the entire DrRacket
 > disappearing or a runtime error at the racket level?
 >
 > Robby
 >
 > On Tue, Nov 18, 2014 at 6:47 PM, Gustavo Massaccesi <gustavo@oma.org.ar> wrote:
 >> New program:
 >>
 >> ;---
 >> #lang racket
 >> (require future-visualizer/trace
 >>          future-visualizer)
 >>
 >> (start-future-tracing!)
 >> (stop-future-tracing!)
 >> :---
 >>
 >> 1) Open DrRacket
 >> 2) Verify that background expansion is enabled
 >> 3) Copy the new program
 >> 3) Run
 >> 4) Make an irrelevant change. For example add a space.
 >> 5) Wait while the background expansion work
 >> 6) Crash!
 >>
 >> None of the identifiers from the future-visualizer module are used
 >> here, but if you remove it the program don't crash.
 >>
 >> Is it possible to run the code of the background expansion inside the program?
 >>
 >> Gustavo
 >>
 >>
 >> On Tue, Nov 18, 2014 at 5:36 PM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >>> I can't get that one. I did keep getting an inexact->exact error, however.
 >>>
 >>> If this looks like a memory corruption bug, then I guess that these
 >>> errors are red herrings. But I can't really tell in this case.
 >>>
 >>> Robby
 >>>
 >>> On Tue, Nov 18, 2014 at 2:28 PM, Gustavo Massaccesi <gustavo@oma.org.ar> wrote:
 >>>> I'm using Win 7, 32 bits.
 >>>>
 >>>> I got a reproducible error (that most of the times don't produce a
 >>>> direct crash).
 >>>>
 >>>> 1) Open DrRacket
 >>>> 2) Copy "the" program
 >>>> 3) Run
 >>>> 4) In the future-visualizer, go to the "Future Creation Tree" and
 >>>> click in the topmost circle (labeled "RTT")
 >>>> 5) An error appears in the DrRacket interaction window:
 >>>>
 >>>> ..\..\..\Program
 >>>> Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt:131:0:
 >>>>
 >>>> event-user-data: contract violation
 >>>>   expected: event?
 >>>>   given: 'runtime-thread
 >>>>
 >>>> Gustavo
 >>>>
 >>>>
 >>>> On Tue, Nov 18, 2014 at 3:46 PM, Robby Findler
 >>>> <robby@eecs.northwestern.edu> wrote:
 >>>>> I managed to make this happen twice under windows 32bit, but not at
 >>>>> all under mac os x 64 bit. The crash comes for me when I click on the
 >>>>> debug backtrace icon next to the error "inexact->exact: no exact
 >>>>> representation". It opens up something in the visualizer and then
 >>>>> crashes before finishing the opening.
 >>>>>
 >>>>>
 >>>>>> libracket3mxxxxxxx.dll!sch_vsprintf(char * s=0x0d29c4f0, int maxlen=14040, const char * msg=0x102a7c14, char * args=0x00038514, char * * _s=0x00c3ec4c, Scheme_Object * * _errno_val=0x00000000)  Line 577 + 0x5 bytes C
 >>>>>   libracket3mxxxxxxx.dll!scheme_log_w_data(Scheme_Logger *
 >>>>> logger=0x11a00748, int level=5, int flags=0, Scheme_Object *
 >>>>> data=0x0d29c4b8, const char * msg=0x102a7c14, ...)  Line 1082 C
 >>>>>   libracket3mxxxxxxx.dll!log_place_event(const char * what=0x102a7c14,
 >>>>> const char * tag=0x102a7c34, int has_amount=1, int amount=230676)
 >>>>> Line 2414 + 0x19 bytes C
 >>>>>   libracket3mxxxxxxx.dll!place_async_send(Scheme_Place_Async_Channel *
 >>>>> ch=0x03380128, Scheme_Object * uo=0x0d29c490)  Line 3628 + 0x18 bytes
 >>>>> C
 >>>>>   libracket3mxxxxxxx.dll!place_send(int argc=2, Scheme_Object * *
 >>>>> args=0x2f543f7c)  Line 3071 + 0x2b bytes C
 >>>>>   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native_fast(Scheme_Object
 >>>>> * rator=0x00000000, int argc=0, Scheme_Object * * argv=0x00000000)
 >>>>> Line 1436 + 0x5 bytes C
 >>>>>   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native(Scheme_Object
 >>>>> * rator=0x00ceb828, int argc=2, Scheme_Object * * argv=0x2f543f7c)
 >>>>> Line 1445 + 0xc bytes C
 >>>>>   003e098c()
 >>>>>   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 >>>>> obj=0x00000000, int num_rands=0, Scheme_Object * * rands=0x00000000,
 >>>>> int get_value=-1)  Line 3147 + 0x26 bytes C
 >>>>>   libracket3mxxxxxxx.dll!apply_k()  Line 1092 + 0x10 bytes C
 >>>>>   libracket3mxxxxxxx.dll!scheme_top_level_do_worker(void * (void)*
 >>>>> k=0x1008d320, int eb=1, int new_thread=1, Scheme_Dynamic_State *
 >>>>> dyn_state=0x00000000)  Line 882 + 0x3 bytes C
 >>>>>   libracket3mxxxxxxx.dll!scheme_apply_thread_thunk(Scheme_Object *
 >>>>> rator=0x0d18b298)  Line 1123 + 0x25 bytes C
 >>>>>   libracket3mxxxxxxx.dll!start_child(Scheme_Thread * volatile
 >>>>> child=0x0d18b9f8, Scheme_Object * volatile child_eval=0x0d18b298)
 >>>>> Line 3330 + 0xc bytes C
 >>>>>   libracket3mxxxxxxx.dll!make_subprocess(Scheme_Object *
 >>>>> child_thunk=0x0d18b298, void * child_start=0x00c3f06c, Scheme_Config *
 >>>>> config=0x11a006a8, Scheme_Bucket_Table * cells=0x0d18b2d0,
 >>>>> Scheme_Object * break_cell=0x11a04fc0, Scheme_Custodian *
 >>>>> mgr=0x00000000, int normal_kill=1)  Line 3429 C
 >>>>>   libracket3mxxxxxxx.dll!scheme_thread_w_details(Scheme_Object *
 >>>>> thunk=0x00000000, Scheme_Config * config=0x00000000,
 >>>>> Scheme_Bucket_Table * cells=0x00000000, Scheme_Object *
 >>>>> break_cell=0x00c3f254, Scheme_Custodian * mgr=0x00000010, int
 >>>>> suspend_to_kill=12841268)  Line 3714 + 0x2d bytes C
 >>>>>
 >>>>> On Tue, Nov 18, 2014 at 6:44 AM,  <gustavo@oma.org.ar> wrote:
 >>>>>> A new problem report is waiting at
 >>>>>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14840
 >>>>>>
 >>>>>> Reported by Gustavo Massaccesi for release: 6.1.1
 >>>>>>
 >>>>>> *** Description:
 >>>>>> The future-visualizer is crashing very frequently. I'm using Win7.
 >>>>>>
 >>>>>> Usually it simply crash, but once I got this backtrace. I'm not sure if the problem is here or there is a wrong pointer elsewhere. I couldn't find an example where the crash is easy to reproduce.
 >>>>>>
 >>>>>> *** How to repeat:
 >>>>>> 1) Open DrRacket
 >>>>>> 2) Copy this program
 >>>>>> 3) Run
 >>>>>> 4) Close the future-visualizer
 >>>>>> 5) Repeat 3) and 4) a few times until it crash.
 >>>>>>
 >>>>>> ;;; Program: ------------------
 >>>>>> #lang racket
 >>>>>> (require racket/future
 >>>>>>          future-visualizer)
 >>>>>>
 >>>>>> (visualize-futures
 >>>>>>  (let* ([z (random 1)]
 >>>>>>         [f (future (lambda () (display z)))]
 >>>>>>         [g (future (lambda () (display z)))])
 >>>>>>    (display z)
 >>>>>>    (touch f)
 >>>>>>    (touch g)))
 >>>>>>
 >>>>>> ;;; Error: ------------------
 >>>>>> event-user-data: contract violation
 >>>>>>   expected: event?
 >>>>>>   given: 'runtime-thread
 >>>>>>
 >>>>>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-drawing.rkt: 131:0
 >>>>>> (define (find-fid-for-coords x y nodes vregion)
 >>>>>>   (define n (find-node-for-coords x y nodes))
 >>>>>>   (if n
 >>>>>>       (event-user-data (node-data (drawable-node-node n)))
 >>>>>>       #f))
 >>>>>>
 >>>>>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-gui.rkt: 243:48
 >>>>>>                                  [click-handler (位 (x y vregion)
 >>>>>>                                                   (define fid (find-fid-for-coords
 >>>>>>                                                                x y (graph-layout-nodes creation-tree-layout)
 >>>>>>                                                                vregion))
 >>>>>>                                                   (cond
 >>>>>>                                                     [(not fid) #f]
 >>>>>>                                                     [else
 >>>>>>                                                      (define seg (first-seg-for-fid fid segments))
 >>>>>>                                                      (set! tacked-seg seg)
 >>>>>>                                                      (send timeline-panel redraw-everything)
 >>>>>>                                                      (post-event listener-table 'segment-click timeline-panel seg)
 >>>>>>                                                      #t]))]
 >>>>>>
 >>>>>> C:\Program Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\pict-canvas.rkt: 100:4
 >>>>>>     (define/override (on-event event)
 >>>>>>       (define vregion (get-viewable-region))
 >>>>>>       (define x (+ (viewable-region-x vregion) (/ (send event get-x) scale-factor)))
 >>>>>>       (define y (+ (viewable-region-y vregion) (/ (send event get-y) scale-factor)))
 >>>>>>       (case (send event get-event-type)
 >>>>>>         [(motion)
 >>>>>>          (when mh
 >>>>>>            (when (mh x y vregion) ;Mouse handler returns non-false if a state change requiring redraw occurred
 >>>>>>              (redraw-the-bitmap/maybe-delayed! vregion #:delay 0 #:only-the-overlay? #t)))]
 >>>>>>         [(left-up)
 >>>>>>          (when ch (ch x y vregion)) ;Ditto for click handler
 >>>>>>          (redraw-the-bitmap/maybe-delayed! vregion #:only-the-overlay? #t)]))
 >>>>>>
 >>>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>>>     (unless (break-paramz? paramz)
 >>>>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>>>     (unless (and (procedure? thunk)
 >>>>>>                  (procedure-arity-includes? thunk 0))
 >>>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>>>     (begin0
 >>>>>>      (with-continuation-mark
 >>>>>>          break-enabled-key
 >>>>>>          (break-paramz-ref paramz 0)
 >>>>>>        (begin
 >>>>>>          (check-for-break)
 >>>>>>          (thunk)))
 >>>>>>      (check-for-break)))
 >>>>>>
 >>>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 264:2
 >>>>>>   (define (call-with-exception-handler exnh thunk)
 >>>>>>     ;; The `begin0' ensures that we don't overwrite an enclosing
 >>>>>>     ;;  exception handler.
 >>>>>>     (begin0
 >>>>>>      (with-continuation-mark
 >>>>>>          exception-handler-key
 >>>>>>          exnh
 >>>>>>        (thunk))
 >>>>>>      (void)))
 >>>>>>
 >>>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\win32\window.rkt: 767:2
 >>>>>>   (define/public (dispatch-on-event e just-pre?)
 >>>>>>     (cond
 >>>>>>      [(other-modal? this e) #t]
 >>>>>>      [(call-pre-on-event this e) #t]
 >>>>>>      [just-pre? #f]
 >>>>>>      [else (when (is-enabled-to-root?) (on-event e)) #t]))
 >>>>>>
 >>>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>>>     (unless (break-paramz? paramz)
 >>>>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>>>     (unless (and (procedure? thunk)
 >>>>>>                  (procedure-arity-includes? thunk 0))
 >>>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>>>     (begin0
 >>>>>>      (with-continuation-mark
 >>>>>>          break-enabled-key
 >>>>>>          (break-paramz-ref paramz 0)
 >>>>>>        (begin
 >>>>>>          (check-for-break)
 >>>>>>          (thunk)))
 >>>>>>      (check-for-break)))
 >>>>>>
 >>>>>> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1641:30                                 (位 ()
 >>>>>>                                 ; =No-Breaks=
 >>>>>>                                 (send context reset-offer-kill)
 >>>>>>                                 (send context set-breakables (get-user-thread) (get-user-custodian))
 >>>>>>                                 (call-with-continuation-prompt
 >>>>>>                                  (位 () ; =User=, =Handler=, =No-Breaks=
 >>>>>>                                    (call-with-break-parameterization
 >>>>>>                                     user-break-parameterization
 >>>>>>                                     (位 () (primitive-dispatch-handler eventspace)))))
 >>>>>>
 >>>>>>                                 ;; in principle, the line below might cause
 >>>>>>                                 ;; "race conditions" in the GUI. That is, there might
 >>>>>>                                 ;; be many little events that the user won't quite
 >>>>>>                                 ;; be able to break.
 >>>>>>                                 (send context set-breakables #f #f)))]
 >>>>>>
 >>>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>>>     (unless (break-paramz? paramz)
 >>>>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>>>     (unless (and (procedure? thunk)
 >>>>>>                  (procedure-arity-includes? thunk 0))
 >>>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>>>     (begin0
 >>>>>>      (with-continuation-mark
 >>>>>>          break-enabled-key
 >>>>>>          (break-paramz-ref paramz 0)
 >>>>>>        (begin
 >>>>>>          (check-for-break)
 >>>>>>          (thunk)))
 >>>>>>      (check-for-break)))
 >>>>>>
 >>>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >>>>>>       (lambda ()
 >>>>>>         ;; communicate the thunk to `really-dispatch-event':
 >>>>>>         (define before (current-inexact-milliseconds))
 >>>>>>         (when (log-level? event-logger 'debug)
 >>>>>>           (log-message event-logger 'debug
 >>>>>>                        (format "starting to handle an event from ~a" (object-name thunk))
 >>>>>>                        (gui-event before #f (object-name thunk))))
 >>>>>>         (let ([b (box thunk)])
 >>>>>>           ;; use the event-dispatch handler:
 >>>>>>           (with-continuation-mark dispatch-event-key b
 >>>>>>             ((event-dispatch-handler) e))
 >>>>>>           ;; if the event-dispatch handler doesn't chain
 >>>>>>           ;; to the original one, then do so now:
 >>>>>>           (when (unbox b)
 >>>>>>             (set-box! b #f)
 >>>>>>             (thunk)))
 >>>>>>         (define after (current-inexact-milliseconds))
 >>>>>>         (when (log-level? event-logger 'debug)
 >>>>>>           (log-message event-logger 'debug
 >>>>>>                        (format "handled an event: ~a msec"
 >>>>>>                                (- after before))
 >>>>>>                        (gui-event before after (object-name thunk)))))
 >>>>>>
 >>>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >>>>>>                                 (lambda (v)
 >>>>>>                                   (when v (handle-event v e))
 >>>>>>                                   (yield evt))))
 >>>>>>
 >>>>>> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 1414:17
 >>>>>>                  (let loop () ; =User=, =Handler=, =No-Breaks=
 >>>>>>                    ; Wait for something to do
 >>>>>>                    (unless (semaphore-try-wait? eval-thread-queue-sema)
 >>>>>>                      ; User event callbacks run here; we turn on
 >>>>>>                      ;  breaks in the dispatch handler.
 >>>>>>                      (yield eval-thread-queue-sema))
 >>>>>>                    ; About to eval something
 >>>>>>                    (semaphore-wait eval-thread-state-sema)
 >>>>>>                    (let ([thunk (car eval-thread-thunks)])
 >>>>>>                      (set! eval-thread-thunks (cdr eval-thread-thunks))
 >>>>>>                      (semaphore-post eval-thread-state-sema)
 >>>>>>                      ; This thunk evals the user's expressions with appropriate
 >>>>>>                      ;   protections.
 >>>>>>                      (thunk))
 >>>>>>                    (loop)))))
 >>>>>>
 >>>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 >>>>>>       (lambda ()
 >>>>>>         ;; communicate the thunk to `really-dispatch-event':
 >>>>>>         (define before (current-inexact-milliseconds))
 >>>>>>         (when (log-level? event-logger 'debug)
 >>>>>>           (log-message event-logger 'debug
 >>>>>>                        (format "starting to handle an event from ~a" (object-name thunk))
 >>>>>>                        (gui-event before #f (object-name thunk))))
 >>>>>>         (let ([b (box thunk)])
 >>>>>>           ;; use the event-dispatch handler:
 >>>>>>           (with-continuation-mark dispatch-event-key b
 >>>>>>             ((event-dispatch-handler) e))
 >>>>>>           ;; if the event-dispatch handler doesn't chain
 >>>>>>           ;; to the original one, then do so now:
 >>>>>>           (when (unbox b)
 >>>>>>             (set-box! b #f)
 >>>>>>             (thunk)))
 >>>>>>         (define after (current-inexact-milliseconds))
 >>>>>>         (when (log-level? event-logger 'debug)
 >>>>>>           (log-message event-logger 'debug
 >>>>>>                        (format "handled an event: ~a msec"
 >>>>>>                                (- after before))
 >>>>>>                        (gui-event before after (object-name thunk)))))
 >>>>>>
 >>>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 >>>>>>                                 (lambda (v)
 >>>>>>                                   (when v (handle-event v e))
 >>>>>>                                   (yield evt))))
 >>>>>>
 >>>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 >>>>>>   (define (call-with-break-parameterization paramz thunk)
 >>>>>>     (unless (break-paramz? paramz)
 >>>>>>       (raise-argument-error 'call-with-break-parameterization "break-parameterization?" 0 paramz thunk))
 >>>>>>     (unless (and (procedure? thunk)
 >>>>>>                  (procedure-arity-includes? thunk 0))
 >>>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 paramz thunk))
 >>>>>>     (begin0
 >>>>>>      (with-continuation-mark
 >>>>>>          break-enabled-key
 >>>>>>          (break-paramz-ref paramz 0)
 >>>>>>        (begin
 >>>>>>          (check-for-break)
 >>>>>>          (thunk)))
 >>>>>>      (check-for-break)))
 >>>>>>
 >>>>>> C:\Program Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 397:18
 >>>>>>                   (let loop ()
 >>>>>>                     (call-with-continuation-prompt
 >>>>>>                      (lambda ()
 >>>>>>                        ;; re-enable breaks (if they are supposed to be enabled):
 >>>>>>                        (call-with-break-parameterization
 >>>>>>                         break-paramz
 >>>>>>                         (lambda ()
 >>>>>>                           ;; yield; any abort (including a break exception)
 >>>>>>                           ;; will get caught and the loop will yield again
 >>>>>>                           (yield (make-semaphore))))))
 >>>>>>                     (loop)))))))
 >>>>>>
 >>>>>> *** Environment:
 >>>>>> windows "Windows NT 6.1 (Build 7601) Service Pack 1" (win32\i386\3m) (get-display-depth) = 32
 >>>>>> Human Language: english
 >>>>>> (current-memory-use) 206643796
 >>>>>> raco pkg (show):
 >>>>>> Installation-wide:
 >>>>>>  Package              Checksum                                    Source
 >>>>>>  main-distribution    84a366a8c2b2908babe6c2811b0ada036bb159df    (catalog main-distribution)
 >>>>>>  racket-lib           436f0928598fc1a8abf27422e8e6588bef45f652    (catalog racket-lib)
 >>>>>>  [187 auto-installed packages not shown]
 >>>>>> User-specific for installation "6.1.1":
 >>>>>>  [none]
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>> Collections:
 >>>>>> ("C:\\Users\\Nadie\\AppData\\Roaming\\Racket\\6.1.1\\collects"
 >>>>>>  (non-existent-path))
 >>>>>> ("C:\\Program Files\\Racket\\collects"
 >>>>>>  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))
 >>>>>>
 >>>>>> Recent Internal Errors:
 >>>>>> Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t none) (default) #() "#lang racket\n" #f #t ((test) (main)) #t))
 >>>>>>
 
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Gustavo Massaccesi <gustavo@oma.org.ar>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14840: Future visualizer is crashing very frequently
Date: Wed, 19 Nov 2014 06:10:25 -0700

 Thanks for all the debugging help! It looks like this one is in my
 area, but it may be a few days before I can get to it.
 
 At Wed, 19 Nov 2014 08:30:50 -0300, Gustavo Massaccesi wrote:
 > Windows open a small white dialog with some text like "Racket GUI
 > stopped working, Windows is looking for a solution for the problem
 > ...". When you close the dialog the entire DrRacket environment
 > disappears.
 > 
 > I just removed the future-visualizer from the dependency list. I
 > replaced it with a few primitives in #%futures. This program also
 > crash during the second background expansion in DrRacket.
 > 
 > ;---
 > #lang racket
 > (require framework
 >          (only-in '#%futures
 >                   reset-future-logs-for-tracing!
 >                   mark-future-trace-end!))
 > 
 > (reset-future-logs-for-tracing!)
 > (void (make-log-receiver (current-logger) 'debug))
 > (mark-future-trace-end!)
 > ;---
 > 
 > On Tue, Nov 18, 2014 at 11:04 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 > > When you say "crash", are you talking about the entire DrRacket
 > > disappearing or a runtime error at the racket level?
 > >
 > > Robby
 > >
 > > On Tue, Nov 18, 2014 at 6:47 PM, Gustavo Massaccesi <gustavo@oma.org.ar> 
 > wrote:
 > >> New program:
 > >>
 > >> ;---
 > >> #lang racket
 > >> (require future-visualizer/trace
 > >>          future-visualizer)
 > >>
 > >> (start-future-tracing!)
 > >> (stop-future-tracing!)
 > >> :---
 > >>
 > >> 1) Open DrRacket
 > >> 2) Verify that background expansion is enabled
 > >> 3) Copy the new program
 > >> 3) Run
 > >> 4) Make an irrelevant change. For example add a space.
 > >> 5) Wait while the background expansion work
 > >> 6) Crash!
 > >>
 > >> None of the identifiers from the future-visualizer module are used
 > >> here, but if you remove it the program don't crash.
 > >>
 > >> Is it possible to run the code of the background expansion inside the 
 > program?
 > >>
 > >> Gustavo
 > >>
 > >>
 > >> On Tue, Nov 18, 2014 at 5:36 PM, Robby Findler
 > >> <robby@eecs.northwestern.edu> wrote:
 > >>> I can't get that one. I did keep getting an inexact->exact error, however.
 > >>>
 > >>> If this looks like a memory corruption bug, then I guess that these
 > >>> errors are red herrings. But I can't really tell in this case.
 > >>>
 > >>> Robby
 > >>>
 > >>> On Tue, Nov 18, 2014 at 2:28 PM, Gustavo Massaccesi <gustavo@oma.org.ar> 
 > wrote:
 > >>>> I'm using Win 7, 32 bits.
 > >>>>
 > >>>> I got a reproducible error (that most of the times don't produce a
 > >>>> direct crash).
 > >>>>
 > >>>> 1) Open DrRacket
 > >>>> 2) Copy "the" program
 > >>>> 3) Run
 > >>>> 4) In the future-visualizer, go to the "Future Creation Tree" and
 > >>>> click in the topmost circle (labeled "RTT")
 > >>>> 5) An error appears in the DrRacket interaction window:
 > >>>>
 > >>>> ..\..\..\Program
 > >>>> 
 > Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-d
 > rawing.rkt:131:0:
 > >>>>
 > >>>> event-user-data: contract violation
 > >>>>   expected: event?
 > >>>>   given: 'runtime-thread
 > >>>>
 > >>>> Gustavo
 > >>>>
 > >>>>
 > >>>> On Tue, Nov 18, 2014 at 3:46 PM, Robby Findler
 > >>>> <robby@eecs.northwestern.edu> wrote:
 > >>>>> I managed to make this happen twice under windows 32bit, but not at
 > >>>>> all under mac os x 64 bit. The crash comes for me when I click on the
 > >>>>> debug backtrace icon next to the error "inexact->exact: no exact
 > >>>>> representation". It opens up something in the visualizer and then
 > >>>>> crashes before finishing the opening.
 > >>>>>
 > >>>>>
 > >>>>>> libracket3mxxxxxxx.dll!sch_vsprintf(char * s=0x0d29c4f0, int 
 > maxlen=14040, const char * msg=0x102a7c14, char * args=0x00038514, char * * 
 > _s=0x00c3ec4c, Scheme_Object * * _errno_val=0x00000000)  Line 577 + 0x5 bytes C
 > >>>>>   libracket3mxxxxxxx.dll!scheme_log_w_data(Scheme_Logger *
 > >>>>> logger=0x11a00748, int level=5, int flags=0, Scheme_Object *
 > >>>>> data=0x0d29c4b8, const char * msg=0x102a7c14, ...)  Line 1082 C
 > >>>>>   libracket3mxxxxxxx.dll!log_place_event(const char * what=0x102a7c14,
 > >>>>> const char * tag=0x102a7c34, int has_amount=1, int amount=230676)
 > >>>>> Line 2414 + 0x19 bytes C
 > >>>>>   libracket3mxxxxxxx.dll!place_async_send(Scheme_Place_Async_Channel *
 > >>>>> ch=0x03380128, Scheme_Object * uo=0x0d29c490)  Line 3628 + 0x18 bytes
 > >>>>> C
 > >>>>>   libracket3mxxxxxxx.dll!place_send(int argc=2, Scheme_Object * *
 > >>>>> args=0x2f543f7c)  Line 3071 + 0x2b bytes C
 > >>>>>   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native_fast(Scheme_Object
 > >>>>> * rator=0x00000000, int argc=0, Scheme_Object * * argv=0x00000000)
 > >>>>> Line 1436 + 0x5 bytes C
 > >>>>>   libracket3mxxxxxxx.dll!_scheme_tail_apply_from_native(Scheme_Object
 > >>>>> * rator=0x00ceb828, int argc=2, Scheme_Object * * argv=0x2f543f7c)
 > >>>>> Line 1445 + 0xc bytes C
 > >>>>>   003e098c()
 > >>>>>   libracket3mxxxxxxx.dll!scheme_do_eval(Scheme_Object *
 > >>>>> obj=0x00000000, int num_rands=0, Scheme_Object * * rands=0x00000000,
 > >>>>> int get_value=-1)  Line 3147 + 0x26 bytes C
 > >>>>>   libracket3mxxxxxxx.dll!apply_k()  Line 1092 + 0x10 bytes C
 > >>>>>   libracket3mxxxxxxx.dll!scheme_top_level_do_worker(void * (void)*
 > >>>>> k=0x1008d320, int eb=1, int new_thread=1, Scheme_Dynamic_State *
 > >>>>> dyn_state=0x00000000)  Line 882 + 0x3 bytes C
 > >>>>>   libracket3mxxxxxxx.dll!scheme_apply_thread_thunk(Scheme_Object *
 > >>>>> rator=0x0d18b298)  Line 1123 + 0x25 bytes C
 > >>>>>   libracket3mxxxxxxx.dll!start_child(Scheme_Thread * volatile
 > >>>>> child=0x0d18b9f8, Scheme_Object * volatile child_eval=0x0d18b298)
 > >>>>> Line 3330 + 0xc bytes C
 > >>>>>   libracket3mxxxxxxx.dll!make_subprocess(Scheme_Object *
 > >>>>> child_thunk=0x0d18b298, void * child_start=0x00c3f06c, Scheme_Config *
 > >>>>> config=0x11a006a8, Scheme_Bucket_Table * cells=0x0d18b2d0,
 > >>>>> Scheme_Object * break_cell=0x11a04fc0, Scheme_Custodian *
 > >>>>> mgr=0x00000000, int normal_kill=1)  Line 3429 C
 > >>>>>   libracket3mxxxxxxx.dll!scheme_thread_w_details(Scheme_Object *
 > >>>>> thunk=0x00000000, Scheme_Config * config=0x00000000,
 > >>>>> Scheme_Bucket_Table * cells=0x00000000, Scheme_Object *
 > >>>>> break_cell=0x00c3f254, Scheme_Custodian * mgr=0x00000010, int
 > >>>>> suspend_to_kill=12841268)  Line 3714 + 0x2d bytes C
 > >>>>>
 > >>>>> On Tue, Nov 18, 2014 at 6:44 AM,  <gustavo@oma.org.ar> wrote:
 > >>>>>> A new problem report is waiting at
 > >>>>>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14840
 > >>>>>>
 > >>>>>> Reported by Gustavo Massaccesi for release: 6.1.1
 > >>>>>>
 > >>>>>> *** Description:
 > >>>>>> The future-visualizer is crashing very frequently. I'm using Win7.
 > >>>>>>
 > >>>>>> Usually it simply crash, but once I got this backtrace. I'm not sure if 
 > the problem is here or there is a wrong pointer elsewhere. I couldn't find an 
 > example where the crash is easy to reproduce.
 > >>>>>>
 > >>>>>> *** How to repeat:
 > >>>>>> 1) Open DrRacket
 > >>>>>> 2) Copy this program
 > >>>>>> 3) Run
 > >>>>>> 4) Close the future-visualizer
 > >>>>>> 5) Repeat 3) and 4) a few times until it crash.
 > >>>>>>
 > >>>>>> ;;; Program: ------------------
 > >>>>>> #lang racket
 > >>>>>> (require racket/future
 > >>>>>>          future-visualizer)
 > >>>>>>
 > >>>>>> (visualize-futures
 > >>>>>>  (let* ([z (random 1)]
 > >>>>>>         [f (future (lambda () (display z)))]
 > >>>>>>         [g (future (lambda () (display z)))])
 > >>>>>>    (display z)
 > >>>>>>    (touch f)
 > >>>>>>    (touch g)))
 > >>>>>>
 > >>>>>> ;;; Error: ------------------
 > >>>>>> event-user-data: contract violation
 > >>>>>>   expected: event?
 > >>>>>>   given: 'runtime-thread
 > >>>>>>
 > >>>>>> C:\Program 
 > Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-d
 > rawing.rkt: 131:0
 > >>>>>> (define (find-fid-for-coords x y nodes vregion)
 > >>>>>>   (define n (find-node-for-coords x y nodes))
 > >>>>>>   (if n
 > >>>>>>       (event-user-data (node-data (drawable-node-node n)))
 > >>>>>>       #f))
 > >>>>>>
 > >>>>>> C:\Program 
 > Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\visualizer-g
 > ui.rkt: 243:48
 > >>>>>>                                  [click-handler (位 (x y vregion)
 > >>>>>>                                                   (define fid 
 > (find-fid-for-coords
 > >>>>>>                                                                x y 
 > (graph-layout-nodes creation-tree-layout)
 > >>>>>>                                                                vregion))
 > >>>>>>                                                   (cond
 > >>>>>>                                                     [(not fid) #f]
 > >>>>>>                                                     [else
 > >>>>>>                                                      (define seg 
 > (first-seg-for-fid fid segments))
 > >>>>>>                                                      (set! tacked-seg 
 > seg)
 > >>>>>>                                                      (send 
 > timeline-panel redraw-everything)
 > >>>>>>                                                      (post-event 
 > listener-table 'segment-click timeline-panel seg)
 > >>>>>>                                                      #t]))]
 > >>>>>>
 > >>>>>> C:\Program 
 > Files\Racket\share\pkgs\future-visualizer\future-visualizer\private\pict-canvas.
 > rkt: 100:4
 > >>>>>>     (define/override (on-event event)
 > >>>>>>       (define vregion (get-viewable-region))
 > >>>>>>       (define x (+ (viewable-region-x vregion) (/ (send event get-x) 
 > scale-factor)))
 > >>>>>>       (define y (+ (viewable-region-y vregion) (/ (send event get-y) 
 > scale-factor)))
 > >>>>>>       (case (send event get-event-type)
 > >>>>>>         [(motion)
 > >>>>>>          (when mh
 > >>>>>>            (when (mh x y vregion) ;Mouse handler returns non-false if a 
 > state change requiring redraw occurred
 > >>>>>>              (redraw-the-bitmap/maybe-delayed! vregion #:delay 0 
 > #:only-the-overlay? #t)))]
 > >>>>>>         [(left-up)
 > >>>>>>          (when ch (ch x y vregion)) ;Ditto for click handler
 > >>>>>>          (redraw-the-bitmap/maybe-delayed! vregion #:only-the-overlay? 
 > #t)]))
 > >>>>>>
 > >>>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 > >>>>>>   (define (call-with-break-parameterization paramz thunk)
 > >>>>>>     (unless (break-paramz? paramz)
 > >>>>>>       (raise-argument-error 'call-with-break-parameterization 
 > "break-parameterization?" 0 paramz thunk))
 > >>>>>>     (unless (and (procedure? thunk)
 > >>>>>>                  (procedure-arity-includes? thunk 0))
 > >>>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 
 > paramz thunk))
 > >>>>>>     (begin0
 > >>>>>>      (with-continuation-mark
 > >>>>>>          break-enabled-key
 > >>>>>>          (break-paramz-ref paramz 0)
 > >>>>>>        (begin
 > >>>>>>          (check-for-break)
 > >>>>>>          (thunk)))
 > >>>>>>      (check-for-break)))
 > >>>>>>
 > >>>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 264:2
 > >>>>>>   (define (call-with-exception-handler exnh thunk)
 > >>>>>>     ;; The `begin0' ensures that we don't overwrite an enclosing
 > >>>>>>     ;;  exception handler.
 > >>>>>>     (begin0
 > >>>>>>      (with-continuation-mark
 > >>>>>>          exception-handler-key
 > >>>>>>          exnh
 > >>>>>>        (thunk))
 > >>>>>>      (void)))
 > >>>>>>
 > >>>>>> C:\Program 
 > Files\Racket\share\pkgs\gui-lib\mred\private\wx\win32\window.rkt: 767:2
 > >>>>>>   (define/public (dispatch-on-event e just-pre?)
 > >>>>>>     (cond
 > >>>>>>      [(other-modal? this e) #t]
 > >>>>>>      [(call-pre-on-event this e) #t]
 > >>>>>>      [just-pre? #f]
 > >>>>>>      [else (when (is-enabled-to-root?) (on-event e)) #t]))
 > >>>>>>
 > >>>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 > >>>>>>   (define (call-with-break-parameterization paramz thunk)
 > >>>>>>     (unless (break-paramz? paramz)
 > >>>>>>       (raise-argument-error 'call-with-break-parameterization 
 > "break-parameterization?" 0 paramz thunk))
 > >>>>>>     (unless (and (procedure? thunk)
 > >>>>>>                  (procedure-arity-includes? thunk 0))
 > >>>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 
 > paramz thunk))
 > >>>>>>     (begin0
 > >>>>>>      (with-continuation-mark
 > >>>>>>          break-enabled-key
 > >>>>>>          (break-paramz-ref paramz 0)
 > >>>>>>        (begin
 > >>>>>>          (check-for-break)
 > >>>>>>          (thunk)))
 > >>>>>>      (check-for-break)))
 > >>>>>>
 > >>>>>> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 
 > 1641:30                                 (位 ()
 > >>>>>>                                 ; =No-Breaks=
 > >>>>>>                                 (send context reset-offer-kill)
 > >>>>>>                                 (send context set-breakables 
 > (get-user-thread) (get-user-custodian))
 > >>>>>>                                 (call-with-continuation-prompt
 > >>>>>>                                  (位 () ; =User=, =Handler=, =No-Breaks=
 > >>>>>>                                    (call-with-break-parameterization
 > >>>>>>                                     user-break-parameterization
 > >>>>>>                                     (位 () (primitive-dispatch-handler 
 > eventspace)))))
 > >>>>>>
 > >>>>>>                                 ;; in principle, the line below might 
 > cause
 > >>>>>>                                 ;; "race conditions" in the GUI. That 
 > is, there might
 > >>>>>>                                 ;; be many little events that the user 
 > won't quite
 > >>>>>>                                 ;; be able to break.
 > >>>>>>                                 (send context set-breakables #f #f)))]
 > >>>>>>
 > >>>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 > >>>>>>   (define (call-with-break-parameterization paramz thunk)
 > >>>>>>     (unless (break-paramz? paramz)
 > >>>>>>       (raise-argument-error 'call-with-break-parameterization 
 > "break-parameterization?" 0 paramz thunk))
 > >>>>>>     (unless (and (procedure? thunk)
 > >>>>>>                  (procedure-arity-includes? thunk 0))
 > >>>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 
 > paramz thunk))
 > >>>>>>     (begin0
 > >>>>>>      (with-continuation-mark
 > >>>>>>          break-enabled-key
 > >>>>>>          (break-paramz-ref paramz 0)
 > >>>>>>        (begin
 > >>>>>>          (check-for-break)
 > >>>>>>          (thunk)))
 > >>>>>>      (check-for-break)))
 > >>>>>>
 > >>>>>> C:\Program 
 > Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 > >>>>>>       (lambda ()
 > >>>>>>         ;; communicate the thunk to `really-dispatch-event':
 > >>>>>>         (define before (current-inexact-milliseconds))
 > >>>>>>         (when (log-level? event-logger 'debug)
 > >>>>>>           (log-message event-logger 'debug
 > >>>>>>                        (format "starting to handle an event from ~a" 
 > (object-name thunk))
 > >>>>>>                        (gui-event before #f (object-name thunk))))
 > >>>>>>         (let ([b (box thunk)])
 > >>>>>>           ;; use the event-dispatch handler:
 > >>>>>>           (with-continuation-mark dispatch-event-key b
 > >>>>>>             ((event-dispatch-handler) e))
 > >>>>>>           ;; if the event-dispatch handler doesn't chain
 > >>>>>>           ;; to the original one, then do so now:
 > >>>>>>           (when (unbox b)
 > >>>>>>             (set-box! b #f)
 > >>>>>>             (thunk)))
 > >>>>>>         (define after (current-inexact-milliseconds))
 > >>>>>>         (when (log-level? event-logger 'debug)
 > >>>>>>           (log-message event-logger 'debug
 > >>>>>>                        (format "handled an event: ~a msec"
 > >>>>>>                                (- after before))
 > >>>>>>                        (gui-event before after (object-name thunk)))))
 > >>>>>>
 > >>>>>> C:\Program 
 > Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 > >>>>>>                                 (lambda (v)
 > >>>>>>                                   (when v (handle-event v e))
 > >>>>>>                                   (yield evt))))
 > >>>>>>
 > >>>>>> C:\Program Files\Racket\share\pkgs\drracket\drracket\private\rep.rkt: 
 > 1414:17
 > >>>>>>                  (let loop () ; =User=, =Handler=, =No-Breaks=
 > >>>>>>                    ; Wait for something to do
 > >>>>>>                    (unless (semaphore-try-wait? eval-thread-queue-sema)
 > >>>>>>                      ; User event callbacks run here; we turn on
 > >>>>>>                      ;  breaks in the dispatch handler.
 > >>>>>>                      (yield eval-thread-queue-sema))
 > >>>>>>                    ; About to eval something
 > >>>>>>                    (semaphore-wait eval-thread-state-sema)
 > >>>>>>                    (let ([thunk (car eval-thread-thunks)])
 > >>>>>>                      (set! eval-thread-thunks (cdr eval-thread-thunks))
 > >>>>>>                      (semaphore-post eval-thread-state-sema)
 > >>>>>>                      ; This thunk evals the user's expressions with 
 > appropriate
 > >>>>>>                      ;   protections.
 > >>>>>>                      (thunk))
 > >>>>>>                    (loop)))))
 > >>>>>>
 > >>>>>> C:\Program 
 > Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 451:6
 > >>>>>>       (lambda ()
 > >>>>>>         ;; communicate the thunk to `really-dispatch-event':
 > >>>>>>         (define before (current-inexact-milliseconds))
 > >>>>>>         (when (log-level? event-logger 'debug)
 > >>>>>>           (log-message event-logger 'debug
 > >>>>>>                        (format "starting to handle an event from ~a" 
 > (object-name thunk))
 > >>>>>>                        (gui-event before #f (object-name thunk))))
 > >>>>>>         (let ([b (box thunk)])
 > >>>>>>           ;; use the event-dispatch handler:
 > >>>>>>           (with-continuation-mark dispatch-event-key b
 > >>>>>>             ((event-dispatch-handler) e))
 > >>>>>>           ;; if the event-dispatch handler doesn't chain
 > >>>>>>           ;; to the original one, then do so now:
 > >>>>>>           (when (unbox b)
 > >>>>>>             (set-box! b #f)
 > >>>>>>             (thunk)))
 > >>>>>>         (define after (current-inexact-milliseconds))
 > >>>>>>         (when (log-level? event-logger 'debug)
 > >>>>>>           (log-message event-logger 'debug
 > >>>>>>                        (format "handled an event: ~a msec"
 > >>>>>>                                (- after before))
 > >>>>>>                        (gui-event before after (object-name thunk)))))
 > >>>>>>
 > >>>>>> C:\Program 
 > Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 502:32
 > >>>>>>                                 (lambda (v)
 > >>>>>>                                   (when v (handle-event v e))
 > >>>>>>                                   (yield evt))))
 > >>>>>>
 > >>>>>> C:\Program Files\Racket\collects\racket\private\more-scheme.rkt: 147:2
 > >>>>>>   (define (call-with-break-parameterization paramz thunk)
 > >>>>>>     (unless (break-paramz? paramz)
 > >>>>>>       (raise-argument-error 'call-with-break-parameterization 
 > "break-parameterization?" 0 paramz thunk))
 > >>>>>>     (unless (and (procedure? thunk)
 > >>>>>>                  (procedure-arity-includes? thunk 0))
 > >>>>>>       (raise-argument-error 'call-with-parameterization "(-> any)" 1 
 > paramz thunk))
 > >>>>>>     (begin0
 > >>>>>>      (with-continuation-mark
 > >>>>>>          break-enabled-key
 > >>>>>>          (break-paramz-ref paramz 0)
 > >>>>>>        (begin
 > >>>>>>          (check-for-break)
 > >>>>>>          (thunk)))
 > >>>>>>      (check-for-break)))
 > >>>>>>
 > >>>>>> C:\Program 
 > Files\Racket\share\pkgs\gui-lib\mred\private\wx\common\queue.rkt: 397:18
 > >>>>>>                   (let loop ()
 > >>>>>>                     (call-with-continuation-prompt
 > >>>>>>                      (lambda ()
 > >>>>>>                        ;; re-enable breaks (if they are supposed to be 
 > enabled):
 > >>>>>>                        (call-with-break-parameterization
 > >>>>>>                         break-paramz
 > >>>>>>                         (lambda ()
 > >>>>>>                           ;; yield; any abort (including a break 
 > exception)
 > >>>>>>                           ;; will get caught and the loop will yield 
 > again
 > >>>>>>                           (yield (make-semaphore))))))
 > >>>>>>                     (loop)))))))
 > >>>>>>
 > >>>>>> *** Environment:
 > >>>>>> windows "Windows NT 6.1 (Build 7601) Service Pack 1" (win32\i386\3m) 
 > (get-display-depth) = 32
 > >>>>>> Human Language: english
 > >>>>>> (current-memory-use) 206643796
 > >>>>>> raco pkg (show):
 > >>>>>> Installation-wide:
 > >>>>>>  Package              Checksum                                    Source
 > >>>>>>  main-distribution    84a366a8c2b2908babe6c2811b0ada036bb159df    
 > (catalog main-distribution)
 > >>>>>>  racket-lib           436f0928598fc1a8abf27422e8e6588bef45f652    
 > (catalog racket-lib)
 > >>>>>>  [187 auto-installed packages not shown]
 > >>>>>> User-specific for installation "6.1.1":
 > >>>>>>  [none]
 > >>>>>>
 > >>>>>>
 > >>>>>>
 > >>>>>> Collections:
 > >>>>>> ("C:\\Users\\Nadie\\AppData\\Roaming\\Racket\\6.1.1\\collects"
 > >>>>>>  (non-existent-path))
 > >>>>>> ("C:\\Program Files\\Racket\\collects"
 > >>>>>>  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" 
 > "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" 
 > "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))
 > >>>>>>
 > >>>>>> Recent Internal Errors:
 > >>>>>> Computer Language: (("Determine language from source") (#(#t print 
 > mixed-fraction-e #f #t none) (default) #() "#lang racket\n" #f #t ((test) 
 > (main)) #t))
 > >>>>>>
 
