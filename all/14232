From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Sun Dec  8 09:52:13 2013
Received: from mail-ob0-f174.google.com (mail-ob0-f174.google.com [209.85.214.174])
	by winooski.ccs.neu.edu (8.14.7/8.14.7) with ESMTP id rB8Eq9is013542
	for <bugs@bugs.plt-scheme.org>; Sun, 8 Dec 2013 09:52:10 -0500
Message-Id: <201312081452.rB8Eq7Og013535@winooski.ccs.neu.edu>
Date: Sun, 8 Dec 2013 09:52:07 -0500
From: rxg@cs.ubc.ca
To: bugs@racket-lang.org
Subject: in teaching languages, max and min turn exact numbers into inexact numbers

>Number:         14232
>Category:       all
>Synopsis:       in teaching languages, max and min turn exact numbers into inexact numbers
>Class:          change-request
>Responsible:    nobody
>Severity:       non-critical
>Priority:       medium
>State:          open
>Confidential:   no
>Arrival-Date:   Sun Dec 08 09:56:01 -0500 2013
>Last-Modified:  Sat Dec 21 18:40:01 -0500 2013
>Originator:     Ron Garcia
>Organization:
plt
>Submitter-Id:   unknown
>Release:        5.3.6
>Environment:
macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 29 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64" (i386-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 144107028
Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()
raco pkg (show):
Installation-wide:
 [none]
User-specific, all-version:
 [none]
User-specific, version-specific (5.3.6):
 [none]



Collections:
("/Users/Ron/Library/Racket/5.3.6/collects"
 (non-existent-path))
("/Applications/Racket v5.3.6/collects"
 ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config" "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist" "htdp" "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax" "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed" "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme" "xml" "xrepl"))

Computer Language: (("Teaching Languages" "How to Design Programs" "Intermediate Student with lambda") (#(#t constructor repeating-decimal #f #t none) #f ()))
>Description:
The Racket documentation does say that "Unless otherwise specified, computations that involve an inexact number produce inexact results." but the following surprised me: if one number out of two given to max or min is inexact, and the result should be the other number, it is transformed into an inexact number.  
>How-To-Repeat:
> (min 6 #i7.0)
#i6.0

> (max 8 #i7.0)
#i8.0
>Fix:
>Audit-Trail:
From: Matthew Flatt <mflatt@cs.utah.edu>
To: rxg@cs.ubc.ca, bugs@racket-lang.org
Cc: nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn exact numbers into inexact numbers
Date: Sun, 8 Dec 2013 08:13:52 -0700

 Yes, that's as intended.
 
 The rationale is "produce an inexact output when the computation is
 tainted by an inexact input". For example, #i7.0 might be so inexact
 that the actual value should have been 5.9.
 
 Since there are no inexact booleans or other inexact kinds of data,
 this idea doesn't necessarily work right. If we're going to allow
 mixtures of exact and inexact numbers, however, it seems to be as good
 a rule as any.
 
 At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 > A new problem report is waiting at
 >   http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 > 
 > Reported by Ron Garcia for release: 5.3.6
 > 
 > *** Description:
 > The Racket documentation does say that "Unless otherwise specified, 
 > computations that involve an inexact number produce inexact results." but the 
 > following surprised me: if one number out of two given to max or min is 
 > inexact, and the result should be the other number, it is transformed into an 
 > inexact number.  
 > 
 > *** How to repeat:
 > > (min 6 #i7.0)
 > #i6.0
 > 
 > > (max 8 #i7.0)
 > #i8.0
 > 
 > *** Environment:
 > macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 29 
 > 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64" 
 > (i386-macosx/3m) (get-display-depth) = 32
 > Human Language: english
 > (current-memory-use) 144107028
 > Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links 
 > #:user? #f #:root? #t) = ()
 > raco pkg (show):
 > Installation-wide:
 >  [none]
 > User-specific, all-version:
 >  [none]
 > User-specific, version-specific (5.3.6):
 >  [none]
 > 
 > 
 > 
 > Collections:
 > ("/Users/Ron/Library/Racket/5.3.6/collects"
 >  (non-existent-path))
 > ("/Applications/Racket v5.3.6/collects"
 >  ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config" 
 > "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" 
 > "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" 
 > "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist" "htdp" 
 > "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" 
 > "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib" 
 > "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg" "plai" 
 > "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" 
 > "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp" "scheme" 
 > "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" 
 > "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax" 
 > "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed" 
 > "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme" "xml" 
 > "xrepl"))
 > 
 > Computer Language: (("Teaching Languages" "How to Design Programs" 
 > "Intermediate Student with lambda") (#(#t constructor repeating-decimal #f #t 
 > none) #f ()))
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Ron Garcia <rxg@cs.ubc.ca>
Cc: bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn exact numbers into inexact numbers
Date: Sun, 8 Dec 2013 08:26:28 -0700

 Ah, I can see why you're want to use inexact infinities that way. All I
 can say is that it doesn't work, due to the constraint of having `min`
 follow the inexactness "taint" rule.
 
 At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 > Thanks for the fast turnaround Matthew.  And the rationale makes sense to me.
 > I realized after-the-fact that my report was rather indirect. 
 > What I was really interested in is being able to use max and min with infinity 
 > and negative infinity without
 > having to meddle with inexact numbers.  Basically I'd love to write something 
 > like:
 > 
 > (min 6 +inf)  
 > 
 > rather than
 > 
 > (inexact->exact (min 6 +inf.0)) 
 > 
 > in the teaching languages, since we haven't taught 110 students about inexact 
 > numbers in the first place.
 > I got caught up in figuring out what was happening and forgot to mention my 
 > real interest.
 > 
 > Cheers,
 > Ron
 > 
 > 
 > 
 > On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > 
 > > Yes, that's as intended.
 > > 
 > > The rationale is "produce an inexact output when the computation is
 > > tainted by an inexact input". For example, #i7.0 might be so inexact
 > > that the actual value should have been 5.9.
 > > 
 > > Since there are no inexact booleans or other inexact kinds of data,
 > > this idea doesn't necessarily work right. If we're going to allow
 > > mixtures of exact and inexact numbers, however, it seems to be as good
 > > a rule as any.
 > > 
 > > At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 > >> A new problem report is waiting at
 > >>  http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 > >> 
 > >> Reported by Ron Garcia for release: 5.3.6
 > >> 
 > >> *** Description:
 > >> The Racket documentation does say that "Unless otherwise specified, 
 > >> computations that involve an inexact number produce inexact results." but 
 > the 
 > >> following surprised me: if one number out of two given to max or min is 
 > >> inexact, and the result should be the other number, it is transformed into 
 > an 
 > >> inexact number.  
 > >> 
 > >> *** How to repeat:
 > >>> (min 6 #i7.0)
 > >> #i6.0
 > >> 
 > >>> (max 8 #i7.0)
 > >> #i8.0
 > >> 
 > >> *** Environment:
 > >> macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 29 
 > >> 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64" 
 > >> (i386-macosx/3m) (get-display-depth) = 32
 > >> Human Language: english
 > >> (current-memory-use) 144107028
 > >> Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); 
 > (links 
 > >> #:user? #f #:root? #t) = ()
 > >> raco pkg (show):
 > >> Installation-wide:
 > >> [none]
 > >> User-specific, all-version:
 > >> [none]
 > >> User-specific, version-specific (5.3.6):
 > >> [none]
 > >> 
 > >> 
 > >> 
 > >> Collections:
 > >> ("/Users/Ron/Library/Racket/5.3.6/collects"
 > >> (non-existent-path))
 > >> ("/Applications/Racket v5.3.6/collects"
 > >> ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config" 
 > >> "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" 
 > "dynext" 
 > >> "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" 
 > >> "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist" 
 > "htdp" 
 > >> "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" 
 > >> "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib" 
 > >> "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg" "plai" 
 > >> "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" 
 > >> "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp" 
 > "scheme" 
 > >> "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" 
 > >> "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax" 
 > >> "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed" 
 > >> "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme" 
 > "xml" 
 > >> "xrepl"))
 > >> 
 > >> Computer Language: (("Teaching Languages" "How to Design Programs" 
 > >> "Intermediate Student with lambda") (#(#t constructor repeating-decimal #f 
 > #t 
 > >> none) #f ()))
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Ron Garcia <rxg@cs.ubc.ca>
Cc: bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn exact numbers into inexact numbers
Date: Sun, 8 Dec 2013 08:39:33 -0700

 Unfortunately, extending the number tower is a lot of work --- even for
 the teaching languages, since they interact with other libraries via
 `require`. So, I doubt that request would go anywhere, though it's
 always possible that someone will have a good idea on how to make it
 work.
 
 At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:
 > Is it worth requesting the addition of exact infinities, at least for the 
 > teaching languages?
 > 
 > Ron
 > 
 > 
 > On 2013-12-08, at 12:26 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > 
 > > Ah, I can see why you're want to use inexact infinities that way. All I
 > > can say is that it doesn't work, due to the constraint of having `min`
 > > follow the inexactness "taint" rule.
 > > 
 > > At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 > >> Thanks for the fast turnaround Matthew.  And the rationale makes sense to 
 > me.
 > >> I realized after-the-fact that my report was rather indirect. 
 > >> What I was really interested in is being able to use max and min with 
 > infinity 
 > >> and negative infinity without
 > >> having to meddle with inexact numbers.  Basically I'd love to write 
 > something 
 > >> like:
 > >> 
 > >> (min 6 +inf)  
 > >> 
 > >> rather than
 > >> 
 > >> (inexact->exact (min 6 +inf.0)) 
 > >> 
 > >> in the teaching languages, since we haven't taught 110 students about 
 > inexact 
 > >> numbers in the first place.
 > >> I got caught up in figuring out what was happening and forgot to mention my 
 > >> real interest.
 > >> 
 > >> Cheers,
 > >> Ron
 > >> 
 > >> 
 > >> 
 > >> On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > >> 
 > >>> Yes, that's as intended.
 > >>> 
 > >>> The rationale is "produce an inexact output when the computation is
 > >>> tainted by an inexact input". For example, #i7.0 might be so inexact
 > >>> that the actual value should have been 5.9.
 > >>> 
 > >>> Since there are no inexact booleans or other inexact kinds of data,
 > >>> this idea doesn't necessarily work right. If we're going to allow
 > >>> mixtures of exact and inexact numbers, however, it seems to be as good
 > >>> a rule as any.
 > >>> 
 > >>> At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 > >>>> A new problem report is waiting at
 > >>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 > >>>> 
 > >>>> Reported by Ron Garcia for release: 5.3.6
 > >>>> 
 > >>>> *** Description:
 > >>>> The Racket documentation does say that "Unless otherwise specified, 
 > >>>> computations that involve an inexact number produce inexact results." but 
 > >> the 
 > >>>> following surprised me: if one number out of two given to max or min is 
 > >>>> inexact, and the result should be the other number, it is transformed 
 > into 
 > >> an 
 > >>>> inexact number.  
 > >>>> 
 > >>>> *** How to repeat:
 > >>>>> (min 6 #i7.0)
 > >>>> #i6.0
 > >>>> 
 > >>>>> (max 8 #i7.0)
 > >>>> #i8.0
 > >>>> 
 > >>>> *** Environment:
 > >>>> macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 29 
 > >>>> 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64" 
 > >>>> (i386-macosx/3m) (get-display-depth) = 32
 > >>>> Human Language: english
 > >>>> (current-memory-use) 144107028
 > >>>> Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); 
 > >> (links 
 > >>>> #:user? #f #:root? #t) = ()
 > >>>> raco pkg (show):
 > >>>> Installation-wide:
 > >>>> [none]
 > >>>> User-specific, all-version:
 > >>>> [none]
 > >>>> User-specific, version-specific (5.3.6):
 > >>>> [none]
 > >>>> 
 > >>>> 
 > >>>> 
 > >>>> Collections:
 > >>>> ("/Users/Ron/Library/Racket/5.3.6/collects"
 > >>>> (non-existent-path))
 > >>>> ("/Applications/Racket v5.3.6/collects"
 > >>>> ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config" 
 > >>>> "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" 
 > >> "dynext" 
 > >>>> "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" 
 > >>>> "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist" 
 > >> "htdp" 
 > >>>> "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" 
 > >>>> "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib" 
 > >>>> "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg" 
 > "plai" 
 > >>>> "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" 
 > >>>> "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp" 
 > >> "scheme" 
 > >>>> "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" 
 > >>>> "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax" 
 > >>>> "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed" 
 > >>>> "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme" 
 > >> "xml" 
 > >>>> "xrepl"))
 > >>>> 
 > >>>> Computer Language: (("Teaching Languages" "How to Design Programs" 
 > >>>> "Intermediate Student with lambda") (#(#t constructor repeating-decimal 
 > #f 
 > >> #t 
 > >>>> none) #f ()))
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: Ron Garcia <rxg@cs.ubc.ca>, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn exact numbers into inexact numbers
Date: Sun, 8 Dec 2013 10:43:28 -0500

 Matthew, I think Ron is asking for one change only (which I wished for in my class demo too): 
 
 The essence of min/max is this: 
 
 (if (> #i6.0 7)
     #i6.0
     7)
 
 I can deal with min of a possibly infinite list by throwing in #i-inf.0 (similar for max). 
 If min and max were implemented with plain if's, wouldn't the tainting go away? 
 
 We could do this for the teaching languages. -- Matthias
 
 
 
 
 On Dec 8, 2013, at 10:39 AM, Matthew Flatt wrote:
 
 > Unfortunately, extending the number tower is a lot of work --- even for
 > the teaching languages, since they interact with other libraries via
 > `require`. So, I doubt that request would go anywhere, though it's
 > always possible that someone will have a good idea on how to make it
 > work.
 > 
 > At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:
 >> Is it worth requesting the addition of exact infinities, at least for the 
 >> teaching languages?
 >> 
 >> Ron
 >> 
 >> 
 >> On 2013-12-08, at 12:26 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >> 
 >>> Ah, I can see why you're want to use inexact infinities that way. All I
 >>> can say is that it doesn't work, due to the constraint of having `min`
 >>> follow the inexactness "taint" rule.
 >>> 
 >>> At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 >>>> Thanks for the fast turnaround Matthew.  And the rationale makes sense to 
 >> me.
 >>>> I realized after-the-fact that my report was rather indirect. 
 >>>> What I was really interested in is being able to use max and min with 
 >> infinity 
 >>>> and negative infinity without
 >>>> having to meddle with inexact numbers.  Basically I'd love to write 
 >> something 
 >>>> like:
 >>>> 
 >>>> (min 6 +inf)  
 >>>> 
 >>>> rather than
 >>>> 
 >>>> (inexact->exact (min 6 +inf.0)) 
 >>>> 
 >>>> in the teaching languages, since we haven't taught 110 students about 
 >> inexact 
 >>>> numbers in the first place.
 >>>> I got caught up in figuring out what was happening and forgot to mention my 
 >>>> real interest.
 >>>> 
 >>>> Cheers,
 >>>> Ron
 >>>> 
 >>>> 
 >>>> 
 >>>> On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>>> 
 >>>>> Yes, that's as intended.
 >>>>> 
 >>>>> The rationale is "produce an inexact output when the computation is
 >>>>> tainted by an inexact input". For example, #i7.0 might be so inexact
 >>>>> that the actual value should have been 5.9.
 >>>>> 
 >>>>> Since there are no inexact booleans or other inexact kinds of data,
 >>>>> this idea doesn't necessarily work right. If we're going to allow
 >>>>> mixtures of exact and inexact numbers, however, it seems to be as good
 >>>>> a rule as any.
 >>>>> 
 >>>>> At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 >>>>>> A new problem report is waiting at
 >>>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 >>>>>> 
 >>>>>> Reported by Ron Garcia for release: 5.3.6
 >>>>>> 
 >>>>>> *** Description:
 >>>>>> The Racket documentation does say that "Unless otherwise specified, 
 >>>>>> computations that involve an inexact number produce inexact results." but 
 >>>> the 
 >>>>>> following surprised me: if one number out of two given to max or min is 
 >>>>>> inexact, and the result should be the other number, it is transformed 
 >> into 
 >>>> an 
 >>>>>> inexact number.  
 >>>>>> 
 >>>>>> *** How to repeat:
 >>>>>>> (min 6 #i7.0)
 >>>>>> #i6.0
 >>>>>> 
 >>>>>>> (max 8 #i7.0)
 >>>>>> #i8.0
 >>>>>> 
 >>>>>> *** Environment:
 >>>>>> macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 29 
 >>>>>> 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64" 
 >>>>>> (i386-macosx/3m) (get-display-depth) = 32
 >>>>>> Human Language: english
 >>>>>> (current-memory-use) 144107028
 >>>>>> Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); 
 >>>> (links 
 >>>>>> #:user? #f #:root? #t) = ()
 >>>>>> raco pkg (show):
 >>>>>> Installation-wide:
 >>>>>> [none]
 >>>>>> User-specific, all-version:
 >>>>>> [none]
 >>>>>> User-specific, version-specific (5.3.6):
 >>>>>> [none]
 >>>>>> 
 >>>>>> 
 >>>>>> 
 >>>>>> Collections:
 >>>>>> ("/Users/Ron/Library/Racket/5.3.6/collects"
 >>>>>> (non-existent-path))
 >>>>>> ("/Applications/Racket v5.3.6/collects"
 >>>>>> ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config" 
 >>>>>> "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" 
 >>>> "dynext" 
 >>>>>> "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" 
 >>>>>> "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist" 
 >>>> "htdp" 
 >>>>>> "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" 
 >>>>>> "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib" 
 >>>>>> "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg" 
 >> "plai" 
 >>>>>> "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" 
 >>>>>> "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp" 
 >>>> "scheme" 
 >>>>>> "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" 
 >>>>>> "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax" 
 >>>>>> "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed" 
 >>>>>> "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme" 
 >>>> "xml" 
 >>>>>> "xrepl"))
 >>>>>> 
 >>>>>> Computer Language: (("Teaching Languages" "How to Design Programs" 
 >>>>>> "Intermediate Student with lambda") (#(#t constructor repeating-decimal 
 >> #f 
 >>>> #t 
 >>>>>> none) #f ()))
 
 
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Ron Garcia <rxg@cs.ubc.ca>, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn exact numbers into inexact numbers
Date: Sun, 8 Dec 2013 08:59:18 -0700

 We could certainly provide a different `min` and `max` in the teaching
 languages, but changing them doesn't seem like a good idea to me.
 
 Although we haven't kept strictly to the idea that teaching-language
 programs work unmodified as Racket programs, I think we've always had
 the correspondence in mind as a rule of thumb, and I think we've
 avoided making teaching-language programs produce different non-error
 results when run as Racket programs.
 
 At Sun, 8 Dec 2013 10:43:28 -0500, Matthias Felleisen wrote:
 > 
 > Matthew, I think Ron is asking for one change only (which I wished for in my 
 > class demo too): 
 > 
 > The essence of min/max is this: 
 > 
 > (if (> #i6.0 7)
 >     #i6.0
 >     7)
 > 
 > I can deal with min of a possibly infinite list by throwing in #i-inf.0 
 > (similar for max). 
 > If min and max were implemented with plain if's, wouldn't the tainting go 
 > away? 
 > 
 > We could do this for the teaching languages. -- Matthias
 > 
 > 
 > 
 > 
 > On Dec 8, 2013, at 10:39 AM, Matthew Flatt wrote:
 > 
 > > Unfortunately, extending the number tower is a lot of work --- even for
 > > the teaching languages, since they interact with other libraries via
 > > `require`. So, I doubt that request would go anywhere, though it's
 > > always possible that someone will have a good idea on how to make it
 > > work.
 > > 
 > > At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:
 > >> Is it worth requesting the addition of exact infinities, at least for the 
 > >> teaching languages?
 > >> 
 > >> Ron
 > >> 
 > >> 
 > >> On 2013-12-08, at 12:26 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > >> 
 > >>> Ah, I can see why you're want to use inexact infinities that way. All I
 > >>> can say is that it doesn't work, due to the constraint of having `min`
 > >>> follow the inexactness "taint" rule.
 > >>> 
 > >>> At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 > >>>> Thanks for the fast turnaround Matthew.  And the rationale makes sense to 
 > >> me.
 > >>>> I realized after-the-fact that my report was rather indirect. 
 > >>>> What I was really interested in is being able to use max and min with 
 > >> infinity 
 > >>>> and negative infinity without
 > >>>> having to meddle with inexact numbers.  Basically I'd love to write 
 > >> something 
 > >>>> like:
 > >>>> 
 > >>>> (min 6 +inf)  
 > >>>> 
 > >>>> rather than
 > >>>> 
 > >>>> (inexact->exact (min 6 +inf.0)) 
 > >>>> 
 > >>>> in the teaching languages, since we haven't taught 110 students about 
 > >> inexact 
 > >>>> numbers in the first place.
 > >>>> I got caught up in figuring out what was happening and forgot to mention 
 > my 
 > >>>> real interest.
 > >>>> 
 > >>>> Cheers,
 > >>>> Ron
 > >>>> 
 > >>>> 
 > >>>> 
 > >>>> On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > >>>> 
 > >>>>> Yes, that's as intended.
 > >>>>> 
 > >>>>> The rationale is "produce an inexact output when the computation is
 > >>>>> tainted by an inexact input". For example, #i7.0 might be so inexact
 > >>>>> that the actual value should have been 5.9.
 > >>>>> 
 > >>>>> Since there are no inexact booleans or other inexact kinds of data,
 > >>>>> this idea doesn't necessarily work right. If we're going to allow
 > >>>>> mixtures of exact and inexact numbers, however, it seems to be as good
 > >>>>> a rule as any.
 > >>>>> 
 > >>>>> At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 > >>>>>> A new problem report is waiting at
 > >>>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 > >>>>>> 
 > >>>>>> Reported by Ron Garcia for release: 5.3.6
 > >>>>>> 
 > >>>>>> *** Description:
 > >>>>>> The Racket documentation does say that "Unless otherwise specified, 
 > >>>>>> computations that involve an inexact number produce inexact results." 
 > but 
 > >>>> the 
 > >>>>>> following surprised me: if one number out of two given to max or min is 
 > >>>>>> inexact, and the result should be the other number, it is transformed 
 > >> into 
 > >>>> an 
 > >>>>>> inexact number.  
 > >>>>>> 
 > >>>>>> *** How to repeat:
 > >>>>>>> (min 6 #i7.0)
 > >>>>>> #i6.0
 > >>>>>> 
 > >>>>>>> (max 8 #i7.0)
 > >>>>>> #i8.0
 > >>>>>> 
 > >>>>>> *** Environment:
 > >>>>>> macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 
 > 29 
 > >>>>>> 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64" 
 > >>>>>> (i386-macosx/3m) (get-display-depth) = 32
 > >>>>>> Human Language: english
 > >>>>>> (current-memory-use) 144107028
 > >>>>>> Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); 
 > >>>> (links 
 > >>>>>> #:user? #f #:root? #t) = ()
 > >>>>>> raco pkg (show):
 > >>>>>> Installation-wide:
 > >>>>>> [none]
 > >>>>>> User-specific, all-version:
 > >>>>>> [none]
 > >>>>>> User-specific, version-specific (5.3.6):
 > >>>>>> [none]
 > >>>>>> 
 > >>>>>> 
 > >>>>>> 
 > >>>>>> Collections:
 > >>>>>> ("/Users/Ron/Library/Racket/5.3.6/collects"
 > >>>>>> (non-existent-path))
 > >>>>>> ("/Applications/Racket v5.3.6/collects"
 > >>>>>> ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" 
 > "config" 
 > >>>>>> "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" 
 > >>>> "dynext" 
 > >>>>>> "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" 
 > >>>>>> "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist" 
 > >>>> "htdp" 
 > >>>>>> "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" 
 > >>>>>> "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib" 
 > >>>>>> "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg" 
 > >> "plai" 
 > >>>>>> "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" 
 > "racklog" 
 > >>>>>> "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp" 
 > >>>> "scheme" 
 > >>>>>> "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" 
 > >>>>>> "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax" 
 > >>>>>> "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed" 
 > >>>>>> "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme" 
 > >>>> "xml" 
 > >>>>>> "xrepl"))
 > >>>>>> 
 > >>>>>> Computer Language: (("Teaching Languages" "How to Design Programs" 
 > >>>>>> "Intermediate Student with lambda") (#(#t constructor repeating-decimal 
 > >> #f 
 > >>>> #t 
 > >>>>>> none) #f ()))
From: Ron Garcia <rxg@cs.ubc.ca>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>, bugs@racket-lang.org,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn exact numbers into inexact numbers
Date: Sun, 8 Dec 2013 14:24:22 -0300

 If there were a "minimum" and "maximum" function with the behavior Matthias describes, I'd be more than happy.
 
 As a side note, I should point out that the member function behaves differently in the teaching languages than it does in Racket:
 in the teaching languages, member returns boolean.  That may be the only exception, but I thought you might want to know.
 
 Ron
 
 
 On 2013-12-08, at 12:59 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 
 > We could certainly provide a different `min` and `max` in the teaching
 > languages, but changing them doesn't seem like a good idea to me.
 > 
 > Although we haven't kept strictly to the idea that teaching-language
 > programs work unmodified as Racket programs, I think we've always had
 > the correspondence in mind as a rule of thumb, and I think we've
 > avoided making teaching-language programs produce different non-error
 > results when run as Racket programs.
 > 
 > At Sun, 8 Dec 2013 10:43:28 -0500, Matthias Felleisen wrote:
 >> 
 >> Matthew, I think Ron is asking for one change only (which I wished for in my 
 >> class demo too): 
 >> 
 >> The essence of min/max is this: 
 >> 
 >> (if (> #i6.0 7)
 >>    #i6.0
 >>    7)
 >> 
 >> I can deal with min of a possibly infinite list by throwing in #i-inf.0 
 >> (similar for max). 
 >> If min and max were implemented with plain if's, wouldn't the tainting go 
 >> away? 
 >> 
 >> We could do this for the teaching languages. -- Matthias
 >> 
 >> 
 >> 
 >> 
 >> On Dec 8, 2013, at 10:39 AM, Matthew Flatt wrote:
 >> 
 >>> Unfortunately, extending the number tower is a lot of work --- even for
 >>> the teaching languages, since they interact with other libraries via
 >>> `require`. So, I doubt that request would go anywhere, though it's
 >>> always possible that someone will have a good idea on how to make it
 >>> work.
 >>> 
 >>> At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:
 >>>> Is it worth requesting the addition of exact infinities, at least for the 
 >>>> teaching languages?
 >>>> 
 >>>> Ron
 >>>> 
 >>>> 
 >>>> On 2013-12-08, at 12:26 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>>> 
 >>>>> Ah, I can see why you're want to use inexact infinities that way. All I
 >>>>> can say is that it doesn't work, due to the constraint of having `min`
 >>>>> follow the inexactness "taint" rule.
 >>>>> 
 >>>>> At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 >>>>>> Thanks for the fast turnaround Matthew.  And the rationale makes sense to 
 >>>> me.
 >>>>>> I realized after-the-fact that my report was rather indirect. 
 >>>>>> What I was really interested in is being able to use max and min with 
 >>>> infinity 
 >>>>>> and negative infinity without
 >>>>>> having to meddle with inexact numbers.  Basically I'd love to write 
 >>>> something 
 >>>>>> like:
 >>>>>> 
 >>>>>> (min 6 +inf)  
 >>>>>> 
 >>>>>> rather than
 >>>>>> 
 >>>>>> (inexact->exact (min 6 +inf.0)) 
 >>>>>> 
 >>>>>> in the teaching languages, since we haven't taught 110 students about 
 >>>> inexact 
 >>>>>> numbers in the first place.
 >>>>>> I got caught up in figuring out what was happening and forgot to mention 
 >> my 
 >>>>>> real interest.
 >>>>>> 
 >>>>>> Cheers,
 >>>>>> Ron
 >>>>>> 
 >>>>>> 
 >>>>>> 
 >>>>>> On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>>>>> 
 >>>>>>> Yes, that's as intended.
 >>>>>>> 
 >>>>>>> The rationale is "produce an inexact output when the computation is
 >>>>>>> tainted by an inexact input". For example, #i7.0 might be so inexact
 >>>>>>> that the actual value should have been 5.9.
 >>>>>>> 
 >>>>>>> Since there are no inexact booleans or other inexact kinds of data,
 >>>>>>> this idea doesn't necessarily work right. If we're going to allow
 >>>>>>> mixtures of exact and inexact numbers, however, it seems to be as good
 >>>>>>> a rule as any.
 >>>>>>> 
 >>>>>>> At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 >>>>>>>> A new problem report is waiting at
 >>>>>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 >>>>>>>> 
 >>>>>>>> Reported by Ron Garcia for release: 5.3.6
 >>>>>>>> 
 >>>>>>>> *** Description:
 >>>>>>>> The Racket documentation does say that "Unless otherwise specified, 
 >>>>>>>> computations that involve an inexact number produce inexact results." 
 >> but 
 >>>>>> the 
 >>>>>>>> following surprised me: if one number out of two given to max or min is 
 >>>>>>>> inexact, and the result should be the other number, it is transformed 
 >>>> into 
 >>>>>> an 
 >>>>>>>> inexact number.  
 >>>>>>>> 
 >>>>>>>> *** How to repeat:
 >>>>>>>>> (min 6 #i7.0)
 >>>>>>>> #i6.0
 >>>>>>>> 
 >>>>>>>>> (max 8 #i7.0)
 >>>>>>>> #i8.0
 >>>>>>>> 
 >>>>>>>> *** Environment:
 >>>>>>>> macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 
 >> 29 
 >>>>>>>> 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64" 
 >>>>>>>> (i386-macosx/3m) (get-display-depth) = 32
 >>>>>>>> Human Language: english
 >>>>>>>> (current-memory-use) 144107028
 >>>>>>>> Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); 
 >>>>>> (links 
 >>>>>>>> #:user? #f #:root? #t) = ()
 >>>>>>>> raco pkg (show):
 >>>>>>>> Installation-wide:
 >>>>>>>> [none]
 >>>>>>>> User-specific, all-version:
 >>>>>>>> [none]
 >>>>>>>> User-specific, version-specific (5.3.6):
 >>>>>>>> [none]
 >>>>>>>> 
 >>>>>>>> 
 >>>>>>>> 
 >>>>>>>> Collections:
 >>>>>>>> ("/Users/Ron/Library/Racket/5.3.6/collects"
 >>>>>>>> (non-existent-path))
 >>>>>>>> ("/Applications/Racket v5.3.6/collects"
 >>>>>>>> ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" 
 >> "config" 
 >>>>>>>> "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" 
 >>>>>> "dynext" 
 >>>>>>>> "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" 
 >>>>>>>> "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist" 
 >>>>>> "htdp" 
 >>>>>>>> "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" 
 >>>>>>>> "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib" 
 >>>>>>>> "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg" 
 >>>> "plai" 
 >>>>>>>> "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" 
 >> "racklog" 
 >>>>>>>> "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp" 
 >>>>>> "scheme" 
 >>>>>>>> "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" 
 >>>>>>>> "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax" 
 >>>>>>>> "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed" 
 >>>>>>>> "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme" 
 >>>>>> "xml" 
 >>>>>>>> "xrepl"))
 >>>>>>>> 
 >>>>>>>> Computer Language: (("Teaching Languages" "How to Design Programs" 
 >>>>>>>> "Intermediate Student with lambda") (#(#t constructor repeating-decimal 
 >>>> #f 
 >>>>>> #t 
 >>>>>>>> none) #f ()))
 
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Ron Garcia <rxg@cs.ubc.ca>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, bugs@racket-lang.org,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn exact numbers into inexact numbers
Date: Sun, 8 Dec 2013 13:41:32 -0500

 Yes, I changed this behavior in a recent release. I should take out member and add member? instead. 
 
 
 
 
 On Dec 8, 2013, at 12:24 PM, Ron Garcia wrote:
 
 > If there were a "minimum" and "maximum" function with the behavior Matthias describes, I'd be more than happy.
 > 
 > As a side note, I should point out that the member function behaves differently in the teaching languages than it does in Racket:
 > in the teaching languages, member returns boolean.  That may be the only exception, but I thought you might want to know.
 > 
 > Ron
 > 
 > 
 > On 2013-12-08, at 12:59 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > 
 >> We could certainly provide a different `min` and `max` in the teaching
 >> languages, but changing them doesn't seem like a good idea to me.
 >> 
 >> Although we haven't kept strictly to the idea that teaching-language
 >> programs work unmodified as Racket programs, I think we've always had
 >> the correspondence in mind as a rule of thumb, and I think we've
 >> avoided making teaching-language programs produce different non-error
 >> results when run as Racket programs.
 >> 
 >> At Sun, 8 Dec 2013 10:43:28 -0500, Matthias Felleisen wrote:
 >>> 
 >>> Matthew, I think Ron is asking for one change only (which I wished for in my 
 >>> class demo too): 
 >>> 
 >>> The essence of min/max is this: 
 >>> 
 >>> (if (> #i6.0 7)
 >>>   #i6.0
 >>>   7)
 >>> 
 >>> I can deal with min of a possibly infinite list by throwing in #i-inf.0 
 >>> (similar for max). 
 >>> If min and max were implemented with plain if's, wouldn't the tainting go 
 >>> away? 
 >>> 
 >>> We could do this for the teaching languages. -- Matthias
 >>> 
 >>> 
 >>> 
 >>> 
 >>> On Dec 8, 2013, at 10:39 AM, Matthew Flatt wrote:
 >>> 
 >>>> Unfortunately, extending the number tower is a lot of work --- even for
 >>>> the teaching languages, since they interact with other libraries via
 >>>> `require`. So, I doubt that request would go anywhere, though it's
 >>>> always possible that someone will have a good idea on how to make it
 >>>> work.
 >>>> 
 >>>> At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:
 >>>>> Is it worth requesting the addition of exact infinities, at least for the 
 >>>>> teaching languages?
 >>>>> 
 >>>>> Ron
 >>>>> 
 >>>>> 
 >>>>> On 2013-12-08, at 12:26 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>>>> 
 >>>>>> Ah, I can see why you're want to use inexact infinities that way. All I
 >>>>>> can say is that it doesn't work, due to the constraint of having `min`
 >>>>>> follow the inexactness "taint" rule.
 >>>>>> 
 >>>>>> At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 >>>>>>> Thanks for the fast turnaround Matthew.  And the rationale makes sense to 
 >>>>> me.
 >>>>>>> I realized after-the-fact that my report was rather indirect. 
 >>>>>>> What I was really interested in is being able to use max and min with 
 >>>>> infinity 
 >>>>>>> and negative infinity without
 >>>>>>> having to meddle with inexact numbers.  Basically I'd love to write 
 >>>>> something 
 >>>>>>> like:
 >>>>>>> 
 >>>>>>> (min 6 +inf)  
 >>>>>>> 
 >>>>>>> rather than
 >>>>>>> 
 >>>>>>> (inexact->exact (min 6 +inf.0)) 
 >>>>>>> 
 >>>>>>> in the teaching languages, since we haven't taught 110 students about 
 >>>>> inexact 
 >>>>>>> numbers in the first place.
 >>>>>>> I got caught up in figuring out what was happening and forgot to mention 
 >>> my 
 >>>>>>> real interest.
 >>>>>>> 
 >>>>>>> Cheers,
 >>>>>>> Ron
 >>>>>>> 
 >>>>>>> 
 >>>>>>> 
 >>>>>>> On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>>>>>> 
 >>>>>>>> Yes, that's as intended.
 >>>>>>>> 
 >>>>>>>> The rationale is "produce an inexact output when the computation is
 >>>>>>>> tainted by an inexact input". For example, #i7.0 might be so inexact
 >>>>>>>> that the actual value should have been 5.9.
 >>>>>>>> 
 >>>>>>>> Since there are no inexact booleans or other inexact kinds of data,
 >>>>>>>> this idea doesn't necessarily work right. If we're going to allow
 >>>>>>>> mixtures of exact and inexact numbers, however, it seems to be as good
 >>>>>>>> a rule as any.
 >>>>>>>> 
 >>>>>>>> At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 >>>>>>>>> A new problem report is waiting at
 >>>>>>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 >>>>>>>>> 
 >>>>>>>>> Reported by Ron Garcia for release: 5.3.6
 >>>>>>>>> 
 >>>>>>>>> *** Description:
 >>>>>>>>> The Racket documentation does say that "Unless otherwise specified, 
 >>>>>>>>> computations that involve an inexact number produce inexact results." 
 >>> but 
 >>>>>>> the 
 >>>>>>>>> following surprised me: if one number out of two given to max or min is 
 >>>>>>>>> inexact, and the result should be the other number, it is transformed 
 >>>>> into 
 >>>>>>> an 
 >>>>>>>>> inexact number.  
 >>>>>>>>> 
 >>>>>>>>> *** How to repeat:
 >>>>>>>>>> (min 6 #i7.0)
 >>>>>>>>> #i6.0
 >>>>>>>>> 
 >>>>>>>>>> (max 8 #i7.0)
 >>>>>>>>> #i8.0
 >>>>>>>>> 
 >>>>>>>>> *** Environment:
 >>>>>>>>> macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 
 >>> 29 
 >>>>>>>>> 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64" 
 >>>>>>>>> (i386-macosx/3m) (get-display-depth) = 32
 >>>>>>>>> Human Language: english
 >>>>>>>>> (current-memory-use) 144107028
 >>>>>>>>> Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); 
 >>>>>>> (links 
 >>>>>>>>> #:user? #f #:root? #t) = ()
 >>>>>>>>> raco pkg (show):
 >>>>>>>>> Installation-wide:
 >>>>>>>>> [none]
 >>>>>>>>> User-specific, all-version:
 >>>>>>>>> [none]
 >>>>>>>>> User-specific, version-specific (5.3.6):
 >>>>>>>>> [none]
 >>>>>>>>> 
 >>>>>>>>> 
 >>>>>>>>> 
 >>>>>>>>> Collections:
 >>>>>>>>> ("/Users/Ron/Library/Racket/5.3.6/collects"
 >>>>>>>>> (non-existent-path))
 >>>>>>>>> ("/Applications/Racket v5.3.6/collects"
 >>>>>>>>> ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" 
 >>> "config" 
 >>>>>>>>> "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" 
 >>>>>>> "dynext" 
 >>>>>>>>> "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" 
 >>>>>>>>> "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist" 
 >>>>>>> "htdp" 
 >>>>>>>>> "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" 
 >>>>>>>>> "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib" 
 >>>>>>>>> "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg" 
 >>>>> "plai" 
 >>>>>>>>> "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" 
 >>> "racklog" 
 >>>>>>>>> "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp" 
 >>>>>>> "scheme" 
 >>>>>>>>> "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" 
 >>>>>>>>> "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax" 
 >>>>>>>>> "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed" 
 >>>>>>>>> "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme" 
 >>>>>>> "xml" 
 >>>>>>>>> "xrepl"))
 >>>>>>>>> 
 >>>>>>>>> Computer Language: (("Teaching Languages" "How to Design Programs" 
 >>>>>>>>> "Intermediate Student with lambda") (#(#t constructor repeating-decimal 
 >>>>> #f 
 >>>>>>> #t 
 >>>>>>>>> none) #f ()))
 > 
 
 
From: Neil Toronto <neil.toronto@gmail.com>
To: Matthew Flatt <mflatt@cs.utah.edu>, Ron Garcia <rxg@cs.ubc.ca>
Cc: bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn
 exact numbers into inexact numbers
Date: Sun, 08 Dec 2013 20:27:01 -0700

 To be clear, the problem is that "infinity" means two different things:
 
   1. Inexact overflow; i.e. any possible number outside the range
      [-max.0,+max.0]
 
   2. An additional real value introduced in the two-point
      compactification of the reals
 
 If +inf.0 and -inf.0 mean #1, the current behavior of `min' and `max' is 
 right. If they mean #2, the current behavior is wrong. Of course, the 
 standard is pretty clear that they mean #1.
 
 Any confusion is compounded by the fact that, in floating-point math, 
 they mean both things unambiguously.
 
 I've wanted exact infinities for things other than `min' and `max'. If I 
 were to extend `math/distributions' to have exact-integer-valued 
 distributions, I would need them; e.g. the inverse cdf of the exact 
 geometric distribution evaluated at 1 should be +inf, not +inf.0. (For 
 1.0, it could return +inf.0.)
 
 If I were to extend the numeric tower, in TR-speak, I'd add 
 Extended-Real and Extended-Integer types. No arithmetic operations would 
 produce infinities unless given them. Both (/ 1 0) and (+ +inf -inf) 
 would raise exceptions. There would be no Extended-Fixnum or 
 Extended-Bytes. I don't know about Extended-Rational; it feels weird to 
 me, because +inf and -inf are limit points that aren't expressible as a 
 quotient. IOW, they're similar to irrationals.
 
 I'll bet it could be done so that it's either hard or impossible to 
 produce one by operating normally on finite values, but still make them 
 useful as bounds, base cases, and idempotent values. I might prototype 
 something in TR to try it.
 
 Neil
 
 On 12/08/2013 08:39 AM, Matthew Flatt wrote:
 > Unfortunately, extending the number tower is a lot of work --- even for
 > the teaching languages, since they interact with other libraries via
 > `require`. So, I doubt that request would go anywhere, though it's
 > always possible that someone will have a good idea on how to make it
 > work.
 >
 > At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:
 >> Is it worth requesting the addition of exact infinities, at least for the
 >> teaching languages?
 >>
 >> Ron
 >>
 >>
 >> On 2013-12-08, at 12:26 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>
 >>> Ah, I can see why you're want to use inexact infinities that way. All I
 >>> can say is that it doesn't work, due to the constraint of having `min`
 >>> follow the inexactness "taint" rule.
 >>>
 >>> At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 >>>> Thanks for the fast turnaround Matthew.  And the rationale makes sense to
 >> me.
 >>>> I realized after-the-fact that my report was rather indirect.
 >>>> What I was really interested in is being able to use max and min with
 >> infinity
 >>>> and negative infinity without
 >>>> having to meddle with inexact numbers.  Basically I'd love to write
 >> something
 >>>> like:
 >>>>
 >>>> (min 6 +inf)
 >>>>
 >>>> rather than
 >>>>
 >>>> (inexact->exact (min 6 +inf.0))
 >>>>
 >>>> in the teaching languages, since we haven't taught 110 students about
 >> inexact
 >>>> numbers in the first place.
 >>>> I got caught up in figuring out what was happening and forgot to mention my
 >>>> real interest.
 >>>>
 >>>> Cheers,
 >>>> Ron
 >>>>
 >>>>
 >>>>
 >>>> On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>>>
 >>>>> Yes, that's as intended.
 >>>>>
 >>>>> The rationale is "produce an inexact output when the computation is
 >>>>> tainted by an inexact input". For example, #i7.0 might be so inexact
 >>>>> that the actual value should have been 5.9.
 >>>>>
 >>>>> Since there are no inexact booleans or other inexact kinds of data,
 >>>>> this idea doesn't necessarily work right. If we're going to allow
 >>>>> mixtures of exact and inexact numbers, however, it seems to be as good
 >>>>> a rule as any.
 >>>>>
 >>>>> At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 >>>>>> A new problem report is waiting at
 >>>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 >>>>>>
 >>>>>> Reported by Ron Garcia for release: 5.3.6
 >>>>>>
 >>>>>> *** Description:
 >>>>>> The Racket documentation does say that "Unless otherwise specified,
 >>>>>> computations that involve an inexact number produce inexact results." but
 >>>> the
 >>>>>> following surprised me: if one number out of two given to max or min is
 >>>>>> inexact, and the result should be the other number, it is transformed
 >> into
 >>>> an
 >>>>>> inexact number.
 >>>>>>
 >>>>>> *** How to repeat:
 >>>>>>> (min 6 #i7.0)
 >>>>>> #i6.0
 >>>>>>
 >>>>>>> (max 8 #i7.0)
 >>>>>> #i8.0
 >>>>>>
 >>>>>> *** Environment:
 >>>>>> macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 29
 >>>>>> 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64"
 >>>>>> (i386-macosx/3m) (get-display-depth) = 32
 >>>>>> Human Language: english
 >>>>>> (current-memory-use) 144107028
 >>>>>> Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = ();
 >>>> (links
 >>>>>> #:user? #f #:root? #t) = ()
 >>>>>> raco pkg (show):
 >>>>>> Installation-wide:
 >>>>>> [none]
 >>>>>> User-specific, all-version:
 >>>>>> [none]
 >>>>>> User-specific, version-specific (5.3.6):
 >>>>>> [none]
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>> Collections:
 >>>>>> ("/Users/Ron/Library/Racket/5.3.6/collects"
 >>>>>> (non-existent-path))
 >>>>>> ("/Applications/Racket v5.3.6/collects"
 >>>>>> ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config"
 >>>>>> "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme"
 >>>> "dynext"
 >>>>>> "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime"
 >>>>>> "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist"
 >>>> "htdp"
 >>>>>> "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy"
 >>>>>> "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib"
 >>>>>> "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg"
 >> "plai"
 >>>>>> "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog"
 >>>>>> "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp"
 >>>> "scheme"
 >>>>>> "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex"
 >>>>>> "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax"
 >>>>>> "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed"
 >>>>>> "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme"
 >>>> "xml"
 >>>>>> "xrepl"))
 >>>>>>
 >>>>>> Computer Language: (("Teaching Languages" "How to Design Programs"
 >>>>>> "Intermediate Student with lambda") (#(#t constructor repeating-decimal
 >> #f
 >>>> #t
 >>>>>> none) #f ()))
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Neil Toronto <neil.toronto@gmail.com>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, Ron Garcia <rxg@cs.ubc.ca>,
        bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn exact numbers into inexact numbers
Date: Mon, 9 Dec 2013 09:02:19 -0500

 It may mean #1 in the standard (I wouldn't know) but I also know that people fall into the #2 trap all the time. I am not exactly sure why you say that the current behavior is correct for min/max. I think it would have been acceptable to return exact numbers when min/max were added to the language. 
 
 Neil, how about extending exact integer/rationals with ordinals? ACL2 has them, though only for proving things from what I can tell. 
 
 -- Matthias
 
 
 
 
 
 
 
 
 On Dec 8, 2013, at 10:27 PM, Neil Toronto <neil.toronto@gmail.com> wrote:
 
 > To be clear, the problem is that "infinity" means two different things:
 > 
 > 1. Inexact overflow; i.e. any possible number outside the range
 >    [-max.0,+max.0]
 > 
 > 2. An additional real value introduced in the two-point
 >    compactification of the reals
 > 
 > If +inf.0 and -inf.0 mean #1, the current behavior of `min' and `max' is right. If they mean #2, the current behavior is wrong. Of course, the standard is pretty clear that they mean #1.
 > 
 > Any confusion is compounded by the fact that, in floating-point math, they mean both things unambiguously.
 > 
 > I've wanted exact infinities for things other than `min' and `max'. If I were to extend `math/distributions' to have exact-integer-valued distributions, I would need them; e.g. the inverse cdf of the exact geometric distribution evaluated at 1 should be +inf, not +inf.0. (For 1.0, it could return +inf.0.)
 > 
 > If I were to extend the numeric tower, in TR-speak, I'd add Extended-Real and Extended-Integer types. No arithmetic operations would produce infinities unless given them. Both (/ 1 0) and (+ +inf -inf) would raise exceptions. There would be no Extended-Fixnum or Extended-Bytes. I don't know about Extended-Rational; it feels weird to me, because +inf and -inf are limit points that aren't expressible as a quotient. IOW, they're similar to irrationals.
 > 
 > I'll bet it could be done so that it's either hard or impossible to produce one by operating normally on finite values, but still make them useful as bounds, base cases, and idempotent values. I might prototype something in TR to try it.
 > 
 > Neil
 > 
 > On 12/08/2013 08:39 AM, Matthew Flatt wrote:
 >> Unfortunately, extending the number tower is a lot of work --- even for
 >> the teaching languages, since they interact with other libraries via
 >> `require`. So, I doubt that request would go anywhere, though it's
 >> always possible that someone will have a good idea on how to make it
 >> work.
 >> 
 >> At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:
 >>> Is it worth requesting the addition of exact infinities, at least for the
 >>> teaching languages?
 >>> 
 >>> Ron
 >>> 
 >>> 
 >>> On 2013-12-08, at 12:26 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>> 
 >>>> Ah, I can see why you're want to use inexact infinities that way. All I
 >>>> can say is that it doesn't work, due to the constraint of having `min`
 >>>> follow the inexactness "taint" rule.
 >>>> 
 >>>> At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 >>>>> Thanks for the fast turnaround Matthew.  And the rationale makes sense to
 >>> me.
 >>>>> I realized after-the-fact that my report was rather indirect.
 >>>>> What I was really interested in is being able to use max and min with
 >>> infinity
 >>>>> and negative infinity without
 >>>>> having to meddle with inexact numbers.  Basically I'd love to write
 >>> something
 >>>>> like:
 >>>>> 
 >>>>> (min 6 +inf)
 >>>>> 
 >>>>> rather than
 >>>>> 
 >>>>> (inexact->exact (min 6 +inf.0))
 >>>>> 
 >>>>> in the teaching languages, since we haven't taught 110 students about
 >>> inexact
 >>>>> numbers in the first place.
 >>>>> I got caught up in figuring out what was happening and forgot to mention my
 >>>>> real interest.
 >>>>> 
 >>>>> Cheers,
 >>>>> Ron
 >>>>> 
 >>>>> 
 >>>>> 
 >>>>> On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>>>> 
 >>>>>> Yes, that's as intended.
 >>>>>> 
 >>>>>> The rationale is "produce an inexact output when the computation is
 >>>>>> tainted by an inexact input". For example, #i7.0 might be so inexact
 >>>>>> that the actual value should have been 5.9.
 >>>>>> 
 >>>>>> Since there are no inexact booleans or other inexact kinds of data,
 >>>>>> this idea doesn't necessarily work right. If we're going to allow
 >>>>>> mixtures of exact and inexact numbers, however, it seems to be as good
 >>>>>> a rule as any.
 >>>>>> 
 >>>>>> At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 >>>>>>> A new problem report is waiting at
 >>>>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 >>>>>>> 
 >>>>>>> Reported by Ron Garcia for release: 5.3.6
 >>>>>>> 
 >>>>>>> *** Description:
 >>>>>>> The Racket documentation does say that "Unless otherwise specified,
 >>>>>>> computations that involve an inexact number produce inexact results." but
 >>>>> the
 >>>>>>> following surprised me: if one number out of two given to max or min is
 >>>>>>> inexact, and the result should be the other number, it is transformed
 >>> into
 >>>>> an
 >>>>>>> inexact number.
 >>>>>>> 
 >>>>>>> *** How to repeat:
 >>>>>>>> (min 6 #i7.0)
 >>>>>>> #i6.0
 >>>>>>> 
 >>>>>>>> (max 8 #i7.0)
 >>>>>>> #i8.0
 >>>>>>> 
 >>>>>>> *** Environment:
 >>>>>>> macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 29
 >>>>>>> 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64"
 >>>>>>> (i386-macosx/3m) (get-display-depth) = 32
 >>>>>>> Human Language: english
 >>>>>>> (current-memory-use) 144107028
 >>>>>>> Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = ();
 >>>>> (links
 >>>>>>> #:user? #f #:root? #t) = ()
 >>>>>>> raco pkg (show):
 >>>>>>> Installation-wide:
 >>>>>>> [none]
 >>>>>>> User-specific, all-version:
 >>>>>>> [none]
 >>>>>>> User-specific, version-specific (5.3.6):
 >>>>>>> [none]
 >>>>>>> 
 >>>>>>> 
 >>>>>>> 
 >>>>>>> Collections:
 >>>>>>> ("/Users/Ron/Library/Racket/5.3.6/collects"
 >>>>>>> (non-existent-path))
 >>>>>>> ("/Applications/Racket v5.3.6/collects"
 >>>>>>> ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config"
 >>>>>>> "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme"
 >>>>> "dynext"
 >>>>>>> "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime"
 >>>>>>> "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist"
 >>>>> "htdp"
 >>>>>>> "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy"
 >>>>>>> "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib"
 >>>>>>> "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg"
 >>> "plai"
 >>>>>>> "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog"
 >>>>>>> "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp"
 >>>>> "scheme"
 >>>>>>> "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex"
 >>>>>>> "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax"
 >>>>>>> "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed"
 >>>>>>> "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme"
 >>>>> "xml"
 >>>>>>> "xrepl"))
 >>>>>>> 
 >>>>>>> Computer Language: (("Teaching Languages" "How to Design Programs"
 >>>>>>> "Intermediate Student with lambda") (#(#t constructor repeating-decimal
 >>> #f
 >>>>> #t
 >>>>>>> none) #f ()))
 > 
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Neil Toronto <neil.toronto@gmail.com>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, Ron Garcia <rxg@cs.ubc.ca>,
        "bugs@racket-lang.org" <bugs@racket-lang.org>,
        "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn
 exact numbers into inexact numbers
Date: Mon, 9 Dec 2013 08:45:27 -0600

 --e89a8fb20472f4f4d704ed1b0be3
 Content-Type: text/plain; charset=UTF-8
 
 This sounds great to me, specifically the part about you working out all
 the interactions with the other primitives and not just tweaking min/max
 and declaring victory.
 
 I still would worry about backwards compatibility so probably this is
 something we should not change in #lang racket, however.
 
 Robby
 
 On Sunday, December 8, 2013, Neil Toronto wrote:
 
 > To be clear, the problem is that "infinity" means two different things:
 >
 >  1. Inexact overflow; i.e. any possible number outside the range
 >     [-max.0,+max.0]
 >
 >  2. An additional real value introduced in the two-point
 >     compactification of the reals
 >
 > If +inf.0 and -inf.0 mean #1, the current behavior of `min' and `max' is
 > right. If they mean #2, the current behavior is wrong. Of course, the
 > standard is pretty clear that they mean #1.
 >
 > Any confusion is compounded by the fact that, in floating-point math, they
 > mean both things unambiguously.
 >
 > I've wanted exact infinities for things other than `min' and `max'. If I
 > were to extend `math/distributions' to have exact-integer-valued
 > distributions, I would need them; e.g. the inverse cdf of the exact
 > geometric distribution evaluated at 1 should be +inf, not +inf.0. (For 1.0,
 > it could return +inf.0.)
 >
 > If I were to extend the numeric tower, in TR-speak, I'd add Extended-Real
 > and Extended-Integer types. No arithmetic operations would produce
 > infinities unless given them. Both (/ 1 0) and (+ +inf -inf) would raise
 > exceptions. There would be no Extended-Fixnum or Extended-Bytes. I don't
 > know about Extended-Rational; it feels weird to me, because +inf and -inf
 > are limit points that aren't expressible as a quotient. IOW, they're
 > similar to irrationals.
 >
 > I'll bet it could be done so that it's either hard or impossible to
 > produce one by operating normally on finite values, but still make them
 > useful as bounds, base cases, and idempotent values. I might prototype
 > something in TR to try it.
 >
 > Neil
 >
 > On 12/08/2013 08:39 AM, Matthew Flatt wrote:
 >
 > Unfortunately, extending the number tower is a lot of work --- even for
 > the teaching languages, since they interact with other libraries via
 > `require`. So, I doubt that request would go anywhere, though it's
 > always possible that someone will have a good idea on how to make it
 > work.
 >
 > At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:
 >
 > Is it worth requesting the addition of exact infinities, at least for the
 > teaching languages?
 >
 > Ron
 >
 >
 > On 2013-12-08, at 12:26 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >
 >  Ah, I can see why you're want to use inexact infinities that way. All I
 > can say is that it doesn't work, due to the constraint of having `min`
 > follow the inexactness "taint" rule.
 >
 > At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 >
 > Thanks for the fast turnaround Matthew.  And the rationale makes sense to
 >
 > me.
 >
 > I realized after-the-fact that my report was rather indirect.
 > What I was really interested in is being able to use max and min with
 >
 > infinity
 >
 > and negative infinity without
 > having to meddle with inexact numbers.  Basically I'd love to write
 >
 > something
 >
 > like:
 >
 > (min 6 +inf)
 >
 > rather than
 >
 > (inexact->exact (min 6 +inf.0))
 >
 > in the teaching languages, since we haven't taught 110 students about
 >
 > inexact
 >
 > numbers in the first place.
 > I got caught up in figuring out what was happening and forgot to mention my
 > real interest.
 >
 > Cheers,
 > Ron
 >
 >
 >
 > On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >
 >  Yes, that's as intended.
 >
 > The rationale is "produce an inexact output when the computation is
 > tainted by an inexact input". For example, #i7.0 might be so inexact
 > that the actual value should have been 5.9.
 >
 > Since there are no inexact booleans or other inexact kinds of data,
 > this idea doesn't necessarily work right. If we're going to allow
 > mixtures of exact and inexact numbers, however, it seems to be as good
 > a rule as any.
 >
 > At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 >
 > A new problem report is waiting at
 > http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 >
 > Reported by Ron Garcia for release: 5.3.6
 >
 > *** Description:
 > The Racket documentation does say that "Unless otherwise specified,
 > computations that involve an inexact number produce inexact results." but
 >
 > the
 >
 > following surprised me: if one number out of two given to max or min is
 > inexact, and the result should be the other number, it is transformed
 >
 > into
 >
 > an
 >
 >
 
 --e89a8fb20472f4f4d704ed1b0be3
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 This sounds great to me, specifically the part about you working out all th=
 e interactions with the other primitives and not just tweaking min/max and =
 declaring victory.=C2=A0<div><br></div><div>I still would worry about backw=
 ards compatibility so probably this is something we should not change in #l=
 ang racket, however.=C2=A0</div>
 <div><br></div><div>Robby<br><br>On Sunday, December 8, 2013, Neil Toronto =
  wrote:<br><blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;bor=
 der-left:1px #ccc solid;padding-left:1ex">To be clear, the problem is that =
 &quot;infinity&quot; means two different things:<br>
 
 <br>
 =C2=A01. Inexact overflow; i.e. any possible number outside the range<br>
 =C2=A0 =C2=A0 [-max.0,+max.0]<br>
 <br>
 =C2=A02. An additional real value introduced in the two-point<br>
 =C2=A0 =C2=A0 compactification of the reals<br>
 <br>
 If +inf.0 and -inf.0 mean #1, the current behavior of `min&#39; and `max&#3=
 9; is right. If they mean #2, the current behavior is wrong. Of course, the=
  standard is pretty clear that they mean #1.<br>
 <br>
 Any confusion is compounded by the fact that, in floating-point math, they =
 mean both things unambiguously.<br>
 <br>
 I&#39;ve wanted exact infinities for things other than `min&#39; and `max&#=
 39;. If I were to extend `math/distributions&#39; to have exact-integer-val=
 ued distributions, I would need them; e.g. the inverse cdf of the exact geo=
 metric distribution evaluated at 1 should be +inf, not +inf.0. (For 1.0, it=
  could return +inf.0.)<br>
 
 <br>
 If I were to extend the numeric tower, in TR-speak, I&#39;d add Extended-Re=
 al and Extended-Integer types. No arithmetic operations would produce infin=
 ities unless given them. Both (/ 1 0) and (+ +inf -inf) would raise excepti=
 ons. There would be no Extended-Fixnum or Extended-Bytes. I don&#39;t know =
 about Extended-Rational; it feels weird to me, because +inf and -inf are li=
 mit points that aren&#39;t expressible as a quotient. IOW, they&#39;re simi=
 lar to irrationals.<br>
 
 <br>
 I&#39;ll bet it could be done so that it&#39;s either hard or impossible to=
  produce one by operating normally on finite values, but still make them us=
 eful as bounds, base cases, and idempotent values. I might prototype someth=
 ing in TR to try it.<br>
 
 <br>
 Neil<br>
 <br>
 On 12/08/2013 08:39 AM, Matthew Flatt wrote:<br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex">
 Unfortunately, extending the number tower is a lot of work --- even for<br>
 the teaching languages, since they interact with other libraries via<br>
 `require`. So, I doubt that request would go anywhere, though it&#39;s<br>
 always possible that someone will have a good idea on how to make it<br>
 work.<br>
 <br>
 At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:<br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex">
 Is it worth requesting the addition of exact infinities, at least for the<b=
 r>
 teaching languages?<br>
 <br>
 Ron<br>
 <br>
 <br>
 On 2013-12-08, at 12:26 PM, Matthew Flatt &lt;<a>mflatt@cs.utah.edu</a>&gt;=
  wrote:<br>
 <br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex">
 Ah, I can see why you&#39;re want to use inexact infinities that way. All I=
 <br>
 can say is that it doesn&#39;t work, due to the constraint of having `min`<=
 br>
 follow the inexactness &quot;taint&quot; rule.<br>
 <br>
 At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:<br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex">
 Thanks for the fast turnaround Matthew. =C2=A0And the rationale makes sense=
  to<br>
 </blockquote></blockquote>
 me.<br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex"><blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;=
 padding-left:1ex">
 I realized after-the-fact that my report was rather indirect.<br>
 What I was really interested in is being able to use max and min with<br>
 </blockquote></blockquote>
 infinity<br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex"><blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;=
 padding-left:1ex">
 and negative infinity without<br>
 having to meddle with inexact numbers. =C2=A0Basically I&#39;d love to writ=
 e<br>
 </blockquote></blockquote>
 something<br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex"><blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;=
 padding-left:1ex">
 like:<br>
 <br>
 (min 6 +inf)<br>
 <br>
 rather than<br>
 <br>
 (inexact-&gt;exact (min 6 +inf.0))<br>
 <br>
 in the teaching languages, since we haven&#39;t taught 110 students about<b=
 r>
 </blockquote></blockquote>
 inexact<br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex"><blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;=
 padding-left:1ex">
 numbers in the first place.<br>
 I got caught up in figuring out what was happening and forgot to mention my=
 <br>
 real interest.<br>
 <br>
 Cheers,<br>
 Ron<br>
 <br>
 <br>
 <br>
 On 2013-12-08, at 12:13 PM, Matthew Flatt &lt;<a>mflatt@cs.utah.edu</a>&gt;=
  wrote:<br>
 <br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex">
 Yes, that&#39;s as intended.<br>
 <br>
 The rationale is &quot;produce an inexact output when the computation is<br=
 >
 tainted by an inexact input&quot;. For example, #i7.0 might be so inexact<b=
 r>
 that the actual value should have been 5.9.<br>
 <br>
 Since there are no inexact booleans or other inexact kinds of data,<br>
 this idea doesn&#39;t necessarily work right. If we&#39;re going to allow<b=
 r>
 mixtures of exact and inexact numbers, however, it seems to be as good<br>
 a rule as any.<br>
 <br>
 At Sun, 8 Dec 2013 09:56:01 -0500, <a>rxg@cs.ubc.ca</a> wrote:<br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex">
 A new problem report is waiting at<br>
 <a href=3D"http://bugs.racket-lang.org/query/?cmd=3Dview&amp;pr=3D14232" ta=
 rget=3D"_blank">http://bugs.racket-lang.org/<u></u>query/?cmd=3Dview&amp;pr=
 =3D14232</a><br>
 <br>
 Reported by Ron Garcia for release: 5.3.6<br>
 <br>
 *** Description:<br>
 The Racket documentation does say that &quot;Unless otherwise specified,<br=
 >
 computations that involve an inexact number produce inexact results.&quot; =
 but<br>
 </blockquote></blockquote>
 the<br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex"><blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;=
 padding-left:1ex">
 following surprised me: if one number out of two given to max or min is<br>
 inexact, and the result should be the other number, it is transformed<br>
 </blockquote></blockquote></blockquote></blockquote>
 into<br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex"><blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;=
 padding-left:1ex">
 an<br>
 <blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
 eft:1ex"><blockquote style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;=
 padding-left:1ex"></blockquote></blockquote></blockquote></blockquote></blo=
 ckquote>
 </blockquote></blockquote></div>
 
 --e89a8fb20472f4f4d704ed1b0be3--
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Neil Toronto <neil.toronto@gmail.com>, Matthew Flatt <mflatt@cs.utah.edu>,
        Ron Garcia <rxg@cs.ubc.ca>,
        "bugs@racket-lang.org" <bugs@racket-lang.org>,
        "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn exact numbers into inexact numbers
Date: Mon, 9 Dec 2013 09:46:15 -0500

 Racket 2 :)
 
 On Dec 9, 2013, at 9:45 AM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 
 > This sounds great to me, specifically the part about you working out all the interactions with the other primitives and not just tweaking min/max and declaring victory. 
 > 
 > I still would worry about backwards compatibility so probably this is something we should not change in #lang racket, however. 
 > 
 > Robby
 > 
 > On Sunday, December 8, 2013, Neil Toronto wrote:
 > To be clear, the problem is that "infinity" means two different things:
 > 
 >  1. Inexact overflow; i.e. any possible number outside the range
 >     [-max.0,+max.0]
 > 
 >  2. An additional real value introduced in the two-point
 >     compactification of the reals
 > 
 > If +inf.0 and -inf.0 mean #1, the current behavior of `min' and `max' is right. If they mean #2, the current behavior is wrong. Of course, the standard is pretty clear that they mean #1.
 > 
 > Any confusion is compounded by the fact that, in floating-point math, they mean both things unambiguously.
 > 
 > I've wanted exact infinities for things other than `min' and `max'. If I were to extend `math/distributions' to have exact-integer-valued distributions, I would need them; e.g. the inverse cdf of the exact geometric distribution evaluated at 1 should be +inf, not +inf.0. (For 1.0, it could return +inf.0.)
 > 
 > If I were to extend the numeric tower, in TR-speak, I'd add Extended-Real and Extended-Integer types. No arithmetic operations would produce infinities unless given them. Both (/ 1 0) and (+ +inf -inf) would raise exceptions. There would be no Extended-Fixnum or Extended-Bytes. I don't know about Extended-Rational; it feels weird to me, because +inf and -inf are limit points that aren't expressible as a quotient. IOW, they're similar to irrationals.
 > 
 > I'll bet it could be done so that it's either hard or impossible to produce one by operating normally on finite values, but still make them useful as bounds, base cases, and idempotent values. I might prototype something in TR to try it.
 > 
 > Neil
 > 
 > On 12/08/2013 08:39 AM, Matthew Flatt wrote:
 > Unfortunately, extending the number tower is a lot of work --- even for
 > the teaching languages, since they interact with other libraries via
 > `require`. So, I doubt that request would go anywhere, though it's
 > always possible that someone will have a good idea on how to make it
 > work.
 > 
 > At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:
 > Is it worth requesting the addition of exact infinities, at least for the
 > teaching languages?
 > 
 > Ron
 > 
 > 
 > On 2013-12-08, at 12:26 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > 
 > Ah, I can see why you're want to use inexact infinities that way. All I
 > can say is that it doesn't work, due to the constraint of having `min`
 > follow the inexactness "taint" rule.
 > 
 > At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 > Thanks for the fast turnaround Matthew.  And the rationale makes sense to
 > me.
 > I realized after-the-fact that my report was rather indirect.
 > What I was really interested in is being able to use max and min with
 > infinity
 > and negative infinity without
 > having to meddle with inexact numbers.  Basically I'd love to write
 > something
 > like:
 > 
 > (min 6 +inf)
 > 
 > rather than
 > 
 > (inexact->exact (min 6 +inf.0))
 > 
 > in the teaching languages, since we haven't taught 110 students about
 > inexact
 > numbers in the first place.
 > I got caught up in figuring out what was happening and forgot to mention my
 > real interest.
 > 
 > Cheers,
 > Ron
 > 
 > 
 > 
 > On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > 
 > Yes, that's as intended.
 > 
 > The rationale is "produce an inexact output when the computation is
 > tainted by an inexact input". For example, #i7.0 might be so inexact
 > that the actual value should have been 5.9.
 > 
 > Since there are no inexact booleans or other inexact kinds of data,
 > this idea doesn't necessarily work right. If we're going to allow
 > mixtures of exact and inexact numbers, however, it seems to be as good
 > a rule as any.
 > 
 > At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 > A new problem report is waiting at
 > http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 > 
 > Reported by Ron Garcia for release: 5.3.6
 > 
 > *** Description:
 > The Racket documentation does say that "Unless otherwise specified,
 > computations that involve an inexact number produce inexact results." but
 > the
 > following surprised me: if one number out of two given to max or min is
 > inexact, and the result should be the other number, it is transformed
 > into
 > an
 
 
From: Neil Toronto <neil.toronto@gmail.com>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, Ron Garcia <rxg@cs.ubc.ca>,
        bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn
 exact numbers into inexact numbers
Date: Mon, 09 Dec 2013 11:59:28 -0700

 You have a terrible habit of asking great questions that answering takes 
 longer than I thought it would. :D
 
 Anyway, here's why I think it's correct for `min' and `max' to follow 
 the taint rules when given +inf.0 or -inf.0. While the first calculation 
 that returns +inf.0 when given finite values always represents overflow, 
 +inf.0 values in subsequent calculations can represent inexact values 
 within [-max.0,+max.0] (which is appx. [-1.8e308,1.8e308]). Here's an 
 example, with the correct, exact calculation first:
 
  > (min #e1.7e308 (/ (* 2 #e1e308) 2))
 #e1e308
 
  > (min #e1.7e308 (/ (* 2 1e308) 2))
 1.7e308
 
 Here, (* 2 1e308) overflows to +inf.0, and (/ +inf.0 2) is still +inf.0. 
 That's why the result is wrong, and why we still need inexactness to 
 signal that it might be way off (which it is).
 
 So I guess I was wrong to say that infinities represent inexact 
 overflow. They really represent either overflow, or "any number, which 
 is probably pretty big, but could be as small as zero."
 
 --
 
 Re: ordinals: More infinities! Yay!
 
 I've looked into this a bit before. There are some nice ways to 
 represent the computable ordinals. But I had a hard time deciding what 
 to do with them after I had them. :)
 
 Practically, the best I came up with is working on infinite arrays. If 
 each axis has an ordinal length, then `array-flatten' for infinite 
 arrays can be defined: flattening an array with shape (vector omega 
 omega) results in an array with shape (vector (* omega omega)). Further, 
 all the elements have well-defined, computable indexes.
 
 Trying a couple of encodings and puzzling over what to do with them was 
 about as far as I got.
 
 Neil 
 
 On 12/09/2013 07:02 AM, Matthias Felleisen wrote:
 >
 > It may mean #1 in the standard (I wouldn't know) but I also know that people fall into the #2 trap all the time. I am not exactly sure why you say that the current behavior is correct for min/max. I think it would have been acceptable to return exact numbers when min/max were added to the language.
 >
 > Neil, how about extending exact integer/rationals with ordinals? ACL2 has them, though only for proving things from what I can tell.
 >
 > -- Matthias
 >
 >
 >
 >
 >
 >
 >
 >
 > On Dec 8, 2013, at 10:27 PM, Neil Toronto <neil.toronto@gmail.com> wrote:
 >
 >> To be clear, the problem is that "infinity" means two different things:
 >>
 >> 1. Inexact overflow; i.e. any possible number outside the range
 >>     [-max.0,+max.0]
 >>
 >> 2. An additional real value introduced in the two-point
 >>     compactification of the reals
 >>
 >> If +inf.0 and -inf.0 mean #1, the current behavior of `min' and `max' is right. If they mean #2, the current behavior is wrong. Of course, the standard is pretty clear that they mean #1.
 >>
 >> Any confusion is compounded by the fact that, in floating-point math, they mean both things unambiguously.
 >>
 >> I've wanted exact infinities for things other than `min' and `max'. If I were to extend `math/distributions' to have exact-integer-valued distributions, I would need them; e.g. the inverse cdf of the exact geometric distribution evaluated at 1 should be +inf, not +inf.0. (For 1.0, it could return +inf.0.)
 >>
 >> If I were to extend the numeric tower, in TR-speak, I'd add Extended-Real and Extended-Integer types. No arithmetic operations would produce infinities unless given them. Both (/ 1 0) and (+ +inf -inf) would raise exceptions. There would be no Extended-Fixnum or Extended-Bytes. I don't know about Extended-Rational; it feels weird to me, because +inf and -inf are limit points that aren't expressible as a quotient. IOW, they're similar to irrationals.
 >>
 >> I'll bet it could be done so that it's either hard or impossible to produce one by operating normally on finite values, but still make them useful as bounds, base cases, and idempotent values. I might prototype something in TR to try it.
 >>
 >> Neil
 >>
 >> On 12/08/2013 08:39 AM, Matthew Flatt wrote:
 >>> Unfortunately, extending the number tower is a lot of work --- even for
 >>> the teaching languages, since they interact with other libraries via
 >>> `require`. So, I doubt that request would go anywhere, though it's
 >>> always possible that someone will have a good idea on how to make it
 >>> work.
 >>>
 >>> At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:
 >>>> Is it worth requesting the addition of exact infinities, at least for the
 >>>> teaching languages?
 >>>>
 >>>> Ron
 >>>>
 >>>>
 >>>> On 2013-12-08, at 12:26 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>>>
 >>>>> Ah, I can see why you're want to use inexact infinities that way. All I
 >>>>> can say is that it doesn't work, due to the constraint of having `min`
 >>>>> follow the inexactness "taint" rule.
 >>>>>
 >>>>> At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 >>>>>> Thanks for the fast turnaround Matthew.  And the rationale makes sense to
 >>>> me.
 >>>>>> I realized after-the-fact that my report was rather indirect.
 >>>>>> What I was really interested in is being able to use max and min with
 >>>> infinity
 >>>>>> and negative infinity without
 >>>>>> having to meddle with inexact numbers.  Basically I'd love to write
 >>>> something
 >>>>>> like:
 >>>>>>
 >>>>>> (min 6 +inf)
 >>>>>>
 >>>>>> rather than
 >>>>>>
 >>>>>> (inexact->exact (min 6 +inf.0))
 >>>>>>
 >>>>>> in the teaching languages, since we haven't taught 110 students about
 >>>> inexact
 >>>>>> numbers in the first place.
 >>>>>> I got caught up in figuring out what was happening and forgot to mention my
 >>>>>> real interest.
 >>>>>>
 >>>>>> Cheers,
 >>>>>> Ron
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>> On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>>>>>
 >>>>>>> Yes, that's as intended.
 >>>>>>>
 >>>>>>> The rationale is "produce an inexact output when the computation is
 >>>>>>> tainted by an inexact input". For example, #i7.0 might be so inexact
 >>>>>>> that the actual value should have been 5.9.
 >>>>>>>
 >>>>>>> Since there are no inexact booleans or other inexact kinds of data,
 >>>>>>> this idea doesn't necessarily work right. If we're going to allow
 >>>>>>> mixtures of exact and inexact numbers, however, it seems to be as good
 >>>>>>> a rule as any.
 >>>>>>>
 >>>>>>> At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 >>>>>>>> A new problem report is waiting at
 >>>>>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 >>>>>>>>
 >>>>>>>> Reported by Ron Garcia for release: 5.3.6
 >>>>>>>>
 >>>>>>>> *** Description:
 >>>>>>>> The Racket documentation does say that "Unless otherwise specified,
 >>>>>>>> computations that involve an inexact number produce inexact results." but
 >>>>>> the
 >>>>>>>> following surprised me: if one number out of two given to max or min is
 >>>>>>>> inexact, and the result should be the other number, it is transformed
 >>>> into
 >>>>>> an
 >>>>>>>> inexact number.
 >>>>>>>>
 >>>>>>>> *** How to repeat:
 >>>>>>>>> (min 6 #i7.0)
 >>>>>>>> #i6.0
 >>>>>>>>
 >>>>>>>>> (max 8 #i7.0)
 >>>>>>>> #i8.0
 >>>>>>>>
 >>>>>>>> *** Environment:
 >>>>>>>> macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 29
 >>>>>>>> 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64"
 >>>>>>>> (i386-macosx/3m) (get-display-depth) = 32
 >>>>>>>> Human Language: english
 >>>>>>>> (current-memory-use) 144107028
 >>>>>>>> Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = ();
 >>>>>> (links
 >>>>>>>> #:user? #f #:root? #t) = ()
 >>>>>>>> raco pkg (show):
 >>>>>>>> Installation-wide:
 >>>>>>>> [none]
 >>>>>>>> User-specific, all-version:
 >>>>>>>> [none]
 >>>>>>>> User-specific, version-specific (5.3.6):
 >>>>>>>> [none]
 >>>>>>>>
 >>>>>>>>
 >>>>>>>>
 >>>>>>>> Collections:
 >>>>>>>> ("/Users/Ron/Library/Racket/5.3.6/collects"
 >>>>>>>> (non-existent-path))
 >>>>>>>> ("/Applications/Racket v5.3.6/collects"
 >>>>>>>> ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config"
 >>>>>>>> "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme"
 >>>>>> "dynext"
 >>>>>>>> "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime"
 >>>>>>>> "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist"
 >>>>>> "htdp"
 >>>>>>>> "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy"
 >>>>>>>> "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib"
 >>>>>>>> "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg"
 >>>> "plai"
 >>>>>>>> "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog"
 >>>>>>>> "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp"
 >>>>>> "scheme"
 >>>>>>>> "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex"
 >>>>>>>> "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax"
 >>>>>>>> "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed"
 >>>>>>>> "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme"
 >>>>>> "xml"
 >>>>>>>> "xrepl"))
 >>>>>>>>
 >>>>>>>> Computer Language: (("Teaching Languages" "How to Design Programs"
 >>>>>>>> "Intermediate Student with lambda") (#(#t constructor repeating-decimal
 >>>> #f
 >>>>>> #t
 >>>>>>>> none) #f ()))
 >>
 >
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Neil Toronto <neil.toronto@gmail.com>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, Ron Garcia <rxg@cs.ubc.ca>,
        bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn exact numbers into inexact numbers
Date: Mon, 9 Dec 2013 14:51:47 -0500

 On Dec 9, 2013, at 1:59 PM, Neil Toronto <neil.toronto@gmail.com> wrote:
 
 > You have a terrible habit of asking great questions that answering takes longer than I thought it would. :D
 > 
 > Anyway, here's why I think it's correct for `min' and `max' to follow the taint rules when given +inf.0 or -inf.0. While the first calculation that returns +inf.0 when given finite values always represents overflow, +inf.0 values in subsequent calculations can represent inexact values within [-max.0,+max.0] (which is appx. [-1.8e308,1.8e308]). Here's an example, with the correct, exact calculation first:
 > 
 > > (min #e1.7e308 (/ (* 2 #e1e308) 2))
 > #e1e308
 > 
 > > (min #e1.7e308 (/ (* 2 1e308) 2))
 > 1.7e308
 > 
 > Here, (* 2 1e308) overflows to +inf.0, and (/ +inf.0 2) is still +inf.0. That's why the result is wrong, and why we still need inexactness to signal that it might be way off (which it is).
 > 
 > So I guess I was wrong to say that infinities represent inexact overflow. They really represent either overflow, or "any number, which is probably pretty big, but could be as small as zero."
 
 
 Thanks for clarifying. Much appreciated -- Matthias
 
 
From: Ron Garcia <rxg@cs.ubc.ca>
To: Neil Toronto <neil.toronto@gmail.com>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, bugs@racket-lang.org,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn exact numbers into inexact numbers
Date: Fri, 13 Dec 2013 14:21:39 -0300

 Hello Neil,
 
 On 2013-12-09, at 12:27 AM, Neil Toronto <neil.toronto@gmail.com> wrote:
 
 > To be clear, the problem is that "infinity" means two different things:
 > 
 > 1. Inexact overflow; i.e. any possible number outside the range
 >    [-max.0,+max.0]
 > 
 > 2. An additional real value introduced in the two-point
 >    compactification of the reals
 > 
 > If +inf.0 and -inf.0 mean #1, the current behavior of `min' and `max' is right. If they mean #2, the current behavior is wrong. Of course, the standard is pretty clear that they mean #1.
 > 
 > Any confusion is compounded by the fact that, in floating-point math, they mean both things unambiguously.
 > 
 > I've wanted exact infinities for things other than `min' and `max'. If I were to extend `math/distributions' to have exact-integer-valued distributions, I would need them; e.g. the inverse cdf of the exact geometric distribution evaluated at 1 should be +inf, not +inf.0. (For 1.0, it could return +inf.0.)
 > 
 > If I were to extend the numeric tower, in TR-speak, I'd add Extended-Real and Extended-Integer types. No arithmetic operations would produce infinities unless given them. Both (/ 1 0) and (+ +inf -inf) would raise exceptions. There would be no Extended-Fixnum or Extended-Bytes. I don't know about Extended-Rational; it feels weird to me, because +inf and -inf are limit points that aren't expressible as a quotient. IOW, they're similar to irrationals.
 I'm not sure how the situation with rationals differs from the situation with Extended-Integers:  +inf and -inf cannot be expressed by taking successors: instead they are the limits of that operation.  Couldn't +inf for instance be seen as the limit of successive division by a quotient that is less than zero (e.g. division by 1/2 repeatedly?)
 
 Best,
 Ron
 
 
 > 
 > I'll bet it could be done so that it's either hard or impossible to produce one by operating normally on finite values, but still make them useful as bounds, base cases, and idempotent values. I might prototype something in TR to try it.
 > 
 > Neil
 > 
 > On 12/08/2013 08:39 AM, Matthew Flatt wrote:
 >> Unfortunately, extending the number tower is a lot of work --- even for
 >> the teaching languages, since they interact with other libraries via
 >> `require`. So, I doubt that request would go anywhere, though it's
 >> always possible that someone will have a good idea on how to make it
 >> work.
 >> 
 >> At Sun, 8 Dec 2013 12:32:28 -0300, Ron Garcia wrote:
 >>> Is it worth requesting the addition of exact infinities, at least for the
 >>> teaching languages?
 >>> 
 >>> Ron
 >>> 
 >>> 
 >>> On 2013-12-08, at 12:26 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>> 
 >>>> Ah, I can see why you're want to use inexact infinities that way. All I
 >>>> can say is that it doesn't work, due to the constraint of having `min`
 >>>> follow the inexactness "taint" rule.
 >>>> 
 >>>> At Sun, 8 Dec 2013 12:19:54 -0300, Ron Garcia wrote:
 >>>>> Thanks for the fast turnaround Matthew.  And the rationale makes sense to
 >>> me.
 >>>>> I realized after-the-fact that my report was rather indirect.
 >>>>> What I was really interested in is being able to use max and min with
 >>> infinity
 >>>>> and negative infinity without
 >>>>> having to meddle with inexact numbers.  Basically I'd love to write
 >>> something
 >>>>> like:
 >>>>> 
 >>>>> (min 6 +inf)
 >>>>> 
 >>>>> rather than
 >>>>> 
 >>>>> (inexact->exact (min 6 +inf.0))
 >>>>> 
 >>>>> in the teaching languages, since we haven't taught 110 students about
 >>> inexact
 >>>>> numbers in the first place.
 >>>>> I got caught up in figuring out what was happening and forgot to mention my
 >>>>> real interest.
 >>>>> 
 >>>>> Cheers,
 >>>>> Ron
 >>>>> 
 >>>>> 
 >>>>> 
 >>>>> On 2013-12-08, at 12:13 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>>>> 
 >>>>>> Yes, that's as intended.
 >>>>>> 
 >>>>>> The rationale is "produce an inexact output when the computation is
 >>>>>> tainted by an inexact input". For example, #i7.0 might be so inexact
 >>>>>> that the actual value should have been 5.9.
 >>>>>> 
 >>>>>> Since there are no inexact booleans or other inexact kinds of data,
 >>>>>> this idea doesn't necessarily work right. If we're going to allow
 >>>>>> mixtures of exact and inexact numbers, however, it seems to be as good
 >>>>>> a rule as any.
 >>>>>> 
 >>>>>> At Sun, 8 Dec 2013 09:56:01 -0500, rxg@cs.ubc.ca wrote:
 >>>>>>> A new problem report is waiting at
 >>>>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14232
 >>>>>>> 
 >>>>>>> Reported by Ron Garcia for release: 5.3.6
 >>>>>>> 
 >>>>>>> *** Description:
 >>>>>>> The Racket documentation does say that "Unless otherwise specified,
 >>>>>>> computations that involve an inexact number produce inexact results." but
 >>>>> the
 >>>>>>> following surprised me: if one number out of two given to max or min is
 >>>>>>> inexact, and the result should be the other number, it is transformed
 >>> into
 >>>>> an
 >>>>>>> inexact number.
 >>>>>>> 
 >>>>>>> *** How to repeat:
 >>>>>>>> (min 6 #i7.0)
 >>>>>>> #i6.0
 >>>>>>> 
 >>>>>>>> (max 8 #i7.0)
 >>>>>>> #i8.0
 >>>>>>> 
 >>>>>>> *** Environment:
 >>>>>>> macosx "Darwin Isis.local 12.5.0 Darwin Kernel Version 12.5.0: Sun Sep 29
 >>>>>>> 13:33:47 PDT 2013; root:xnu-2050.48.12~1/RELEASE_X86_64 x86_64"
 >>>>>>> (i386-macosx/3m) (get-display-depth) = 32
 >>>>>>> Human Language: english
 >>>>>>> (current-memory-use) 144107028
 >>>>>>> Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = ();
 >>>>> (links
 >>>>>>> #:user? #f #:root? #t) = ()
 >>>>>>> raco pkg (show):
 >>>>>>> Installation-wide:
 >>>>>>> [none]
 >>>>>>> User-specific, all-version:
 >>>>>>> [none]
 >>>>>>> User-specific, version-specific (5.3.6):
 >>>>>>> [none]
 >>>>>>> 
 >>>>>>> 
 >>>>>>> 
 >>>>>>> Collections:
 >>>>>>> ("/Users/Ron/Library/Racket/5.3.6/collects"
 >>>>>>> (non-existent-path))
 >>>>>>> ("/Applications/Racket v5.3.6/collects"
 >>>>>>> ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config"
 >>>>>>> "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme"
 >>>>> "dynext"
 >>>>>>> "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime"
 >>>>>>> "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist"
 >>>>> "htdp"
 >>>>>>> "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy"
 >>>>>>> "macro-debugger" "make" "math" "mred" "mrlib" "mysterx" "mzcom" "mzlib"
 >>>>>>> "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg"
 >>> "plai"
 >>>>>>> "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog"
 >>>>>>> "rackunit" "raco" "reader" "readline" "realm" "redex" "rnrs" "s-exp"
 >>>>> "scheme"
 >>>>>>> "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex"
 >>>>>>> "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax"
 >>>>>>> "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed"
 >>>>>>> "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme"
 >>>>> "xml"
 >>>>>>> "xrepl"))
 >>>>>>> 
 >>>>>>> Computer Language: (("Teaching Languages" "How to Design Programs"
 >>>>>>> "Intermediate Student with lambda") (#(#t constructor repeating-decimal
 >>> #f
 >>>>> #t
 >>>>>>> none) #f ()))
 
 
From: Neil Toronto <neil.toronto@gmail.com>
To: Ron Garcia <rxg@cs.ubc.ca>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, bugs@racket-lang.org,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14232: in teaching languages, max and min turn
 exact numbers into inexact numbers
Date: Sat, 21 Dec 2013 16:39:03 -0700

 On 12/13/2013 10:21 AM, Ron Garcia wrote:
 > Hello Neil,
 >
 > On 2013-12-09, at 12:27 AM, Neil Toronto <neil.toronto@gmail.com> wrote:
 >
 >> To be clear, the problem is that "infinity" means two different things:
 >>
 >> 1. Inexact overflow; i.e. any possible number outside the range
 >>     [-max.0,+max.0]
 >>
 >> 2. An additional real value introduced in the two-point
 >>     compactification of the reals
 >>
 >> If +inf.0 and -inf.0 mean #1, the current behavior of `min' and `max' is right. If they mean #2, the current behavior is wrong. Of course, the standard is pretty clear that they mean #1.
 >>
 >> Any confusion is compounded by the fact that, in floating-point math, they mean both things unambiguously.
 >>
 >> I've wanted exact infinities for things other than `min' and `max'. If I were to extend `math/distributions' to have exact-integer-valued distributions, I would need them; e.g. the inverse cdf of the exact geometric distribution evaluated at 1 should be +inf, not +inf.0. (For 1.0, it could return +inf.0.)
 >>
 >> If I were to extend the numeric tower, in TR-speak, I'd add Extended-Real and Extended-Integer types. No arithmetic operations would produce infinities unless given them. Both (/ 1 0) and (+ +inf -inf) would raise exceptions. There would be no Extended-Fixnum or Extended-Bytes. I don't know about Extended-Rational; it feels weird to me, because +inf and -inf are limit points that aren't expressible as a quotient. IOW, they're similar to irrationals.
 > I'm not sure how the situation with rationals differs from the situation with Extended-Integers:  +inf and -inf cannot be expressed by taking successors: instead they are the limits of that operation.  Couldn't +inf for instance be seen as the limit of successive division by a quotient that is less than zero (e.g. division by 1/2 repeatedly?)
 
 That's true. The difference is that every non-infinite limit of integers 
 is an integer (if a limit exists), but there are non-infinite limits of 
 rationals that aren't rationals.
 
 Here's another way to look at it. Closing the integers under limits 
 yields the extended integers. Closing the rationals under limits yields 
 the extended reals. There is no field that, when closed under limits, is 
 the extended rationals.
 
 I have no idea whether this distinction is a good reason to not have an 
 Extended-Rational type. I could also argue that we *should* have one, 
 because the extended rationals can be constructed from the extended 
 integers. I'll probably just try modeling them in TR and see if anything 
 weird happens.
 
 Neil 
 
