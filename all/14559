From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Tue Jun 10 12:13:51 2014
Received: from mail-oa0-f43.google.com (mail-oa0-f43.google.com [209.85.219.43])
	by winooski.ccs.neu.edu (8.14.7/8.14.7) with ESMTP id s5AGDouc027575
	for <bugs@bugs.plt-scheme.org>; Tue, 10 Jun 2014 12:13:50 -0400
Message-Id: <201406101613.s5AGDm0O027566@winooski.ccs.neu.edu>
Date: Tue, 10 Jun 2014 12:13:48 -0400
From: eric.n.dobson@gmail.com
To: bugs@racket-lang.org
Subject: Contract system doesn't make it easy to handle cyclic data structures

>Number:         14559
>Category:       all
>Synopsis:       Contract system doesn't make it easy to handle cyclic data structures
>Class:          sw-bug
>Responsible:    robby
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Tue Jun 10 12:16:01 -0400 2014
>Closed-Date:    Thu Jun 12 08:58:28 -0400 2014
>Last-Modified:  Fri Jul 04 06:00:01 -0400 2014
>Originator:     Eric Dobson
>Organization:
plt
>Submitter-Id:   unknown
>Release:        HEAD
>Environment:
MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.27 Safari/537.36
>Description:
The contracts that TR generates should be able to handle cyclic data structures. But this isn't true because the base contract combinators do not provide the machinery for this. I expect the following program to not loop but it does.

The contract it currently generates is equivalent to this:

(define c (recursive-contract
            (or/c #f (cons/c c c))
            #:flat))
>How-To-Repeat:
#lang racket/load

(module tr typed/racket
  (provide f)
  (define-type X (U #f (Pair X X)))
  (: f (X -> X))
  (define (f x) x))
(require 'tr)

(define cycle (shared ([x (cons x x)]) x))

(displayln 'before)
(f cycle)
(displayln 'after)
>Fix:
>Audit-Trail:
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>
Cc: nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 05:58:21 -0500

 Should this contract accept this value or not?
 
 Robby
 
 On Tue, Jun 10, 2014 at 11:16 AM,  <eric.n.dobson@gmail.com> wrote:
 > A new problem report is waiting at
 >   http://bugs.racket-lang.org/query/?cmd=view&pr=14559
 >
 > Reported by Eric Dobson for release: HEAD
 >
 > *** Description:
 > The contracts that TR generates should be able to handle cyclic data structures. But this isn't true because the base contract combinators do not provide the machinery for this. I expect the following program to not loop but it does.
 >
 > The contract it currently generates is equivalent to this:
 >
 > (define c (recursive-contract
 >             (or/c #f (cons/c c c))
 >             #:flat))
 >
 > *** How to repeat:
 > #lang racket/load
 >
 > (module tr typed/racket
 >   (provide f)
 >   (define-type X (U #f (Pair X X)))
 >   (: f (X -> X))
 >   (define (f x) x))
 > (require 'tr)
 >
 > (define cycle (shared ([x (cons x x)]) x))
 >
 > (displayln 'before)
 > (f cycle)
 > (displayln 'after)
 >
 > *** Environment:
 > MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.27 Safari/537.36
 >
Responsible changed from "nobody" to "robby" by robby@racket-lang.org at Thu, 12 Jun 2014 08:58:28 -0400
Reason>>> A commit by robby@racket-lang.org has resolved this report
  http://git.racket-lang.org/plt/commit/7728e062f4
State changed from "open" to "closed" by robby@racket-lang.org at Thu, 12 Jun 2014 08:58:28 -0400
Reason>>> A commit by robby@racket-lang.org has resolved this report
  http://git.racket-lang.org/plt/commit/7728e062f4
  | adjust recursive-contract so that it terminates on cyclic values
  | 
  | closes PR 14559
  | 
  | This slows down tight recursive contract loops by about 10%, using
  | the code below as the micro-benchmark:
  | 
  | (require racket/contract/base)
  | 
  | (define c
  |   (recursive-contract
  |    (or/c #f (cons/c c c))
  |    #:flat))
  | 
  | (define n1
  |   (let loop ([i 500000])
  |     (cond
  |       [(zero? i) #f]
  |       [else (cons (loop (- i 1)) #f)])))
  | 
  | (define n2
  |   (let loop ([i 500000])
  |     (cond
  |       [(zero? i) n1]
  |       [else (cons (loop (- i 1)) #f)])))
  | 
  | (collect-garbage) (collect-garbage) (collect-garbage)
  | 
  | (void
  |  (time (contract c n1 'pos 'neg))
  |  (time (contract c n2 'pos 'neg)))
  | 
  | (cdr n1)
  | (cdr n2)

From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Thu, 12 Jun 2014 09:13:01 -0400

 My hunch is that this makes the type system (kind of, at least) unsound. 
 
 Denotationally, 
 
   ;; C is one of 
   ;; -- #f
   ;; -- (cons C C)
 
 is an _inductive_ definition, meaning functions that traverse it structurally are guaranteed to terminate. The value named cycle (should be called cyclic) does NOT belong to this type, from this denotational perspective. 
 
 But yes, I acknowledge that 'cycle' is a rational tree and it is thus possible to decide whether it fits the patter modulo sharing pointers. 
 
 The saving grace is that the only effect we are getting here is non-termination (I think, plus induced effects). 
 
 It is not obvious to me that 'cycle' should pass this contract or whether the contract should diverge. 
 
 -- Matthias
 
 
 
 
 On Jun 12, 2014, at 6:58 AM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 
 > Should this contract accept this value or not?
 > 
 > Robby
 > 
 > On Tue, Jun 10, 2014 at 11:16 AM,  <eric.n.dobson@gmail.com> wrote:
 >> A new problem report is waiting at
 >>  http://bugs.racket-lang.org/query/?cmd=view&pr=14559
 >> 
 >> Reported by Eric Dobson for release: HEAD
 >> 
 >> *** Description:
 >> The contracts that TR generates should be able to handle cyclic data structures. But this isn't true because the base contract combinators do not provide the machinery for this. I expect the following program to not loop but it does.
 >> 
 >> The contract it currently generates is equivalent to this:
 >> 
 >> (define c (recursive-contract
 >>            (or/c #f (cons/c c c))
 >>            #:flat))
 >> 
 >> *** How to repeat:
 >> #lang racket/load
 >> 
 >> (module tr typed/racket
 >>  (provide f)
 >>  (define-type X (U #f (Pair X X)))
 >>  (: f (X -> X))
 >>  (define (f x) x))
 >> (require 'tr)
 >> 
 >> (define cycle (shared ([x (cons x x)]) x))
 >> 
 >> (displayln 'before)
 >> (f cycle)
 >> (displayln 'after)
 >> 
 >> *** Environment:
 >> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.27 Safari/537.36
 >> 
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 08:18:24 -0500

 I think the contact could also reject this value without diverging.
 
 Robby
 
 On Thu, Jun 12, 2014 at 8:13 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > My hunch is that this makes the type system (kind of, at least) unsound.
 >
 > Denotationally,
 >
 >   ;; C is one of
 >   ;; -- #f
 >   ;; -- (cons C C)
 >
 > is an _inductive_ definition, meaning functions that traverse it structurally are guaranteed to terminate. The value named cycle (should be called cyclic) does NOT belong to this type, from this denotational perspective.
 >
 > But yes, I acknowledge that 'cycle' is a rational tree and it is thus possible to decide whether it fits the patter modulo sharing pointers.
 >
 > The saving grace is that the only effect we are getting here is non-termination (I think, plus induced effects).
 >
 > It is not obvious to me that 'cycle' should pass this contract or whether the contract should diverge.
 >
 > -- Matthias
 >
 >
 >
 >
 > On Jun 12, 2014, at 6:58 AM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 >
 >> Should this contract accept this value or not?
 >>
 >> Robby
 >>
 >> On Tue, Jun 10, 2014 at 11:16 AM,  <eric.n.dobson@gmail.com> wrote:
 >>> A new problem report is waiting at
 >>>  http://bugs.racket-lang.org/query/?cmd=view&pr=14559
 >>>
 >>> Reported by Eric Dobson for release: HEAD
 >>>
 >>> *** Description:
 >>> The contracts that TR generates should be able to handle cyclic data structures. But this isn't true because the base contract combinators do not provide the machinery for this. I expect the following program to not loop but it does.
 >>>
 >>> The contract it currently generates is equivalent to this:
 >>>
 >>> (define c (recursive-contract
 >>>            (or/c #f (cons/c c c))
 >>>            #:flat))
 >>>
 >>> *** How to repeat:
 >>> #lang racket/load
 >>>
 >>> (module tr typed/racket
 >>>  (provide f)
 >>>  (define-type X (U #f (Pair X X)))
 >>>  (: f (X -> X))
 >>>  (define (f x) x))
 >>> (require 'tr)
 >>>
 >>> (define cycle (shared ([x (cons x x)]) x))
 >>>
 >>> (displayln 'before)
 >>> (f cycle)
 >>> (displayln 'after)
 >>>
 >>> *** Environment:
 >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.27 Safari/537.36
 >>>
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Thu, 12 Jun 2014 09:24:05 -0400

 Correct. That's what it does now, right? 
 
 
 On Jun 12, 2014, at 9:18 AM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 
 > I think the contact could also reject this value without diverging.
 > 
 > Robby
 > 
 > On Thu, Jun 12, 2014 at 8:13 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> My hunch is that this makes the type system (kind of, at least) unsound.
 >> 
 >> Denotationally,
 >> 
 >>  ;; C is one of
 >>  ;; -- #f
 >>  ;; -- (cons C C)
 >> 
 >> is an _inductive_ definition, meaning functions that traverse it structurally are guaranteed to terminate. The value named cycle (should be called cyclic) does NOT belong to this type, from this denotational perspective.
 >> 
 >> But yes, I acknowledge that 'cycle' is a rational tree and it is thus possible to decide whether it fits the patter modulo sharing pointers.
 >> 
 >> The saving grace is that the only effect we are getting here is non-termination (I think, plus induced effects).
 >> 
 >> It is not obvious to me that 'cycle' should pass this contract or whether the contract should diverge.
 >> 
 >> -- Matthias
 >> 
 >> 
 >> 
 >> 
 >> On Jun 12, 2014, at 6:58 AM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 >> 
 >>> Should this contract accept this value or not?
 >>> 
 >>> Robby
 >>> 
 >>> On Tue, Jun 10, 2014 at 11:16 AM,  <eric.n.dobson@gmail.com> wrote:
 >>>> A new problem report is waiting at
 >>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14559
 >>>> 
 >>>> Reported by Eric Dobson for release: HEAD
 >>>> 
 >>>> *** Description:
 >>>> The contracts that TR generates should be able to handle cyclic data structures. But this isn't true because the base contract combinators do not provide the machinery for this. I expect the following program to not loop but it does.
 >>>> 
 >>>> The contract it currently generates is equivalent to this:
 >>>> 
 >>>> (define c (recursive-contract
 >>>>           (or/c #f (cons/c c c))
 >>>>           #:flat))
 >>>> 
 >>>> *** How to repeat:
 >>>> #lang racket/load
 >>>> 
 >>>> (module tr typed/racket
 >>>> (provide f)
 >>>> (define-type X (U #f (Pair X X)))
 >>>> (: f (X -> X))
 >>>> (define (f x) x))
 >>>> (require 'tr)
 >>>> 
 >>>> (define cycle (shared ([x (cons x x)]) x))
 >>>> 
 >>>> (displayln 'before)
 >>>> (f cycle)
 >>>> (displayln 'after)
 >>>> 
 >>>> *** Environment:
 >>>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.27 Safari/537.36
 >>>> 
 >> 
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 08:29:57 -0500

 It currently accepts the value.
 
 Robby
 
 On Thu, Jun 12, 2014 at 8:24 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > Correct. That's what it does now, right?
 >
 >
 > On Jun 12, 2014, at 9:18 AM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 >
 >> I think the contact could also reject this value without diverging.
 >>
 >> Robby
 >>
 >> On Thu, Jun 12, 2014 at 8:13 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> My hunch is that this makes the type system (kind of, at least) unsound.
 >>>
 >>> Denotationally,
 >>>
 >>>  ;; C is one of
 >>>  ;; -- #f
 >>>  ;; -- (cons C C)
 >>>
 >>> is an _inductive_ definition, meaning functions that traverse it structurally are guaranteed to terminate. The value named cycle (should be called cyclic) does NOT belong to this type, from this denotational perspective.
 >>>
 >>> But yes, I acknowledge that 'cycle' is a rational tree and it is thus possible to decide whether it fits the patter modulo sharing pointers.
 >>>
 >>> The saving grace is that the only effect we are getting here is non-termination (I think, plus induced effects).
 >>>
 >>> It is not obvious to me that 'cycle' should pass this contract or whether the contract should diverge.
 >>>
 >>> -- Matthias
 >>>
 >>>
 >>>
 >>>
 >>> On Jun 12, 2014, at 6:58 AM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 >>>
 >>>> Should this contract accept this value or not?
 >>>>
 >>>> Robby
 >>>>
 >>>> On Tue, Jun 10, 2014 at 11:16 AM,  <eric.n.dobson@gmail.com> wrote:
 >>>>> A new problem report is waiting at
 >>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14559
 >>>>>
 >>>>> Reported by Eric Dobson for release: HEAD
 >>>>>
 >>>>> *** Description:
 >>>>> The contracts that TR generates should be able to handle cyclic data structures. But this isn't true because the base contract combinators do not provide the machinery for this. I expect the following program to not loop but it does.
 >>>>>
 >>>>> The contract it currently generates is equivalent to this:
 >>>>>
 >>>>> (define c (recursive-contract
 >>>>>           (or/c #f (cons/c c c))
 >>>>>           #:flat))
 >>>>>
 >>>>> *** How to repeat:
 >>>>> #lang racket/load
 >>>>>
 >>>>> (module tr typed/racket
 >>>>> (provide f)
 >>>>> (define-type X (U #f (Pair X X)))
 >>>>> (: f (X -> X))
 >>>>> (define (f x) x))
 >>>>> (require 'tr)
 >>>>>
 >>>>> (define cycle (shared ([x (cons x x)]) x))
 >>>>>
 >>>>> (displayln 'before)
 >>>>> (f cycle)
 >>>>> (displayln 'after)
 >>>>>
 >>>>> *** Environment:
 >>>>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.27 Safari/537.36
 >>>>>
 >>>
 >
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 09:40:26 -0400

 On Thu, Jun 12, 2014 at 9:13 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > My hunch is that this makes the type system (kind of, at least) unsound.
 >
 > Denotationally,
 >
 >   ;; C is one of
 >   ;; -- #f
 >   ;; -- (cons C C)
 >
 > is an _inductive_ definition, meaning functions that traverse it structurally are guaranteed to terminate. The value named cycle (should be called cyclic) does NOT belong to this type, from this denotational perspective.
 
 Do you think that this is true for (mutable) vectors as well? IOW,
 that cyclic vectors should be ruled out by the types? My hunch is that
 you think that mutable data can be cyclic, but not immutable data.
 
 Fortunately or unfortunately, this isn't the distinction that Racket's
 semantics makes, and so I think TR and the contract system should both
 follow Racket.
 
 Sam
 
 
 
 >
 > But yes, I acknowledge that 'cycle' is a rational tree and it is thus possible to decide whether it fits the patter modulo sharing pointers.
 >
 > The saving grace is that the only effect we are getting here is non-termination (I think, plus induced effects).
 >
 > It is not obvious to me that 'cycle' should pass this contract or whether the contract should diverge.
 >
 > -- Matthias
 >
 >
 >
 >
 > On Jun 12, 2014, at 6:58 AM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 >
 >> Should this contract accept this value or not?
 >>
 >> Robby
 >>
 >> On Tue, Jun 10, 2014 at 11:16 AM,  <eric.n.dobson@gmail.com> wrote:
 >>> A new problem report is waiting at
 >>>  http://bugs.racket-lang.org/query/?cmd=view&pr=14559
 >>>
 >>> Reported by Eric Dobson for release: HEAD
 >>>
 >>> *** Description:
 >>> The contracts that TR generates should be able to handle cyclic data structures. But this isn't true because the base contract combinators do not provide the machinery for this. I expect the following program to not loop but it does.
 >>>
 >>> The contract it currently generates is equivalent to this:
 >>>
 >>> (define c (recursive-contract
 >>>            (or/c #f (cons/c c c))
 >>>            #:flat))
 >>>
 >>> *** How to repeat:
 >>> #lang racket/load
 >>>
 >>> (module tr typed/racket
 >>>  (provide f)
 >>>  (define-type X (U #f (Pair X X)))
 >>>  (: f (X -> X))
 >>>  (define (f x) x))
 >>> (require 'tr)
 >>>
 >>> (define cycle (shared ([x (cons x x)]) x))
 >>>
 >>> (displayln 'before)
 >>> (f cycle)
 >>> (displayln 'after)
 >>>
 >>> *** Environment:
 >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.27 Safari/537.36
 >>>
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Thu, 12 Jun 2014 10:32:20 -0400

 On Jun 12, 2014, at 9:40 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > On Thu, Jun 12, 2014 at 9:13 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> My hunch is that this makes the type system (kind of, at least) unsound.
 >> 
 >> Denotationally,
 >> 
 >>  ;; C is one of
 >>  ;; -- #f
 >>  ;; -- (cons C C)
 >> 
 >> is an _inductive_ definition, meaning functions that traverse it structurally are guaranteed to terminate. The value named cycle (should be called cyclic) does NOT belong to this type, from this denotational perspective.
 > 
 > Do you think that this is true for (mutable) vectors as well? IOW,
 > that cyclic vectors should be ruled out by the types? My hunch is that
 > you think that mutable data can be cyclic, but not immutable data.
 
 
 Unless you introduce co-inductive definitions, your algebraic data types are inductive. Cycles come from co-induction (share, laziness) and are rational or they come from mutation. 
 
 If you haven't noticed, adding co-inductive definition to declarative PLs is a minor fashion these days. 
 
 
 > Fortunately or unfortunately, this isn't the distinction that Racket's
 > semantics makes, and so I think TR and the contract system should both
 > follow Racket.
 
 
 That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them. 
 
 Does anyone know what OCaml does? I asked Xavier and Didier about this recently -- because of the Undefined paper -- and they said they can't recall this CAML paper from the early 90s that I have in my memories. (Well for all I know I reviewed it and dismissed it because I had developed the letrec version of shared with Bruce.) 
 
 What does it do? From what I recall it has cyclic declarations (for rational data). -- Matthias
 
 
 
 
 
 
 
 > 
 > Sam
 > 
 > 
 > 
 >> 
 >> But yes, I acknowledge that 'cycle' is a rational tree and it is thus possible to decide whether it fits the patter modulo sharing pointers.
 >> 
 >> The saving grace is that the only effect we are getting here is non-termination (I think, plus induced effects).
 >> 
 >> It is not obvious to me that 'cycle' should pass this contract or whether the contract should diverge.
 >> 
 >> -- Matthias
 >> 
 >> 
 >> 
 >> 
 >> On Jun 12, 2014, at 6:58 AM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 >> 
 >>> Should this contract accept this value or not?
 >>> 
 >>> Robby
 >>> 
 >>> On Tue, Jun 10, 2014 at 11:16 AM,  <eric.n.dobson@gmail.com> wrote:
 >>>> A new problem report is waiting at
 >>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14559
 >>>> 
 >>>> Reported by Eric Dobson for release: HEAD
 >>>> 
 >>>> *** Description:
 >>>> The contracts that TR generates should be able to handle cyclic data structures. But this isn't true because the base contract combinators do not provide the machinery for this. I expect the following program to not loop but it does.
 >>>> 
 >>>> The contract it currently generates is equivalent to this:
 >>>> 
 >>>> (define c (recursive-contract
 >>>>           (or/c #f (cons/c c c))
 >>>>           #:flat))
 >>>> 
 >>>> *** How to repeat:
 >>>> #lang racket/load
 >>>> 
 >>>> (module tr typed/racket
 >>>> (provide f)
 >>>> (define-type X (U #f (Pair X X)))
 >>>> (: f (X -> X))
 >>>> (define (f x) x))
 >>>> (require 'tr)
 >>>> 
 >>>> (define cycle (shared ([x (cons x x)]) x))
 >>>> 
 >>>> (displayln 'before)
 >>>> (f cycle)
 >>>> (displayln 'after)
 >>>> 
 >>>> *** Environment:
 >>>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.27 Safari/537.36
 >>>> 
 >> 
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 10:38:20 -0400

 On Thu, Jun 12, 2014 at 10:32 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 > On Jun 12, 2014, at 9:40 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >> On Thu, Jun 12, 2014 at 9:13 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> My hunch is that this makes the type system (kind of, at least) unsound.
 >>>
 >>> Denotationally,
 >>>
 >>>  ;; C is one of
 >>>  ;; -- #f
 >>>  ;; -- (cons C C)
 >>>
 >>> is an _inductive_ definition, meaning functions that traverse it structurally are guaranteed to terminate. The value named cycle (should be called cyclic) does NOT belong to this type, from this denotational perspective.
 >>
 >> Do you think that this is true for (mutable) vectors as well? IOW,
 >> that cyclic vectors should be ruled out by the types? My hunch is that
 >> you think that mutable data can be cyclic, but not immutable data.
 >
 >
 > Unless you introduce co-inductive definitions, your algebraic data types are inductive. Cycles come from co-induction (share, laziness) and are rational or they come from mutation.
 
 Right, and things built with `cons` in Racket are co-inductive.
 
 >> Fortunately or unfortunately, this isn't the distinction that Racket's
 >> semantics makes, and so I think TR and the contract system should both
 >> follow Racket.
 >
 > That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them.
 
 Of course -- we get to design the type system. But the most important
 constraint on the type system, in my view, is that it corresponds to
 the semantics Racket programs already have. And in Racket, data
 structures built with `cons` can have cycles.
 
 Sam
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Thu, 12 Jun 2014 10:44:02 -0400

 On Jun 12, 2014, at 10:38 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 >>> Fortunately or unfortunately, this isn't the distinction that Racket's
 >>> semantics makes, and so I think TR and the contract system should both
 >>> follow Racket.
 >> 
 >> That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them.
 > 
 > Of course -- we get to design the type system. But the most important
 > constraint on the type system, in my view, is that it corresponds to
 > the semantics Racket programs already have. And in Racket, data
 > structures built with `cons` can have cycles.
 
 
 Do you want a sound type system? 
 
 Do you know whether co-inductive denotations are sound? 
 
 If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet". 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 10:51:51 -0400

 On Thu, Jun 12, 2014 at 10:44 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > On Jun 12, 2014, at 10:38 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >>>> Fortunately or unfortunately, this isn't the distinction that Racket's
 >>>> semantics makes, and so I think TR and the contract system should both
 >>>> follow Racket.
 >>>
 >>> That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them.
 >>
 >> Of course -- we get to design the type system. But the most important
 >> constraint on the type system, in my view, is that it corresponds to
 >> the semantics Racket programs already have. And in Racket, data
 >> structures built with `cons` can have cycles.
 >
 >
 > Do you want a sound type system?
 
 Yes, of course.
 
 > Do you know whether co-inductive denotations are sound?
 
 I don't see why we should think about this any differently than
 vectors or mutable pairs (which were also fixed in the same way by
 Robby's changes).
 
 > If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 
 Of course, if there's a soundness problem here, I want to fix it. But
 if you want to rule out cyclic pairs in TR, that would be a much
 bigger change.  Consider this program:
 
 (: f (-> Any Integer))
 (define (f x)
   (match x
    [(cons a b) (f a)]
    [_ 0]))
 
 Does it terminate on all inputs?
 
 Sam
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Thu, 12 Jun 2014 10:59:52 -0400

 On Jun 12, 2014, at 10:51 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 >> 
 >> Do you know whether co-inductive denotations are sound?
 > 
 > I don't see why we should think about this any differently than
 > vectors or mutable pairs (which were also fixed in the same way by
 > Robby's changes).
 
 
 
 Yes, but is this 'fix' sound for TR? 
 
 
 
 >> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 > 
 > Of course, if there's a soundness problem here, I want to fix it. But
 > if you want to rule out cyclic pairs in TR, that would be a much
 > bigger change.  Consider this program:
 > 
 > (: f (-> Any Integer))
 > (define (f x)
 >  (match x
 >   [(cons a b) (f a)]
 >   [_ 0]))
 > 
 > Does it terminate on all inputs?
 
 
 In the old type system, yes. There are no cyclic cons-es. 
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 11:14:58 -0400

 On Thu, Jun 12, 2014 at 10:59 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > On Jun 12, 2014, at 10:51 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >>>
 >>> Do you know whether co-inductive denotations are sound?
 >>
 >> I don't see why we should think about this any differently than
 >> vectors or mutable pairs (which were also fixed in the same way by
 >> Robby's changes).
 >
 > Yes, but is this 'fix' sound for TR?
 
 Do you think there were soundness holes in TR before? Do you think
 this is only about cons?
 
 >>> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 >>
 >> Of course, if there's a soundness problem here, I want to fix it. But
 >> if you want to rule out cyclic pairs in TR, that would be a much
 >> bigger change.  Consider this program:
 >>
 >> (: f (-> Any Integer))
 >> (define (f x)
 >>  (match x
 >>   [(cons a b) (f a)]
 >>   [_ 0]))
 >>
 >> Does it terminate on all inputs?
 >
 > In the old type system, yes. There are no cyclic cons-es.
 
 Unfortunately not. Here are two ways to get `f` to loop, ignoring
 Robby's changes:
 
 1:
 
 (module m racket
   (provide c)
   (define c (shared ([c (cons c 1)]) c)))
 
 (require/typed 'm [c Any]) (f c)
 
 2:
 
 (f (read (open-input-string "#0=(#0# . 1)")))
 
 Sam
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Thu, 12 Jun 2014 11:19:41 -0400

 On Jun 12, 2014, at 11:14 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 >> 
 >> Yes, but is this 'fix' sound for TR?
 > 
 > Do you think there were soundness holes in TR before? Do you think
 > this is only about cons?
 
 
 
 I am perfectly aware of soundness holes. 
 I was hoping that we'd get at least one 
 thing right. 
 
 
 
 
 
 >>>> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 >>> 
 >>> Of course, if there's a soundness problem here, I want to fix it. But
 >>> if you want to rule out cyclic pairs in TR, that would be a much
 >>> bigger change.  Consider this program:
 >>> 
 >>> (: f (-> Any Integer))
 >>> (define (f x)
 >>> (match x
 >>>  [(cons a b) (f a)]
 >>>  [_ 0]))
 >>> 
 >>> Does it terminate on all inputs?
 >> 
 >> In the old type system, yes. There are no cyclic cons-es.
 > 
 > Unfortunately not. Here are two ways to get `f` to loop, ignoring
 > Robby's changes:
 > 
 > 1:
 > 
 > (module m racket
 >  (provide c)
 >  (define c (shared ([c (cons c 1)]) c)))
 > 
 > (require/typed 'm [c Any]) (f c)
 
 
 Is this a hole in Any again? 
 
 
 > 
 > 2:
 > 
 > (f (read (open-input-string "#0=(#0# . 1)")))
 
 
 This is shared in disguise. 
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 08:16:31 -0700

 A list of numbers (C) is either
 Null or (Cons Number C)
 
 Should cyclic data structures be allowed by this definition, or should
 this definition correspond to list?. Currently TR assumes that it
 corresponds to list?.
 
 To be consistent with that we have to assume inductive instead of co-inductive.
 
 
 
 On Thu, Jun 12, 2014 at 7:51 AM, Sam Tobin-Hochstadt
 <samth@cs.indiana.edu> wrote:
 > On Thu, Jun 12, 2014 at 10:44 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >>
 >> On Jun 12, 2014, at 10:38 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>
 >>>>> Fortunately or unfortunately, this isn't the distinction that Racket's
 >>>>> semantics makes, and so I think TR and the contract system should both
 >>>>> follow Racket.
 >>>>
 >>>> That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them.
 >>>
 >>> Of course -- we get to design the type system. But the most important
 >>> constraint on the type system, in my view, is that it corresponds to
 >>> the semantics Racket programs already have. And in Racket, data
 >>> structures built with `cons` can have cycles.
 >>
 >>
 >> Do you want a sound type system?
 >
 > Yes, of course.
 >
 >> Do you know whether co-inductive denotations are sound?
 >
 > I don't see why we should think about this any differently than
 > vectors or mutable pairs (which were also fixed in the same way by
 > Robby's changes).
 >
 >> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 >
 > Of course, if there's a soundness problem here, I want to fix it. But
 > if you want to rule out cyclic pairs in TR, that would be a much
 > bigger change.  Consider this program:
 >
 > (: f (-> Any Integer))
 > (define (f x)
 >   (match x
 >    [(cons a b) (f a)]
 >    [_ 0]))
 >
 > Does it terminate on all inputs?
 >
 > Sam
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Thu, 12 Jun 2014 11:18:33 -0400

 On Jun 12, 2014, at 11:16 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 
 > A list of numbers (C) is either
 > Null or (Cons Number C)
 > 
 > Should cyclic data structures be allowed by this definition, or should
 > this definition correspond to list?. Currently TR assumes that it
 > corresponds to list?.
 > 
 > To be consistent with that we have to assume inductive instead of co-inductive.
 
 
 
 The meaning of these words was settled before I was born (literally). 
 It is always understood to be the inductive (smallest fixpoint). 
 
 
 
 
 
 
 
 
 
 > 
 > 
 > 
 > On Thu, Jun 12, 2014 at 7:51 AM, Sam Tobin-Hochstadt
 > <samth@cs.indiana.edu> wrote:
 >> On Thu, Jun 12, 2014 at 10:44 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>> 
 >>> On Jun 12, 2014, at 10:38 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>> 
 >>>>>> Fortunately or unfortunately, this isn't the distinction that Racket's
 >>>>>> semantics makes, and so I think TR and the contract system should both
 >>>>>> follow Racket.
 >>>>> 
 >>>>> That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them.
 >>>> 
 >>>> Of course -- we get to design the type system. But the most important
 >>>> constraint on the type system, in my view, is that it corresponds to
 >>>> the semantics Racket programs already have. And in Racket, data
 >>>> structures built with `cons` can have cycles.
 >>> 
 >>> 
 >>> Do you want a sound type system?
 >> 
 >> Yes, of course.
 >> 
 >>> Do you know whether co-inductive denotations are sound?
 >> 
 >> I don't see why we should think about this any differently than
 >> vectors or mutable pairs (which were also fixed in the same way by
 >> Robby's changes).
 >> 
 >>> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 >> 
 >> Of course, if there's a soundness problem here, I want to fix it. But
 >> if you want to rule out cyclic pairs in TR, that would be a much
 >> bigger change.  Consider this program:
 >> 
 >> (: f (-> Any Integer))
 >> (define (f x)
 >>  (match x
 >>   [(cons a b) (f a)]
 >>   [_ 0]))
 >> 
 >> Does it terminate on all inputs?
 >> 
 >> Sam
 
 
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 08:25:52 -0700

 Exactly. I'm saying that we already treat the definitions as inductive.
 
 Otherwise C = (U #f (Cons Number C)) is different from C = (U Null
 (Cons Number C)), in ways other than checking the base case.
 
 On Thu, Jun 12, 2014 at 8:18 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > On Jun 12, 2014, at 11:16 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >
 >> A list of numbers (C) is either
 >> Null or (Cons Number C)
 >>
 >> Should cyclic data structures be allowed by this definition, or should
 >> this definition correspond to list?. Currently TR assumes that it
 >> corresponds to list?.
 >>
 >> To be consistent with that we have to assume inductive instead of co-inductive.
 >
 >
 >
 > The meaning of these words was settled before I was born (literally).
 > It is always understood to be the inductive (smallest fixpoint).
 >
 >
 >
 >
 >
 >
 >
 >
 >
 >>
 >>
 >>
 >> On Thu, Jun 12, 2014 at 7:51 AM, Sam Tobin-Hochstadt
 >> <samth@cs.indiana.edu> wrote:
 >>> On Thu, Jun 12, 2014 at 10:44 AM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>>
 >>>> On Jun 12, 2014, at 10:38 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>>
 >>>>>>> Fortunately or unfortunately, this isn't the distinction that Racket's
 >>>>>>> semantics makes, and so I think TR and the contract system should both
 >>>>>>> follow Racket.
 >>>>>>
 >>>>>> That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them.
 >>>>>
 >>>>> Of course -- we get to design the type system. But the most important
 >>>>> constraint on the type system, in my view, is that it corresponds to
 >>>>> the semantics Racket programs already have. And in Racket, data
 >>>>> structures built with `cons` can have cycles.
 >>>>
 >>>>
 >>>> Do you want a sound type system?
 >>>
 >>> Yes, of course.
 >>>
 >>>> Do you know whether co-inductive denotations are sound?
 >>>
 >>> I don't see why we should think about this any differently than
 >>> vectors or mutable pairs (which were also fixed in the same way by
 >>> Robby's changes).
 >>>
 >>>> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 >>>
 >>> Of course, if there's a soundness problem here, I want to fix it. But
 >>> if you want to rule out cyclic pairs in TR, that would be a much
 >>> bigger change.  Consider this program:
 >>>
 >>> (: f (-> Any Integer))
 >>> (define (f x)
 >>>  (match x
 >>>   [(cons a b) (f a)]
 >>>   [_ 0]))
 >>>
 >>> Does it terminate on all inputs?
 >>>
 >>> Sam
 >
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 11:37:26 -0400

 On Thu, Jun 12, 2014 at 11:19 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > On Jun 12, 2014, at 11:14 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >>>
 >>> Yes, but is this 'fix' sound for TR?
 >>
 >> Do you think there were soundness holes in TR before? Do you think
 >> this is only about cons?
 >
 >
 >
 > I am perfectly aware of soundness holes.
 > I was hoping that we'd get at least one
 > thing right.
 
 No, I mean in related to cyclic data.  Currently I don't think there
 are any, but if you have a suspicion about something that's broken, we
 can investigate.
 
 >>>>> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 >>>>
 >>>> Of course, if there's a soundness problem here, I want to fix it. But
 >>>> if you want to rule out cyclic pairs in TR, that would be a much
 >>>> bigger change.  Consider this program:
 >>>>
 >>>> (: f (-> Any Integer))
 >>>> (define (f x)
 >>>> (match x
 >>>>  [(cons a b) (f a)]
 >>>>  [_ 0]))
 >>>>
 >>>> Does it terminate on all inputs?
 >>>
 >>> In the old type system, yes. There are no cyclic cons-es.
 >>
 >> Unfortunately not. Here are two ways to get `f` to loop, ignoring
 >> Robby's changes:
 >>
 >> 1:
 >>
 >> (module m racket
 >>  (provide c)
 >>  (define c (shared ([c (cons c 1)]) c)))
 >>
 >> (require/typed 'm [c Any]) (f c)
 >
 >
 > Is this a hole in Any again?
 
 I don't think so. `Any` there is translated to `any/c` -- the tricky
 case for `Any` goes the other way.
 
 >> 2:
 >>
 >> (f (read (open-input-string "#0=(#0# . 1)")))
 >
 >
 > This is shared in disguise.
 
 I'd say it's the other way around -- `shared` is built on the reader mechanism.
 
 Sam
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 11:38:11 -0400

 Do we treat them as inductive in any place other than generating `list?`?
 
 Sam
 
 On Thu, Jun 12, 2014 at 11:25 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > Exactly. I'm saying that we already treat the definitions as inductive.
 >
 > Otherwise C = (U #f (Cons Number C)) is different from C = (U Null
 > (Cons Number C)), in ways other than checking the base case.
 >
 > On Thu, Jun 12, 2014 at 8:18 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >>
 >> On Jun 12, 2014, at 11:16 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>
 >>> A list of numbers (C) is either
 >>> Null or (Cons Number C)
 >>>
 >>> Should cyclic data structures be allowed by this definition, or should
 >>> this definition correspond to list?. Currently TR assumes that it
 >>> corresponds to list?.
 >>>
 >>> To be consistent with that we have to assume inductive instead of co-inductive.
 >>
 >>
 >>
 >> The meaning of these words was settled before I was born (literally).
 >> It is always understood to be the inductive (smallest fixpoint).
 >>
 >>
 >>
 >>
 >>
 >>
 >>
 >>
 >>
 >>>
 >>>
 >>>
 >>> On Thu, Jun 12, 2014 at 7:51 AM, Sam Tobin-Hochstadt
 >>> <samth@cs.indiana.edu> wrote:
 >>>> On Thu, Jun 12, 2014 at 10:44 AM, Matthias Felleisen
 >>>> <matthias@ccs.neu.edu> wrote:
 >>>>>
 >>>>> On Jun 12, 2014, at 10:38 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>>>
 >>>>>>>> Fortunately or unfortunately, this isn't the distinction that Racket's
 >>>>>>>> semantics makes, and so I think TR and the contract system should both
 >>>>>>>> follow Racket.
 >>>>>>>
 >>>>>>> That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them.
 >>>>>>
 >>>>>> Of course -- we get to design the type system. But the most important
 >>>>>> constraint on the type system, in my view, is that it corresponds to
 >>>>>> the semantics Racket programs already have. And in Racket, data
 >>>>>> structures built with `cons` can have cycles.
 >>>>>
 >>>>>
 >>>>> Do you want a sound type system?
 >>>>
 >>>> Yes, of course.
 >>>>
 >>>>> Do you know whether co-inductive denotations are sound?
 >>>>
 >>>> I don't see why we should think about this any differently than
 >>>> vectors or mutable pairs (which were also fixed in the same way by
 >>>> Robby's changes).
 >>>>
 >>>>> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 >>>>
 >>>> Of course, if there's a soundness problem here, I want to fix it. But
 >>>> if you want to rule out cyclic pairs in TR, that would be a much
 >>>> bigger change.  Consider this program:
 >>>>
 >>>> (: f (-> Any Integer))
 >>>> (define (f x)
 >>>>  (match x
 >>>>   [(cons a b) (f a)]
 >>>>   [_ 0]))
 >>>>
 >>>> Does it terminate on all inputs?
 >>>>
 >>>> Sam
 >>
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 08:47:28 -0700

 On Thu, Jun 12, 2014 at 8:38 AM, Sam Tobin-Hochstadt
 <samth@cs.indiana.edu> wrote:
 > Do we treat them as inductive in any place other than generating `list?`?
 Yes everywhere along the R/TR boundary in the base environment. (We
 assume (Listof A) corresponds to (listof a?), otherwise typed programs
 can provide cyclic values to functions not expecting them).
 The filter of 'list?'. This is likely a soundness hole, I'm working on
 an example.
 
 >
 > Sam
 >
 > On Thu, Jun 12, 2014 at 11:25 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> Exactly. I'm saying that we already treat the definitions as inductive.
 >>
 >> Otherwise C = (U #f (Cons Number C)) is different from C = (U Null
 >> (Cons Number C)), in ways other than checking the base case.
 >>
 >> On Thu, Jun 12, 2014 at 8:18 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> On Jun 12, 2014, at 11:16 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>
 >>>> A list of numbers (C) is either
 >>>> Null or (Cons Number C)
 >>>>
 >>>> Should cyclic data structures be allowed by this definition, or should
 >>>> this definition correspond to list?. Currently TR assumes that it
 >>>> corresponds to list?.
 >>>>
 >>>> To be consistent with that we have to assume inductive instead of co-inductive.
 >>>
 >>>
 >>>
 >>> The meaning of these words was settled before I was born (literally).
 >>> It is always understood to be the inductive (smallest fixpoint).
 >>>
 >>>
 >>>
 >>>
 >>>
 >>>
 >>>
 >>>
 >>>
 >>>>
 >>>>
 >>>>
 >>>> On Thu, Jun 12, 2014 at 7:51 AM, Sam Tobin-Hochstadt
 >>>> <samth@cs.indiana.edu> wrote:
 >>>>> On Thu, Jun 12, 2014 at 10:44 AM, Matthias Felleisen
 >>>>> <matthias@ccs.neu.edu> wrote:
 >>>>>>
 >>>>>> On Jun 12, 2014, at 10:38 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>>>>
 >>>>>>>>> Fortunately or unfortunately, this isn't the distinction that Racket's
 >>>>>>>>> semantics makes, and so I think TR and the contract system should both
 >>>>>>>>> follow Racket.
 >>>>>>>>
 >>>>>>>> That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them.
 >>>>>>>
 >>>>>>> Of course -- we get to design the type system. But the most important
 >>>>>>> constraint on the type system, in my view, is that it corresponds to
 >>>>>>> the semantics Racket programs already have. And in Racket, data
 >>>>>>> structures built with `cons` can have cycles.
 >>>>>>
 >>>>>>
 >>>>>> Do you want a sound type system?
 >>>>>
 >>>>> Yes, of course.
 >>>>>
 >>>>>> Do you know whether co-inductive denotations are sound?
 >>>>>
 >>>>> I don't see why we should think about this any differently than
 >>>>> vectors or mutable pairs (which were also fixed in the same way by
 >>>>> Robby's changes).
 >>>>>
 >>>>>> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 >>>>>
 >>>>> Of course, if there's a soundness problem here, I want to fix it. But
 >>>>> if you want to rule out cyclic pairs in TR, that would be a much
 >>>>> bigger change.  Consider this program:
 >>>>>
 >>>>> (: f (-> Any Integer))
 >>>>> (define (f x)
 >>>>>  (match x
 >>>>>   [(cons a b) (f a)]
 >>>>>   [_ 0]))
 >>>>>
 >>>>> Does it terminate on all inputs?
 >>>>>
 >>>>> Sam
 >>>
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 08:55:32 -0700

 Example program that when optimized returns #t and non optimized returns #f.
 
 #lang racket/load
 
 (module tr typed/racket ;#:no-optimize
   (provide f)
   (define-type C (Pair Number (Pair Number C)))
   (: f (C -> #t))
   (define (f x) (if (list? (ann x (Listof Number))) #t #f)))
 
 (require 'tr)
 (displayln (f (shared ([x (cons 1 x)]) x)))
 
 On Thu, Jun 12, 2014 at 8:47 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > On Thu, Jun 12, 2014 at 8:38 AM, Sam Tobin-Hochstadt
 > <samth@cs.indiana.edu> wrote:
 >> Do we treat them as inductive in any place other than generating `list?`?
 > Yes everywhere along the R/TR boundary in the base environment. (We
 > assume (Listof A) corresponds to (listof a?), otherwise typed programs
 > can provide cyclic values to functions not expecting them).
 > The filter of 'list?'. This is likely a soundness hole, I'm working on
 > an example.
 >
 >>
 >> Sam
 >>
 >> On Thu, Jun 12, 2014 at 11:25 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>> Exactly. I'm saying that we already treat the definitions as inductive.
 >>>
 >>> Otherwise C = (U #f (Cons Number C)) is different from C = (U Null
 >>> (Cons Number C)), in ways other than checking the base case.
 >>>
 >>> On Thu, Jun 12, 2014 at 8:18 AM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>>
 >>>> On Jun 12, 2014, at 11:16 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>
 >>>>> A list of numbers (C) is either
 >>>>> Null or (Cons Number C)
 >>>>>
 >>>>> Should cyclic data structures be allowed by this definition, or should
 >>>>> this definition correspond to list?. Currently TR assumes that it
 >>>>> corresponds to list?.
 >>>>>
 >>>>> To be consistent with that we have to assume inductive instead of co-inductive.
 >>>>
 >>>>
 >>>>
 >>>> The meaning of these words was settled before I was born (literally).
 >>>> It is always understood to be the inductive (smallest fixpoint).
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>> On Thu, Jun 12, 2014 at 7:51 AM, Sam Tobin-Hochstadt
 >>>>> <samth@cs.indiana.edu> wrote:
 >>>>>> On Thu, Jun 12, 2014 at 10:44 AM, Matthias Felleisen
 >>>>>> <matthias@ccs.neu.edu> wrote:
 >>>>>>>
 >>>>>>> On Jun 12, 2014, at 10:38 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>>>>>
 >>>>>>>>>> Fortunately or unfortunately, this isn't the distinction that Racket's
 >>>>>>>>>> semantics makes, and so I think TR and the contract system should both
 >>>>>>>>>> follow Racket.
 >>>>>>>>>
 >>>>>>>>> That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them.
 >>>>>>>>
 >>>>>>>> Of course -- we get to design the type system. But the most important
 >>>>>>>> constraint on the type system, in my view, is that it corresponds to
 >>>>>>>> the semantics Racket programs already have. And in Racket, data
 >>>>>>>> structures built with `cons` can have cycles.
 >>>>>>>
 >>>>>>>
 >>>>>>> Do you want a sound type system?
 >>>>>>
 >>>>>> Yes, of course.
 >>>>>>
 >>>>>>> Do you know whether co-inductive denotations are sound?
 >>>>>>
 >>>>>> I don't see why we should think about this any differently than
 >>>>>> vectors or mutable pairs (which were also fixed in the same way by
 >>>>>> Robby's changes).
 >>>>>>
 >>>>>>> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 >>>>>>
 >>>>>> Of course, if there's a soundness problem here, I want to fix it. But
 >>>>>> if you want to rule out cyclic pairs in TR, that would be a much
 >>>>>> bigger change.  Consider this program:
 >>>>>>
 >>>>>> (: f (-> Any Integer))
 >>>>>> (define (f x)
 >>>>>>  (match x
 >>>>>>   [(cons a b) (f a)]
 >>>>>>   [_ 0]))
 >>>>>>
 >>>>>> Does it terminate on all inputs?
 >>>>>>
 >>>>>> Sam
 >>>>
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 12:09:52 -0400

 This is only with Robby's new change, right?  Previously, that
 contract would have looped.
 
 Sam
 
 On Thu, Jun 12, 2014 at 11:55 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > Example program that when optimized returns #t and non optimized returns #f.
 >
 > #lang racket/load
 >
 > (module tr typed/racket ;#:no-optimize
 >   (provide f)
 >   (define-type C (Pair Number (Pair Number C)))
 >   (: f (C -> #t))
 >   (define (f x) (if (list? (ann x (Listof Number))) #t #f)))
 >
 > (require 'tr)
 > (displayln (f (shared ([x (cons 1 x)]) x)))
 >
 > On Thu, Jun 12, 2014 at 8:47 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> On Thu, Jun 12, 2014 at 8:38 AM, Sam Tobin-Hochstadt
 >> <samth@cs.indiana.edu> wrote:
 >>> Do we treat them as inductive in any place other than generating `list?`?
 >> Yes everywhere along the R/TR boundary in the base environment. (We
 >> assume (Listof A) corresponds to (listof a?), otherwise typed programs
 >> can provide cyclic values to functions not expecting them).
 >> The filter of 'list?'. This is likely a soundness hole, I'm working on
 >> an example.
 >>
 >>>
 >>> Sam
 >>>
 >>> On Thu, Jun 12, 2014 at 11:25 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> Exactly. I'm saying that we already treat the definitions as inductive.
 >>>>
 >>>> Otherwise C = (U #f (Cons Number C)) is different from C = (U Null
 >>>> (Cons Number C)), in ways other than checking the base case.
 >>>>
 >>>> On Thu, Jun 12, 2014 at 8:18 AM, Matthias Felleisen
 >>>> <matthias@ccs.neu.edu> wrote:
 >>>>>
 >>>>> On Jun 12, 2014, at 11:16 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>
 >>>>>> A list of numbers (C) is either
 >>>>>> Null or (Cons Number C)
 >>>>>>
 >>>>>> Should cyclic data structures be allowed by this definition, or should
 >>>>>> this definition correspond to list?. Currently TR assumes that it
 >>>>>> corresponds to list?.
 >>>>>>
 >>>>>> To be consistent with that we have to assume inductive instead of co-inductive.
 >>>>>
 >>>>>
 >>>>>
 >>>>> The meaning of these words was settled before I was born (literally).
 >>>>> It is always understood to be the inductive (smallest fixpoint).
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>> On Thu, Jun 12, 2014 at 7:51 AM, Sam Tobin-Hochstadt
 >>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>> On Thu, Jun 12, 2014 at 10:44 AM, Matthias Felleisen
 >>>>>>> <matthias@ccs.neu.edu> wrote:
 >>>>>>>>
 >>>>>>>> On Jun 12, 2014, at 10:38 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>>>>>>
 >>>>>>>>>>> Fortunately or unfortunately, this isn't the distinction that Racket's
 >>>>>>>>>>> semantics makes, and so I think TR and the contract system should both
 >>>>>>>>>>> follow Racket.
 >>>>>>>>>>
 >>>>>>>>>> That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them.
 >>>>>>>>>
 >>>>>>>>> Of course -- we get to design the type system. But the most important
 >>>>>>>>> constraint on the type system, in my view, is that it corresponds to
 >>>>>>>>> the semantics Racket programs already have. And in Racket, data
 >>>>>>>>> structures built with `cons` can have cycles.
 >>>>>>>>
 >>>>>>>>
 >>>>>>>> Do you want a sound type system?
 >>>>>>>
 >>>>>>> Yes, of course.
 >>>>>>>
 >>>>>>>> Do you know whether co-inductive denotations are sound?
 >>>>>>>
 >>>>>>> I don't see why we should think about this any differently than
 >>>>>>> vectors or mutable pairs (which were also fixed in the same way by
 >>>>>>> Robby's changes).
 >>>>>>>
 >>>>>>>> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 >>>>>>>
 >>>>>>> Of course, if there's a soundness problem here, I want to fix it. But
 >>>>>>> if you want to rule out cyclic pairs in TR, that would be a much
 >>>>>>> bigger change.  Consider this program:
 >>>>>>>
 >>>>>>> (: f (-> Any Integer))
 >>>>>>> (define (f x)
 >>>>>>>  (match x
 >>>>>>>   [(cons a b) (f a)]
 >>>>>>>   [_ 0]))
 >>>>>>>
 >>>>>>> Does it terminate on all inputs?
 >>>>>>>
 >>>>>>> Sam
 >>>>>
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 09:19:51 -0700

 Correct. Which is why I'm arguing for an inductive interpretation, and
 have the contract fail on such values.
 
 TR can still see cyclic values through an Any contract. But I don't
 see any soundness holes with that.
 
 
 On Thu, Jun 12, 2014 at 9:09 AM, Sam Tobin-Hochstadt
 <samth@cs.indiana.edu> wrote:
 > This is only with Robby's new change, right?  Previously, that
 > contract would have looped.
 >
 > Sam
 >
 > On Thu, Jun 12, 2014 at 11:55 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> Example program that when optimized returns #t and non optimized returns #f.
 >>
 >> #lang racket/load
 >>
 >> (module tr typed/racket ;#:no-optimize
 >>   (provide f)
 >>   (define-type C (Pair Number (Pair Number C)))
 >>   (: f (C -> #t))
 >>   (define (f x) (if (list? (ann x (Listof Number))) #t #f)))
 >>
 >> (require 'tr)
 >> (displayln (f (shared ([x (cons 1 x)]) x)))
 >>
 >> On Thu, Jun 12, 2014 at 8:47 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>> On Thu, Jun 12, 2014 at 8:38 AM, Sam Tobin-Hochstadt
 >>> <samth@cs.indiana.edu> wrote:
 >>>> Do we treat them as inductive in any place other than generating `list?`?
 >>> Yes everywhere along the R/TR boundary in the base environment. (We
 >>> assume (Listof A) corresponds to (listof a?), otherwise typed programs
 >>> can provide cyclic values to functions not expecting them).
 >>> The filter of 'list?'. This is likely a soundness hole, I'm working on
 >>> an example.
 >>>
 >>>>
 >>>> Sam
 >>>>
 >>>> On Thu, Jun 12, 2014 at 11:25 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>> Exactly. I'm saying that we already treat the definitions as inductive.
 >>>>>
 >>>>> Otherwise C = (U #f (Cons Number C)) is different from C = (U Null
 >>>>> (Cons Number C)), in ways other than checking the base case.
 >>>>>
 >>>>> On Thu, Jun 12, 2014 at 8:18 AM, Matthias Felleisen
 >>>>> <matthias@ccs.neu.edu> wrote:
 >>>>>>
 >>>>>> On Jun 12, 2014, at 11:16 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>
 >>>>>>> A list of numbers (C) is either
 >>>>>>> Null or (Cons Number C)
 >>>>>>>
 >>>>>>> Should cyclic data structures be allowed by this definition, or should
 >>>>>>> this definition correspond to list?. Currently TR assumes that it
 >>>>>>> corresponds to list?.
 >>>>>>>
 >>>>>>> To be consistent with that we have to assume inductive instead of co-inductive.
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>> The meaning of these words was settled before I was born (literally).
 >>>>>> It is always understood to be the inductive (smallest fixpoint).
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>>>
 >>>>>>>
 >>>>>>>
 >>>>>>> On Thu, Jun 12, 2014 at 7:51 AM, Sam Tobin-Hochstadt
 >>>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>>> On Thu, Jun 12, 2014 at 10:44 AM, Matthias Felleisen
 >>>>>>>> <matthias@ccs.neu.edu> wrote:
 >>>>>>>>>
 >>>>>>>>> On Jun 12, 2014, at 10:38 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>>>>>>>
 >>>>>>>>>>>> Fortunately or unfortunately, this isn't the distinction that Racket's
 >>>>>>>>>>>> semantics makes, and so I think TR and the contract system should both
 >>>>>>>>>>>> follow Racket.
 >>>>>>>>>>>
 >>>>>>>>>>> That's not the point. We need to decide what we want types to denote, what guarantees we want to associate with them.
 >>>>>>>>>>
 >>>>>>>>>> Of course -- we get to design the type system. But the most important
 >>>>>>>>>> constraint on the type system, in my view, is that it corresponds to
 >>>>>>>>>> the semantics Racket programs already have. And in Racket, data
 >>>>>>>>>> structures built with `cons` can have cycles.
 >>>>>>>>>
 >>>>>>>>>
 >>>>>>>>> Do you want a sound type system?
 >>>>>>>>
 >>>>>>>> Yes, of course.
 >>>>>>>>
 >>>>>>>>> Do you know whether co-inductive denotations are sound?
 >>>>>>>>
 >>>>>>>> I don't see why we should think about this any differently than
 >>>>>>>> vectors or mutable pairs (which were also fixed in the same way by
 >>>>>>>> Robby's changes).
 >>>>>>>>
 >>>>>>>>> If they turn out not to be sound (with current methods), I would much prefer if TR simply said "sorry, this cannot be done yet".
 >>>>>>>>
 >>>>>>>> Of course, if there's a soundness problem here, I want to fix it. But
 >>>>>>>> if you want to rule out cyclic pairs in TR, that would be a much
 >>>>>>>> bigger change.  Consider this program:
 >>>>>>>>
 >>>>>>>> (: f (-> Any Integer))
 >>>>>>>> (define (f x)
 >>>>>>>>  (match x
 >>>>>>>>   [(cons a b) (f a)]
 >>>>>>>>   [_ 0]))
 >>>>>>>>
 >>>>>>>> Does it terminate on all inputs?
 >>>>>>>>
 >>>>>>>> Sam
 >>>>>>
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 12:37:51 -0400

 On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > Correct. Which is why I'm arguing for an inductive interpretation, and
 > have the contract fail on such values.
 >
 > TR can still see cyclic values through an Any contract. But I don't
 > see any soundness holes with that.
 
 Ok, let me try to summarize what we've figured out:
 
 1. TR has recursive types, which we currently give a least-fixed-point
 interpretation to. [1]
 
 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 `A` have a particular relation to `list?`.
 
 3. Giving a _greatest_ fixed point interpretation to TR recursive
 types would require changing (2).
 
 4. There's also a GFP lurking inside the definition of `Any`.
 
 5. The contract system previously looped on cyclic data, but is now
 giving `recursive-contract` a GFP interpretation.
 
 We have a few choices:
 
 A: GFP interpretation for TR types. This requires changing the type of
 `list?`, `andmap`, and possibly the type of other recursively-defined
 functions, including some user-defined ones (although I doubt it).
 
 B: LFP interpretation for TR types.  This means we need (at a minimum)
 a way of telling the contract system to reject cycles in
 `recursive-contract`.
 
 B leaves us without a way of describing the output of
 `make-reader-graph` except as `Any`. However, I think B is probably
 the right choice.
 
 [1] Note that some algorithms on these types require a GFP.
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 09:54:59 -0700

 I agree with that summarization, and also think that B is the right choice.
 
 On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 <samth@cs.indiana.edu> wrote:
 > On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> Correct. Which is why I'm arguing for an inductive interpretation, and
 >> have the contract fail on such values.
 >>
 >> TR can still see cyclic values through an Any contract. But I don't
 >> see any soundness holes with that.
 >
 > Ok, let me try to summarize what we've figured out:
 >
 > 1. TR has recursive types, which we currently give a least-fixed-point
 > interpretation to. [1]
 >
 > 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 > `A` have a particular relation to `list?`.
 >
 > 3. Giving a _greatest_ fixed point interpretation to TR recursive
 > types would require changing (2).
 >
 > 4. There's also a GFP lurking inside the definition of `Any`.
 >
 > 5. The contract system previously looped on cyclic data, but is now
 > giving `recursive-contract` a GFP interpretation.
 >
 > We have a few choices:
 >
 > A: GFP interpretation for TR types. This requires changing the type of
 > `list?`, `andmap`, and possibly the type of other recursively-defined
 > functions, including some user-defined ones (although I doubt it).
 >
 > B: LFP interpretation for TR types.  This means we need (at a minimum)
 > a way of telling the contract system to reject cycles in
 > `recursive-contract`.
 >
 > B leaves us without a way of describing the output of
 > `make-reader-graph` except as `Any`. However, I think B is probably
 > the right choice.
 >
 > [1] Note that some algorithms on these types require a GFP.

----------
A commit by robby@racket-lang.org was marked as relevant
  http://git.racket-lang.org/plt/commit/d664ee1430
  | change recursive-contract to reject cyclic values
  | 
  | For a few reasons:
  | 
  |  - this seems to fit better with how TR already works
  | 
  |  - cyclic values are something that, at least in my experience,
  |    abstractions are not generally equipped to handle (and,
  |    perhaps worse, don't seem all that useful when weighed against
  |    the non-termination problems that can come up)
  | 
  |  - there was a suspicious case in the projection where, when a
  |    cycle was detected the projection just returned its argument
  |    (the place in the diff for this commit where there is now a
  |    call to raise-blame-error). I couldn't get this to cause problems,
  |    but this might just be because I'm not smart enough
  | 
  | related to PR 14559

From: Robby Findler <robby@eecs.northwestern.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 12 Jun 2014 23:57:13 -0500

 I've pushed a change to recursive-contract following Eric's
 suggestion. If that's not what's needed, please let me know.
 
 If you can spare some mental cycles to argue why the projection should
 do nothing when it sees a cycle or can find a bug with that behavior,
 that'd also be most appreciated.
 
 Robby
 
 On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > I agree with that summarization, and also think that B is the right choice.
 >
 > On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 > <samth@cs.indiana.edu> wrote:
 >> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>> have the contract fail on such values.
 >>>
 >>> TR can still see cyclic values through an Any contract. But I don't
 >>> see any soundness holes with that.
 >>
 >> Ok, let me try to summarize what we've figured out:
 >>
 >> 1. TR has recursive types, which we currently give a least-fixed-point
 >> interpretation to. [1]
 >>
 >> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >> `A` have a particular relation to `list?`.
 >>
 >> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >> types would require changing (2).
 >>
 >> 4. There's also a GFP lurking inside the definition of `Any`.
 >>
 >> 5. The contract system previously looped on cyclic data, but is now
 >> giving `recursive-contract` a GFP interpretation.
 >>
 >> We have a few choices:
 >>
 >> A: GFP interpretation for TR types. This requires changing the type of
 >> `list?`, `andmap`, and possibly the type of other recursively-defined
 >> functions, including some user-defined ones (although I doubt it).
 >>
 >> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >> a way of telling the contract system to reject cycles in
 >> `recursive-contract`.
 >>
 >> B leaves us without a way of describing the output of
 >> `make-reader-graph` except as `Any`. However, I think B is probably
 >> the right choice.
 >>
 >> [1] Note that some algorithms on these types require a GFP.
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 05:38:43 -0500

 Actually, what I pushed doesn't/can't work. At least, I'm not sure
 where to store the path information that would need to be checked to
 determine if a cycle has happened.
 
 This is a place, however, where the contract system wasn't looping
 before, even tho there was cyclic data. Here's an example:
 
 #lang racket/base
 (require racket/contract/base)
 
 (struct s (x) #:mutable)
 (define an-s (s #f))
 (set-s-x! an-s an-s)
 
 (define c
   (recursive-contract
    (struct/c s c)))
 
 (s-x (s-x (contract c an-s 'pos 'neg)))
 
 What behavior would help TR here?
 
 Robby
 
 
 
 On Thu, Jun 12, 2014 at 11:57 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > I've pushed a change to recursive-contract following Eric's
 > suggestion. If that's not what's needed, please let me know.
 >
 > If you can spare some mental cycles to argue why the projection should
 > do nothing when it sees a cycle or can find a bug with that behavior,
 > that'd also be most appreciated.
 >
 > Robby
 >
 > On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> I agree with that summarization, and also think that B is the right choice.
 >>
 >> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >> <samth@cs.indiana.edu> wrote:
 >>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>> have the contract fail on such values.
 >>>>
 >>>> TR can still see cyclic values through an Any contract. But I don't
 >>>> see any soundness holes with that.
 >>>
 >>> Ok, let me try to summarize what we've figured out:
 >>>
 >>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>> interpretation to. [1]
 >>>
 >>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>> `A` have a particular relation to `list?`.
 >>>
 >>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>> types would require changing (2).
 >>>
 >>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>
 >>> 5. The contract system previously looped on cyclic data, but is now
 >>> giving `recursive-contract` a GFP interpretation.
 >>>
 >>> We have a few choices:
 >>>
 >>> A: GFP interpretation for TR types. This requires changing the type of
 >>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>> functions, including some user-defined ones (although I doubt it).
 >>>
 >>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>> a way of telling the contract system to reject cycles in
 >>> `recursive-contract`.
 >>>
 >>> B leaves us without a way of describing the output of
 >>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>> the right choice.
 >>>
 >>> [1] Note that some algorithms on these types require a GFP.
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 08:38:11 -0400

 The problem for TR is mostly about lists, rather than about cyclic
 data in general. Typed Racket assumes that types like:
 
      (Rec T (U Null (Pair Number T)))
 
 are related to contracts like:
 
     (letrec ([t (recursive-contract (or/c null (cons/c number? t)))]) t)
 
 but also to:
 
     (listof number?)
 
 and to:
 
    (andmap number? l)
 
 More generally, Racket has a bunch of functions on "lists", which are
 defined not to be cyclic. I believe that Racket programmers use
 specifications like the type I gave above (which is just the
 definition of `(Listof Number)`) and expect them to correspond to what
 we mean by "lists". I don't think there are other data structures
 where this is an issue [1].
 
 So your example isn't problematic for TR, but Eric's original example is.
 
 [1] There's also syntax objects, but those are much weirder and don't
 play that well with types in a lot of other ways too.
 
 On Fri, Jun 13, 2014 at 6:38 AM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > Actually, what I pushed doesn't/can't work. At least, I'm not sure
 > where to store the path information that would need to be checked to
 > determine if a cycle has happened.
 >
 > This is a place, however, where the contract system wasn't looping
 > before, even tho there was cyclic data. Here's an example:
 >
 > #lang racket/base
 > (require racket/contract/base)
 >
 > (struct s (x) #:mutable)
 > (define an-s (s #f))
 > (set-s-x! an-s an-s)
 >
 > (define c
 >   (recursive-contract
 >    (struct/c s c)))
 >
 > (s-x (s-x (contract c an-s 'pos 'neg)))
 >
 > What behavior would help TR here?
 >
 > Robby
 >
 >
 >
 > On Thu, Jun 12, 2014 at 11:57 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> I've pushed a change to recursive-contract following Eric's
 >> suggestion. If that's not what's needed, please let me know.
 >>
 >> If you can spare some mental cycles to argue why the projection should
 >> do nothing when it sees a cycle or can find a bug with that behavior,
 >> that'd also be most appreciated.
 >>
 >> Robby
 >>
 >> On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>> I agree with that summarization, and also think that B is the right choice.
 >>>
 >>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>> <samth@cs.indiana.edu> wrote:
 >>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>> have the contract fail on such values.
 >>>>>
 >>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>> see any soundness holes with that.
 >>>>
 >>>> Ok, let me try to summarize what we've figured out:
 >>>>
 >>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>> interpretation to. [1]
 >>>>
 >>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>> `A` have a particular relation to `list?`.
 >>>>
 >>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>> types would require changing (2).
 >>>>
 >>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>
 >>>> 5. The contract system previously looped on cyclic data, but is now
 >>>> giving `recursive-contract` a GFP interpretation.
 >>>>
 >>>> We have a few choices:
 >>>>
 >>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>> functions, including some user-defined ones (although I doubt it).
 >>>>
 >>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>> a way of telling the contract system to reject cycles in
 >>>> `recursive-contract`.
 >>>>
 >>>> B leaves us without a way of describing the output of
 >>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>> the right choice.
 >>>>
 >>>> [1] Note that some algorithms on these types require a GFP.
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 07:48:18 -0500

 So, I guess it would be okay if only flat contacts did the no-cycle
 checking?  And otherwise recursive-contract behaves like it did in
 6.0?
 
 Robby
 
 On Fri, Jun 13, 2014 at 7:38 AM, Sam Tobin-Hochstadt
 <samth@cs.indiana.edu> wrote:
 > The problem for TR is mostly about lists, rather than about cyclic
 > data in general. Typed Racket assumes that types like:
 >
 >      (Rec T (U Null (Pair Number T)))
 >
 > are related to contracts like:
 >
 >     (letrec ([t (recursive-contract (or/c null (cons/c number? t)))]) t)
 >
 > but also to:
 >
 >     (listof number?)
 >
 > and to:
 >
 >    (andmap number? l)
 >
 > More generally, Racket has a bunch of functions on "lists", which are
 > defined not to be cyclic. I believe that Racket programmers use
 > specifications like the type I gave above (which is just the
 > definition of `(Listof Number)`) and expect them to correspond to what
 > we mean by "lists". I don't think there are other data structures
 > where this is an issue [1].
 >
 > So your example isn't problematic for TR, but Eric's original example is.
 >
 > [1] There's also syntax objects, but those are much weirder and don't
 > play that well with types in a lot of other ways too.
 >
 > On Fri, Jun 13, 2014 at 6:38 AM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> Actually, what I pushed doesn't/can't work. At least, I'm not sure
 >> where to store the path information that would need to be checked to
 >> determine if a cycle has happened.
 >>
 >> This is a place, however, where the contract system wasn't looping
 >> before, even tho there was cyclic data. Here's an example:
 >>
 >> #lang racket/base
 >> (require racket/contract/base)
 >>
 >> (struct s (x) #:mutable)
 >> (define an-s (s #f))
 >> (set-s-x! an-s an-s)
 >>
 >> (define c
 >>   (recursive-contract
 >>    (struct/c s c)))
 >>
 >> (s-x (s-x (contract c an-s 'pos 'neg)))
 >>
 >> What behavior would help TR here?
 >>
 >> Robby
 >>
 >>
 >>
 >> On Thu, Jun 12, 2014 at 11:57 PM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >>> I've pushed a change to recursive-contract following Eric's
 >>> suggestion. If that's not what's needed, please let me know.
 >>>
 >>> If you can spare some mental cycles to argue why the projection should
 >>> do nothing when it sees a cycle or can find a bug with that behavior,
 >>> that'd also be most appreciated.
 >>>
 >>> Robby
 >>>
 >>> On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> I agree with that summarization, and also think that B is the right choice.
 >>>>
 >>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>> <samth@cs.indiana.edu> wrote:
 >>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>> have the contract fail on such values.
 >>>>>>
 >>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>> see any soundness holes with that.
 >>>>>
 >>>>> Ok, let me try to summarize what we've figured out:
 >>>>>
 >>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>> interpretation to. [1]
 >>>>>
 >>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>> `A` have a particular relation to `list?`.
 >>>>>
 >>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>> types would require changing (2).
 >>>>>
 >>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>
 >>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>
 >>>>> We have a few choices:
 >>>>>
 >>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>
 >>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>> a way of telling the contract system to reject cycles in
 >>>>> `recursive-contract`.
 >>>>>
 >>>>> B leaves us without a way of describing the output of
 >>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>> the right choice.
 >>>>>
 >>>>> [1] Note that some algorithms on these types require a GFP.
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 08:53:43 -0400

 I don't know if that works, because the _contents_ of the list could
 require non-flat contracts.
 
 Sam
 
 On Fri, Jun 13, 2014 at 8:48 AM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > So, I guess it would be okay if only flat contacts did the no-cycle
 > checking?  And otherwise recursive-contract behaves like it did in
 > 6.0?
 >
 > Robby
 >
 > On Fri, Jun 13, 2014 at 7:38 AM, Sam Tobin-Hochstadt
 > <samth@cs.indiana.edu> wrote:
 >> The problem for TR is mostly about lists, rather than about cyclic
 >> data in general. Typed Racket assumes that types like:
 >>
 >>      (Rec T (U Null (Pair Number T)))
 >>
 >> are related to contracts like:
 >>
 >>     (letrec ([t (recursive-contract (or/c null (cons/c number? t)))]) t)
 >>
 >> but also to:
 >>
 >>     (listof number?)
 >>
 >> and to:
 >>
 >>    (andmap number? l)
 >>
 >> More generally, Racket has a bunch of functions on "lists", which are
 >> defined not to be cyclic. I believe that Racket programmers use
 >> specifications like the type I gave above (which is just the
 >> definition of `(Listof Number)`) and expect them to correspond to what
 >> we mean by "lists". I don't think there are other data structures
 >> where this is an issue [1].
 >>
 >> So your example isn't problematic for TR, but Eric's original example is.
 >>
 >> [1] There's also syntax objects, but those are much weirder and don't
 >> play that well with types in a lot of other ways too.
 >>
 >> On Fri, Jun 13, 2014 at 6:38 AM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >>> Actually, what I pushed doesn't/can't work. At least, I'm not sure
 >>> where to store the path information that would need to be checked to
 >>> determine if a cycle has happened.
 >>>
 >>> This is a place, however, where the contract system wasn't looping
 >>> before, even tho there was cyclic data. Here's an example:
 >>>
 >>> #lang racket/base
 >>> (require racket/contract/base)
 >>>
 >>> (struct s (x) #:mutable)
 >>> (define an-s (s #f))
 >>> (set-s-x! an-s an-s)
 >>>
 >>> (define c
 >>>   (recursive-contract
 >>>    (struct/c s c)))
 >>>
 >>> (s-x (s-x (contract c an-s 'pos 'neg)))
 >>>
 >>> What behavior would help TR here?
 >>>
 >>> Robby
 >>>
 >>>
 >>>
 >>> On Thu, Jun 12, 2014 at 11:57 PM, Robby Findler
 >>> <robby@eecs.northwestern.edu> wrote:
 >>>> I've pushed a change to recursive-contract following Eric's
 >>>> suggestion. If that's not what's needed, please let me know.
 >>>>
 >>>> If you can spare some mental cycles to argue why the projection should
 >>>> do nothing when it sees a cycle or can find a bug with that behavior,
 >>>> that'd also be most appreciated.
 >>>>
 >>>> Robby
 >>>>
 >>>> On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>> I agree with that summarization, and also think that B is the right choice.
 >>>>>
 >>>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>>> <samth@cs.indiana.edu> wrote:
 >>>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>>> have the contract fail on such values.
 >>>>>>>
 >>>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>>> see any soundness holes with that.
 >>>>>>
 >>>>>> Ok, let me try to summarize what we've figured out:
 >>>>>>
 >>>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>>> interpretation to. [1]
 >>>>>>
 >>>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>>> `A` have a particular relation to `list?`.
 >>>>>>
 >>>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>>> types would require changing (2).
 >>>>>>
 >>>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>>
 >>>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>>
 >>>>>> We have a few choices:
 >>>>>>
 >>>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>>
 >>>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>>> a way of telling the contract system to reject cycles in
 >>>>>> `recursive-contract`.
 >>>>>>
 >>>>>> B leaves us without a way of describing the output of
 >>>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>>> the right choice.
 >>>>>>
 >>>>>> [1] Note that some algorithms on these types require a GFP.
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 08:21:55 -0500

 Oh-- and then to ask "is that helpful"?
 
 Robby
 
 On Fri, Jun 13, 2014 at 8:21 AM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > Well, I guess what I'm saying is that I understand how to add an
 > option to recursive-contract so that it fails where it currently loops
 > and I believe that is on flat recursive contacts when given cyclic
 > values.
 >
 > Robby
 >
 > On Fri, Jun 13, 2014 at 7:53 AM, Sam Tobin-Hochstadt
 > <samth@cs.indiana.edu> wrote:
 >> I don't know if that works, because the _contents_ of the list could
 >> require non-flat contracts.
 >>
 >> Sam
 >>
 >> On Fri, Jun 13, 2014 at 8:48 AM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >>> So, I guess it would be okay if only flat contacts did the no-cycle
 >>> checking?  And otherwise recursive-contract behaves like it did in
 >>> 6.0?
 >>>
 >>> Robby
 >>>
 >>> On Fri, Jun 13, 2014 at 7:38 AM, Sam Tobin-Hochstadt
 >>> <samth@cs.indiana.edu> wrote:
 >>>> The problem for TR is mostly about lists, rather than about cyclic
 >>>> data in general. Typed Racket assumes that types like:
 >>>>
 >>>>      (Rec T (U Null (Pair Number T)))
 >>>>
 >>>> are related to contracts like:
 >>>>
 >>>>     (letrec ([t (recursive-contract (or/c null (cons/c number? t)))]) t)
 >>>>
 >>>> but also to:
 >>>>
 >>>>     (listof number?)
 >>>>
 >>>> and to:
 >>>>
 >>>>    (andmap number? l)
 >>>>
 >>>> More generally, Racket has a bunch of functions on "lists", which are
 >>>> defined not to be cyclic. I believe that Racket programmers use
 >>>> specifications like the type I gave above (which is just the
 >>>> definition of `(Listof Number)`) and expect them to correspond to what
 >>>> we mean by "lists". I don't think there are other data structures
 >>>> where this is an issue [1].
 >>>>
 >>>> So your example isn't problematic for TR, but Eric's original example is.
 >>>>
 >>>> [1] There's also syntax objects, but those are much weirder and don't
 >>>> play that well with types in a lot of other ways too.
 >>>>
 >>>> On Fri, Jun 13, 2014 at 6:38 AM, Robby Findler
 >>>> <robby@eecs.northwestern.edu> wrote:
 >>>>> Actually, what I pushed doesn't/can't work. At least, I'm not sure
 >>>>> where to store the path information that would need to be checked to
 >>>>> determine if a cycle has happened.
 >>>>>
 >>>>> This is a place, however, where the contract system wasn't looping
 >>>>> before, even tho there was cyclic data. Here's an example:
 >>>>>
 >>>>> #lang racket/base
 >>>>> (require racket/contract/base)
 >>>>>
 >>>>> (struct s (x) #:mutable)
 >>>>> (define an-s (s #f))
 >>>>> (set-s-x! an-s an-s)
 >>>>>
 >>>>> (define c
 >>>>>   (recursive-contract
 >>>>>    (struct/c s c)))
 >>>>>
 >>>>> (s-x (s-x (contract c an-s 'pos 'neg)))
 >>>>>
 >>>>> What behavior would help TR here?
 >>>>>
 >>>>> Robby
 >>>>>
 >>>>>
 >>>>>
 >>>>> On Thu, Jun 12, 2014 at 11:57 PM, Robby Findler
 >>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>> I've pushed a change to recursive-contract following Eric's
 >>>>>> suggestion. If that's not what's needed, please let me know.
 >>>>>>
 >>>>>> If you can spare some mental cycles to argue why the projection should
 >>>>>> do nothing when it sees a cycle or can find a bug with that behavior,
 >>>>>> that'd also be most appreciated.
 >>>>>>
 >>>>>> Robby
 >>>>>>
 >>>>>> On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>> I agree with that summarization, and also think that B is the right choice.
 >>>>>>>
 >>>>>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>>>>> have the contract fail on such values.
 >>>>>>>>>
 >>>>>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>>>>> see any soundness holes with that.
 >>>>>>>>
 >>>>>>>> Ok, let me try to summarize what we've figured out:
 >>>>>>>>
 >>>>>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>>>>> interpretation to. [1]
 >>>>>>>>
 >>>>>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>>>>> `A` have a particular relation to `list?`.
 >>>>>>>>
 >>>>>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>>>>> types would require changing (2).
 >>>>>>>>
 >>>>>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>>>>
 >>>>>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>>>>
 >>>>>>>> We have a few choices:
 >>>>>>>>
 >>>>>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>>>>
 >>>>>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>>>>> a way of telling the contract system to reject cycles in
 >>>>>>>> `recursive-contract`.
 >>>>>>>>
 >>>>>>>> B leaves us without a way of describing the output of
 >>>>>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>>>>> the right choice.
 >>>>>>>>
 >>>>>>>> [1] Note that some algorithms on these types require a GFP.
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 08:21:43 -0500

 Well, I guess what I'm saying is that I understand how to add an
 option to recursive-contract so that it fails where it currently loops
 and I believe that is on flat recursive contacts when given cyclic
 values.
 
 Robby
 
 On Fri, Jun 13, 2014 at 7:53 AM, Sam Tobin-Hochstadt
 <samth@cs.indiana.edu> wrote:
 > I don't know if that works, because the _contents_ of the list could
 > require non-flat contracts.
 >
 > Sam
 >
 > On Fri, Jun 13, 2014 at 8:48 AM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> So, I guess it would be okay if only flat contacts did the no-cycle
 >> checking?  And otherwise recursive-contract behaves like it did in
 >> 6.0?
 >>
 >> Robby
 >>
 >> On Fri, Jun 13, 2014 at 7:38 AM, Sam Tobin-Hochstadt
 >> <samth@cs.indiana.edu> wrote:
 >>> The problem for TR is mostly about lists, rather than about cyclic
 >>> data in general. Typed Racket assumes that types like:
 >>>
 >>>      (Rec T (U Null (Pair Number T)))
 >>>
 >>> are related to contracts like:
 >>>
 >>>     (letrec ([t (recursive-contract (or/c null (cons/c number? t)))]) t)
 >>>
 >>> but also to:
 >>>
 >>>     (listof number?)
 >>>
 >>> and to:
 >>>
 >>>    (andmap number? l)
 >>>
 >>> More generally, Racket has a bunch of functions on "lists", which are
 >>> defined not to be cyclic. I believe that Racket programmers use
 >>> specifications like the type I gave above (which is just the
 >>> definition of `(Listof Number)`) and expect them to correspond to what
 >>> we mean by "lists". I don't think there are other data structures
 >>> where this is an issue [1].
 >>>
 >>> So your example isn't problematic for TR, but Eric's original example is.
 >>>
 >>> [1] There's also syntax objects, but those are much weirder and don't
 >>> play that well with types in a lot of other ways too.
 >>>
 >>> On Fri, Jun 13, 2014 at 6:38 AM, Robby Findler
 >>> <robby@eecs.northwestern.edu> wrote:
 >>>> Actually, what I pushed doesn't/can't work. At least, I'm not sure
 >>>> where to store the path information that would need to be checked to
 >>>> determine if a cycle has happened.
 >>>>
 >>>> This is a place, however, where the contract system wasn't looping
 >>>> before, even tho there was cyclic data. Here's an example:
 >>>>
 >>>> #lang racket/base
 >>>> (require racket/contract/base)
 >>>>
 >>>> (struct s (x) #:mutable)
 >>>> (define an-s (s #f))
 >>>> (set-s-x! an-s an-s)
 >>>>
 >>>> (define c
 >>>>   (recursive-contract
 >>>>    (struct/c s c)))
 >>>>
 >>>> (s-x (s-x (contract c an-s 'pos 'neg)))
 >>>>
 >>>> What behavior would help TR here?
 >>>>
 >>>> Robby
 >>>>
 >>>>
 >>>>
 >>>> On Thu, Jun 12, 2014 at 11:57 PM, Robby Findler
 >>>> <robby@eecs.northwestern.edu> wrote:
 >>>>> I've pushed a change to recursive-contract following Eric's
 >>>>> suggestion. If that's not what's needed, please let me know.
 >>>>>
 >>>>> If you can spare some mental cycles to argue why the projection should
 >>>>> do nothing when it sees a cycle or can find a bug with that behavior,
 >>>>> that'd also be most appreciated.
 >>>>>
 >>>>> Robby
 >>>>>
 >>>>> On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>> I agree with that summarization, and also think that B is the right choice.
 >>>>>>
 >>>>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>>>> have the contract fail on such values.
 >>>>>>>>
 >>>>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>>>> see any soundness holes with that.
 >>>>>>>
 >>>>>>> Ok, let me try to summarize what we've figured out:
 >>>>>>>
 >>>>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>>>> interpretation to. [1]
 >>>>>>>
 >>>>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>>>> `A` have a particular relation to `list?`.
 >>>>>>>
 >>>>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>>>> types would require changing (2).
 >>>>>>>
 >>>>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>>>
 >>>>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>>>
 >>>>>>> We have a few choices:
 >>>>>>>
 >>>>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>>>
 >>>>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>>>> a way of telling the contract system to reject cycles in
 >>>>>>> `recursive-contract`.
 >>>>>>>
 >>>>>>> B leaves us without a way of describing the output of
 >>>>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>>>> the right choice.
 >>>>>>>
 >>>>>>> [1] Note that some algorithms on these types require a GFP.
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 09:46:12 -0400

 What would the option do for this program:
 
 (letrec ([t (recursive-contract (or/c null? (cons/c (vectorof integer?) t)))])
   (contract t (shared ([x (cons (vector 1) x)]) x) 'a 'b))
 
 In other words, does it require flatness in the contents of the
 recursive contract, or just in the recursive part?
 
 Sam
 
 On Fri, Jun 13, 2014 at 9:21 AM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > Oh-- and then to ask "is that helpful"?
 >
 > Robby
 >
 > On Fri, Jun 13, 2014 at 8:21 AM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> Well, I guess what I'm saying is that I understand how to add an
 >> option to recursive-contract so that it fails where it currently loops
 >> and I believe that is on flat recursive contacts when given cyclic
 >> values.
 >>
 >> Robby
 >>
 >> On Fri, Jun 13, 2014 at 7:53 AM, Sam Tobin-Hochstadt
 >> <samth@cs.indiana.edu> wrote:
 >>> I don't know if that works, because the _contents_ of the list could
 >>> require non-flat contracts.
 >>>
 >>> Sam
 >>>
 >>> On Fri, Jun 13, 2014 at 8:48 AM, Robby Findler
 >>> <robby@eecs.northwestern.edu> wrote:
 >>>> So, I guess it would be okay if only flat contacts did the no-cycle
 >>>> checking?  And otherwise recursive-contract behaves like it did in
 >>>> 6.0?
 >>>>
 >>>> Robby
 >>>>
 >>>> On Fri, Jun 13, 2014 at 7:38 AM, Sam Tobin-Hochstadt
 >>>> <samth@cs.indiana.edu> wrote:
 >>>>> The problem for TR is mostly about lists, rather than about cyclic
 >>>>> data in general. Typed Racket assumes that types like:
 >>>>>
 >>>>>      (Rec T (U Null (Pair Number T)))
 >>>>>
 >>>>> are related to contracts like:
 >>>>>
 >>>>>     (letrec ([t (recursive-contract (or/c null (cons/c number? t)))]) t)
 >>>>>
 >>>>> but also to:
 >>>>>
 >>>>>     (listof number?)
 >>>>>
 >>>>> and to:
 >>>>>
 >>>>>    (andmap number? l)
 >>>>>
 >>>>> More generally, Racket has a bunch of functions on "lists", which are
 >>>>> defined not to be cyclic. I believe that Racket programmers use
 >>>>> specifications like the type I gave above (which is just the
 >>>>> definition of `(Listof Number)`) and expect them to correspond to what
 >>>>> we mean by "lists". I don't think there are other data structures
 >>>>> where this is an issue [1].
 >>>>>
 >>>>> So your example isn't problematic for TR, but Eric's original example is.
 >>>>>
 >>>>> [1] There's also syntax objects, but those are much weirder and don't
 >>>>> play that well with types in a lot of other ways too.
 >>>>>
 >>>>> On Fri, Jun 13, 2014 at 6:38 AM, Robby Findler
 >>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>> Actually, what I pushed doesn't/can't work. At least, I'm not sure
 >>>>>> where to store the path information that would need to be checked to
 >>>>>> determine if a cycle has happened.
 >>>>>>
 >>>>>> This is a place, however, where the contract system wasn't looping
 >>>>>> before, even tho there was cyclic data. Here's an example:
 >>>>>>
 >>>>>> #lang racket/base
 >>>>>> (require racket/contract/base)
 >>>>>>
 >>>>>> (struct s (x) #:mutable)
 >>>>>> (define an-s (s #f))
 >>>>>> (set-s-x! an-s an-s)
 >>>>>>
 >>>>>> (define c
 >>>>>>   (recursive-contract
 >>>>>>    (struct/c s c)))
 >>>>>>
 >>>>>> (s-x (s-x (contract c an-s 'pos 'neg)))
 >>>>>>
 >>>>>> What behavior would help TR here?
 >>>>>>
 >>>>>> Robby
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>> On Thu, Jun 12, 2014 at 11:57 PM, Robby Findler
 >>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>> I've pushed a change to recursive-contract following Eric's
 >>>>>>> suggestion. If that's not what's needed, please let me know.
 >>>>>>>
 >>>>>>> If you can spare some mental cycles to argue why the projection should
 >>>>>>> do nothing when it sees a cycle or can find a bug with that behavior,
 >>>>>>> that'd also be most appreciated.
 >>>>>>>
 >>>>>>> Robby
 >>>>>>>
 >>>>>>> On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>> I agree with that summarization, and also think that B is the right choice.
 >>>>>>>>
 >>>>>>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>>>>>> have the contract fail on such values.
 >>>>>>>>>>
 >>>>>>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>>>>>> see any soundness holes with that.
 >>>>>>>>>
 >>>>>>>>> Ok, let me try to summarize what we've figured out:
 >>>>>>>>>
 >>>>>>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>>>>>> interpretation to. [1]
 >>>>>>>>>
 >>>>>>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>>>>>> `A` have a particular relation to `list?`.
 >>>>>>>>>
 >>>>>>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>>>>>> types would require changing (2).
 >>>>>>>>>
 >>>>>>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>>>>>
 >>>>>>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>>>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>>>>>
 >>>>>>>>> We have a few choices:
 >>>>>>>>>
 >>>>>>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>>>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>>>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>>>>>
 >>>>>>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>>>>>> a way of telling the contract system to reject cycles in
 >>>>>>>>> `recursive-contract`.
 >>>>>>>>>
 >>>>>>>>> B leaves us without a way of describing the output of
 >>>>>>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>>>>>> the right choice.
 >>>>>>>>>
 >>>>>>>>> [1] Note that some algorithms on these types require a GFP.
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Fri, 13 Jun 2014 10:26:58 -0400

 I'd prefer to have a uniform interpretation of contracts 
 for non-mutable potentially infinite (rational) data. I 
 just sense that unsoundness may lurk in other corners too
 ___and___ that adding co-inductive type constructions separately
 is the right way to go. 
 
 ;; --- 
 
 I still think we should check OCAML for this issue. 
 They have a minor form of 'share'. I won't find time
 before the final is over. 
 
 -- Matthias
 
 
 
 
 
 
 On Jun 13, 2014, at 9:46 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > What would the option do for this program:
 > 
 > (letrec ([t (recursive-contract (or/c null? (cons/c (vectorof integer?) t)))])
 >  (contract t (shared ([x (cons (vector 1) x)]) x) 'a 'b))
 > 
 > In other words, does it require flatness in the contents of the
 > recursive contract, or just in the recursive part?
 > 
 > Sam
 > 
 > On Fri, Jun 13, 2014 at 9:21 AM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> Oh-- and then to ask "is that helpful"?
 >> 
 >> Robby
 >> 
 >> On Fri, Jun 13, 2014 at 8:21 AM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >>> Well, I guess what I'm saying is that I understand how to add an
 >>> option to recursive-contract so that it fails where it currently loops
 >>> and I believe that is on flat recursive contacts when given cyclic
 >>> values.
 >>> 
 >>> Robby
 >>> 
 >>> On Fri, Jun 13, 2014 at 7:53 AM, Sam Tobin-Hochstadt
 >>> <samth@cs.indiana.edu> wrote:
 >>>> I don't know if that works, because the _contents_ of the list could
 >>>> require non-flat contracts.
 >>>> 
 >>>> Sam
 >>>> 
 >>>> On Fri, Jun 13, 2014 at 8:48 AM, Robby Findler
 >>>> <robby@eecs.northwestern.edu> wrote:
 >>>>> So, I guess it would be okay if only flat contacts did the no-cycle
 >>>>> checking?  And otherwise recursive-contract behaves like it did in
 >>>>> 6.0?
 >>>>> 
 >>>>> Robby
 >>>>> 
 >>>>> On Fri, Jun 13, 2014 at 7:38 AM, Sam Tobin-Hochstadt
 >>>>> <samth@cs.indiana.edu> wrote:
 >>>>>> The problem for TR is mostly about lists, rather than about cyclic
 >>>>>> data in general. Typed Racket assumes that types like:
 >>>>>> 
 >>>>>>     (Rec T (U Null (Pair Number T)))
 >>>>>> 
 >>>>>> are related to contracts like:
 >>>>>> 
 >>>>>>    (letrec ([t (recursive-contract (or/c null (cons/c number? t)))]) t)
 >>>>>> 
 >>>>>> but also to:
 >>>>>> 
 >>>>>>    (listof number?)
 >>>>>> 
 >>>>>> and to:
 >>>>>> 
 >>>>>>   (andmap number? l)
 >>>>>> 
 >>>>>> More generally, Racket has a bunch of functions on "lists", which are
 >>>>>> defined not to be cyclic. I believe that Racket programmers use
 >>>>>> specifications like the type I gave above (which is just the
 >>>>>> definition of `(Listof Number)`) and expect them to correspond to what
 >>>>>> we mean by "lists". I don't think there are other data structures
 >>>>>> where this is an issue [1].
 >>>>>> 
 >>>>>> So your example isn't problematic for TR, but Eric's original example is.
 >>>>>> 
 >>>>>> [1] There's also syntax objects, but those are much weirder and don't
 >>>>>> play that well with types in a lot of other ways too.
 >>>>>> 
 >>>>>> On Fri, Jun 13, 2014 at 6:38 AM, Robby Findler
 >>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>> Actually, what I pushed doesn't/can't work. At least, I'm not sure
 >>>>>>> where to store the path information that would need to be checked to
 >>>>>>> determine if a cycle has happened.
 >>>>>>> 
 >>>>>>> This is a place, however, where the contract system wasn't looping
 >>>>>>> before, even tho there was cyclic data. Here's an example:
 >>>>>>> 
 >>>>>>> #lang racket/base
 >>>>>>> (require racket/contract/base)
 >>>>>>> 
 >>>>>>> (struct s (x) #:mutable)
 >>>>>>> (define an-s (s #f))
 >>>>>>> (set-s-x! an-s an-s)
 >>>>>>> 
 >>>>>>> (define c
 >>>>>>>  (recursive-contract
 >>>>>>>   (struct/c s c)))
 >>>>>>> 
 >>>>>>> (s-x (s-x (contract c an-s 'pos 'neg)))
 >>>>>>> 
 >>>>>>> What behavior would help TR here?
 >>>>>>> 
 >>>>>>> Robby
 >>>>>>> 
 >>>>>>> 
 >>>>>>> 
 >>>>>>> On Thu, Jun 12, 2014 at 11:57 PM, Robby Findler
 >>>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>>> I've pushed a change to recursive-contract following Eric's
 >>>>>>>> suggestion. If that's not what's needed, please let me know.
 >>>>>>>> 
 >>>>>>>> If you can spare some mental cycles to argue why the projection should
 >>>>>>>> do nothing when it sees a cycle or can find a bug with that behavior,
 >>>>>>>> that'd also be most appreciated.
 >>>>>>>> 
 >>>>>>>> Robby
 >>>>>>>> 
 >>>>>>>> On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>> I agree with that summarization, and also think that B is the right choice.
 >>>>>>>>> 
 >>>>>>>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>>>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>>>>>>> have the contract fail on such values.
 >>>>>>>>>>> 
 >>>>>>>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>>>>>>> see any soundness holes with that.
 >>>>>>>>>> 
 >>>>>>>>>> Ok, let me try to summarize what we've figured out:
 >>>>>>>>>> 
 >>>>>>>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>>>>>>> interpretation to. [1]
 >>>>>>>>>> 
 >>>>>>>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>>>>>>> `A` have a particular relation to `list?`.
 >>>>>>>>>> 
 >>>>>>>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>>>>>>> types would require changing (2).
 >>>>>>>>>> 
 >>>>>>>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>>>>>> 
 >>>>>>>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>>>>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>>>>>> 
 >>>>>>>>>> We have a few choices:
 >>>>>>>>>> 
 >>>>>>>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>>>>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>>>>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>>>>>> 
 >>>>>>>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>>>>>>> a way of telling the contract system to reject cycles in
 >>>>>>>>>> `recursive-contract`.
 >>>>>>>>>> 
 >>>>>>>>>> B leaves us without a way of describing the output of
 >>>>>>>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>>>>>>> the right choice.
 >>>>>>>>>> 
 >>>>>>>>>> [1] Note that some algorithms on these types require a GFP.
 
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>,
        Shriram Krishnamurthi <sk@cs.brown.edu>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Fri, 13 Jun 2014 10:24:57 -0400

 Catching up with life. 
 
 Eric, thank you for working out the soundness problem that I had
 only in my gut. 
 
 I am glad to see we're going with option B. 
 
 I do think that we may wish to work out an MS thesis for someone
 or a PhD starter project for types with GFP interpretations in TR. 
 As I said there are several papers on this now. Some of the examples
 cone straight out of the kind of HtDP examples I used to cover with
 shared and that Shriram still covers in his version. 
 
 More on the rest in a separate message -- Matthias
 
 
 
 
 
 On Jun 12, 2014, at 12:54 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 
 > I agree with that summarization, and also think that B is the right choice.
 > 
 > On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 > <samth@cs.indiana.edu> wrote:
 >> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>> have the contract fail on such values.
 >>> 
 >>> TR can still see cyclic values through an Any contract. But I don't
 >>> see any soundness holes with that.
 >> 
 >> Ok, let me try to summarize what we've figured out:
 >> 
 >> 1. TR has recursive types, which we currently give a least-fixed-point
 >> interpretation to. [1]
 >> 
 >> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >> `A` have a particular relation to `list?`.
 >> 
 >> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >> types would require changing (2).
 >> 
 >> 4. There's also a GFP lurking inside the definition of `Any`.
 >> 
 >> 5. The contract system previously looped on cyclic data, but is now
 >> giving `recursive-contract` a GFP interpretation.
 >> 
 >> We have a few choices:
 >> 
 >> A: GFP interpretation for TR types. This requires changing the type of
 >> `list?`, `andmap`, and possibly the type of other recursively-defined
 >> functions, including some user-defined ones (although I doubt it).
 >> 
 >> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >> a way of telling the contract system to reject cycles in
 >> `recursive-contract`.
 >> 
 >> B leaves us without a way of describing the output of
 >> `make-reader-graph` except as `Any`. However, I think B is probably
 >> the right choice.
 >> 
 >> [1] Note that some algorithms on these types require a GFP.
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>,
        Shriram Krishnamurthi <sk@cs.brown.edu>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 10:26:37 -0400

 On Fri, Jun 13, 2014 at 10:24 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > Catching up with life.
 >
 > Eric, thank you for working out the soundness problem that I had
 > only in my gut.
 >
 > I am glad to see we're going with option B.
 
 Well, it turns out we're not necessarily going with option B -- see
 Robby's more recent messages.
 
 Sam
 
 >
 > I do think that we may wish to work out an MS thesis for someone
 > or a PhD starter project for types with GFP interpretations in TR.
 > As I said there are several papers on this now. Some of the examples
 > cone straight out of the kind of HtDP examples I used to cover with
 > shared and that Shriram still covers in his version.
 >
 > More on the rest in a separate message -- Matthias
 >
 >
 >
 >
 >
 > On Jun 12, 2014, at 12:54 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >
 >> I agree with that summarization, and also think that B is the right choice.
 >>
 >> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >> <samth@cs.indiana.edu> wrote:
 >>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>> have the contract fail on such values.
 >>>>
 >>>> TR can still see cyclic values through an Any contract. But I don't
 >>>> see any soundness holes with that.
 >>>
 >>> Ok, let me try to summarize what we've figured out:
 >>>
 >>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>> interpretation to. [1]
 >>>
 >>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>> `A` have a particular relation to `list?`.
 >>>
 >>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>> types would require changing (2).
 >>>
 >>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>
 >>> 5. The contract system previously looped on cyclic data, but is now
 >>> giving `recursive-contract` a GFP interpretation.
 >>>
 >>> We have a few choices:
 >>>
 >>> A: GFP interpretation for TR types. This requires changing the type of
 >>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>> functions, including some user-defined ones (although I doubt it).
 >>>
 >>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>> a way of telling the contract system to reject cycles in
 >>> `recursive-contract`.
 >>>
 >>> B leaves us without a way of describing the output of
 >>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>> the right choice.
 >>>
 >>> [1] Note that some algorithms on these types require a GFP.
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Fri, 13 Jun 2014 10:29:26 -0400

 Robby will work out the right thing. What did I miss? 
 
 
 On Jun 13, 2014, at 10:26 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > On Fri, Jun 13, 2014 at 10:24 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> Catching up with life.
 >> 
 >> Eric, thank you for working out the soundness problem that I had
 >> only in my gut.
 >> 
 >> I am glad to see we're going with option B.
 > 
 > Well, it turns out we're not necessarily going with option B -- see
 > Robby's more recent messages.
 > 
 > Sam
 > 
 >> 
 >> I do think that we may wish to work out an MS thesis for someone
 >> or a PhD starter project for types with GFP interpretations in TR.
 >> As I said there are several papers on this now. Some of the examples
 >> cone straight out of the kind of HtDP examples I used to cover with
 >> shared and that Shriram still covers in his version.
 >> 
 >> More on the rest in a separate message -- Matthias
 >> 
 >> 
 >> 
 >> 
 >> 
 >> On Jun 12, 2014, at 12:54 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> 
 >>> I agree with that summarization, and also think that B is the right choice.
 >>> 
 >>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>> <samth@cs.indiana.edu> wrote:
 >>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>> have the contract fail on such values.
 >>>>> 
 >>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>> see any soundness holes with that.
 >>>> 
 >>>> Ok, let me try to summarize what we've figured out:
 >>>> 
 >>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>> interpretation to. [1]
 >>>> 
 >>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>> `A` have a particular relation to `list?`.
 >>>> 
 >>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>> types would require changing (2).
 >>>> 
 >>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>> 
 >>>> 5. The contract system previously looped on cyclic data, but is now
 >>>> giving `recursive-contract` a GFP interpretation.
 >>>> 
 >>>> We have a few choices:
 >>>> 
 >>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>> functions, including some user-defined ones (although I doubt it).
 >>>> 
 >>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>> a way of telling the contract system to reject cycles in
 >>>> `recursive-contract`.
 >>>> 
 >>>> B leaves us without a way of describing the output of
 >>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>> the right choice.
 >>>> 
 >>>> [1] Note that some algorithms on these types require a GFP.
 >> 
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 09:51:37 -0500

 Ha! :) And now I take back whenever I called you a pessimist before!
 
 In all seriousness, I feel like there is a right thing to be worked
 out, but I'm not clear on what TR actually needs.
 
 Robby
 
 
 On Fri, Jun 13, 2014 at 9:29 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > Robby will work out the right thing. What did I miss?
 >
 >
 > On Jun 13, 2014, at 10:26 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >> On Fri, Jun 13, 2014 at 10:24 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> Catching up with life.
 >>>
 >>> Eric, thank you for working out the soundness problem that I had
 >>> only in my gut.
 >>>
 >>> I am glad to see we're going with option B.
 >>
 >> Well, it turns out we're not necessarily going with option B -- see
 >> Robby's more recent messages.
 >>
 >> Sam
 >>
 >>>
 >>> I do think that we may wish to work out an MS thesis for someone
 >>> or a PhD starter project for types with GFP interpretations in TR.
 >>> As I said there are several papers on this now. Some of the examples
 >>> cone straight out of the kind of HtDP examples I used to cover with
 >>> shared and that Shriram still covers in his version.
 >>>
 >>> More on the rest in a separate message -- Matthias
 >>>
 >>>
 >>>
 >>>
 >>>
 >>> On Jun 12, 2014, at 12:54 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>
 >>>> I agree with that summarization, and also think that B is the right choice.
 >>>>
 >>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>> <samth@cs.indiana.edu> wrote:
 >>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>> have the contract fail on such values.
 >>>>>>
 >>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>> see any soundness holes with that.
 >>>>>
 >>>>> Ok, let me try to summarize what we've figured out:
 >>>>>
 >>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>> interpretation to. [1]
 >>>>>
 >>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>> `A` have a particular relation to `list?`.
 >>>>>
 >>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>> types would require changing (2).
 >>>>>
 >>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>
 >>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>
 >>>>> We have a few choices:
 >>>>>
 >>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>
 >>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>> a way of telling the contract system to reject cycles in
 >>>>> `recursive-contract`.
 >>>>>
 >>>>> B leaves us without a way of describing the output of
 >>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>> the right choice.
 >>>>>
 >>>>> [1] Note that some algorithms on these types require a GFP.
 >>>
 >
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 09:49:34 -0500

 I guess it could be possible to accommodate that kind of thing, but
 what I had in mind wouldn't have, right. So what I wrote earlier was
 wrong: that would not be a flat contact, but it would loop.
 
 I guess that TR needs recursive-contract to properly signal an error
 for this example?
 
 Robby
 
 On Fri, Jun 13, 2014 at 8:46 AM, Sam Tobin-Hochstadt
 <samth@cs.indiana.edu> wrote:
 > What would the option do for this program:
 >
 > (letrec ([t (recursive-contract (or/c null? (cons/c (vectorof integer?) t)))])
 >   (contract t (shared ([x (cons (vector 1) x)]) x) 'a 'b))
 >
 > In other words, does it require flatness in the contents of the
 > recursive contract, or just in the recursive part?
 >
 > Sam
 >
 > On Fri, Jun 13, 2014 at 9:21 AM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> Oh-- and then to ask "is that helpful"?
 >>
 >> Robby
 >>
 >> On Fri, Jun 13, 2014 at 8:21 AM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >>> Well, I guess what I'm saying is that I understand how to add an
 >>> option to recursive-contract so that it fails where it currently loops
 >>> and I believe that is on flat recursive contacts when given cyclic
 >>> values.
 >>>
 >>> Robby
 >>>
 >>> On Fri, Jun 13, 2014 at 7:53 AM, Sam Tobin-Hochstadt
 >>> <samth@cs.indiana.edu> wrote:
 >>>> I don't know if that works, because the _contents_ of the list could
 >>>> require non-flat contracts.
 >>>>
 >>>> Sam
 >>>>
 >>>> On Fri, Jun 13, 2014 at 8:48 AM, Robby Findler
 >>>> <robby@eecs.northwestern.edu> wrote:
 >>>>> So, I guess it would be okay if only flat contacts did the no-cycle
 >>>>> checking?  And otherwise recursive-contract behaves like it did in
 >>>>> 6.0?
 >>>>>
 >>>>> Robby
 >>>>>
 >>>>> On Fri, Jun 13, 2014 at 7:38 AM, Sam Tobin-Hochstadt
 >>>>> <samth@cs.indiana.edu> wrote:
 >>>>>> The problem for TR is mostly about lists, rather than about cyclic
 >>>>>> data in general. Typed Racket assumes that types like:
 >>>>>>
 >>>>>>      (Rec T (U Null (Pair Number T)))
 >>>>>>
 >>>>>> are related to contracts like:
 >>>>>>
 >>>>>>     (letrec ([t (recursive-contract (or/c null (cons/c number? t)))]) t)
 >>>>>>
 >>>>>> but also to:
 >>>>>>
 >>>>>>     (listof number?)
 >>>>>>
 >>>>>> and to:
 >>>>>>
 >>>>>>    (andmap number? l)
 >>>>>>
 >>>>>> More generally, Racket has a bunch of functions on "lists", which are
 >>>>>> defined not to be cyclic. I believe that Racket programmers use
 >>>>>> specifications like the type I gave above (which is just the
 >>>>>> definition of `(Listof Number)`) and expect them to correspond to what
 >>>>>> we mean by "lists". I don't think there are other data structures
 >>>>>> where this is an issue [1].
 >>>>>>
 >>>>>> So your example isn't problematic for TR, but Eric's original example is.
 >>>>>>
 >>>>>> [1] There's also syntax objects, but those are much weirder and don't
 >>>>>> play that well with types in a lot of other ways too.
 >>>>>>
 >>>>>> On Fri, Jun 13, 2014 at 6:38 AM, Robby Findler
 >>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>> Actually, what I pushed doesn't/can't work. At least, I'm not sure
 >>>>>>> where to store the path information that would need to be checked to
 >>>>>>> determine if a cycle has happened.
 >>>>>>>
 >>>>>>> This is a place, however, where the contract system wasn't looping
 >>>>>>> before, even tho there was cyclic data. Here's an example:
 >>>>>>>
 >>>>>>> #lang racket/base
 >>>>>>> (require racket/contract/base)
 >>>>>>>
 >>>>>>> (struct s (x) #:mutable)
 >>>>>>> (define an-s (s #f))
 >>>>>>> (set-s-x! an-s an-s)
 >>>>>>>
 >>>>>>> (define c
 >>>>>>>   (recursive-contract
 >>>>>>>    (struct/c s c)))
 >>>>>>>
 >>>>>>> (s-x (s-x (contract c an-s 'pos 'neg)))
 >>>>>>>
 >>>>>>> What behavior would help TR here?
 >>>>>>>
 >>>>>>> Robby
 >>>>>>>
 >>>>>>>
 >>>>>>>
 >>>>>>> On Thu, Jun 12, 2014 at 11:57 PM, Robby Findler
 >>>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>>> I've pushed a change to recursive-contract following Eric's
 >>>>>>>> suggestion. If that's not what's needed, please let me know.
 >>>>>>>>
 >>>>>>>> If you can spare some mental cycles to argue why the projection should
 >>>>>>>> do nothing when it sees a cycle or can find a bug with that behavior,
 >>>>>>>> that'd also be most appreciated.
 >>>>>>>>
 >>>>>>>> Robby
 >>>>>>>>
 >>>>>>>> On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>> I agree with that summarization, and also think that B is the right choice.
 >>>>>>>>>
 >>>>>>>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>>>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>>>>>>> have the contract fail on such values.
 >>>>>>>>>>>
 >>>>>>>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>>>>>>> see any soundness holes with that.
 >>>>>>>>>>
 >>>>>>>>>> Ok, let me try to summarize what we've figured out:
 >>>>>>>>>>
 >>>>>>>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>>>>>>> interpretation to. [1]
 >>>>>>>>>>
 >>>>>>>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>>>>>>> `A` have a particular relation to `list?`.
 >>>>>>>>>>
 >>>>>>>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>>>>>>> types would require changing (2).
 >>>>>>>>>>
 >>>>>>>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>>>>>>
 >>>>>>>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>>>>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>>>>>>
 >>>>>>>>>> We have a few choices:
 >>>>>>>>>>
 >>>>>>>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>>>>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>>>>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>>>>>>
 >>>>>>>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>>>>>>> a way of telling the contract system to reject cycles in
 >>>>>>>>>> `recursive-contract`.
 >>>>>>>>>>
 >>>>>>>>>> B leaves us without a way of describing the output of
 >>>>>>>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>>>>>>> the right choice.
 >>>>>>>>>>
 >>>>>>>>>> [1] Note that some algorithms on these types require a GFP.
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Fri, 13 Jun 2014 10:55:31 -0400

 TR needs to compile recursive types on non-mutable types into contracts that raise an exception when given a cyclic value. -- Matthias
 
 
 
 
 
 
 On Jun 13, 2014, at 10:51 AM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 
 > Ha! :) And now I take back whenever I called you a pessimist before!
 > 
 > In all seriousness, I feel like there is a right thing to be worked
 > out, but I'm not clear on what TR actually needs.
 > 
 > Robby
 > 
 > 
 > On Fri, Jun 13, 2014 at 9:29 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> Robby will work out the right thing. What did I miss?
 >> 
 >> 
 >> On Jun 13, 2014, at 10:26 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >> 
 >>> On Fri, Jun 13, 2014 at 10:24 AM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>> 
 >>>> Catching up with life.
 >>>> 
 >>>> Eric, thank you for working out the soundness problem that I had
 >>>> only in my gut.
 >>>> 
 >>>> I am glad to see we're going with option B.
 >>> 
 >>> Well, it turns out we're not necessarily going with option B -- see
 >>> Robby's more recent messages.
 >>> 
 >>> Sam
 >>> 
 >>>> 
 >>>> I do think that we may wish to work out an MS thesis for someone
 >>>> or a PhD starter project for types with GFP interpretations in TR.
 >>>> As I said there are several papers on this now. Some of the examples
 >>>> cone straight out of the kind of HtDP examples I used to cover with
 >>>> shared and that Shriram still covers in his version.
 >>>> 
 >>>> More on the rest in a separate message -- Matthias
 >>>> 
 >>>> 
 >>>> 
 >>>> 
 >>>> 
 >>>> On Jun 12, 2014, at 12:54 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> 
 >>>>> I agree with that summarization, and also think that B is the right choice.
 >>>>> 
 >>>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>>> <samth@cs.indiana.edu> wrote:
 >>>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>>> have the contract fail on such values.
 >>>>>>> 
 >>>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>>> see any soundness holes with that.
 >>>>>> 
 >>>>>> Ok, let me try to summarize what we've figured out:
 >>>>>> 
 >>>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>>> interpretation to. [1]
 >>>>>> 
 >>>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>>> `A` have a particular relation to `list?`.
 >>>>>> 
 >>>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>>> types would require changing (2).
 >>>>>> 
 >>>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>> 
 >>>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>> 
 >>>>>> We have a few choices:
 >>>>>> 
 >>>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>> 
 >>>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>>> a way of telling the contract system to reject cycles in
 >>>>>> `recursive-contract`.
 >>>>>> 
 >>>>>> B leaves us without a way of describing the output of
 >>>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>>> the right choice.
 >>>>>> 
 >>>>>> [1] Note that some algorithms on these types require a GFP.
 >>>> 
 >> 
 
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Fri, 13 Jun 2014 10:56:20 -0400

 P.S. You never have called me a pessimist because I am an optimist. 
 
 This conversation could have been run on the-plt.slack 
 
 
 
 
 On Jun 13, 2014, at 10:51 AM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 
 > Ha! :) And now I take back whenever I called you a pessimist before!
 > 
 > In all seriousness, I feel like there is a right thing to be worked
 > out, but I'm not clear on what TR actually needs.
 > 
 > Robby
 > 
 > 
 > On Fri, Jun 13, 2014 at 9:29 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> Robby will work out the right thing. What did I miss?
 >> 
 >> 
 >> On Jun 13, 2014, at 10:26 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >> 
 >>> On Fri, Jun 13, 2014 at 10:24 AM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>> 
 >>>> Catching up with life.
 >>>> 
 >>>> Eric, thank you for working out the soundness problem that I had
 >>>> only in my gut.
 >>>> 
 >>>> I am glad to see we're going with option B.
 >>> 
 >>> Well, it turns out we're not necessarily going with option B -- see
 >>> Robby's more recent messages.
 >>> 
 >>> Sam
 >>> 
 >>>> 
 >>>> I do think that we may wish to work out an MS thesis for someone
 >>>> or a PhD starter project for types with GFP interpretations in TR.
 >>>> As I said there are several papers on this now. Some of the examples
 >>>> cone straight out of the kind of HtDP examples I used to cover with
 >>>> shared and that Shriram still covers in his version.
 >>>> 
 >>>> More on the rest in a separate message -- Matthias
 >>>> 
 >>>> 
 >>>> 
 >>>> 
 >>>> 
 >>>> On Jun 12, 2014, at 12:54 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> 
 >>>>> I agree with that summarization, and also think that B is the right choice.
 >>>>> 
 >>>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>>> <samth@cs.indiana.edu> wrote:
 >>>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>>> have the contract fail on such values.
 >>>>>>> 
 >>>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>>> see any soundness holes with that.
 >>>>>> 
 >>>>>> Ok, let me try to summarize what we've figured out:
 >>>>>> 
 >>>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>>> interpretation to. [1]
 >>>>>> 
 >>>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>>> `A` have a particular relation to `list?`.
 >>>>>> 
 >>>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>>> types would require changing (2).
 >>>>>> 
 >>>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>> 
 >>>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>> 
 >>>>>> We have a few choices:
 >>>>>> 
 >>>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>> 
 >>>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>>> a way of telling the contract system to reject cycles in
 >>>>>> `recursive-contract`.
 >>>>>> 
 >>>>>> B leaves us without a way of describing the output of
 >>>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>>> the right choice.
 >>>>>> 
 >>>>>> [1] Note that some algorithms on these types require a GFP.
 >>>> 
 >> 
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 11:01:07 -0400

 Looping is better than passing, since it will avoid the unsoundness.
 
 The shortest way to describe what TR wants is that the recursive
 implementation of lists (for arbitrary element contracts) should agree
 with `listof` and with `list?`. In places where it doesn't agree,
 looping is better than disagreeing.
 
 For non-lists, I don't think TR cares (or rather, TR's soundness
 doesn't rely on any of the choices under consideration).
 
 Does that answer your question?
 
 Sam
 
 On Fri, Jun 13, 2014 at 10:49 AM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > I guess it could be possible to accommodate that kind of thing, but
 > what I had in mind wouldn't have, right. So what I wrote earlier was
 > wrong: that would not be a flat contact, but it would loop.
 >
 > I guess that TR needs recursive-contract to properly signal an error
 > for this example?
 >
 > Robby
 >
 > On Fri, Jun 13, 2014 at 8:46 AM, Sam Tobin-Hochstadt
 > <samth@cs.indiana.edu> wrote:
 >> What would the option do for this program:
 >>
 >> (letrec ([t (recursive-contract (or/c null? (cons/c (vectorof integer?) t)))])
 >>   (contract t (shared ([x (cons (vector 1) x)]) x) 'a 'b))
 >>
 >> In other words, does it require flatness in the contents of the
 >> recursive contract, or just in the recursive part?
 >>
 >> Sam
 >>
 >> On Fri, Jun 13, 2014 at 9:21 AM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >>> Oh-- and then to ask "is that helpful"?
 >>>
 >>> Robby
 >>>
 >>> On Fri, Jun 13, 2014 at 8:21 AM, Robby Findler
 >>> <robby@eecs.northwestern.edu> wrote:
 >>>> Well, I guess what I'm saying is that I understand how to add an
 >>>> option to recursive-contract so that it fails where it currently loops
 >>>> and I believe that is on flat recursive contacts when given cyclic
 >>>> values.
 >>>>
 >>>> Robby
 >>>>
 >>>> On Fri, Jun 13, 2014 at 7:53 AM, Sam Tobin-Hochstadt
 >>>> <samth@cs.indiana.edu> wrote:
 >>>>> I don't know if that works, because the _contents_ of the list could
 >>>>> require non-flat contracts.
 >>>>>
 >>>>> Sam
 >>>>>
 >>>>> On Fri, Jun 13, 2014 at 8:48 AM, Robby Findler
 >>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>> So, I guess it would be okay if only flat contacts did the no-cycle
 >>>>>> checking?  And otherwise recursive-contract behaves like it did in
 >>>>>> 6.0?
 >>>>>>
 >>>>>> Robby
 >>>>>>
 >>>>>> On Fri, Jun 13, 2014 at 7:38 AM, Sam Tobin-Hochstadt
 >>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>> The problem for TR is mostly about lists, rather than about cyclic
 >>>>>>> data in general. Typed Racket assumes that types like:
 >>>>>>>
 >>>>>>>      (Rec T (U Null (Pair Number T)))
 >>>>>>>
 >>>>>>> are related to contracts like:
 >>>>>>>
 >>>>>>>     (letrec ([t (recursive-contract (or/c null (cons/c number? t)))]) t)
 >>>>>>>
 >>>>>>> but also to:
 >>>>>>>
 >>>>>>>     (listof number?)
 >>>>>>>
 >>>>>>> and to:
 >>>>>>>
 >>>>>>>    (andmap number? l)
 >>>>>>>
 >>>>>>> More generally, Racket has a bunch of functions on "lists", which are
 >>>>>>> defined not to be cyclic. I believe that Racket programmers use
 >>>>>>> specifications like the type I gave above (which is just the
 >>>>>>> definition of `(Listof Number)`) and expect them to correspond to what
 >>>>>>> we mean by "lists". I don't think there are other data structures
 >>>>>>> where this is an issue [1].
 >>>>>>>
 >>>>>>> So your example isn't problematic for TR, but Eric's original example is.
 >>>>>>>
 >>>>>>> [1] There's also syntax objects, but those are much weirder and don't
 >>>>>>> play that well with types in a lot of other ways too.
 >>>>>>>
 >>>>>>> On Fri, Jun 13, 2014 at 6:38 AM, Robby Findler
 >>>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>>> Actually, what I pushed doesn't/can't work. At least, I'm not sure
 >>>>>>>> where to store the path information that would need to be checked to
 >>>>>>>> determine if a cycle has happened.
 >>>>>>>>
 >>>>>>>> This is a place, however, where the contract system wasn't looping
 >>>>>>>> before, even tho there was cyclic data. Here's an example:
 >>>>>>>>
 >>>>>>>> #lang racket/base
 >>>>>>>> (require racket/contract/base)
 >>>>>>>>
 >>>>>>>> (struct s (x) #:mutable)
 >>>>>>>> (define an-s (s #f))
 >>>>>>>> (set-s-x! an-s an-s)
 >>>>>>>>
 >>>>>>>> (define c
 >>>>>>>>   (recursive-contract
 >>>>>>>>    (struct/c s c)))
 >>>>>>>>
 >>>>>>>> (s-x (s-x (contract c an-s 'pos 'neg)))
 >>>>>>>>
 >>>>>>>> What behavior would help TR here?
 >>>>>>>>
 >>>>>>>> Robby
 >>>>>>>>
 >>>>>>>>
 >>>>>>>>
 >>>>>>>> On Thu, Jun 12, 2014 at 11:57 PM, Robby Findler
 >>>>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>>>> I've pushed a change to recursive-contract following Eric's
 >>>>>>>>> suggestion. If that's not what's needed, please let me know.
 >>>>>>>>>
 >>>>>>>>> If you can spare some mental cycles to argue why the projection should
 >>>>>>>>> do nothing when it sees a cycle or can find a bug with that behavior,
 >>>>>>>>> that'd also be most appreciated.
 >>>>>>>>>
 >>>>>>>>> Robby
 >>>>>>>>>
 >>>>>>>>> On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>>> I agree with that summarization, and also think that B is the right choice.
 >>>>>>>>>>
 >>>>>>>>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>>>>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>>>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>>>>>>>> have the contract fail on such values.
 >>>>>>>>>>>>
 >>>>>>>>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>>>>>>>> see any soundness holes with that.
 >>>>>>>>>>>
 >>>>>>>>>>> Ok, let me try to summarize what we've figured out:
 >>>>>>>>>>>
 >>>>>>>>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>>>>>>>> interpretation to. [1]
 >>>>>>>>>>>
 >>>>>>>>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>>>>>>>> `A` have a particular relation to `list?`.
 >>>>>>>>>>>
 >>>>>>>>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>>>>>>>> types would require changing (2).
 >>>>>>>>>>>
 >>>>>>>>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>>>>>>>
 >>>>>>>>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>>>>>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>>>>>>>
 >>>>>>>>>>> We have a few choices:
 >>>>>>>>>>>
 >>>>>>>>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>>>>>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>>>>>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>>>>>>>
 >>>>>>>>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>>>>>>>> a way of telling the contract system to reject cycles in
 >>>>>>>>>>> `recursive-contract`.
 >>>>>>>>>>>
 >>>>>>>>>>> B leaves us without a way of describing the output of
 >>>>>>>>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>>>>>>>> the right choice.
 >>>>>>>>>>>
 >>>>>>>>>>> [1] Note that some algorithms on these types require a GFP.
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 11:05:10 -0500

 Yes, I think so.
 
 To implement this, I think that that means that cons/c (and
 combinators that are similar) needs to cooperate with
 recursive-contract to do something special to do cycle detection for
 lists. For example, this should also do the checking:
 
 (define x (recursive-contract (or/c null? (cons/c number? (cons/c (->
 any/c any) x)))))
 
 (define x (recursive-contract (or/c null? (cons/c (-> any/c any) x)
 (cons/c (-> any/c any/c any) (cons/c boolean? x)))))
 
 and other variations like mutual references, etc.
 
 But wouldn't TR also need this for some more general class going
 forward? And what is that class? That is, I don't think of lists as a
 primitive part of racket (they are just some struct hiding somewhere)
 so there should be a different way to describe what TR needs.
 
 Or maybe a better approach is to make a special cons+empty+recursion
 contract combinator that matches with TR needs?
 
 Robby
 
 On Fri, Jun 13, 2014 at 10:01 AM, Sam Tobin-Hochstadt
 <samth@cs.indiana.edu> wrote:
 > Looping is better than passing, since it will avoid the unsoundness.
 >
 > The shortest way to describe what TR wants is that the recursive
 > implementation of lists (for arbitrary element contracts) should agree
 > with `listof` and with `list?`. In places where it doesn't agree,
 > looping is better than disagreeing.
 >
 > For non-lists, I don't think TR cares (or rather, TR's soundness
 > doesn't rely on any of the choices under consideration).
 >
 > Does that answer your question?
 >
 > Sam
 >
 > On Fri, Jun 13, 2014 at 10:49 AM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> I guess it could be possible to accommodate that kind of thing, but
 >> what I had in mind wouldn't have, right. So what I wrote earlier was
 >> wrong: that would not be a flat contact, but it would loop.
 >>
 >> I guess that TR needs recursive-contract to properly signal an error
 >> for this example?
 >>
 >> Robby
 >>
 >> On Fri, Jun 13, 2014 at 8:46 AM, Sam Tobin-Hochstadt
 >> <samth@cs.indiana.edu> wrote:
 >>> What would the option do for this program:
 >>>
 >>> (letrec ([t (recursive-contract (or/c null? (cons/c (vectorof integer?) t)))])
 >>>   (contract t (shared ([x (cons (vector 1) x)]) x) 'a 'b))
 >>>
 >>> In other words, does it require flatness in the contents of the
 >>> recursive contract, or just in the recursive part?
 >>>
 >>> Sam
 >>>
 >>> On Fri, Jun 13, 2014 at 9:21 AM, Robby Findler
 >>> <robby@eecs.northwestern.edu> wrote:
 >>>> Oh-- and then to ask "is that helpful"?
 >>>>
 >>>> Robby
 >>>>
 >>>> On Fri, Jun 13, 2014 at 8:21 AM, Robby Findler
 >>>> <robby@eecs.northwestern.edu> wrote:
 >>>>> Well, I guess what I'm saying is that I understand how to add an
 >>>>> option to recursive-contract so that it fails where it currently loops
 >>>>> and I believe that is on flat recursive contacts when given cyclic
 >>>>> values.
 >>>>>
 >>>>> Robby
 >>>>>
 >>>>> On Fri, Jun 13, 2014 at 7:53 AM, Sam Tobin-Hochstadt
 >>>>> <samth@cs.indiana.edu> wrote:
 >>>>>> I don't know if that works, because the _contents_ of the list could
 >>>>>> require non-flat contracts.
 >>>>>>
 >>>>>> Sam
 >>>>>>
 >>>>>> On Fri, Jun 13, 2014 at 8:48 AM, Robby Findler
 >>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>> So, I guess it would be okay if only flat contacts did the no-cycle
 >>>>>>> checking?  And otherwise recursive-contract behaves like it did in
 >>>>>>> 6.0?
 >>>>>>>
 >>>>>>> Robby
 >>>>>>>
 >>>>>>> On Fri, Jun 13, 2014 at 7:38 AM, Sam Tobin-Hochstadt
 >>>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>>> The problem for TR is mostly about lists, rather than about cyclic
 >>>>>>>> data in general. Typed Racket assumes that types like:
 >>>>>>>>
 >>>>>>>>      (Rec T (U Null (Pair Number T)))
 >>>>>>>>
 >>>>>>>> are related to contracts like:
 >>>>>>>>
 >>>>>>>>     (letrec ([t (recursive-contract (or/c null (cons/c number? t)))]) t)
 >>>>>>>>
 >>>>>>>> but also to:
 >>>>>>>>
 >>>>>>>>     (listof number?)
 >>>>>>>>
 >>>>>>>> and to:
 >>>>>>>>
 >>>>>>>>    (andmap number? l)
 >>>>>>>>
 >>>>>>>> More generally, Racket has a bunch of functions on "lists", which are
 >>>>>>>> defined not to be cyclic. I believe that Racket programmers use
 >>>>>>>> specifications like the type I gave above (which is just the
 >>>>>>>> definition of `(Listof Number)`) and expect them to correspond to what
 >>>>>>>> we mean by "lists". I don't think there are other data structures
 >>>>>>>> where this is an issue [1].
 >>>>>>>>
 >>>>>>>> So your example isn't problematic for TR, but Eric's original example is.
 >>>>>>>>
 >>>>>>>> [1] There's also syntax objects, but those are much weirder and don't
 >>>>>>>> play that well with types in a lot of other ways too.
 >>>>>>>>
 >>>>>>>> On Fri, Jun 13, 2014 at 6:38 AM, Robby Findler
 >>>>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>>>> Actually, what I pushed doesn't/can't work. At least, I'm not sure
 >>>>>>>>> where to store the path information that would need to be checked to
 >>>>>>>>> determine if a cycle has happened.
 >>>>>>>>>
 >>>>>>>>> This is a place, however, where the contract system wasn't looping
 >>>>>>>>> before, even tho there was cyclic data. Here's an example:
 >>>>>>>>>
 >>>>>>>>> #lang racket/base
 >>>>>>>>> (require racket/contract/base)
 >>>>>>>>>
 >>>>>>>>> (struct s (x) #:mutable)
 >>>>>>>>> (define an-s (s #f))
 >>>>>>>>> (set-s-x! an-s an-s)
 >>>>>>>>>
 >>>>>>>>> (define c
 >>>>>>>>>   (recursive-contract
 >>>>>>>>>    (struct/c s c)))
 >>>>>>>>>
 >>>>>>>>> (s-x (s-x (contract c an-s 'pos 'neg)))
 >>>>>>>>>
 >>>>>>>>> What behavior would help TR here?
 >>>>>>>>>
 >>>>>>>>> Robby
 >>>>>>>>>
 >>>>>>>>>
 >>>>>>>>>
 >>>>>>>>> On Thu, Jun 12, 2014 at 11:57 PM, Robby Findler
 >>>>>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>>>>> I've pushed a change to recursive-contract following Eric's
 >>>>>>>>>> suggestion. If that's not what's needed, please let me know.
 >>>>>>>>>>
 >>>>>>>>>> If you can spare some mental cycles to argue why the projection should
 >>>>>>>>>> do nothing when it sees a cycle or can find a bug with that behavior,
 >>>>>>>>>> that'd also be most appreciated.
 >>>>>>>>>>
 >>>>>>>>>> Robby
 >>>>>>>>>>
 >>>>>>>>>> On Thu, Jun 12, 2014 at 11:54 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>>>> I agree with that summarization, and also think that B is the right choice.
 >>>>>>>>>>>
 >>>>>>>>>>> On Thu, Jun 12, 2014 at 9:37 AM, Sam Tobin-Hochstadt
 >>>>>>>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>>>>>>> On Thu, Jun 12, 2014 at 12:19 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>>>>>> Correct. Which is why I'm arguing for an inductive interpretation, and
 >>>>>>>>>>>>> have the contract fail on such values.
 >>>>>>>>>>>>>
 >>>>>>>>>>>>> TR can still see cyclic values through an Any contract. But I don't
 >>>>>>>>>>>>> see any soundness holes with that.
 >>>>>>>>>>>>
 >>>>>>>>>>>> Ok, let me try to summarize what we've figured out:
 >>>>>>>>>>>>
 >>>>>>>>>>>> 1. TR has recursive types, which we currently give a least-fixed-point
 >>>>>>>>>>>> interpretation to. [1]
 >>>>>>>>>>>>
 >>>>>>>>>>>> 2. TR assumes that types such as (Rec T (U Null (Pair A T))) for some
 >>>>>>>>>>>> `A` have a particular relation to `list?`.
 >>>>>>>>>>>>
 >>>>>>>>>>>> 3. Giving a _greatest_ fixed point interpretation to TR recursive
 >>>>>>>>>>>> types would require changing (2).
 >>>>>>>>>>>>
 >>>>>>>>>>>> 4. There's also a GFP lurking inside the definition of `Any`.
 >>>>>>>>>>>>
 >>>>>>>>>>>> 5. The contract system previously looped on cyclic data, but is now
 >>>>>>>>>>>> giving `recursive-contract` a GFP interpretation.
 >>>>>>>>>>>>
 >>>>>>>>>>>> We have a few choices:
 >>>>>>>>>>>>
 >>>>>>>>>>>> A: GFP interpretation for TR types. This requires changing the type of
 >>>>>>>>>>>> `list?`, `andmap`, and possibly the type of other recursively-defined
 >>>>>>>>>>>> functions, including some user-defined ones (although I doubt it).
 >>>>>>>>>>>>
 >>>>>>>>>>>> B: LFP interpretation for TR types.  This means we need (at a minimum)
 >>>>>>>>>>>> a way of telling the contract system to reject cycles in
 >>>>>>>>>>>> `recursive-contract`.
 >>>>>>>>>>>>
 >>>>>>>>>>>> B leaves us without a way of describing the output of
 >>>>>>>>>>>> `make-reader-graph` except as `Any`. However, I think B is probably
 >>>>>>>>>>>> the right choice.
 >>>>>>>>>>>>
 >>>>>>>>>>>> [1] Note that some algorithms on these types require a GFP.
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 12:27:54 -0400

 On Fri, Jun 13, 2014 at 12:05 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > Yes, I think so.
 >
 > To implement this, I think that that means that cons/c (and
 > combinators that are similar) needs to cooperate with
 > recursive-contract to do something special to do cycle detection for
 > lists. For example, this should also do the checking:
 >
 > (define x (recursive-contract (or/c null? (cons/c number? (cons/c (->
 > any/c any) x)))))
 >
 > (define x (recursive-contract (or/c null? (cons/c (-> any/c any) x)
 > (cons/c (-> any/c any/c any) (cons/c boolean? x)))))
 >
 > and other variations like mutual references, etc.
 
 Right, exactly.
 
 > But wouldn't TR also need this for some more general class going
 > forward? And what is that class? That is, I don't think of lists as a
 > primitive part of racket (they are just some struct hiding somewhere)
 > so there should be a different way to describe what TR needs.
 
 I don't think there's anything else like lists in Racket today. In
 particular, the relevant features of lists for our purposes are:
 
 1. They're defined as a recursive type over exposed constructors that
 can also be used for other things (this isn't true for sets, for
 example, or for queues).
 2. They have a non-trivial invariant, that they can't have cycles.
 3. They're constructed with constructors that don't check the invariant.
 4. There are a bunch of standard functions that do check the invariant.
 5. Mostly people ignore the values that don't match the invariant.
 
 This strikes me as not-very-good data structure design, and so I hope
 that we don't have lots of other instances.
 
 So I don't see lists as a primitive part of Racket, just as a set of
 choices made by the standard library that I hope we don't make in
 other places.
 
 If Racket came with a family of functions on n-way trees constructed
 out of plain vectors, where all of the functions checked for absence
 of cycles, we'd have the same issue.
 
 > Or maybe a better approach is to make a special cons+empty+recursion
 > contract combinator that matches with TR needs?
 
 I don't think that works, because you can create more "interesting"
 versions of lists pretty easily in TR -- like even length lists, which
 are a subtype of lists. Or maybe the combinator you're imagining
 supports all of that, but I sort of doubt it.
 
 Sam
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Fri, 13 Jun 2014 17:49:46 -0400

 On Jun 13, 2014, at 12:27 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > On Fri, Jun 13, 2014 at 12:05 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> Yes, I think so.
 >> 
 >> To implement this, I think that that means that cons/c (and
 >> combinators that are similar) needs to cooperate with
 >> recursive-contract to do something special to do cycle detection for
 >> lists. For example, this should also do the checking:
 >> 
 >> (define x (recursive-contract (or/c null? (cons/c number? (cons/c (->
 >> any/c any) x)))))
 >> 
 >> (define x (recursive-contract (or/c null? (cons/c (-> any/c any) x)
 >> (cons/c (-> any/c any/c any) (cons/c boolean? x)))))
 >> 
 >> and other variations like mutual references, etc.
 > 
 > Right, exactly.
 > 
 >> But wouldn't TR also need this for some more general class going
 >> forward? And what is that class? That is, I don't think of lists as a
 >> primitive part of racket (they are just some struct hiding somewhere)
 >> so there should be a different way to describe what TR needs.
 > 
 > I don't think there's anything else like lists in Racket today. In
 > particular, the relevant features of lists for our purposes are:
 > 
 > 1. They're defined as a recursive type over exposed constructors that
 > can also be used for other things (this isn't true for sets, for
 > example, or for queues).
 > 2. They have a non-trivial invariant, that they can't have cycles.
 > 3. They're constructed with constructors that don't check the invariant.
 > 4. There are a bunch of standard functions that do check the invariant.
 > 5. Mostly people ignore the values that don't match the invariant.
 > 
 > This strikes me as not-very-good data structure design, and so I hope
 > that we don't have lots of other instances.
 > 
 > So I don't see lists as a primitive part of Racket, just as a set of
 > choices made by the standard library that I hope we don't make in
 > other places.
 > 
 > If Racket came with a family of functions on n-way trees constructed
 > out of plain vectors, where all of the functions checked for absence
 > of cycles, we'd have the same issue.
 
 
 I think anyone programming in Racket has the ability to construct
 exactly the same kind of data type again. Since you can't prevent 
 this, I think you want general support. -- Matthias
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 18:19:01 -0400

 Of course, anyone else could do the same thing. But I don't think
 they'd expect to
 
 (a) write a predicate for their data that explicitly checked for and
 rejected cycles
 (b) expect that predicate to correspond precisely to the type they wrote down
 
 That's the problem with lists -- `list?` is a complex function, and
 people expect it to correspond precisely to a simple type.
 
 Sam
 
 On Fri, Jun 13, 2014 at 5:49 PM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > On Jun 13, 2014, at 12:27 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >> On Fri, Jun 13, 2014 at 12:05 PM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >>> Yes, I think so.
 >>>
 >>> To implement this, I think that that means that cons/c (and
 >>> combinators that are similar) needs to cooperate with
 >>> recursive-contract to do something special to do cycle detection for
 >>> lists. For example, this should also do the checking:
 >>>
 >>> (define x (recursive-contract (or/c null? (cons/c number? (cons/c (->
 >>> any/c any) x)))))
 >>>
 >>> (define x (recursive-contract (or/c null? (cons/c (-> any/c any) x)
 >>> (cons/c (-> any/c any/c any) (cons/c boolean? x)))))
 >>>
 >>> and other variations like mutual references, etc.
 >>
 >> Right, exactly.
 >>
 >>> But wouldn't TR also need this for some more general class going
 >>> forward? And what is that class? That is, I don't think of lists as a
 >>> primitive part of racket (they are just some struct hiding somewhere)
 >>> so there should be a different way to describe what TR needs.
 >>
 >> I don't think there's anything else like lists in Racket today. In
 >> particular, the relevant features of lists for our purposes are:
 >>
 >> 1. They're defined as a recursive type over exposed constructors that
 >> can also be used for other things (this isn't true for sets, for
 >> example, or for queues).
 >> 2. They have a non-trivial invariant, that they can't have cycles.
 >> 3. They're constructed with constructors that don't check the invariant.
 >> 4. There are a bunch of standard functions that do check the invariant.
 >> 5. Mostly people ignore the values that don't match the invariant.
 >>
 >> This strikes me as not-very-good data structure design, and so I hope
 >> that we don't have lots of other instances.
 >>
 >> So I don't see lists as a primitive part of Racket, just as a set of
 >> choices made by the standard library that I hope we don't make in
 >> other places.
 >>
 >> If Racket came with a family of functions on n-way trees constructed
 >> out of plain vectors, where all of the functions checked for absence
 >> of cycles, we'd have the same issue.
 >
 >
 > I think anyone programming in Racket has the ability to construct
 > exactly the same kind of data type again. Since you can't prevent
 > this, I think you want general support. -- Matthias
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Fri, 13 Jun 2014 18:38:28 -0400

 We need to support the programmers with the same power that we use for our own programs. KD
 
 
 On Jun 13, 2014, at 6:19 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > Of course, anyone else could do the same thing. But I don't think
 > they'd expect to
 > 
 > (a) write a predicate for their data that explicitly checked for and
 > rejected cycles
 > (b) expect that predicate to correspond precisely to the type they wrote down
 > 
 > That's the problem with lists -- `list?` is a complex function, and
 > people expect it to correspond precisely to a simple type.
 > 
 > Sam
 > 
 > On Fri, Jun 13, 2014 at 5:49 PM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> On Jun 13, 2014, at 12:27 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >> 
 >>> On Fri, Jun 13, 2014 at 12:05 PM, Robby Findler
 >>> <robby@eecs.northwestern.edu> wrote:
 >>>> Yes, I think so.
 >>>> 
 >>>> To implement this, I think that that means that cons/c (and
 >>>> combinators that are similar) needs to cooperate with
 >>>> recursive-contract to do something special to do cycle detection for
 >>>> lists. For example, this should also do the checking:
 >>>> 
 >>>> (define x (recursive-contract (or/c null? (cons/c number? (cons/c (->
 >>>> any/c any) x)))))
 >>>> 
 >>>> (define x (recursive-contract (or/c null? (cons/c (-> any/c any) x)
 >>>> (cons/c (-> any/c any/c any) (cons/c boolean? x)))))
 >>>> 
 >>>> and other variations like mutual references, etc.
 >>> 
 >>> Right, exactly.
 >>> 
 >>>> But wouldn't TR also need this for some more general class going
 >>>> forward? And what is that class? That is, I don't think of lists as a
 >>>> primitive part of racket (they are just some struct hiding somewhere)
 >>>> so there should be a different way to describe what TR needs.
 >>> 
 >>> I don't think there's anything else like lists in Racket today. In
 >>> particular, the relevant features of lists for our purposes are:
 >>> 
 >>> 1. They're defined as a recursive type over exposed constructors that
 >>> can also be used for other things (this isn't true for sets, for
 >>> example, or for queues).
 >>> 2. They have a non-trivial invariant, that they can't have cycles.
 >>> 3. They're constructed with constructors that don't check the invariant.
 >>> 4. There are a bunch of standard functions that do check the invariant.
 >>> 5. Mostly people ignore the values that don't match the invariant.
 >>> 
 >>> This strikes me as not-very-good data structure design, and so I hope
 >>> that we don't have lots of other instances.
 >>> 
 >>> So I don't see lists as a primitive part of Racket, just as a set of
 >>> choices made by the standard library that I hope we don't make in
 >>> other places.
 >>> 
 >>> If Racket came with a family of functions on n-way trees constructed
 >>> out of plain vectors, where all of the functions checked for absence
 >>> of cycles, we'd have the same issue.
 >> 
 >> 
 >> I think anyone programming in Racket has the ability to construct
 >> exactly the same kind of data type again. Since you can't prevent
 >> this, I think you want general support. -- Matthias
 >> 
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 20:07:09 -0500

 While I think that Matthias's general point is right, I can also see
 that Sam's arguments have merit here, specifically that if we were
 doing (the untyped version of) lists over again, we might make
 difference choices and those different choices are generally supported
 by what TR does. At least that's how I understood Sam's argument.
 
 Sam: as to the "I kind of doubt it": that's exactly what I had in
 mind, actually. Roughly, there would ba new class of value and isn't a
 contract, but cons/c accepts it (as a second argument) and it knows
 how to do the cycle checking.
 
 This would shift some of the burden over to TR, however, as TR would
 have to decide between using those things and using
 recursive-contract.
 
 Is that feasible?
 
 Robby
 
 
 
 On Fri, Jun 13, 2014 at 5:38 PM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > We need to support the programmers with the same power that we use for our own programs. KD
 >
 >
 > On Jun 13, 2014, at 6:19 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >> Of course, anyone else could do the same thing. But I don't think
 >> they'd expect to
 >>
 >> (a) write a predicate for their data that explicitly checked for and
 >> rejected cycles
 >> (b) expect that predicate to correspond precisely to the type they wrote down
 >>
 >> That's the problem with lists -- `list?` is a complex function, and
 >> people expect it to correspond precisely to a simple type.
 >>
 >> Sam
 >>
 >> On Fri, Jun 13, 2014 at 5:49 PM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> On Jun 13, 2014, at 12:27 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>
 >>>> On Fri, Jun 13, 2014 at 12:05 PM, Robby Findler
 >>>> <robby@eecs.northwestern.edu> wrote:
 >>>>> Yes, I think so.
 >>>>>
 >>>>> To implement this, I think that that means that cons/c (and
 >>>>> combinators that are similar) needs to cooperate with
 >>>>> recursive-contract to do something special to do cycle detection for
 >>>>> lists. For example, this should also do the checking:
 >>>>>
 >>>>> (define x (recursive-contract (or/c null? (cons/c number? (cons/c (->
 >>>>> any/c any) x)))))
 >>>>>
 >>>>> (define x (recursive-contract (or/c null? (cons/c (-> any/c any) x)
 >>>>> (cons/c (-> any/c any/c any) (cons/c boolean? x)))))
 >>>>>
 >>>>> and other variations like mutual references, etc.
 >>>>
 >>>> Right, exactly.
 >>>>
 >>>>> But wouldn't TR also need this for some more general class going
 >>>>> forward? And what is that class? That is, I don't think of lists as a
 >>>>> primitive part of racket (they are just some struct hiding somewhere)
 >>>>> so there should be a different way to describe what TR needs.
 >>>>
 >>>> I don't think there's anything else like lists in Racket today. In
 >>>> particular, the relevant features of lists for our purposes are:
 >>>>
 >>>> 1. They're defined as a recursive type over exposed constructors that
 >>>> can also be used for other things (this isn't true for sets, for
 >>>> example, or for queues).
 >>>> 2. They have a non-trivial invariant, that they can't have cycles.
 >>>> 3. They're constructed with constructors that don't check the invariant.
 >>>> 4. There are a bunch of standard functions that do check the invariant.
 >>>> 5. Mostly people ignore the values that don't match the invariant.
 >>>>
 >>>> This strikes me as not-very-good data structure design, and so I hope
 >>>> that we don't have lots of other instances.
 >>>>
 >>>> So I don't see lists as a primitive part of Racket, just as a set of
 >>>> choices made by the standard library that I hope we don't make in
 >>>> other places.
 >>>>
 >>>> If Racket came with a family of functions on n-way trees constructed
 >>>> out of plain vectors, where all of the functions checked for absence
 >>>> of cycles, we'd have the same issue.
 >>>
 >>>
 >>> I think anyone programming in Racket has the ability to construct
 >>> exactly the same kind of data type again. Since you can't prevent
 >>> this, I think you want general support. -- Matthias
 >>>
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Fri, 13 Jun 2014 21:14:29 -0400

 S-expressions and their functions are such an incredible dt
 that it has been reinvented over and over again. I doubt we'd
 do it differently. Indeed, I argue we'd do it the same way 
 again. 
 
 See Perlis. 
 
 -- Matthias
 
 
 
 
 On Jun 13, 2014, at 9:07 PM, Robby Findler wrote:
 
 > While I think that Matthias's general point is right, I can also see
 > that Sam's arguments have merit here, specifically that if we were
 > doing (the untyped version of) lists over again, we might make
 > difference choices and those different choices are generally supported
 > by what TR does. At least that's how I understood Sam's argument.
 > 
 > Sam: as to the "I kind of doubt it": that's exactly what I had in
 > mind, actually. Roughly, there would ba new class of value and isn't a
 > contract, but cons/c accepts it (as a second argument) and it knows
 > how to do the cycle checking.
 > 
 > This would shift some of the burden over to TR, however, as TR would
 > have to decide between using those things and using
 > recursive-contract.
 > 
 > Is that feasible?
 > 
 > Robby
 > 
 > 
 > 
 > On Fri, Jun 13, 2014 at 5:38 PM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> We need to support the programmers with the same power that we use for our own programs. KD
 >> 
 >> 
 >> On Jun 13, 2014, at 6:19 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >> 
 >>> Of course, anyone else could do the same thing. But I don't think
 >>> they'd expect to
 >>> 
 >>> (a) write a predicate for their data that explicitly checked for and
 >>> rejected cycles
 >>> (b) expect that predicate to correspond precisely to the type they wrote down
 >>> 
 >>> That's the problem with lists -- `list?` is a complex function, and
 >>> people expect it to correspond precisely to a simple type.
 >>> 
 >>> Sam
 >>> 
 >>> On Fri, Jun 13, 2014 at 5:49 PM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>> 
 >>>> On Jun 13, 2014, at 12:27 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>> 
 >>>>> On Fri, Jun 13, 2014 at 12:05 PM, Robby Findler
 >>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>> Yes, I think so.
 >>>>>> 
 >>>>>> To implement this, I think that that means that cons/c (and
 >>>>>> combinators that are similar) needs to cooperate with
 >>>>>> recursive-contract to do something special to do cycle detection for
 >>>>>> lists. For example, this should also do the checking:
 >>>>>> 
 >>>>>> (define x (recursive-contract (or/c null? (cons/c number? (cons/c (->
 >>>>>> any/c any) x)))))
 >>>>>> 
 >>>>>> (define x (recursive-contract (or/c null? (cons/c (-> any/c any) x)
 >>>>>> (cons/c (-> any/c any/c any) (cons/c boolean? x)))))
 >>>>>> 
 >>>>>> and other variations like mutual references, etc.
 >>>>> 
 >>>>> Right, exactly.
 >>>>> 
 >>>>>> But wouldn't TR also need this for some more general class going
 >>>>>> forward? And what is that class? That is, I don't think of lists as a
 >>>>>> primitive part of racket (they are just some struct hiding somewhere)
 >>>>>> so there should be a different way to describe what TR needs.
 >>>>> 
 >>>>> I don't think there's anything else like lists in Racket today. In
 >>>>> particular, the relevant features of lists for our purposes are:
 >>>>> 
 >>>>> 1. They're defined as a recursive type over exposed constructors that
 >>>>> can also be used for other things (this isn't true for sets, for
 >>>>> example, or for queues).
 >>>>> 2. They have a non-trivial invariant, that they can't have cycles.
 >>>>> 3. They're constructed with constructors that don't check the invariant.
 >>>>> 4. There are a bunch of standard functions that do check the invariant.
 >>>>> 5. Mostly people ignore the values that don't match the invariant.
 >>>>> 
 >>>>> This strikes me as not-very-good data structure design, and so I hope
 >>>>> that we don't have lots of other instances.
 >>>>> 
 >>>>> So I don't see lists as a primitive part of Racket, just as a set of
 >>>>> choices made by the standard library that I hope we don't make in
 >>>>> other places.
 >>>>> 
 >>>>> If Racket came with a family of functions on n-way trees constructed
 >>>>> out of plain vectors, where all of the functions checked for absence
 >>>>> of cycles, we'd have the same issue.
 >>>> 
 >>>> 
 >>>> I think anyone programming in Racket has the ability to construct
 >>>> exactly the same kind of data type again. Since you can't prevent
 >>>> this, I think you want general support. -- Matthias
 >>>> 
 >> 
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 20:18:04 -0500

 I have to admit I don't know the history, but do you really consider
 cyclic lists to be a historically important piece of the design? It
 doesn't seem to be in ML, for example.
 
 It's in Lisps because of set-cdr!, but we have excised that.
 
 And once we get rid of cycles in lists, then all the problems from
 this thread go away. No?
 
 Robby
 
 On Fri, Jun 13, 2014 at 8:14 PM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > S-expressions and their functions are such an incredible dt
 > that it has been reinvented over and over again. I doubt we'd
 > do it differently. Indeed, I argue we'd do it the same way
 > again.
 >
 > See Perlis.
 >
 > -- Matthias
 >
 >
 >
 >
 > On Jun 13, 2014, at 9:07 PM, Robby Findler wrote:
 >
 >> While I think that Matthias's general point is right, I can also see
 >> that Sam's arguments have merit here, specifically that if we were
 >> doing (the untyped version of) lists over again, we might make
 >> difference choices and those different choices are generally supported
 >> by what TR does. At least that's how I understood Sam's argument.
 >>
 >> Sam: as to the "I kind of doubt it": that's exactly what I had in
 >> mind, actually. Roughly, there would ba new class of value and isn't a
 >> contract, but cons/c accepts it (as a second argument) and it knows
 >> how to do the cycle checking.
 >>
 >> This would shift some of the burden over to TR, however, as TR would
 >> have to decide between using those things and using
 >> recursive-contract.
 >>
 >> Is that feasible?
 >>
 >> Robby
 >>
 >>
 >>
 >> On Fri, Jun 13, 2014 at 5:38 PM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> We need to support the programmers with the same power that we use for our own programs. KD
 >>>
 >>>
 >>> On Jun 13, 2014, at 6:19 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>
 >>>> Of course, anyone else could do the same thing. But I don't think
 >>>> they'd expect to
 >>>>
 >>>> (a) write a predicate for their data that explicitly checked for and
 >>>> rejected cycles
 >>>> (b) expect that predicate to correspond precisely to the type they wrote down
 >>>>
 >>>> That's the problem with lists -- `list?` is a complex function, and
 >>>> people expect it to correspond precisely to a simple type.
 >>>>
 >>>> Sam
 >>>>
 >>>> On Fri, Jun 13, 2014 at 5:49 PM, Matthias Felleisen
 >>>> <matthias@ccs.neu.edu> wrote:
 >>>>>
 >>>>> On Jun 13, 2014, at 12:27 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>>>
 >>>>>> On Fri, Jun 13, 2014 at 12:05 PM, Robby Findler
 >>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>> Yes, I think so.
 >>>>>>>
 >>>>>>> To implement this, I think that that means that cons/c (and
 >>>>>>> combinators that are similar) needs to cooperate with
 >>>>>>> recursive-contract to do something special to do cycle detection for
 >>>>>>> lists. For example, this should also do the checking:
 >>>>>>>
 >>>>>>> (define x (recursive-contract (or/c null? (cons/c number? (cons/c (->
 >>>>>>> any/c any) x)))))
 >>>>>>>
 >>>>>>> (define x (recursive-contract (or/c null? (cons/c (-> any/c any) x)
 >>>>>>> (cons/c (-> any/c any/c any) (cons/c boolean? x)))))
 >>>>>>>
 >>>>>>> and other variations like mutual references, etc.
 >>>>>>
 >>>>>> Right, exactly.
 >>>>>>
 >>>>>>> But wouldn't TR also need this for some more general class going
 >>>>>>> forward? And what is that class? That is, I don't think of lists as a
 >>>>>>> primitive part of racket (they are just some struct hiding somewhere)
 >>>>>>> so there should be a different way to describe what TR needs.
 >>>>>>
 >>>>>> I don't think there's anything else like lists in Racket today. In
 >>>>>> particular, the relevant features of lists for our purposes are:
 >>>>>>
 >>>>>> 1. They're defined as a recursive type over exposed constructors that
 >>>>>> can also be used for other things (this isn't true for sets, for
 >>>>>> example, or for queues).
 >>>>>> 2. They have a non-trivial invariant, that they can't have cycles.
 >>>>>> 3. They're constructed with constructors that don't check the invariant.
 >>>>>> 4. There are a bunch of standard functions that do check the invariant.
 >>>>>> 5. Mostly people ignore the values that don't match the invariant.
 >>>>>>
 >>>>>> This strikes me as not-very-good data structure design, and so I hope
 >>>>>> that we don't have lots of other instances.
 >>>>>>
 >>>>>> So I don't see lists as a primitive part of Racket, just as a set of
 >>>>>> choices made by the standard library that I hope we don't make in
 >>>>>> other places.
 >>>>>>
 >>>>>> If Racket came with a family of functions on n-way trees constructed
 >>>>>> out of plain vectors, where all of the functions checked for absence
 >>>>>> of cycles, we'd have the same issue.
 >>>>>
 >>>>>
 >>>>> I think anyone programming in Racket has the ability to construct
 >>>>> exactly the same kind of data type again. Since you can't prevent
 >>>>> this, I think you want general support. -- Matthias
 >>>>>
 >>>
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Fri, 13 Jun 2014 21:19:43 -0400

 On Jun 13, 2014, at 9:18 PM, Robby Findler wrote:
 
 > I have to admit I don't know the history, but do you really consider
 > cyclic lists to be a historically important piece of the design? It
 > doesn't seem to be in ML, for example.
 
 
 They were an integral part of early Lisp programming 
 and we have found new uses every so often. 
 
 ML's type system stood in its way. 
 
 
 > It's in Lisps because of set-cdr!, but we have excised that.
 > 
 > And once we get rid of cycles in lists, then all the problems from
 > this thread go away. No?
 
 
 Yes. 
 
 
 > 
 > Robby
 > 
 > On Fri, Jun 13, 2014 at 8:14 PM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> S-expressions and their functions are such an incredible dt
 >> that it has been reinvented over and over again. I doubt we'd
 >> do it differently. Indeed, I argue we'd do it the same way
 >> again.
 >> 
 >> See Perlis.
 >> 
 >> -- Matthias
 >> 
 >> 
 >> 
 >> 
 >> On Jun 13, 2014, at 9:07 PM, Robby Findler wrote:
 >> 
 >>> While I think that Matthias's general point is right, I can also see
 >>> that Sam's arguments have merit here, specifically that if we were
 >>> doing (the untyped version of) lists over again, we might make
 >>> difference choices and those different choices are generally supported
 >>> by what TR does. At least that's how I understood Sam's argument.
 >>> 
 >>> Sam: as to the "I kind of doubt it": that's exactly what I had in
 >>> mind, actually. Roughly, there would ba new class of value and isn't a
 >>> contract, but cons/c accepts it (as a second argument) and it knows
 >>> how to do the cycle checking.
 >>> 
 >>> This would shift some of the burden over to TR, however, as TR would
 >>> have to decide between using those things and using
 >>> recursive-contract.
 >>> 
 >>> Is that feasible?
 >>> 
 >>> Robby
 >>> 
 >>> 
 >>> 
 >>> On Fri, Jun 13, 2014 at 5:38 PM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>> 
 >>>> We need to support the programmers with the same power that we use for our own programs. KD
 >>>> 
 >>>> 
 >>>> On Jun 13, 2014, at 6:19 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>> 
 >>>>> Of course, anyone else could do the same thing. But I don't think
 >>>>> they'd expect to
 >>>>> 
 >>>>> (a) write a predicate for their data that explicitly checked for and
 >>>>> rejected cycles
 >>>>> (b) expect that predicate to correspond precisely to the type they wrote down
 >>>>> 
 >>>>> That's the problem with lists -- `list?` is a complex function, and
 >>>>> people expect it to correspond precisely to a simple type.
 >>>>> 
 >>>>> Sam
 >>>>> 
 >>>>> On Fri, Jun 13, 2014 at 5:49 PM, Matthias Felleisen
 >>>>> <matthias@ccs.neu.edu> wrote:
 >>>>>> 
 >>>>>> On Jun 13, 2014, at 12:27 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>>>> 
 >>>>>>> On Fri, Jun 13, 2014 at 12:05 PM, Robby Findler
 >>>>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>>> Yes, I think so.
 >>>>>>>> 
 >>>>>>>> To implement this, I think that that means that cons/c (and
 >>>>>>>> combinators that are similar) needs to cooperate with
 >>>>>>>> recursive-contract to do something special to do cycle detection for
 >>>>>>>> lists. For example, this should also do the checking:
 >>>>>>>> 
 >>>>>>>> (define x (recursive-contract (or/c null? (cons/c number? (cons/c (->
 >>>>>>>> any/c any) x)))))
 >>>>>>>> 
 >>>>>>>> (define x (recursive-contract (or/c null? (cons/c (-> any/c any) x)
 >>>>>>>> (cons/c (-> any/c any/c any) (cons/c boolean? x)))))
 >>>>>>>> 
 >>>>>>>> and other variations like mutual references, etc.
 >>>>>>> 
 >>>>>>> Right, exactly.
 >>>>>>> 
 >>>>>>>> But wouldn't TR also need this for some more general class going
 >>>>>>>> forward? And what is that class? That is, I don't think of lists as a
 >>>>>>>> primitive part of racket (they are just some struct hiding somewhere)
 >>>>>>>> so there should be a different way to describe what TR needs.
 >>>>>>> 
 >>>>>>> I don't think there's anything else like lists in Racket today. In
 >>>>>>> particular, the relevant features of lists for our purposes are:
 >>>>>>> 
 >>>>>>> 1. They're defined as a recursive type over exposed constructors that
 >>>>>>> can also be used for other things (this isn't true for sets, for
 >>>>>>> example, or for queues).
 >>>>>>> 2. They have a non-trivial invariant, that they can't have cycles.
 >>>>>>> 3. They're constructed with constructors that don't check the invariant.
 >>>>>>> 4. There are a bunch of standard functions that do check the invariant.
 >>>>>>> 5. Mostly people ignore the values that don't match the invariant.
 >>>>>>> 
 >>>>>>> This strikes me as not-very-good data structure design, and so I hope
 >>>>>>> that we don't have lots of other instances.
 >>>>>>> 
 >>>>>>> So I don't see lists as a primitive part of Racket, just as a set of
 >>>>>>> choices made by the standard library that I hope we don't make in
 >>>>>>> other places.
 >>>>>>> 
 >>>>>>> If Racket came with a family of functions on n-way trees constructed
 >>>>>>> out of plain vectors, where all of the functions checked for absence
 >>>>>>> of cycles, we'd have the same issue.
 >>>>>> 
 >>>>>> 
 >>>>>> I think anyone programming in Racket has the ability to construct
 >>>>>> exactly the same kind of data type again. Since you can't prevent
 >>>>>> this, I think you want general support. -- Matthias
 >>>>>> 
 >>>> 
 >> 
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 20:23:15 -0500

 On Fri, Jun 13, 2014 at 8:19 PM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > On Jun 13, 2014, at 9:18 PM, Robby Findler wrote:
 >
 >> I have to admit I don't know the history, but do you really consider
 >> cyclic lists to be a historically important piece of the design? It
 >> doesn't seem to be in ML, for example.
 >
 >
 > They were an integral part of early Lisp programming
 > and we have found new uses every so often.
 
 I don't think we've found any new uses that I wouldn't happily replace
 with some other, custom data-structure. Lists are so pervasive and
 I've no doubt that there are tons of functions out there that that
 will either crash (if they call 'map') or loop (if they wrote their
 own list-processing function) or silently produce the wrong answer (if
 the use 'list?') when they get a "cyclic list" as an input.
 
 > ML's type system stood in its way.
 
 Is this intended as an ironic statement? :)
 
 Robby
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 13 Jun 2014 20:31:02 -0500

 Oh, I'm starting to perhaps get it. If we change pairs like this then
 we really affect our "data interchange" format in a way that is very
 hard to predict (it is impossible for backwards compatibility
 concerns, of course, but we're not talking about changing it).
 
 Okay, my intuition was based more on programming with lists, not
 programming with sexps in general. And detangling them seems like a
 job for someone with more ... something ... than I have.
 
 Robby
 
 On Fri, Jun 13, 2014 at 8:23 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > On Fri, Jun 13, 2014 at 8:19 PM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >>
 >> On Jun 13, 2014, at 9:18 PM, Robby Findler wrote:
 >>
 >>> I have to admit I don't know the history, but do you really consider
 >>> cyclic lists to be a historically important piece of the design? It
 >>> doesn't seem to be in ML, for example.
 >>
 >>
 >> They were an integral part of early Lisp programming
 >> and we have found new uses every so often.
 >
 > I don't think we've found any new uses that I wouldn't happily replace
 > with some other, custom data-structure. Lists are so pervasive and
 > I've no doubt that there are tons of functions out there that that
 > will either crash (if they call 'map') or loop (if they wrote their
 > own list-processing function) or silently produce the wrong answer (if
 > the use 'list?') when they get a "cyclic list" as an input.
 >
 >> ML's type system stood in its way.
 >
 > Is this intended as an ironic statement? :)
 >
 > Robby
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Fri, 13 Jun 2014 21:44:24 -0400

 Yes! 
 
 On Jun 13, 2014, at 9:31 PM, Robby Findler wrote:
 
 > Oh, I'm starting to perhaps get it. If we change pairs like this then
 > we really affect our "data interchange" format in a way that is very
 > hard to predict (it is impossible for backwards compatibility
 > concerns, of course, but we're not talking about changing it).
 > 
 > Okay, my intuition was based more on programming with lists, not
 > programming with sexps in general. And detangling them seems like a
 > job for someone with more ... something ... than I have.
 > 
 > Robby
 > 
 > On Fri, Jun 13, 2014 at 8:23 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> On Fri, Jun 13, 2014 at 8:19 PM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>> 
 >>> On Jun 13, 2014, at 9:18 PM, Robby Findler wrote:
 >>> 
 >>>> I have to admit I don't know the history, but do you really consider
 >>>> cyclic lists to be a historically important piece of the design? It
 >>>> doesn't seem to be in ML, for example.
 >>> 
 >>> 
 >>> They were an integral part of early Lisp programming
 >>> and we have found new uses every so often.
 >> 
 >> I don't think we've found any new uses that I wouldn't happily replace
 >> with some other, custom data-structure. Lists are so pervasive and
 >> I've no doubt that there are tons of functions out there that that
 >> will either crash (if they call 'map') or loop (if they wrote their
 >> own list-processing function) or silently produce the wrong answer (if
 >> the use 'list?') when they get a "cyclic list" as an input.
 >> 
 >>> ML's type system stood in its way.
 >> 
 >> Is this intended as an ironic statement? :)
 >> 
 >> Robby
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Sun, 15 Jun 2014 01:12:20 -0500

 On Fri, Jun 13, 2014 at 8:07 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > Sam: as to the "I kind of doubt it": that's exactly what I had in
 > mind, actually. Roughly, there would ba new class of value and isn't a
 > contract, but cons/c accepts it (as a second argument) and it knows
 > how to do the cycle checking.
 >
 > This would shift some of the burden over to TR, however, as TR would
 > have to decide between using those things and using
 > recursive-contract.
 
 Oh, rats. I just realized that won't work.
 
 The contract needs to know that the "path" between the recursive
 occurrence of the contract and itself is all first-order. I think
 that's what TR needs too, but I'm not sure.
 
 So, for example, is this contract (and/or the type it comes from) problematic?
 
 (define c (recursive-contract (cons/c number? (vector/c (cons/c boolean? c)))))
 
 Robby
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: endobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        bug-notification <bug-notification@racket-lang.org>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Sun, 15 Jun 2014 09:27:31 -0500

 Oh, right. I think you'd said that before.
 
 Robby
 
 
 On Sun, Jun 15, 2014 at 7:46 AM, Sam Tobin-Hochstadt
 <samth@cs.indiana.edu> wrote:
 > No, I don't think this is problematic.
 >
 > On Jun 15, 2014 2:12 AM, "Robby Findler" <robby@eecs.northwestern.edu>
 > wrote:
 >>
 >> On Fri, Jun 13, 2014 at 8:07 PM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >> > Sam: as to the "I kind of doubt it": that's exactly what I had in
 >> > mind, actually. Roughly, there would ba new class of value and isn't a
 >> > contract, but cons/c accepts it (as a second argument) and it knows
 >> > how to do the cycle checking.
 >> >
 >> > This would shift some of the burden over to TR, however, as TR would
 >> > have to decide between using those things and using
 >> > recursive-contract.
 >>
 >> Oh, rats. I just realized that won't work.
 >>
 >> The contract needs to know that the "path" between the recursive
 >> occurrence of the contract and itself is all first-order. I think
 >> that's what TR needs too, but I'm not sure.
 >>
 >> So, for example, is this contract (and/or the type it comes from)
 >> problematic?
 >>
 >> (define c (recursive-contract (cons/c number? (vector/c (cons/c boolean?
 >> c)))))
 >>
 >> Robby
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: endobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        bug-notification <bug-notification@racket-lang.org>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Sun, 15 Jun 2014 08:46:40 -0400

 --20cf307812d25c605604fbdf4d03
 Content-Type: text/plain; charset=UTF-8
 
 No, I don't think this is problematic.
 On Jun 15, 2014 2:12 AM, "Robby Findler" <robby@eecs.northwestern.edu>
 wrote:
 
 > On Fri, Jun 13, 2014 at 8:07 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 > > Sam: as to the "I kind of doubt it": that's exactly what I had in
 > > mind, actually. Roughly, there would ba new class of value and isn't a
 > > contract, but cons/c accepts it (as a second argument) and it knows
 > > how to do the cycle checking.
 > >
 > > This would shift some of the burden over to TR, however, as TR would
 > > have to decide between using those things and using
 > > recursive-contract.
 >
 > Oh, rats. I just realized that won't work.
 >
 > The contract needs to know that the "path" between the recursive
 > occurrence of the contract and itself is all first-order. I think
 > that's what TR needs too, but I'm not sure.
 >
 > So, for example, is this contract (and/or the type it comes from)
 > problematic?
 >
 > (define c (recursive-contract (cons/c number? (vector/c (cons/c boolean?
 > c)))))
 >
 > Robby
 >
 
 --20cf307812d25c605604fbdf4d03
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 <p dir=3D"ltr">No, I don&#39;t think this is problematic.</p>
 <div class=3D"gmail_quote">On Jun 15, 2014 2:12 AM, &quot;Robby Findler&quo=
 t; &lt;<a href=3D"mailto:robby@eecs.northwestern.edu">robby@eecs.northweste=
 rn.edu</a>&gt; wrote:<br type=3D"attribution"><blockquote class=3D"gmail_qu=
 ote" style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex=
 ">
 On Fri, Jun 13, 2014 at 8:07 PM, Robby Findler<br>
 &lt;<a href=3D"mailto:robby@eecs.northwestern.edu">robby@eecs.northwestern.=
 edu</a>&gt; wrote:<br>
 &gt; Sam: as to the &quot;I kind of doubt it&quot;: that&#39;s exactly what=
  I had in<br>
 &gt; mind, actually. Roughly, there would ba new class of value and isn&#39=
 ;t a<br>
 &gt; contract, but cons/c accepts it (as a second argument) and it knows<br=
 >
 &gt; how to do the cycle checking.<br>
 &gt;<br>
 &gt; This would shift some of the burden over to TR, however, as TR would<b=
 r>
 &gt; have to decide between using those things and using<br>
 &gt; recursive-contract.<br>
 <br>
 Oh, rats. I just realized that won&#39;t work.<br>
 <br>
 The contract needs to know that the &quot;path&quot; between the recursive<=
 br>
 occurrence of the contract and itself is all first-order. I think<br>
 that&#39;s what TR needs too, but I&#39;m not sure.<br>
 <br>
 So, for example, is this contract (and/or the type it comes from) problemat=
 ic?<br>
 <br>
 (define c (recursive-contract (cons/c number? (vector/c (cons/c boolean? c)=
 ))))<br>
 <br>
 Robby<br>
 </blockquote></div>
 
 --20cf307812d25c605604fbdf4d03--
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Mon, 16 Jun 2014 06:55:02 -0400

 I don't think so. Here is a program that constructs a value of this kind: 
 
 #lang typed/racket
 
 (define-type V (Vectorof P))
 (define-type P (Pair Boolean (cons Number V)))
 
 (: v V)
 (define v (vector (cons #f (cons 10 (vector)))))
 
 ; (: b P)
 (define b (cons #t (cons 22 v)))
 
 (vector-set! v 0 b)
 v
 
 
 And that value lives in TR and it is clearly not inductive because Vectorof says 'mutable'. 
 
 [[ The error messages were so misleading that I needed 10 mins to construct this thing. I want my Untyped Racket. ]]
 
 
 
 
 On Jun 15, 2014, at 2:12 AM, Robby Findler wrote:
 
 > On Fri, Jun 13, 2014 at 8:07 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> Sam: as to the "I kind of doubt it": that's exactly what I had in
 >> mind, actually. Roughly, there would ba new class of value and isn't a
 >> contract, but cons/c accepts it (as a second argument) and it knows
 >> how to do the cycle checking.
 >> 
 >> This would shift some of the burden over to TR, however, as TR would
 >> have to decide between using those things and using
 >> recursive-contract.
 > 
 > Oh, rats. I just realized that won't work.
 > 
 > The contract needs to know that the "path" between the recursive
 > occurrence of the contract and itself is all first-order. I think
 > that's what TR needs too, but I'm not sure.
 > 
 > So, for example, is this contract (and/or the type it comes from) problematic?
 > 
 > (define c (recursive-contract (cons/c number? (vector/c (cons/c boolean? c)))))
 > 
 > Robby
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: endobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>,
        Robby Findler <robby@eecs.northwestern.edu>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Mon, 16 Jun 2014 07:15:12 -0400

 --089e0149c594166be404fbf2249a
 Content-Type: text/plain; charset=UTF-8
 
 On Jun 16, 2014 6:55 AM, "Matthias Felleisen" <matthias@ccs.neu.edu> wrote:
 
 > [[ The error messages were so misleading that I needed 10 mins to
 construct this thing. I want my Untyped Racket. ]]
 
 What error messages were the problem here?
 
 Sam
 
 --089e0149c594166be404fbf2249a
 Content-Type: text/html; charset=UTF-8
 
 <p dir="ltr"><br>
 On Jun 16, 2014 6:55 AM, &quot;Matthias Felleisen&quot; &lt;<a href="mailto:matthias@ccs.neu.edu">matthias@ccs.neu.edu</a>&gt; wrote:</p>
 <p dir="ltr">&gt; [[ The error messages were so misleading that I needed 10 mins to construct this thing. I want my Untyped Racket. ]]</p>
 <p dir="ltr">What error messages were the problem here?</p>
 <p dir="ltr">Sam<br>
 </p>
 
 --089e0149c594166be404fbf2249a--
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: endobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>,
        Robby Findler <robby@eecs.northwestern.edu>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Mon, 16 Jun 2014 09:54:41 -0400

 On Jun 16, 2014, at 7:15 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > 
 > On Jun 16, 2014 6:55 AM, "Matthias Felleisen" <matthias@ccs.neu.edu> wrote:
 > 
 > > [[ The error messages were so misleading that I needed 10 mins to construct this thing. I want my Untyped Racket. ]]
 > 
 > What error messages were the problem here?
 
 
 TR complained about instantiations of 'cons' with messages that seemed to say that it can match the expansion of T but it really wants the typed named T. It was somewhat frustrating and I should have taken the time to submit complaints but I really wanted to get this done. 
 
 -- Matthias
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bug-notification <bug-notification@racket-lang.org>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Mon, 16 Jun 2014 09:58:02 -0400

 --089e011777216c190304fbf46a2f
 Content-Type: text/plain; charset=UTF-8
 
 Can you reproduce the problem now?
 
 Giving good error messages with polymorphic functions isn't easy, but I'm
 sure there are some things that could be better.
 
 Sam
 On Jun 16, 2014 9:54 AM, "Matthias Felleisen" <matthias@ccs.neu.edu> wrote:
 
 >
 > On Jun 16, 2014, at 7:15 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu>
 > wrote:
 >
 > >
 > > On Jun 16, 2014 6:55 AM, "Matthias Felleisen" <matthias@ccs.neu.edu>
 > wrote:
 > >
 > > > [[ The error messages were so misleading that I needed 10 mins to
 > construct this thing. I want my Untyped Racket. ]]
 > >
 > > What error messages were the problem here?
 >
 >
 > TR complained about instantiations of 'cons' with messages that seemed to
 > say that it can match the expansion of T but it really wants the typed
 > named T. It was somewhat frustrating and I should have taken the time to
 > submit complaints but I really wanted to get this done.
 >
 > -- Matthias
 >
 >
 
 --089e011777216c190304fbf46a2f
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 <p dir=3D"ltr">Can you reproduce the problem now?</p>
 <p dir=3D"ltr">Giving good error messages with polymorphic functions isn&#3=
 9;t easy, but I&#39;m sure there are some things that could be better.</p>
 <p dir=3D"ltr">Sam</p>
 <div class=3D"gmail_quote">On Jun 16, 2014 9:54 AM, &quot;Matthias Felleise=
 n&quot; &lt;<a href=3D"mailto:matthias@ccs.neu.edu">matthias@ccs.neu.edu</a=
 >&gt; wrote:<br type=3D"attribution"><blockquote class=3D"gmail_quote" styl=
 e=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">
 <br>
 On Jun 16, 2014, at 7:15 AM, Sam Tobin-Hochstadt &lt;<a href=3D"mailto:samt=
 h@cs.indiana.edu">samth@cs.indiana.edu</a>&gt; wrote:<br>
 <br>
 &gt;<br>
 &gt; On Jun 16, 2014 6:55 AM, &quot;Matthias Felleisen&quot; &lt;<a href=3D=
 "mailto:matthias@ccs.neu.edu">matthias@ccs.neu.edu</a>&gt; wrote:<br>
 &gt;<br>
 &gt; &gt; [[ The error messages were so misleading that I needed 10 mins to=
  construct this thing. I want my Untyped Racket. ]]<br>
 &gt;<br>
 &gt; What error messages were the problem here?<br>
 <br>
 <br>
 TR complained about instantiations of &#39;cons&#39; with messages that see=
 med to say that it can match the expansion of T but it really wants the typ=
 ed named T. It was somewhat frustrating and I should have taken the time to=
  submit complaints but I really wanted to get this done.<br>
 
 <br>
 -- Matthias<br>
 <br>
 </blockquote></div>
 
 --089e011777216c190304fbf46a2f--
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bug-notification <bug-notification@racket-lang.org>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Mon, 16 Jun 2014 10:04:22 -0400

 Two versions: 
 
 --------------------------------------------------------------
 
 #lang typed/racket
 
 (define-type P (Pair Boolean (cons Number (Vectorof P))))
 
 (define v (vector (cons #f (cons 10 (vector)))))
 (define b (cons #t (cons 22 v)))
 
 (vector-set! v 0 b)
 v
 
 --------------------------------------------------------------
 
 #lang typed/racket
 
 (define-type P (Pair Boolean (cons Number (Vectorof P))))
 
 (define v (vector (cons #f (cons 10 (vector)))))
 
 (: b P)
 (define b (cons #t (cons 22 v)))
 
 (vector-set! v 0 b)
 v
 
 
 
 On Jun 16, 2014, at 9:58 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > Can you reproduce the problem now?
 > 
 > Giving good error messages with polymorphic functions isn't easy, but I'm sure there are some things that could be better.
 > 
 > Sam
 > 
 > On Jun 16, 2014 9:54 AM, "Matthias Felleisen" <matthias@ccs.neu.edu> wrote:
 > 
 > On Jun 16, 2014, at 7:15 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 > 
 > >
 > > On Jun 16, 2014 6:55 AM, "Matthias Felleisen" <matthias@ccs.neu.edu> wrote:
 > >
 > > > [[ The error messages were so misleading that I needed 10 mins to construct this thing. I want my Untyped Racket. ]]
 > >
 > > What error messages were the problem here?
 > 
 > 
 > TR complained about instantiations of 'cons' with messages that seemed to say that it can match the expansion of T but it really wants the typed named T. It was somewhat frustrating and I should have taken the time to submit complaints but I really wanted to get this done.
 > 
 > -- Matthias
 > 
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bug-notification <bug-notification@racket-lang.org>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Mon, 16 Jun 2014 11:01:20 -0400

 This looks like it's just inferring an overly-specific type for a
 mutable data structure that doesn't have a type annotation.
 
 That's more obvious in the first case than in the second, but it's
 what's happening in both cases.
 
 TR could infer better types than `Positive-Byte` and `False` (and that
 should be easy to do) but it won't fix the problem, because TR doesn't
 have any way of knowing what the type of `(vector)` is supposed to be.
 Maybe there should be a special `EmptyVector` type that is a subtype
 of all vectors -- that would potentially allow this program to
 typecheck with no annotation, but it seems like an
 otherwise-not-useful special case.
 
 Sam
 
 On Mon, Jun 16, 2014 at 10:04 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 >
 > Two versions:
 >
 > --------------------------------------------------------------
 >
 > #lang typed/racket
 >
 > (define-type P (Pair Boolean (cons Number (Vectorof P))))
 >
 > (define v (vector (cons #f (cons 10 (vector)))))
 > (define b (cons #t (cons 22 v)))
 >
 > (vector-set! v 0 b)
 > v
 >
 > --------------------------------------------------------------
 >
 > #lang typed/racket
 >
 > (define-type P (Pair Boolean (cons Number (Vectorof P))))
 >
 > (define v (vector (cons #f (cons 10 (vector)))))
 >
 > (: b P)
 > (define b (cons #t (cons 22 v)))
 >
 > (vector-set! v 0 b)
 > v
 >
 >
 >
 > On Jun 16, 2014, at 9:58 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >> Can you reproduce the problem now?
 >>
 >> Giving good error messages with polymorphic functions isn't easy, but I'm sure there are some things that could be better.
 >>
 >> Sam
 >>
 >> On Jun 16, 2014 9:54 AM, "Matthias Felleisen" <matthias@ccs.neu.edu> wrote:
 >>
 >> On Jun 16, 2014, at 7:15 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>
 >> >
 >> > On Jun 16, 2014 6:55 AM, "Matthias Felleisen" <matthias@ccs.neu.edu> wrote:
 >> >
 >> > > [[ The error messages were so misleading that I needed 10 mins to construct this thing. I want my Untyped Racket. ]]
 >> >
 >> > What error messages were the problem here?
 >>
 >>
 >> TR complained about instantiations of 'cons' with messages that seemed to say that it can match the expansion of T but it really wants the typed named T. It was somewhat frustrating and I should have taken the time to submit complaints but I really wanted to get this done.
 >>
 >> -- Matthias
 >>
 >
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bug-notification <bug-notification@racket-lang.org>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to handle cyclic data structures
Date: Mon, 16 Jun 2014 11:06:47 -0400

 Some of these things came up with partial annotations, as the second example shows. 
 
 If you still think it's too special, I am fine. 
 
 
 
 
 On Jun 16, 2014, at 11:01 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > This looks like it's just inferring an overly-specific type for a
 > mutable data structure that doesn't have a type annotation.
 > 
 > That's more obvious in the first case than in the second, but it's
 > what's happening in both cases.
 > 
 > TR could infer better types than `Positive-Byte` and `False` (and that
 > should be easy to do) but it won't fix the problem, because TR doesn't
 > have any way of knowing what the type of `(vector)` is supposed to be.
 > Maybe there should be a special `EmptyVector` type that is a subtype
 > of all vectors -- that would potentially allow this program to
 > typecheck with no annotation, but it seems like an
 > otherwise-not-useful special case.
 > 
 > Sam
 > 
 > On Mon, Jun 16, 2014 at 10:04 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> 
 >> Two versions:
 >> 
 >> --------------------------------------------------------------
 >> 
 >> #lang typed/racket
 >> 
 >> (define-type P (Pair Boolean (cons Number (Vectorof P))))
 >> 
 >> (define v (vector (cons #f (cons 10 (vector)))))
 >> (define b (cons #t (cons 22 v)))
 >> 
 >> (vector-set! v 0 b)
 >> v
 >> 
 >> --------------------------------------------------------------
 >> 
 >> #lang typed/racket
 >> 
 >> (define-type P (Pair Boolean (cons Number (Vectorof P))))
 >> 
 >> (define v (vector (cons #f (cons 10 (vector)))))
 >> 
 >> (: b P)
 >> (define b (cons #t (cons 22 v)))
 >> 
 >> (vector-set! v 0 b)
 >> v
 >> 
 >> 
 >> 
 >> On Jun 16, 2014, at 9:58 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >> 
 >>> Can you reproduce the problem now?
 >>> 
 >>> Giving good error messages with polymorphic functions isn't easy, but I'm sure there are some things that could be better.
 >>> 
 >>> Sam
 >>> 
 >>> On Jun 16, 2014 9:54 AM, "Matthias Felleisen" <matthias@ccs.neu.edu> wrote:
 >>> 
 >>> On Jun 16, 2014, at 7:15 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>> 
 >>>> 
 >>>> On Jun 16, 2014 6:55 AM, "Matthias Felleisen" <matthias@ccs.neu.edu> wrote:
 >>>> 
 >>>>> [[ The error messages were so misleading that I needed 10 mins to construct this thing. I want my Untyped Racket. ]]
 >>>> 
 >>>> What error messages were the problem here?
 >>> 
 >>> 
 >>> TR complained about instantiations of 'cons' with messages that seemed to say that it can match the expansion of T but it really wants the typed named T. It was somewhat frustrating and I should have taken the time to submit complaints but I really wanted to get this done.
 >>> 
 >>> -- Matthias
 >>> 
 >> 
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        Robby Findler <robby@eecs.northwestern.edu>,
        bug-notification <bug-notification@racket-lang.org>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Mon, 16 Jun 2014 11:39:28 -0400

 On Mon, Jun 16, 2014 at 11:06 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > Some of these things came up with partial annotations, as the second example shows.
 
 Right, in the second example, it still inferred an overly-specific type for `v`.
 
 > If you still think it's too special, I am fine.
 
 The overly-specialized thing would be special handling of the empty
 vector (which I doubt people use much).  We can improve the rest (and
 give better error messages).
 
 Sam
 
 >
 >
 >
 > On Jun 16, 2014, at 11:01 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >> This looks like it's just inferring an overly-specific type for a
 >> mutable data structure that doesn't have a type annotation.
 >>
 >> That's more obvious in the first case than in the second, but it's
 >> what's happening in both cases.
 >>
 >> TR could infer better types than `Positive-Byte` and `False` (and that
 >> should be easy to do) but it won't fix the problem, because TR doesn't
 >> have any way of knowing what the type of `(vector)` is supposed to be.
 >> Maybe there should be a special `EmptyVector` type that is a subtype
 >> of all vectors -- that would potentially allow this program to
 >> typecheck with no annotation, but it seems like an
 >> otherwise-not-useful special case.
 >>
 >> Sam
 >>
 >> On Mon, Jun 16, 2014 at 10:04 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>>
 >>> Two versions:
 >>>
 >>> --------------------------------------------------------------
 >>>
 >>> #lang typed/racket
 >>>
 >>> (define-type P (Pair Boolean (cons Number (Vectorof P))))
 >>>
 >>> (define v (vector (cons #f (cons 10 (vector)))))
 >>> (define b (cons #t (cons 22 v)))
 >>>
 >>> (vector-set! v 0 b)
 >>> v
 >>>
 >>> --------------------------------------------------------------
 >>>
 >>> #lang typed/racket
 >>>
 >>> (define-type P (Pair Boolean (cons Number (Vectorof P))))
 >>>
 >>> (define v (vector (cons #f (cons 10 (vector)))))
 >>>
 >>> (: b P)
 >>> (define b (cons #t (cons 22 v)))
 >>>
 >>> (vector-set! v 0 b)
 >>> v
 >>>
 >>>
 >>>
 >>> On Jun 16, 2014, at 9:58 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>
 >>>> Can you reproduce the problem now?
 >>>>
 >>>> Giving good error messages with polymorphic functions isn't easy, but I'm sure there are some things that could be better.
 >>>>
 >>>> Sam
 >>>>
 >>>> On Jun 16, 2014 9:54 AM, "Matthias Felleisen" <matthias@ccs.neu.edu> wrote:
 >>>>
 >>>> On Jun 16, 2014, at 7:15 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>>
 >>>>>
 >>>>> On Jun 16, 2014 6:55 AM, "Matthias Felleisen" <matthias@ccs.neu.edu> wrote:
 >>>>>
 >>>>>> [[ The error messages were so misleading that I needed 10 mins to construct this thing. I want my Untyped Racket. ]]
 >>>>>
 >>>>> What error messages were the problem here?
 >>>>
 >>>>
 >>>> TR complained about instantiations of 'cons' with messages that seemed to say that it can match the expansion of T but it really wants the typed named T. It was somewhat frustrating and I should have taken the time to submit complaints but I really wanted to get this done.
 >>>>
 >>>> -- Matthias
 >>>>
 >>>
 >
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 3 Jul 2014 20:39:55 -0500

 Returning to this now. I think what I'm going to do is specialize
 listness in the contract system. Specifically, I plan to:
 
 - revert 7728e062f481a5bce42c663d91e6e0919d706e62
 
 - add a list-contract? predicate.
 
 Contracts that answer #t to list-contract? will internally use list?
 to check their values. I expect cons/c to return a contract that is
 list-contract? when it's second argument is. Also, empty? and null?
 and '() and listof and list/c will all be list-contract?. And
 recursive-contract will have to get in on this too, presumably via a
 keyword argument where you declare that the recursive thing you're
 building is a list-contract? (and that is checked when the expression
 is eventually evaluated).
 
 So, contracts that are not list-contract? may accept lists, but
 contracts that are list-contract? will reject non-list? values. (Note
 that this is orthogonal to flat/non-flat.)
 
 It seems clear we want to do the first step before the release. I'm
 okay with waiting for the second one until after, tho, if people think
 that's wise.
 
 Opinions?
 
 Robby

----------
A commit by robby@racket-lang.org was marked as relevant
  http://git.racket-lang.org/plt/commit/f49dd363fa
  | added list-contract?
  | 
  | and specialized a bunch of list-related contracts to track list?-ness,
  | notably recursive-contract now accepts a #:list-contract? argument
  | that means that it insists that values it accepts be list? (and
  | thus not cyclic)
  | 
  | related to PR 14559

From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Thu, 3 Jul 2014 23:15:18 -0500

 Okay, timezones. I just pushed it. No problem to revert it or change
 it or whatever if you guys think it should be done better or different
 or not at all.
 
 Robby
 
 On Thu, Jul 3, 2014 at 8:39 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > Returning to this now. I think what I'm going to do is specialize
 > listness in the contract system. Specifically, I plan to:
 >
 > - revert 7728e062f481a5bce42c663d91e6e0919d706e62
 >
 > - add a list-contract? predicate.
 >
 > Contracts that answer #t to list-contract? will internally use list?
 > to check their values. I expect cons/c to return a contract that is
 > list-contract? when it's second argument is. Also, empty? and null?
 > and '() and listof and list/c will all be list-contract?. And
 > recursive-contract will have to get in on this too, presumably via a
 > keyword argument where you declare that the recursive thing you're
 > building is a list-contract? (and that is checked when the expression
 > is eventually evaluated).
 >
 > So, contracts that are not list-contract? may accept lists, but
 > contracts that are list-contract? will reject non-list? values. (Note
 > that this is orthogonal to flat/non-flat.)
 >
 > It seems clear we want to do the first step before the release. I'm
 > okay with waiting for the second one until after, tho, if people think
 > that's wise.
 >
 > Opinions?
 >
 > Robby
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>,
        nobody <nobody@racket-lang.org>
Subject: Re: [racket-bug] all/14559: Contract system doesn't make it easy to
 handle cyclic data structures
Date: Fri, 4 Jul 2014 11:56:35 +0200

 This sounds great. Hopefully we'll be able to integrate this soon.
 
 Sam
 
 On Fri, Jul 4, 2014 at 6:15 AM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > Okay, timezones. I just pushed it. No problem to revert it or change
 > it or whatever if you guys think it should be done better or different
 > or not at all.
 >
 > Robby
 >
 > On Thu, Jul 3, 2014 at 8:39 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> Returning to this now. I think what I'm going to do is specialize
 >> listness in the contract system. Specifically, I plan to:
 >>
 >> - revert 7728e062f481a5bce42c663d91e6e0919d706e62
 >>
 >> - add a list-contract? predicate.
 >>
 >> Contracts that answer #t to list-contract? will internally use list?
 >> to check their values. I expect cons/c to return a contract that is
 >> list-contract? when it's second argument is. Also, empty? and null?
 >> and '() and listof and list/c will all be list-contract?. And
 >> recursive-contract will have to get in on this too, presumably via a
 >> keyword argument where you declare that the recursive thing you're
 >> building is a list-contract? (and that is checked when the expression
 >> is eventually evaluated).
 >>
 >> So, contracts that are not list-contract? may accept lists, but
 >> contracts that are list-contract? will reject non-list? values. (Note
 >> that this is orthogonal to flat/non-flat.)
 >>
 >> It seems clear we want to do the first step before the release. I'm
 >> okay with waiting for the second one until after, tho, if people think
 >> that's wise.
 >>
 >> Opinions?
 >>
 >> Robby
