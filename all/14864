From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Mon Dec  1 18:14:57 2014
Received: from mail-ie0-f171.google.com (mail-ie0-f171.google.com [209.85.223.171])
	by winooski.ccs.neu.edu (8.14.7/8.14.7) with ESMTP id sB1NEt4K024651
	for <bugs@bugs.plt-scheme.org>; Mon, 1 Dec 2014 18:14:55 -0500
Message-Id: <201412012314.sB1NEqME024635@winooski.ccs.neu.edu>
Date: Mon, 1 Dec 2014 18:14:52 -0500
From: mbertheau@gmail.com
To: bugs@racket-lang.org
Subject: xrepl readline behaves strangely

>Number:         14864
>Category:       all
>Synopsis:       xrepl readline behaves strangely
>Class:          sw-bug
>Responsible:    nobody
>Severity:       non-critical
>Priority:       medium
>State:          open
>Confidential:   no
>Arrival-Date:   Mon Dec 01 18:16:01 -0500 2014
>Last-Modified:  Wed Dec 03 16:48:01 -0500 2014
>Originator:     Markus Bertheau
>Organization:
plt
>Submitter-Id:   unknown
>Release:        6.1.1
>Environment:
unix "Linux markus 3.11.0-26-generic #45-Ubuntu SMP Tue Jul 15 04:02:06 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux" (x86_64-linux/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 279209412
raco pkg (show):
Installation-wide:
 Package              Checksum                                    Source
 main-distribution    84a366a8c2b2908babe6c2811b0ada036bb159df    (catalog main-distribution)
 racket-lib           436f0928598fc1a8abf27422e8e6588bef45f652    (catalog racket-lib)
 [181 auto-installed packages not shown]
User-specific for installation "6.1.1":
 [none]



Collections:
("/home/markus/.racket/6.1.1/collects"
 (non-existent-path))
("/home/markus/racket/collects"
 (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))

Recent Internal Errors: 
Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t #t ((test) (main)) #t))
>Description:
The readline in xrepl works somehow different than it works for example in bash, but also in python. Steps to reproduce below.
>How-To-Repeat:
1. $ cat > ~/.inputrc
set editing-mode vi
set keymap vi
2. $ cat > ~/.racketrc
(require xrepl)
3. $ racket
4. -> (+ 1 2)
5. -> ^D
6. $ racket
7. <Up>

Expected: the previous command (+ 1 2) appears on the repl prompt.
Actual: The promt doesn't change and nothing appears on it.

Another scenario:
3. $ racket
4. -> <Down><Up>
; side note: now the last command does appear.
5. -> w
Actual: moves cursor to 1
Expected: inserts w
6. -> cw<Right>
Actual: Deletes 1 and then deletes to end of line
Expected: Deletes 1 and moves cursor one position to the right
>Fix:
>Audit-Trail:
From: Eli Barzilay <eli@barzilay.org>
To: mbertheau@gmail.com, "bugs@racket-lang.org" <bugs@racket-lang.org>
Cc: "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14864: xrepl readline behaves strangely
Date: Tue, 2 Dec 2014 21:03:38 -0500

 On Mon, Dec 1, 2014 at 6:16 PM,  <mbertheau@gmail.com> wrote:
 > The readline in xrepl works somehow different than it works for
 > example in bash, but also in python.
 
 I don't know what exactly is used in python, but bash most definitely
 doesn't use readline or at most it uses it with a ton of its own
 customized behavior, so differences are certainly there.
 
 > Steps to reproduce below.
 >
 > *** How to repeat:
 > 1. $ cat > ~/.inputrc
 > set editing-mode vi
 > set keymap vi
 > 2. $ cat > ~/.racketrc
 > (require xrepl)
 > 3. $ racket
 > 4. -> (+ 1 2)
 > 5. -> ^D
 > 6. $ racket
 > 7. <Up>
 
 I don't use vi editing, but this looks roughly like what I'd expect it
 to do...  My guess is that things went fine, and after the above you
 should be able to see that the history is indeed there using
 
     (get-preference 'readline-input-history)
 
 
 > Expected: the previous command (+ 1 2) appears on the repl prompt.
 > Actual: The promt doesn't change and nothing appears on it.
 
 Since you set it explicitly to vi mode, you need to get out of insert
 mode using escape, and then go up with a "k".  When I do that it works
 fine for me.  I was also able to use "ESC <up>" to get the previous
 expression.  Just hitting <up> a few times worked once -- I'm guessing
 that readline is trying to distinguish a proper <esc> from an escape
 sequence, and it can get confused.  (But I have highly customized escape
 sequences on my xterm, so this is likely to be something untypical.)
 
 I don't know more about using vi mode, but there might be some way to
 customize it to identify an escape sequence resulting from an arrow key
 and respond to that, but I don't see anything, and trying to bind the
 arrow keys doesn't work for me -- it still requires an ESC before
 navigation.
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Markus Bertheau <mbertheau@gmail.com>
To: Eli Barzilay <eli@barzilay.org>
Cc: "bugs@racket-lang.org" <bugs@racket-lang.org>,
        "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14864: xrepl readline behaves strangely
Date: Wed, 3 Dec 2014 08:17:12 +0100

 --089e013c6258e84dd505094aa144
 Content-Type: text/plain; charset=UTF-8
 
 Ok, so here's a simple program that doesn't have any customized readline
 behaviour, that exhibits the expected behaviour:
 
 https://gist.github.com/mbertheau/da3b2464f61dfe43504e
 
 Inline:
 
 /*
  * cc -o main main.c -lreadline
  */
 
 #include "readline/readline.h"
 
 int main(int argc, const char* argv)
 {
     char *line;
     while (1) {
         line = readline("Prompt> ");
         if (!line) {
             break;
         }
 
         if (*line) {
             add_history(line);
         }
     }
 }
 
 On Wed, Dec 3, 2014 at 3:03 AM, Eli Barzilay <eli@barzilay.org> wrote:
 
 > On Mon, Dec 1, 2014 at 6:16 PM,  <mbertheau@gmail.com> wrote:
 > > The readline in xrepl works somehow different than it works for
 > > example in bash, but also in python.
 >
 > I don't know what exactly is used in python, but bash most definitely
 > doesn't use readline or at most it uses it with a ton of its own
 > customized behavior, so differences are certainly there.
 >
 > > Steps to reproduce below.
 > >
 > > *** How to repeat:
 > > 1. $ cat > ~/.inputrc
 > > set editing-mode vi
 > > set keymap vi
 > > 2. $ cat > ~/.racketrc
 > > (require xrepl)
 > > 3. $ racket
 > > 4. -> (+ 1 2)
 > > 5. -> ^D
 > > 6. $ racket
 > > 7. <Up>
 >
 > I don't use vi editing, but this looks roughly like what I'd expect it
 > to do...  My guess is that things went fine, and after the above you
 > should be able to see that the history is indeed there using
 >
 >     (get-preference 'readline-input-history)
 >
 >
 > > Expected: the previous command (+ 1 2) appears on the repl prompt.
 > > Actual: The promt doesn't change and nothing appears on it.
 >
 > Since you set it explicitly to vi mode, you need to get out of insert
 > mode using escape, and then go up with a "k".  When I do that it works
 > fine for me.  I was also able to use "ESC <up>" to get the previous
 > expression.  Just hitting <up> a few times worked once -- I'm guessing
 > that readline is trying to distinguish a proper <esc> from an escape
 > sequence, and it can get confused.  (But I have highly customized escape
 > sequences on my xterm, so this is likely to be something untypical.)
 >
 > I don't know more about using vi mode, but there might be some way to
 > customize it to identify an escape sequence resulting from an arrow key
 > and respond to that, but I don't see anything, and trying to bind the
 > arrow keys doesn't work for me -- it still requires an ESC before
 > navigation.
 >
 > --
 >           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                     http://barzilay.org/                   Maze is Life!
 >
 
 
 
 -- 
 Markus Bertheau <mbertheau@gmail.com>
 
 --089e013c6258e84dd505094aa144
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 <div dir=3D"ltr">Ok, so here&#39;s a simple program that doesn&#39;t have a=
 ny customized readline behaviour, that exhibits the expected behaviour:<div=
 ><br></div><div><a href=3D"https://gist.github.com/mbertheau/da3b2464f61dfe=
 43504e">https://gist.github.com/mbertheau/da3b2464f61dfe43504e</a><br></div=
 ><div><br></div><div>Inline:</div><div><br></div><div><div>/*</div><div>=C2=
 =A0* cc -o main main.c -lreadline</div><div>=C2=A0*/</div><div><br></div><d=
 iv>#include &quot;readline/readline.h&quot;</div><div><br></div><div>int ma=
 in(int argc, const char* argv)</div><div>{</div><div>=C2=A0 =C2=A0 char *li=
 ne;</div><div>=C2=A0 =C2=A0 while (1) {</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 line =3D readline(&quot;Prompt&gt; &quot;);</div><div>=C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 if (!line) {</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0=
  break;</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 }</div><div><br></div><div>=
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 if (*line) {</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 add_history(line);</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 }</div><div>=C2=A0 =C2=A0 }</div><div>}</div></div></div><div class=3D"gmai=
 l_extra"><br><div class=3D"gmail_quote">On Wed, Dec 3, 2014 at 3:03 AM, Eli=
  Barzilay <span dir=3D"ltr">&lt;<a href=3D"mailto:eli@barzilay.org" target=
 =3D"_blank">eli@barzilay.org</a>&gt;</span> wrote:<br><blockquote class=3D"=
 gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-=
 left:1ex">On Mon, Dec 1, 2014 at 6:16 PM,=C2=A0 &lt;<a href=3D"mailto:mbert=
 heau@gmail.com">mbertheau@gmail.com</a>&gt; wrote:<br>
 &gt; The readline in xrepl works somehow different than it works for<br>
 &gt; example in bash, but also in python.<br>
 <br>
 I don&#39;t know what exactly is used in python, but bash most definitely<b=
 r>
 doesn&#39;t use readline or at most it uses it with a ton of its own<br>
 customized behavior, so differences are certainly there.<br>
 <br>
 &gt; Steps to reproduce below.<br>
 &gt;<br>
 &gt; *** How to repeat:<br>
 &gt; 1. $ cat &gt; ~/.inputrc<br>
 &gt; set editing-mode vi<br>
 &gt; set keymap vi<br>
 &gt; 2. $ cat &gt; ~/.racketrc<br>
 &gt; (require xrepl)<br>
 &gt; 3. $ racket<br>
 &gt; 4. -&gt; (+ 1 2)<br>
 &gt; 5. -&gt; ^D<br>
 &gt; 6. $ racket<br>
 &gt; 7. &lt;Up&gt;<br>
 <br>
 I don&#39;t use vi editing, but this looks roughly like what I&#39;d expect=
  it<br>
 to do...=C2=A0 My guess is that things went fine, and after the above you<b=
 r>
 should be able to see that the history is indeed there using<br>
 <br>
 =C2=A0 =C2=A0 (get-preference &#39;readline-input-history)<br>
 <br>
 <br>
 &gt; Expected: the previous command (+ 1 2) appears on the repl prompt.<br>
 &gt; Actual: The promt doesn&#39;t change and nothing appears on it.<br>
 <br>
 Since you set it explicitly to vi mode, you need to get out of insert<br>
 mode using escape, and then go up with a &quot;k&quot;.=C2=A0 When I do tha=
 t it works<br>
 fine for me.=C2=A0 I was also able to use &quot;ESC &lt;up&gt;&quot; to get=
  the previous<br>
 expression.=C2=A0 Just hitting &lt;up&gt; a few times worked once -- I&#39;=
 m guessing<br>
 that readline is trying to distinguish a proper &lt;esc&gt; from an escape<=
 br>
 sequence, and it can get confused.=C2=A0 (But I have highly customized esca=
 pe<br>
 sequences on my xterm, so this is likely to be something untypical.)<br>
 <br>
 I don&#39;t know more about using vi mode, but there might be some way to<b=
 r>
 customize it to identify an escape sequence resulting from an arrow key<br>
 and respond to that, but I don&#39;t see anything, and trying to bind the<b=
 r>
 arrow keys doesn&#39;t work for me -- it still requires an ESC before<br>
 navigation.<br>
 <span class=3D"HOEnZb"><font color=3D"#888888"><br>
 --<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ((lambda (x) (x x)) (lambda (x) (x x)))=
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 Eli Barzilay:<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 <a hr=
 ef=3D"http://barzilay.org/" target=3D"_blank">http://barzilay.org/</a>=C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0Maze is L=
 ife!<br>
 </font></span></blockquote></div><br><br clear=3D"all"><div><br></div>-- <b=
 r><div class=3D"gmail_signature">Markus Bertheau &lt;<a href=3D"mailto:mber=
 theau@gmail.com" target=3D"_blank">mbertheau@gmail.com</a>&gt;</div>
 </div>
 
 --089e013c6258e84dd505094aa144--
From: Eli Barzilay <eli@barzilay.org>
To: Markus Bertheau <mbertheau@gmail.com>
Cc: "bugs@racket-lang.org" <bugs@racket-lang.org>,
        "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14864: xrepl readline behaves strangely
Date: Wed, 3 Dec 2014 08:58:49 -0500

 [Matthew: one-line fix where it says "one-line fix", but also see the
 "this comment should be added" later on.  I'd make this into a PR, but
 it's not clear whether the new repos are ready for that.]
 
 On Wed, Dec 3, 2014 at 2:17 AM, Markus Bertheau <mbertheau@gmail.com> wrote:
 > Ok, so here's a simple program that doesn't have any customized readline
 > behaviour, that exhibits the expected behaviour:
 > [...]
 
 Ugh...  I didn't even think about trying C.  Racket does the moral
 equivalent of adding these to your code:
 
     int my_getc(FILE *dummy) { return fgetc(stdin); }
 
 and later:
 
     rl_getc_function = my_getc;
 
 and adding that gets me the broken behavior.  I then went to the
 readline sources to look at rl_getc() -- and then main difference is
 that it uses read() on the fd number.  The difference is obvious:
 fgetc() buffers.
 
 So the one-line fix in "rktrl.rkt" is to add:
 
     (file-stream-buffer-mode real-input-port 'none)
 
 You can get that fixed now by adding that line to your .racketrc file
 before the require line, with (current-input-port) instead of
 real-input-port.
 
 I can kind of see how something like buffering might mess things up: if
 it reads as much as it wants instead of jsut one char, it might read
 some terminal reply that should have been intercepted by readline.  Or
 something.  But the weird thing is that this should have been messing up
 the emacs input mode too.  It looks like they had some kind of mess
 (unsurprising) with the vi-mode reading being done differently than
 emacs-mode -- I found this in the readline changelog:
 
     The vi-mode code now gets characters via the application-settable
     value of rl_getc_function rather than calling rl_getc directly.
 
 In any case, it might have been something that got recently noticed and
 fixed in readline, which in the most recent version (6.3) has this
 blurb added to the description of the `rl_getc_function' global:
 
     In general, an application that sets @var{rl_getc_function} should
     consider setting @var{rl_input_available_hook} as well.
 
 So a *better* fix than the above would be this:
 
     (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool)
                   byte-ready?)
 
 but the problem with that is that this `rl_input_available_hook' is a
 new addition, and doesn't exist in 6.2...  I compiled 6.3 to verify that
 this (without disabling buffering as above) indeed fixes the problem.
 
 So I think that this comment should be added:
 
     ;; According to the readline 6.3 documentation, if we set
     ;; rl_getc_function then we should also set the following.  But this
     ;; is a 6.3 addition, so it should be done when 6.3 is common enough
     ;; to depend on.
     ;; (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool)
     ;;               byte-ready?)
 
 (I'd also add "(Which hopefully might never happen since someone will
 surely write a racket readline-like implementation during the decade it
 would take for 6.3 to spread enough.)")
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Eli Barzilay <eli@barzilay.org>, Markus Bertheau <mbertheau@gmail.com>
Cc: "bugs@racket-lang.org" <bugs@racket-lang.org>,
        "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14864: xrepl readline behaves strangely
Date: Wed, 03 Dec 2014 14:30:07 +0000

 --001a113a6a9c2b03e7050950ae39
 Content-Type: text/plain; charset=UTF-8
 
 Yes, you can make a PR for the racket/readline repository.
 
 Sam
 
 On Wed, Dec 3, 2014, 8:58 AM Eli Barzilay <eli@barzilay.org> wrote:
 
 > [Matthew: one-line fix where it says "one-line fix", but also see the
 > "this comment should be added" later on.  I'd make this into a PR, but
 > it's not clear whether the new repos are ready for that.]
 >
 > On Wed, Dec 3, 2014 at 2:17 AM, Markus Bertheau <mbertheau@gmail.com>
 > wrote:
 > > Ok, so here's a simple program that doesn't have any customized readline
 > > behaviour, that exhibits the expected behaviour:
 > > [...]
 >
 > Ugh...  I didn't even think about trying C.  Racket does the moral
 > equivalent of adding these to your code:
 >
 >     int my_getc(FILE *dummy) { return fgetc(stdin); }
 >
 > and later:
 >
 >     rl_getc_function = my_getc;
 >
 > and adding that gets me the broken behavior.  I then went to the
 > readline sources to look at rl_getc() -- and then main difference is
 > that it uses read() on the fd number.  The difference is obvious:
 > fgetc() buffers.
 >
 > So the one-line fix in "rktrl.rkt" is to add:
 >
 >     (file-stream-buffer-mode real-input-port 'none)
 >
 > You can get that fixed now by adding that line to your .racketrc file
 > before the require line, with (current-input-port) instead of
 > real-input-port.
 >
 > I can kind of see how something like buffering might mess things up: if
 > it reads as much as it wants instead of jsut one char, it might read
 > some terminal reply that should have been intercepted by readline.  Or
 > something.  But the weird thing is that this should have been messing up
 > the emacs input mode too.  It looks like they had some kind of mess
 > (unsurprising) with the vi-mode reading being done differently than
 > emacs-mode -- I found this in the readline changelog:
 >
 >     The vi-mode code now gets characters via the application-settable
 >     value of rl_getc_function rather than calling rl_getc directly.
 >
 > In any case, it might have been something that got recently noticed and
 > fixed in readline, which in the most recent version (6.3) has this
 > blurb added to the description of the `rl_getc_function' global:
 >
 >     In general, an application that sets @var{rl_getc_function} should
 >     consider setting @var{rl_input_available_hook} as well.
 >
 > So a *better* fix than the above would be this:
 >
 >     (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool)
 >                   byte-ready?)
 >
 > but the problem with that is that this `rl_input_available_hook' is a
 > new addition, and doesn't exist in 6.2...  I compiled 6.3 to verify that
 > this (without disabling buffering as above) indeed fixes the problem.
 >
 > So I think that this comment should be added:
 >
 >     ;; According to the readline 6.3 documentation, if we set
 >     ;; rl_getc_function then we should also set the following.  But this
 >     ;; is a 6.3 addition, so it should be done when 6.3 is common enough
 >     ;; to depend on.
 >     ;; (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool)
 >     ;;               byte-ready?)
 >
 > (I'd also add "(Which hopefully might never happen since someone will
 > surely write a racket readline-like implementation during the decade it
 > would take for 6.3 to spread enough.)")
 >
 > --
 >           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                     http://barzilay.org/                   Maze is Life!
 >
 
 --001a113a6a9c2b03e7050950ae39
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 <p dir=3D"ltr">Yes, you can make a PR for the racket/readline repository.</=
 p>
 <p dir=3D"ltr">Sam<br>
 </p>
 <br><div class=3D"gmail_quote">On Wed, Dec 3, 2014, 8:58 AM=C2=A0Eli Barzil=
 ay &lt;<a href=3D"mailto:eli@barzilay.org">eli@barzilay.org</a>&gt; wrote:<=
 br><blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left=
 :1px #ccc solid;padding-left:1ex">[Matthew: one-line fix where it says &quo=
 t;one-line fix&quot;, but also see the<br>
 &quot;this comment should be added&quot; later on.=C2=A0 I&#39;d make this =
 into a PR, but<br>
 it&#39;s not clear whether the new repos are ready for that.]<br>
 <br>
 On Wed, Dec 3, 2014 at 2:17 AM, Markus Bertheau &lt;<a href=3D"mailto:mbert=
 heau@gmail.com" target=3D"_blank">mbertheau@gmail.com</a>&gt; wrote:<br>
 &gt; Ok, so here&#39;s a simple program that doesn&#39;t have any customize=
 d readline<br>
 &gt; behaviour, that exhibits the expected behaviour:<br>
 &gt; [...]<br>
 <br>
 Ugh...=C2=A0 I didn&#39;t even think about trying C.=C2=A0 Racket does the =
 moral<br>
 equivalent of adding these to your code:<br>
 <br>
 =C2=A0 =C2=A0 int my_getc(FILE *dummy) { return fgetc(stdin); }<br>
 <br>
 and later:<br>
 <br>
 =C2=A0 =C2=A0 rl_getc_function =3D my_getc;<br>
 <br>
 and adding that gets me the broken behavior.=C2=A0 I then went to the<br>
 readline sources to look at rl_getc() -- and then main difference is<br>
 that it uses read() on the fd number.=C2=A0 The difference is obvious:<br>
 fgetc() buffers.<br>
 <br>
 So the one-line fix in &quot;rktrl.rkt&quot; is to add:<br>
 <br>
 =C2=A0 =C2=A0 (file-stream-buffer-mode real-input-port &#39;none)<br>
 <br>
 You can get that fixed now by adding that line to your .racketrc file<br>
 before the require line, with (current-input-port) instead of<br>
 real-input-port.<br>
 <br>
 I can kind of see how something like buffering might mess things up: if<br>
 it reads as much as it wants instead of jsut one char, it might read<br>
 some terminal reply that should have been intercepted by readline.=C2=A0 Or=
 <br>
 something.=C2=A0 But the weird thing is that this should have been messing =
 up<br>
 the emacs input mode too.=C2=A0 It looks like they had some kind of mess<br=
 >
 (unsurprising) with the vi-mode reading being done differently than<br>
 emacs-mode -- I found this in the readline changelog:<br>
 <br>
 =C2=A0 =C2=A0 The vi-mode code now gets characters via the application-sett=
 able<br>
 =C2=A0 =C2=A0 value of rl_getc_function rather than calling rl_getc directl=
 y.<br>
 <br>
 In any case, it might have been something that got recently noticed and<br>
 fixed in readline, which in the most recent version (6.3) has this<br>
 blurb added to the description of the `rl_getc_function&#39; global:<br>
 <br>
 =C2=A0 =C2=A0 In general, an application that sets @var{rl_getc_function} s=
 hould<br>
 =C2=A0 =C2=A0 consider setting @var{rl_input_available_hook} as well.<br>
 <br>
 So a *better* fix than the above would be this:<br>
 <br>
 =C2=A0 =C2=A0 (set-ffi-obj! &quot;rl_input_available_hook&quot; libreadline=
  (_fun -&gt; _bool)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 byte-ready?)=
 <br>
 <br>
 but the problem with that is that this `rl_input_available_hook&#39; is a<b=
 r>
 new addition, and doesn&#39;t exist in 6.2...=C2=A0 I compiled 6.3 to verif=
 y that<br>
 this (without disabling buffering as above) indeed fixes the problem.<br>
 <br>
 So I think that this comment should be added:<br>
 <br>
 =C2=A0 =C2=A0 ;; According to the readline 6.3 documentation, if we set<br>
 =C2=A0 =C2=A0 ;; rl_getc_function then we should also set the following.=C2=
 =A0 But this<br>
 =C2=A0 =C2=A0 ;; is a 6.3 addition, so it should be done when 6.3 is common=
  enough<br>
 =C2=A0 =C2=A0 ;; to depend on.<br>
 =C2=A0 =C2=A0 ;; (set-ffi-obj! &quot;rl_input_available_hook&quot; libreadl=
 ine (_fun -&gt; _bool)<br>
 =C2=A0 =C2=A0 ;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0byte=
 -ready?)<br>
 <br>
 (I&#39;d also add &quot;(Which hopefully might never happen since someone w=
 ill<br>
 surely write a racket readline-like implementation during the decade it<br>
 would take for 6.3 to spread enough.)&quot;)<br>
 <br>
 --<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ((lambda (x) (x x)) (lambda (x) (x x)))=
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 Eli Barzilay:<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 <a hr=
 ef=3D"http://barzilay.org/" target=3D"_blank">http://barzilay.org/</a>=C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0Maze is L=
 ife!<br>
 </blockquote></div>
 
 --001a113a6a9c2b03e7050950ae39--
From: Markus Bertheau <mbertheau@gmail.com>
To: Eli Barzilay <eli@barzilay.org>
Cc: "bugs@racket-lang.org" <bugs@racket-lang.org>,
        "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14864: xrepl readline behaves strangely
Date: Wed, 3 Dec 2014 22:39:31 +0100

 --047d7b3a8b1eccc651050956adbd
 Content-Type: text/plain; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 Thank you for your detailed analysis!
 
 However, I must report that I couldn't fix the behaviour with either of the
 two lines added to ~/.racketrc =E2=80=93 I'm getting errors. I'm quite a ne=
 wbie to
 racket and lisp, so I don't really know what they mean.
 
 If I add
 
 (file-stream-buffer-mode current-input-port 'none)
 
 before (require xrepl), racket complains as follows:
 
 file-stream-buffer-mode: contract violation
   expected: port?
   given: #<procedure:current-input-port>
   argument position: 1st
   other arguments...:
    'none
 
 If I add
 
 (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool)
 byte-ready?)
 
 instead, racket complains
 
 /home/markus/.racketrc:1:58: ->: bad syntax
   in: ->
 
 Thank you for your efforts!
 
 On Wed, Dec 3, 2014 at 2:58 PM, Eli Barzilay <eli@barzilay.org> wrote:
 
 > [Matthew: one-line fix where it says "one-line fix", but also see the
 > "this comment should be added" later on.  I'd make this into a PR, but
 > it's not clear whether the new repos are ready for that.]
 >
 > On Wed, Dec 3, 2014 at 2:17 AM, Markus Bertheau <mbertheau@gmail.com>
 > wrote:
 > > Ok, so here's a simple program that doesn't have any customized readlin=
 e
 > > behaviour, that exhibits the expected behaviour:
 > > [...]
 >
 > Ugh...  I didn't even think about trying C.  Racket does the moral
 > equivalent of adding these to your code:
 >
 >     int my_getc(FILE *dummy) { return fgetc(stdin); }
 >
 > and later:
 >
 >     rl_getc_function =3D my_getc;
 >
 > and adding that gets me the broken behavior.  I then went to the
 > readline sources to look at rl_getc() -- and then main difference is
 > that it uses read() on the fd number.  The difference is obvious:
 > fgetc() buffers.
 >
 > So the one-line fix in "rktrl.rkt" is to add:
 >
 >     (file-stream-buffer-mode real-input-port 'none)
 >
 > You can get that fixed now by adding that line to your .racketrc file
 > before the require line, with (current-input-port) instead of
 > real-input-port.
 >
 > I can kind of see how something like buffering might mess things up: if
 > it reads as much as it wants instead of jsut one char, it might read
 > some terminal reply that should have been intercepted by readline.  Or
 > something.  But the weird thing is that this should have been messing up
 > the emacs input mode too.  It looks like they had some kind of mess
 > (unsurprising) with the vi-mode reading being done differently than
 > emacs-mode -- I found this in the readline changelog:
 >
 >     The vi-mode code now gets characters via the application-settable
 >     value of rl_getc_function rather than calling rl_getc directly.
 >
 > In any case, it might have been something that got recently noticed and
 > fixed in readline, which in the most recent version (6.3) has this
 > blurb added to the description of the `rl_getc_function' global:
 >
 >     In general, an application that sets @var{rl_getc_function} should
 >     consider setting @var{rl_input_available_hook} as well.
 >
 > So a *better* fix than the above would be this:
 >
 >     (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool)
 >                   byte-ready?)
 >
 > but the problem with that is that this `rl_input_available_hook' is a
 > new addition, and doesn't exist in 6.2...  I compiled 6.3 to verify that
 > this (without disabling buffering as above) indeed fixes the problem.
 >
 > So I think that this comment should be added:
 >
 >     ;; According to the readline 6.3 documentation, if we set
 >     ;; rl_getc_function then we should also set the following.  But this
 >     ;; is a 6.3 addition, so it should be done when 6.3 is common enough
 >     ;; to depend on.
 >     ;; (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool=
 )
 >     ;;               byte-ready?)
 >
 > (I'd also add "(Which hopefully might never happen since someone will
 > surely write a racket readline-like implementation during the decade it
 > would take for 6.3 to spread enough.)")
 >
 > --
 >           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                     http://barzilay.org/                   Maze is Life!
 >
 
 
 
 --=20
 Markus Bertheau <mbertheau@gmail.com>
 
 --047d7b3a8b1eccc651050956adbd
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 <div dir=3D"ltr">Thank you for your detailed analysis!<div><br></div><div>H=
 owever, I must report that I couldn&#39;t fix the behaviour with either of =
 the two lines added to ~/.racketrc =E2=80=93 I&#39;m getting errors. I&#39;=
 m quite a newbie to racket and lisp, so I don&#39;t really know what they m=
 ean.</div><div><br></div><div>If I add</div><div><br></div><div>(file-strea=
 m-buffer-mode current-input-port &#39;none)<br></div><div><br></div><div>be=
 fore (require xrepl), racket complains as follows:</div><div><br></div><div=
 ><div>file-stream-buffer-mode: contract violation</div><div>=C2=A0 expected=
 : port?</div><div>=C2=A0 given: #&lt;procedure:current-input-port&gt;</div>=
 <div>=C2=A0 argument position: 1st</div><div>=C2=A0 other arguments...:</di=
 v><div>=C2=A0 =C2=A0&#39;none</div></div><div><br></div><div>If I add</div>=
 <div><br></div><div>(set-ffi-obj! &quot;rl_input_available_hook&quot; libre=
 adline (_fun -&gt; _bool) byte-ready?)<br></div><div><br></div><div>instead=
 , racket complains</div><div><br></div><div><div>/home/markus/.racketrc:1:5=
 8: -&gt;: bad syntax</div><div>=C2=A0 in: -&gt;</div></div><div><br></div><=
 div>Thank you for your efforts!</div></div><div class=3D"gmail_extra"><br><=
 div class=3D"gmail_quote">On Wed, Dec 3, 2014 at 2:58 PM, Eli Barzilay <spa=
 n dir=3D"ltr">&lt;<a href=3D"mailto:eli@barzilay.org" target=3D"_blank">eli=
 @barzilay.org</a>&gt;</span> wrote:<br><blockquote class=3D"gmail_quote" st=
 yle=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">[Matt=
 hew: one-line fix where it says &quot;one-line fix&quot;, but also see the<=
 br>
 &quot;this comment should be added&quot; later on.=C2=A0 I&#39;d make this =
 into a PR, but<br>
 it&#39;s not clear whether the new repos are ready for that.]<br>
 <span class=3D""><br>
 On Wed, Dec 3, 2014 at 2:17 AM, Markus Bertheau &lt;<a href=3D"mailto:mbert=
 heau@gmail.com">mbertheau@gmail.com</a>&gt; wrote:<br>
 &gt; Ok, so here&#39;s a simple program that doesn&#39;t have any customize=
 d readline<br>
 &gt; behaviour, that exhibits the expected behaviour:<br>
 </span>&gt; [...]<br>
 <br>
 Ugh...=C2=A0 I didn&#39;t even think about trying C.=C2=A0 Racket does the =
 moral<br>
 equivalent of adding these to your code:<br>
 <br>
 =C2=A0 =C2=A0 int my_getc(FILE *dummy) { return fgetc(stdin); }<br>
 <br>
 and later:<br>
 <br>
 =C2=A0 =C2=A0 rl_getc_function =3D my_getc;<br>
 <br>
 and adding that gets me the broken behavior.=C2=A0 I then went to the<br>
 readline sources to look at rl_getc() -- and then main difference is<br>
 that it uses read() on the fd number.=C2=A0 The difference is obvious:<br>
 fgetc() buffers.<br>
 <br>
 So the one-line fix in &quot;rktrl.rkt&quot; is to add:<br>
 <br>
 =C2=A0 =C2=A0 (file-stream-buffer-mode real-input-port &#39;none)<br>
 <br>
 You can get that fixed now by adding that line to your .racketrc file<br>
 before the require line, with (current-input-port) instead of<br>
 real-input-port.<br>
 <br>
 I can kind of see how something like buffering might mess things up: if<br>
 it reads as much as it wants instead of jsut one char, it might read<br>
 some terminal reply that should have been intercepted by readline.=C2=A0 Or=
 <br>
 something.=C2=A0 But the weird thing is that this should have been messing =
 up<br>
 the emacs input mode too.=C2=A0 It looks like they had some kind of mess<br=
 >
 (unsurprising) with the vi-mode reading being done differently than<br>
 emacs-mode -- I found this in the readline changelog:<br>
 <br>
 =C2=A0 =C2=A0 The vi-mode code now gets characters via the application-sett=
 able<br>
 =C2=A0 =C2=A0 value of rl_getc_function rather than calling rl_getc directl=
 y.<br>
 <br>
 In any case, it might have been something that got recently noticed and<br>
 fixed in readline, which in the most recent version (6.3) has this<br>
 blurb added to the description of the `rl_getc_function&#39; global:<br>
 <br>
 =C2=A0 =C2=A0 In general, an application that sets @var{rl_getc_function} s=
 hould<br>
 =C2=A0 =C2=A0 consider setting @var{rl_input_available_hook} as well.<br>
 <br>
 So a *better* fix than the above would be this:<br>
 <br>
 =C2=A0 =C2=A0 (set-ffi-obj! &quot;rl_input_available_hook&quot; libreadline=
  (_fun -&gt; _bool)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 byte-ready?)=
 <br>
 <br>
 but the problem with that is that this `rl_input_available_hook&#39; is a<b=
 r>
 new addition, and doesn&#39;t exist in 6.2...=C2=A0 I compiled 6.3 to verif=
 y that<br>
 this (without disabling buffering as above) indeed fixes the problem.<br>
 <br>
 So I think that this comment should be added:<br>
 <br>
 =C2=A0 =C2=A0 ;; According to the readline 6.3 documentation, if we set<br>
 =C2=A0 =C2=A0 ;; rl_getc_function then we should also set the following.=C2=
 =A0 But this<br>
 =C2=A0 =C2=A0 ;; is a 6.3 addition, so it should be done when 6.3 is common=
  enough<br>
 =C2=A0 =C2=A0 ;; to depend on.<br>
 =C2=A0 =C2=A0 ;; (set-ffi-obj! &quot;rl_input_available_hook&quot; libreadl=
 ine (_fun -&gt; _bool)<br>
 =C2=A0 =C2=A0 ;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0byte=
 -ready?)<br>
 <br>
 (I&#39;d also add &quot;(Which hopefully might never happen since someone w=
 ill<br>
 surely write a racket readline-like implementation during the decade it<br>
 would take for 6.3 to spread enough.)&quot;)<br>
 <div class=3D"HOEnZb"><div class=3D"h5"><br>
 --<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ((lambda (x) (x x)) (lambda (x) (x x)))=
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 Eli Barzilay:<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 <a hr=
 ef=3D"http://barzilay.org/" target=3D"_blank">http://barzilay.org/</a>=C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0Maze is L=
 ife!<br>
 </div></div></blockquote></div><br><br clear=3D"all"><div><br></div>-- <br>=
 <div class=3D"gmail_signature">Markus Bertheau &lt;<a href=3D"mailto:mberth=
 eau@gmail.com" target=3D"_blank">mbertheau@gmail.com</a>&gt;</div>
 </div>
 
 --047d7b3a8b1eccc651050956adbd--
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Markus Bertheau <mbertheau@gmail.com>
Cc: Eli Barzilay <eli@barzilay.org>,
        "bugs@racket-lang.org" <bugs@racket-lang.org>,
        "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14864: xrepl readline behaves strangely
Date: Wed, 3 Dec 2014 16:41:11 -0500

 On Wed, Dec 3, 2014 at 4:39 PM, Markus Bertheau <mbertheau@gmail.com> wrote:
 > Thank you for your detailed analysis!
 >
 > However, I must report that I couldn't fix the behaviour with either of the
 > two lines added to ~/.racketrc â€“ I'm getting errors. I'm quite a newbie to
 > racket and lisp, so I don't really know what they mean.
 >
 > If I add
 >
 > (file-stream-buffer-mode current-input-port 'none)
 
 This should be:
 
     (file-stream-buffer-mode (current-input-port) 'none)
 
 because `current-input-port` is a parameter which you invoke to get the value.
 
 Sam
 
 >
 > before (require xrepl), racket complains as follows:
 >
 > file-stream-buffer-mode: contract violation
 >   expected: port?
 >   given: #<procedure:current-input-port>
 >   argument position: 1st
 >   other arguments...:
 >    'none
 >
 > If I add
 >
 > (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool)
 > byte-ready?)
 >
 > instead, racket complains
 >
 > /home/markus/.racketrc:1:58: ->: bad syntax
 >   in: ->
 >
 > Thank you for your efforts!
 >
 > On Wed, Dec 3, 2014 at 2:58 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >>
 >> [Matthew: one-line fix where it says "one-line fix", but also see the
 >> "this comment should be added" later on.  I'd make this into a PR, but
 >> it's not clear whether the new repos are ready for that.]
 >>
 >> On Wed, Dec 3, 2014 at 2:17 AM, Markus Bertheau <mbertheau@gmail.com>
 >> wrote:
 >> > Ok, so here's a simple program that doesn't have any customized readline
 >> > behaviour, that exhibits the expected behaviour:
 >> > [...]
 >>
 >> Ugh...  I didn't even think about trying C.  Racket does the moral
 >> equivalent of adding these to your code:
 >>
 >>     int my_getc(FILE *dummy) { return fgetc(stdin); }
 >>
 >> and later:
 >>
 >>     rl_getc_function = my_getc;
 >>
 >> and adding that gets me the broken behavior.  I then went to the
 >> readline sources to look at rl_getc() -- and then main difference is
 >> that it uses read() on the fd number.  The difference is obvious:
 >> fgetc() buffers.
 >>
 >> So the one-line fix in "rktrl.rkt" is to add:
 >>
 >>     (file-stream-buffer-mode real-input-port 'none)
 >>
 >> You can get that fixed now by adding that line to your .racketrc file
 >> before the require line, with (current-input-port) instead of
 >> real-input-port.
 >>
 >> I can kind of see how something like buffering might mess things up: if
 >> it reads as much as it wants instead of jsut one char, it might read
 >> some terminal reply that should have been intercepted by readline.  Or
 >> something.  But the weird thing is that this should have been messing up
 >> the emacs input mode too.  It looks like they had some kind of mess
 >> (unsurprising) with the vi-mode reading being done differently than
 >> emacs-mode -- I found this in the readline changelog:
 >>
 >>     The vi-mode code now gets characters via the application-settable
 >>     value of rl_getc_function rather than calling rl_getc directly.
 >>
 >> In any case, it might have been something that got recently noticed and
 >> fixed in readline, which in the most recent version (6.3) has this
 >> blurb added to the description of the `rl_getc_function' global:
 >>
 >>     In general, an application that sets @var{rl_getc_function} should
 >>     consider setting @var{rl_input_available_hook} as well.
 >>
 >> So a *better* fix than the above would be this:
 >>
 >>     (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool)
 >>                   byte-ready?)
 >>
 >> but the problem with that is that this `rl_input_available_hook' is a
 >> new addition, and doesn't exist in 6.2...  I compiled 6.3 to verify that
 >> this (without disabling buffering as above) indeed fixes the problem.
 >>
 >> So I think that this comment should be added:
 >>
 >>     ;; According to the readline 6.3 documentation, if we set
 >>     ;; rl_getc_function then we should also set the following.  But this
 >>     ;; is a 6.3 addition, so it should be done when 6.3 is common enough
 >>     ;; to depend on.
 >>     ;; (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool)
 >>     ;;               byte-ready?)
 >>
 >> (I'd also add "(Which hopefully might never happen since someone will
 >> surely write a racket readline-like implementation during the decade it
 >> would take for 6.3 to spread enough.)")
 >>
 >> --
 >>           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >>                     http://barzilay.org/                   Maze is Life!
 >
 >
 >
 >
 > --
 > Markus Bertheau <mbertheau@gmail.com>
 
From: Markus Bertheau <mbertheau@gmail.com>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eli Barzilay <eli@barzilay.org>,
        "bugs@racket-lang.org" <bugs@racket-lang.org>,
        "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14864: xrepl readline behaves strangely
Date: Wed, 3 Dec 2014 22:47:04 +0100

 --089e01160fe2d811de050956c8b2
 Content-Type: text/plain; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 Thank you, Sam and Jens, now it works :)
 
 Markus
 
 On Wed, Dec 3, 2014 at 10:41 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu>
 wrote:
 
 > On Wed, Dec 3, 2014 at 4:39 PM, Markus Bertheau <mbertheau@gmail.com>
 > wrote:
 > > Thank you for your detailed analysis!
 > >
 > > However, I must report that I couldn't fix the behaviour with either of
 > the
 > > two lines added to ~/.racketrc =E2=80=93 I'm getting errors. I'm quite =
 a newbie
 > to
 > > racket and lisp, so I don't really know what they mean.
 > >
 > > If I add
 > >
 > > (file-stream-buffer-mode current-input-port 'none)
 >
 > This should be:
 >
 >     (file-stream-buffer-mode (current-input-port) 'none)
 >
 > because `current-input-port` is a parameter which you invoke to get the
 > value.
 >
 > Sam
 >
 > >
 > > before (require xrepl), racket complains as follows:
 > >
 > > file-stream-buffer-mode: contract violation
 > >   expected: port?
 > >   given: #<procedure:current-input-port>
 > >   argument position: 1st
 > >   other arguments...:
 > >    'none
 > >
 > > If I add
 > >
 > > (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool)
 > > byte-ready?)
 > >
 > > instead, racket complains
 > >
 > > /home/markus/.racketrc:1:58: ->: bad syntax
 > >   in: ->
 > >
 > > Thank you for your efforts!
 > >
 > > On Wed, Dec 3, 2014 at 2:58 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > >>
 > >> [Matthew: one-line fix where it says "one-line fix", but also see the
 > >> "this comment should be added" later on.  I'd make this into a PR, but
 > >> it's not clear whether the new repos are ready for that.]
 > >>
 > >> On Wed, Dec 3, 2014 at 2:17 AM, Markus Bertheau <mbertheau@gmail.com>
 > >> wrote:
 > >> > Ok, so here's a simple program that doesn't have any customized
 > readline
 > >> > behaviour, that exhibits the expected behaviour:
 > >> > [...]
 > >>
 > >> Ugh...  I didn't even think about trying C.  Racket does the moral
 > >> equivalent of adding these to your code:
 > >>
 > >>     int my_getc(FILE *dummy) { return fgetc(stdin); }
 > >>
 > >> and later:
 > >>
 > >>     rl_getc_function =3D my_getc;
 > >>
 > >> and adding that gets me the broken behavior.  I then went to the
 > >> readline sources to look at rl_getc() -- and then main difference is
 > >> that it uses read() on the fd number.  The difference is obvious:
 > >> fgetc() buffers.
 > >>
 > >> So the one-line fix in "rktrl.rkt" is to add:
 > >>
 > >>     (file-stream-buffer-mode real-input-port 'none)
 > >>
 > >> You can get that fixed now by adding that line to your .racketrc file
 > >> before the require line, with (current-input-port) instead of
 > >> real-input-port.
 > >>
 > >> I can kind of see how something like buffering might mess things up: i=
 f
 > >> it reads as much as it wants instead of jsut one char, it might read
 > >> some terminal reply that should have been intercepted by readline.  Or
 > >> something.  But the weird thing is that this should have been messing =
 up
 > >> the emacs input mode too.  It looks like they had some kind of mess
 > >> (unsurprising) with the vi-mode reading being done differently than
 > >> emacs-mode -- I found this in the readline changelog:
 > >>
 > >>     The vi-mode code now gets characters via the application-settable
 > >>     value of rl_getc_function rather than calling rl_getc directly.
 > >>
 > >> In any case, it might have been something that got recently noticed an=
 d
 > >> fixed in readline, which in the most recent version (6.3) has this
 > >> blurb added to the description of the `rl_getc_function' global:
 > >>
 > >>     In general, an application that sets @var{rl_getc_function} should
 > >>     consider setting @var{rl_input_available_hook} as well.
 > >>
 > >> So a *better* fix than the above would be this:
 > >>
 > >>     (set-ffi-obj! "rl_input_available_hook" libreadline (_fun -> _bool=
 )
 > >>                   byte-ready?)
 > >>
 > >> but the problem with that is that this `rl_input_available_hook' is a
 > >> new addition, and doesn't exist in 6.2...  I compiled 6.3 to verify th=
 at
 > >> this (without disabling buffering as above) indeed fixes the problem.
 > >>
 > >> So I think that this comment should be added:
 > >>
 > >>     ;; According to the readline 6.3 documentation, if we set
 > >>     ;; rl_getc_function then we should also set the following.  But th=
 is
 > >>     ;; is a 6.3 addition, so it should be done when 6.3 is common enou=
 gh
 > >>     ;; to depend on.
 > >>     ;; (set-ffi-obj! "rl_input_available_hook" libreadline (_fun ->
 > _bool)
 > >>     ;;               byte-ready?)
 > >>
 > >> (I'd also add "(Which hopefully might never happen since someone will
 > >> surely write a racket readline-like implementation during the decade i=
 t
 > >> would take for 6.3 to spread enough.)")
 > >>
 > >> --
 > >>           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzila=
 y:
 > >>                     http://barzilay.org/                   Maze is
 > Life!
 > >
 > >
 > >
 > >
 > > --
 > > Markus Bertheau <mbertheau@gmail.com>
 >
 
 
 
 --=20
 Markus Bertheau <mbertheau@gmail.com>
 
 --089e01160fe2d811de050956c8b2
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 <div dir=3D"ltr">Thank you, Sam and Jens, now it works :)<div><br></div><di=
 v>Markus</div></div><div class=3D"gmail_extra"><br><div class=3D"gmail_quot=
 e">On Wed, Dec 3, 2014 at 10:41 PM, Sam Tobin-Hochstadt <span dir=3D"ltr">&=
 lt;<a href=3D"mailto:samth@cs.indiana.edu" target=3D"_blank">samth@cs.india=
 na.edu</a>&gt;</span> wrote:<br><blockquote class=3D"gmail_quote" style=3D"=
 margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><span class=
 =3D"">On Wed, Dec 3, 2014 at 4:39 PM, Markus Bertheau &lt;<a href=3D"mailto=
 :mbertheau@gmail.com">mbertheau@gmail.com</a>&gt; wrote:<br>
 &gt; Thank you for your detailed analysis!<br>
 &gt;<br>
 &gt; However, I must report that I couldn&#39;t fix the behaviour with eith=
 er of the<br>
 &gt; two lines added to ~/.racketrc =E2=80=93 I&#39;m getting errors. I&#39=
 ;m quite a newbie to<br>
 &gt; racket and lisp, so I don&#39;t really know what they mean.<br>
 &gt;<br>
 &gt; If I add<br>
 &gt;<br>
 &gt; (file-stream-buffer-mode current-input-port &#39;none)<br>
 <br>
 </span>This should be:<br>
 <br>
 =C2=A0 =C2=A0 (file-stream-buffer-mode (current-input-port) &#39;none)<br>
 <br>
 because `current-input-port` is a parameter which you invoke to get the val=
 ue.<br>
 <span class=3D"HOEnZb"><font color=3D"#888888"><br>
 Sam<br>
 </font></span><div class=3D"HOEnZb"><div class=3D"h5"><br>
 &gt;<br>
 &gt; before (require xrepl), racket complains as follows:<br>
 &gt;<br>
 &gt; file-stream-buffer-mode: contract violation<br>
 &gt;=C2=A0 =C2=A0expected: port?<br>
 &gt;=C2=A0 =C2=A0given: #&lt;procedure:current-input-port&gt;<br>
 &gt;=C2=A0 =C2=A0argument position: 1st<br>
 &gt;=C2=A0 =C2=A0other arguments...:<br>
 &gt;=C2=A0 =C2=A0 &#39;none<br>
 &gt;<br>
 &gt; If I add<br>
 &gt;<br>
 &gt; (set-ffi-obj! &quot;rl_input_available_hook&quot; libreadline (_fun -&=
 gt; _bool)<br>
 &gt; byte-ready?)<br>
 &gt;<br>
 &gt; instead, racket complains<br>
 &gt;<br>
 &gt; /home/markus/.racketrc:1:58: -&gt;: bad syntax<br>
 &gt;=C2=A0 =C2=A0in: -&gt;<br>
 &gt;<br>
 &gt; Thank you for your efforts!<br>
 &gt;<br>
 &gt; On Wed, Dec 3, 2014 at 2:58 PM, Eli Barzilay &lt;<a href=3D"mailto:eli=
 @barzilay.org">eli@barzilay.org</a>&gt; wrote:<br>
 &gt;&gt;<br>
 &gt;&gt; [Matthew: one-line fix where it says &quot;one-line fix&quot;, but=
  also see the<br>
 &gt;&gt; &quot;this comment should be added&quot; later on.=C2=A0 I&#39;d m=
 ake this into a PR, but<br>
 &gt;&gt; it&#39;s not clear whether the new repos are ready for that.]<br>
 &gt;&gt;<br>
 &gt;&gt; On Wed, Dec 3, 2014 at 2:17 AM, Markus Bertheau &lt;<a href=3D"mai=
 lto:mbertheau@gmail.com">mbertheau@gmail.com</a>&gt;<br>
 &gt;&gt; wrote:<br>
 &gt;&gt; &gt; Ok, so here&#39;s a simple program that doesn&#39;t have any =
 customized readline<br>
 &gt;&gt; &gt; behaviour, that exhibits the expected behaviour:<br>
 &gt;&gt; &gt; [...]<br>
 &gt;&gt;<br>
 &gt;&gt; Ugh...=C2=A0 I didn&#39;t even think about trying C.=C2=A0 Racket =
 does the moral<br>
 &gt;&gt; equivalent of adding these to your code:<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0int my_getc(FILE *dummy) { return fgetc(stdin);=
  }<br>
 &gt;&gt;<br>
 &gt;&gt; and later:<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0rl_getc_function =3D my_getc;<br>
 &gt;&gt;<br>
 &gt;&gt; and adding that gets me the broken behavior.=C2=A0 I then went to =
 the<br>
 &gt;&gt; readline sources to look at rl_getc() -- and then main difference =
 is<br>
 &gt;&gt; that it uses read() on the fd number.=C2=A0 The difference is obvi=
 ous:<br>
 &gt;&gt; fgetc() buffers.<br>
 &gt;&gt;<br>
 &gt;&gt; So the one-line fix in &quot;rktrl.rkt&quot; is to add:<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(file-stream-buffer-mode real-input-port &#39;n=
 one)<br>
 &gt;&gt;<br>
 &gt;&gt; You can get that fixed now by adding that line to your .racketrc f=
 ile<br>
 &gt;&gt; before the require line, with (current-input-port) instead of<br>
 &gt;&gt; real-input-port.<br>
 &gt;&gt;<br>
 &gt;&gt; I can kind of see how something like buffering might mess things u=
 p: if<br>
 &gt;&gt; it reads as much as it wants instead of jsut one char, it might re=
 ad<br>
 &gt;&gt; some terminal reply that should have been intercepted by readline.=
 =C2=A0 Or<br>
 &gt;&gt; something.=C2=A0 But the weird thing is that this should have been=
  messing up<br>
 &gt;&gt; the emacs input mode too.=C2=A0 It looks like they had some kind o=
 f mess<br>
 &gt;&gt; (unsurprising) with the vi-mode reading being done differently tha=
 n<br>
 &gt;&gt; emacs-mode -- I found this in the readline changelog:<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0The vi-mode code now gets characters via the ap=
 plication-settable<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0value of rl_getc_function rather than calling r=
 l_getc directly.<br>
 &gt;&gt;<br>
 &gt;&gt; In any case, it might have been something that got recently notice=
 d and<br>
 &gt;&gt; fixed in readline, which in the most recent version (6.3) has this=
 <br>
 &gt;&gt; blurb added to the description of the `rl_getc_function&#39; globa=
 l:<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0In general, an application that sets @var{rl_ge=
 tc_function} should<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0consider setting @var{rl_input_available_hook} =
 as well.<br>
 &gt;&gt;<br>
 &gt;&gt; So a *better* fix than the above would be this:<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(set-ffi-obj! &quot;rl_input_available_hook&quo=
 t; libreadline (_fun -&gt; _bool)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0byte-ready?)<br>
 &gt;&gt;<br>
 &gt;&gt; but the problem with that is that this `rl_input_available_hook&#3=
 9; is a<br>
 &gt;&gt; new addition, and doesn&#39;t exist in 6.2...=C2=A0 I compiled 6.3=
  to verify that<br>
 &gt;&gt; this (without disabling buffering as above) indeed fixes the probl=
 em.<br>
 &gt;&gt;<br>
 &gt;&gt; So I think that this comment should be added:<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; According to the readline 6.3 documentation,=
  if we set<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; rl_getc_function then we should also set the=
  following.=C2=A0 But this<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; is a 6.3 addition, so it should be done when=
  6.3 is common enough<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; to depend on.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; (set-ffi-obj! &quot;rl_input_available_hook&=
 quot; libreadline (_fun -&gt; _bool)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0byte-ready?)<br>
 &gt;&gt;<br>
 &gt;&gt; (I&#39;d also add &quot;(Which hopefully might never happen since =
 someone will<br>
 &gt;&gt; surely write a racket readline-like implementation during the deca=
 de it<br>
 &gt;&gt; would take for 6.3 to spread enough.)&quot;)<br>
 &gt;&gt;<br>
 &gt;&gt; --<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0((lambda (x) (x x)) (lambd=
 a (x) (x x)))=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 Eli Barzilay:<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0<a href=3D"http://barzilay.org/" target=3D"_blank">http://barzila=
 y.org/</a>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0Maze is Life!<br>
 &gt;<br>
 &gt;<br>
 &gt;<br>
 &gt;<br>
 &gt; --<br>
 &gt; Markus Bertheau &lt;<a href=3D"mailto:mbertheau@gmail.com">mbertheau@g=
 mail.com</a>&gt;<br>
 </div></div></blockquote></div><br><br clear=3D"all"><div><br></div>-- <br>=
 <div class=3D"gmail_signature">Markus Bertheau &lt;<a href=3D"mailto:mberth=
 eau@gmail.com" target=3D"_blank">mbertheau@gmail.com</a>&gt;</div>
 </div>
 
 --089e01160fe2d811de050956c8b2--
