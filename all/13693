From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Sat Apr 13 14:54:19 2013
Received: from mail-ob0-f176.google.com (mail-ob0-f176.google.com [209.85.214.176])
	by champlain.ccs.neu.edu (8.14.4/8.14.4) with ESMTP id r3DIsFbp025447
	for <bugs@bugs.plt-scheme.org>; Sat, 13 Apr 2013 14:54:15 -0400
Message-Id: <201304131854.r3DIsD3b025441@champlain.ccs.neu.edu>
Date: Sat, 13 Apr 2013 14:54:13 -0400
From: matthias@ccs.neu.edu
To: bugs@racket-lang.org
Subject: class/c does not check that init-fields (specified) agree with init-fields (supplied)

>Number:         13693
>Category:       all
>Synopsis:       class/c does not check that init-fields (specified) agree with init-fields (supplied)
>Class:          sw-bug
>Responsible:    sstrickl
>Severity:       serious
>Priority:       medium
>State:          analyzed
>Confidential:   no
>Arrival-Date:   Sat Apr 13 14:56:01 -0400 2013
>Closed-Date:    
>Last-Modified:  Sun Apr 14 17:08:01 -0400 2013
>Originator:     matthias
>Organization:
plt
>Submitter-Id:   unknown
>Release:        5.3.4.3--2013-04-12(6642c114/d)
>Environment:
macosx "Darwin europeii.westell.com 11.4.2 Darwin Kernel Version 11.4.2: Thu Aug 23 16:25:48 PDT 2012; root:xnu-1699.32.7~1/RELEASE_X86_64 x86_64" (x86_64-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 520907672
Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()
raco pkg (show):
Installation-wide:
 [none]
User-specific, all-version:
 [none]
User-specific, version-specific (5.3.4.3):
 [none]



Collections:
("/Users/matthias/0Unison/collects/"
 ("._.DS_Store" ".DS_Store" "compiled" "date" "finance" "info-domain" "info.ss" "pdf.ss~" "session" "short" "testing" "tll-collects" "utils" "web"))
("/Users/matthias/Library/Racket/5.3.4.3/collects"
 (non-existent-path))
("/Users/matthias/plt/collects"
 (".gitignore" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compatibility" "compiler" "config" "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "future-visualizer" "games" "graphics" "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" "hierlist" "honu" "htdp" "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" "macro-debugger" "make" "math" "meta" "mred" "mrlib" "mysterx" "mz" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg" "plai" "planet" "planet2" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raclog" "raco" "racunit" "reader" "readline" "realm" "redex" "repo-time-stamp" "repos-time-stamp" "rnrs" "s-exp" "schelog" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" "string-constan!
 ts" "swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engine" "tests" "tex2page" "texpict" "tool" "trace" "typed" "typed-racket" "typed-scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml" "xrepl"))

Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t #t ((main) (test))))
>Description:
The program below should signal a contract error because turn% does not supply the 
init-fields that turn/c requires but the program runs w/o a hitch and creates an 
instance. 
>How-To-Repeat:
#lang racket

(module server racket 
  
  (provide 
   (contract-out 
    (turn% turn/c)))
  
  (define turn/c
    (class/c 
     (init-field (board integer?))
     ;; this method is called once, and exactly once 
     (place (->m integer? integer? (listof integer?)))))
  
  (define turn%
    (class object% 
      (init-field current-state current-tree)
      (field [board 1])
      (super-new)
      
      (define/public (place tile hotel)
        '()))))

(module client racket 
  (require (submod ".." server))
  
  (new turn% [current-state 1][current-tree 2]))

(require 'client)
>Fix:
>Audit-Trail:
Responsible changed from "nobody" to "sstrickl" by sstrickl at Sat, 13 Apr 2013 16:17:49 -0400
Reason>>> Issue in class/c

State changed from "open" to "analyzed" by sstrickl at Sat, 13 Apr 2013 16:17:49 -0400
Reason>>> Found the issue, working on the fix now.

State changed from "analyzed" to "closed" by sstrickl@racket-lang.org at Sat, 13 Apr 2013 17:31:53 -0400
Reason>>> A commit by sstrickl@racket-lang.org has resolved this report
  http://git.racket-lang.org/plt/commit/27b4df3eb5
  | Check that init args mentioned in contracts are provided.
  | 
  | Closes PR 13693.


State changed from "closed" to "analyzed" by sstrickl at Sat, 13 Apr 2013 17:36:25 -0400
Reason>>> My first fix was bogus, and though I tested it with contract-tests.rktl, I didn't test 
it with the entire codebase, and apparently the previous semantics were already 
important.

From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: matthias@ccs.neu.edu, bugs@racket-lang.org
Cc: nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields (specified) agree with init-fields (supplied)
Date: Sat, 13 Apr 2013 17:40:50 -0400

 Okay, so what should the behavior of a class/c contract in this situation be?  Right now, it checks the value if you provide one, and lets the underlying system catch the issue where you don't provide one and there isn't already a default value.  (Due to the dynamic nature of the initialization system, you can't really do better than this in general, otherwise we'd already have real first-order checks for init arg existence when contract wrapping.)
 
 We can't change things so that adding a contract mentioning an initialization argument forces the user to provide it by default (see my earlier commit and revert), but would you be okay with a #:force option, or something akin to that, which means "the user should always provide this initialization argument", that you would use in situations like yours?
 
 Stevie
 
 On Apr 13, 2013, at 2:56 PM, matthias@ccs.neu.edu wrote:
 
 > A new problem report is waiting at
 >  http://bugs.racket-lang.org/query/?cmd=view&pr=13693
 > 
 > Reported by matthias for release: 5.3.4.3--2013-04-12(6642c114/d)
 > 
 > *** Description:
 > The program below should signal a contract error because turn% does not supply the 
 > init-fields that turn/c requires but the program runs w/o a hitch and creates an 
 > instance. 
 > 
 > *** How to repeat:
 > #lang racket
 > 
 > (module server racket 
 > 
 >  (provide 
 >   (contract-out 
 >    (turn% turn/c)))
 > 
 >  (define turn/c
 >    (class/c 
 >     (init-field (board integer?))
 >     ;; this method is called once, and exactly once 
 >     (place (->m integer? integer? (listof integer?)))))
 > 
 >  (define turn%
 >    (class object% 
 >      (init-field current-state current-tree)
 >      (field [board 1])
 >      (super-new)
 > 
 >      (define/public (place tile hotel)
 >        '()))))
 > 
 > (module client racket 
 >  (require (submod ".." server))
 > 
 >  (new turn% [current-state 1][current-tree 2]))
 > 
 > (require 'client)
 > 
 > *** Environment:
 > macosx "Darwin europeii.westell.com 11.4.2 Darwin Kernel Version 11.4.2: Thu Aug 23 16:25:48 PDT 2012; root:xnu-1699.32.7~1/RELEASE_X86_64 x86_64" (x86_64-macosx/3m) (get-display-depth) = 32
 > Human Language: english
 > (current-memory-use) 520907672
 > Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()
 > raco pkg (show):
 > Installation-wide:
 > [none]
 > User-specific, all-version:
 > [none]
 > User-specific, version-specific (5.3.4.3):
 > [none]
 > 
 > 
 > 
 > Collections:
 > ("/Users/matthias/0Unison/collects/"
 > ("._.DS_Store" ".DS_Store" "compiled" "date" "finance" "info-domain" "info.ss" "pdf.ss~" "session" "short" "testing" "tll-collects" "utils" "web"))
 > ("/Users/matthias/Library/Racket/5.3.4.3/collects"
 > (non-existent-path))
 > ("/Users/matthias/plt/collects"
 > (".gitignore" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compatibility" "compiler" "config" "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "future-visualizer" "games" "graphics" "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" "hierlist" "honu" "htdp" "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" "macro-debugger" "make" "math" "meta" "mred" "mrlib" "mysterx" "mz" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "pkg" "plai" "planet" "planet2" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raclog" "raco" "racunit" "reader" "readline" "realm" "redex" "repo-time-stamp" "repos-time-stamp" "rnrs" "s-exp" "schelog" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" "string-constan!
 > ts" "swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engine" "tests" "tex2page" "texpict" "tool" "trace" "typed" "typed-racket" "typed-scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml" "xrepl"))
 > 
 > Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t #t ((main) (test))))
 > 
 
 
From: Asumu Takikawa <asumu@ccs.neu.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: matthias@ccs.neu.edu, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields
 (specified) agree with init-fields (supplied)
Date: Sat, 13 Apr 2013 17:52:53 -0400

 On 2013-04-13 17:40:50 -0400, Stevie Strickland wrote:
 > Okay, so what should the behavior of a class/c contract in this
 > situation be?  Right now, it checks the value if you provide one, and
 > lets the underlying system catch the issue where you don't provide one
 > and there isn't already a default value.  (Due to the dynamic nature
 > of the initialization system, you can't really do better than this in
 > general, otherwise we'd already have real first-order checks for init
 > arg existence when contract wrapping.)
 
 Is there any hope of fixing this at the init system level? It seems
 like introducing an additional option to patch over a deficiency in the
 init system is undesirable.
 
 Is it possible to figure out if a default is provided or not as long as
 `init-rest` is not used?
 
 Cheers,
 Asumu
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Asumu Takikawa <asumu@ccs.neu.edu>
Cc: matthias@ccs.neu.edu, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields (specified) agree with init-fields (supplied)
Date: Sat, 13 Apr 2013 17:59:27 -0400

 It's not just init-rest that's the problem. In fact, it's not really the problem. The problem is that (super-init ...) can appear at non-top-level positions, can appear multiple times, can appear under conditionals, etc., so there's no static analysis you can do during class form expansion that tells you which init-args have been provided to a superclass by a subclass, which means you can't calculate which init-args are safe or unsafe to provide during class initialization.
 
 Without that calculation, we can't do first-order checks of any kind, or anything else that depends on knowing that information like determining whether not providing a contracted init-arg is okay or not because of a default value.
 
 Well, other than revamping the init system to make it something we can calculate by limiting how super-new can be used.  The only reason it's not limited to the top-level currently is just to allow it to be nested within locking regions in certain mred classes, I believe, and even there it's only used once per class and not performed conditionally IIRC, but there may be more I'm forgetting.
 
 Stevie
 
 On Apr 13, 2013, at 5:52 PM, Asumu Takikawa <asumu@ccs.neu.edu> wrote:
 
 > On 2013-04-13 17:40:50 -0400, Stevie Strickland wrote:
 >> Okay, so what should the behavior of a class/c contract in this
 >> situation be?  Right now, it checks the value if you provide one, and
 >> lets the underlying system catch the issue where you don't provide one
 >> and there isn't already a default value.  (Due to the dynamic nature
 >> of the initialization system, you can't really do better than this in
 >> general, otherwise we'd already have real first-order checks for init
 >> arg existence when contract wrapping.)
 > 
 > Is there any hope of fixing this at the init system level? It seems
 > like introducing an additional option to patch over a deficiency in the
 > init system is undesirable.
 > 
 > Is it possible to figure out if a default is provided or not as long as
 > `init-rest` is not used?
 > 
 > Cheers,
 > Asumu
 
 
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields (specified) agree with init-fields (supplied)
Date: Sat, 13 Apr 2013 18:03:45 -0400

 Yes, this would help out Typed Racket tremendously as well as the contract system :)
 
 Stevie
 
 On Apr 13, 2013, at 6:02 PM, Sam Tobin-Hochstadt <samth@ccs.neu.edu> wrote:
 
 > On Sat, Apr 13, 2013 at 5:59 PM, Stevie Strickland <sstrickl@ccs.neu.edu> wrote:
 >> 
 >> Well, other than revamping the init system to make it something we can calculate by limiting how super-new can be used.
 > 
 > 
 > Please!
 
 
From: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields
 (specified) agree with init-fields (supplied)
Date: Sat, 13 Apr 2013 18:02:40 -0400

 On Sat, Apr 13, 2013 at 5:59 PM, Stevie Strickland <sstrickl@ccs.neu.edu> wrote:
 >
 > Well, other than revamping the init system to make it something we can calculate by limiting how super-new can be used.
 
 
 Please!
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields (specified) agree with init-fields (supplied)
Date: Sun, 14 Apr 2013 12:43:50 -0400

 1. That's backwards. TR can (and probably will have to) impose some discipline on how objects are initialized so that we can assign sound types. Keep in mind that computing is chaos, types provide some order. (Milner, not me) 
 
 2. I don't quite understand the problem here. 
 
 Say class Cl has a contract Co that specifies init argument a. Now say Cl doesn't even support a, but supports b. 
 
 Question 1: if some client supplies [a 1] should the contract monitoring fail? The new will fail because there is no a field. 
 
 Question 2: if some client supplies [b 1] should the contract monitoring fail? 
 
 I see that you have resolve this so that the contract catches the contradiction (my update just finished), and I think this is correct. 
 
 Is this a problem for existing code? 
 
 
 
 
 
 On Apr 13, 2013, at 6:03 PM, Stevie Strickland wrote:
 
 > Yes, this would help out Typed Racket tremendously as well as the contract system :)
 > 
 > Stevie
 > 
 > On Apr 13, 2013, at 6:02 PM, Sam Tobin-Hochstadt <samth@ccs.neu.edu> wrote:
 > 
 >> On Sat, Apr 13, 2013 at 5:59 PM, Stevie Strickland <sstrickl@ccs.neu.edu> wrote:
 >>> 
 >>> Well, other than revamping the init system to make it something we can calculate by limiting how super-new can be used.
 >> 
 >> 
 >> Please!
 > 
 
 
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields (specified) agree with init-fields (supplied)
Date: Sun, 14 Apr 2013 12:49:51 -0400

 On Apr 14, 2013, at 12:43 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 > 2. I don't quite understand the problem here. 
 > 
 > Say class Cl has a contract Co that specifies init argument a. Now say Cl doesn't even support a, but supports b. 
 
 The problem is that determining whether a given class supports a given initialization argument in our current initialization system is undecidable.
 
 Stevie
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields (specified) agree with init-fields (supplied)
Date: Sun, 14 Apr 2013 12:52:40 -0400

 However, positing an ideal world where we could decide that...
 
 On Apr 14, 2013, at 12:43 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 
 > Say class Cl has a contract Co that specifies init argument a. Now say Cl doesn't even support a, but supports b. 
 > 
 > Question 1: if some client supplies [a 1] should the contract monitoring fail? The new will fail because there is no a field. 
 
 Yes, it should.  (We can't in the current system because without actually trying the initialization, we can't determine this.)
 
 > Question 2: if some client supplies [b 1] should the contract monitoring fail? 
 
 In opaque class contracts, yes, and in translucent ones, no.  At least that's my initial guess, but I could be convinced differently on the second, since it seems like initialization is a different beast than feature existence/use.
 
 Stevie
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields (specified) agree with init-fields (supplied)
Date: Sun, 14 Apr 2013 13:35:59 -0400

 On Apr 14, 2013, at 12:52 PM, Stevie Strickland wrote:
 
 > However, positing an ideal world where we could decide that...
 > 
 > On Apr 14, 2013, at 12:43 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 > 
 >> Say class Cl has a contract Co that specifies init argument a. Now say Cl doesn't even support a, but supports b. 
 >> 
 >> Question 1: if some client supplies [a 1] should the contract monitoring fail? The new will fail because there is no a field. 
 > 
 > Yes, it should.  (We can't in the current system because without actually trying the initialization, we can't determine this.)
 > 
 >> Question 2: if some client supplies [b 1] should the contract monitoring fail? 
 > 
 > In opaque class contracts, yes, and in translucent ones, no.  At least that's my initial guess, but I could be convinced differently on the second, since it seems like initialization is a different beast than feature existence/use.
 
 
 Agreed. 
 
 > On Apr 14, 2013, at 12:43 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >> 2. I don't quite understand the problem here. 
 >> 
 >> Say class Cl has a contract Co that specifies init argument a. Now say Cl doesn't even support a, but supports b. 
 > 
 > The problem is that determining whether a given class supports a given initialization argument in our current initialization system is undecidable.
 
 
 I see the miscommunication problem. 
 
 I understand that we cannot catch this as a first-order check. But, when a client uses (new Cl [a 1]) in such a situation and the objection creation blows up, the blame should go Cl not the client, correct? 
 
 -- Matthias
 
 
 
 
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields (specified) agree with init-fields (supplied)
Date: Sun, 14 Apr 2013 13:47:30 -0400

 On Apr 14, 2013, at 1:35 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 > 
 > On Apr 14, 2013, at 12:52 PM, Stevie Strickland wrote:
 > 
 >> On Apr 14, 2013, at 12:43 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >>> 2. I don't quite understand the problem here. 
 >>> 
 >>> Say class Cl has a contract Co that specifies init argument a. Now say Cl doesn't even support a, but supports b. 
 >> 
 >> The problem is that determining whether a given class supports a given initialization argument in our current initialization system is undecidable.
 > 
 > I see the miscommunication problem. 
 > 
 > I understand that we cannot catch this as a first-order check. But, when a client uses (new Cl [a 1]) in such a situation and the objection creation blows up, the blame should go Cl not the client, correct? 
 
 Yes, I agree.  But currently, that's a runtime error, not a contract error, since we can't even catch it as a higher-order check without putting in an exception handler during initialization that catches the failure when an unused initialization argument reaches object%.
 
 Stevie
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields (specified) agree with init-fields (supplied)
Date: Sun, 14 Apr 2013 14:41:10 -0400

 Let me clarify, since I realized I'm somewhat mistaken: we could record what initialization arguments have been involved in the class hierarchy, so if the initialization argument was never declared, then yes, we could catch that.  However, if we have a class hierarchy similar to the following sketch:
 
 (define a%
   (class object%
     (super-new)
     (init a) ...))
 
 (define b%
   (class a%
     (if (... some condition ...)
         (super-new)
         (super-new [a 3]))
     ...))
 
 Whether or not (new b%) or (new b% [a 4]) is safe or not all depends on that condition, and can't be detected until we at least get to the first spot where that initialization argument was first declared.  (Once you throw the fact that initialization arguments with the same name can be redeclared at multiple levels, then it gets even more fun to decide when things have gone wrong.)
 
 Now, doing this kind of check would require passing the initialization argument contracts (or at least the fact that there were contracts on certain initialization arguments) upwards through the class hierarchy and checking at each step whether or not those initialization arguments were ever declared, which means additional overhead during object initialization for even uncontracted classes.
 
 So I'll grant that we could do some more expensive work here that would catch this issue, but I think it's worth first asking whether we even need (or want) the full power of the current semantics and, if not, figuring out a better, less expressive system.
 
 Stevie
 
 On Apr 14, 2013, at 1:47 PM, Stevie Strickland <sstrickl@ccs.neu.edu> wrote:
 
 > On Apr 14, 2013, at 1:35 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >> 
 >> On Apr 14, 2013, at 12:52 PM, Stevie Strickland wrote:
 >> 
 >>> On Apr 14, 2013, at 12:43 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >>>> 2. I don't quite understand the problem here. 
 >>>> 
 >>>> Say class Cl has a contract Co that specifies init argument a. Now say Cl doesn't even support a, but supports b. 
 >>> 
 >>> The problem is that determining whether a given class supports a given initialization argument in our current initialization system is undecidable.
 >> 
 >> I see the miscommunication problem. 
 >> 
 >> I understand that we cannot catch this as a first-order check. But, when a client uses (new Cl [a 1]) in such a situation and the objection creation blows up, the blame should go Cl not the client, correct? 
 > 
 > Yes, I agree.  But currently, that's a runtime error, not a contract error, since we can't even catch it as a higher-order check without putting in an exception handler during initialization that catches the failure when an unused initialization argument reaches object%.
 > 
 > Stevie
 
 
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields (specified) agree with init-fields (supplied)
Date: Sun, 14 Apr 2013 16:55:20 -0400

 --Apple-Mail=_D51BE0F7-CC9A-4BE3-B91F-F2D7510B71D3
 Content-Transfer-Encoding: quoted-printable
 Content-Type: text/plain;
 	charset=us-ascii
 
 That's the change I tried yesterday and had to back out, because there =
 are already contracts that have init-args, but where the use of those =
 classes take advantage of default arguments.  (You can try reapplying my =
 earlier commit and see where it breaks if you're interested.)
 
 Stevie
 
 On Apr 14, 2013, at 4:52 PM, Robby Findler <robby@eecs.northwestern.edu> =
 wrote:
 
 > I'm not sure if this is a stupid question or not, but why not have =
 init arg declarations influence "new" by saying "if I have a class =
 contract on a class that says that x, y, and z are supplied, then they =
 must be actually written down in the 'new' expression that also has that =
 class" and "if a class with such a contract is extended, then all of =
 those arguments must be set by the time we reach the super call that =
 gets to that class".
 >=20
 > That is, we could turn this in code like this:
 >=20
 > #lang racket
 >=20
 > ;; returns a class that will signal an error if it doesn't get x,y,z.
 > (define (xyz-args-proj %)
 >   (class %
 >     (init [x (error "expected an x arg")]
 >           [y (error "expected a y arg")]
 >           [z (error "expected a z arg")])
 >     (super-new [x x] [y y] [z z])))
 >=20
 >=20
 > (define c%
 >   (class object%
 >     (init x y z)
 >     (printf "x ~s y ~s z ~s\n" x y z)
 >     (super-new)))
 >=20
 > (define c-with-contract% (xyz-args-proj c%))
 > (define d%
 >   (class c-with-contract%
 >     (super-new [x 1])))
 >=20
 > (new d% [y 2] [z 3])
 > (new d% [y 2])
 >=20
 > I think this approach would handle Stevie's example: if "a" shows up =
 somewhere (either because "... some condition..." is false or because it =
 was true but a was passed to 'new') then there won't be a violation.
 >=20
 > ---
 >=20
 > Separately, I think the argument one might posit for it being =
 important to be able to say
 >=20
 >   (super-new)
 >=20
 > and have the arguments just pass thru is to support mixins. That is, I =
 think the standard argument is that we don't want mixins to have to =
 declare which argument sets they work with.
 >=20
 > But I'm not actually sure if this is a good argument. We have enough =
 code that I'd say that if we can change it to accomodate some =
 restriction than we're in good shape.
 >=20
 > Robby
 >=20
 >=20
 > On Sun, Apr 14, 2013 at 1:41 PM, Stevie Strickland =
 <sstrickl@ccs.neu.edu> wrote:
 > Let me clarify, since I realized I'm somewhat mistaken: we could =
 record what initialization arguments have been involved in the class =
 hierarchy, so if the initialization argument was never declared, then =
 yes, we could catch that.  However, if we have a class hierarchy similar =
 to the following sketch:
 >=20
 > (define a%
 >   (class object%
 >     (super-new)
 >     (init a) ...))
 >=20
 > (define b%
 >   (class a%
 >     (if (... some condition ...)
 >         (super-new)
 >         (super-new [a 3]))
 >     ...))
 >=20
 > Whether or not (new b%) or (new b% [a 4]) is safe or not all depends =
 on that condition, and can't be detected until we at least get to the =
 first spot where that initialization argument was first declared.  (Once =
 you throw the fact that initialization arguments with the same name can =
 be redeclared at multiple levels, then it gets even more fun to decide =
 when things have gone wrong.)
 >=20
 > Now, doing this kind of check would require passing the initialization =
 argument contracts (or at least the fact that there were contracts on =
 certain initialization arguments) upwards through the class hierarchy =
 and checking at each step whether or not those initialization arguments =
 were ever declared, which means additional overhead during object =
 initialization for even uncontracted classes.
 >=20
 > So I'll grant that we could do some more expensive work here that =
 would catch this issue, but I think it's worth first asking whether we =
 even need (or want) the full power of the current semantics and, if not, =
 figuring out a better, less expressive system.
 >=20
 > Stevie
 >=20
 > On Apr 14, 2013, at 1:47 PM, Stevie Strickland <sstrickl@ccs.neu.edu> =
 wrote:
 >=20
 > > On Apr 14, 2013, at 1:35 PM, Matthias Felleisen =
 <matthias@ccs.neu.edu> wrote:
 > >>
 > >> On Apr 14, 2013, at 12:52 PM, Stevie Strickland wrote:
 > >>
 > >>> On Apr 14, 2013, at 12:43 PM, Matthias Felleisen =
 <matthias@ccs.neu.edu> wrote:
 > >>>> 2. I don't quite understand the problem here.
 > >>>>
 > >>>> Say class Cl has a contract Co that specifies init argument a. =
 Now say Cl doesn't even support a, but supports b.
 > >>>
 > >>> The problem is that determining whether a given class supports a =
 given initialization argument in our current initialization system is =
 undecidable.
 > >>
 > >> I see the miscommunication problem.
 > >>
 > >> I understand that we cannot catch this as a first-order check. But, =
 when a client uses (new Cl [a 1]) in such a situation and the objection =
 creation blows up, the blame should go Cl not the client, correct?
 > >
 > > Yes, I agree.  But currently, that's a runtime error, not a contract =
 error, since we can't even catch it as a higher-order check without =
 putting in an exception handler during initialization that catches the =
 failure when an unused initialization argument reaches object%.
 > >
 > > Stevie
 >=20
 >=20
 
 
 --Apple-Mail=_D51BE0F7-CC9A-4BE3-B91F-F2D7510B71D3
 Content-Transfer-Encoding: quoted-printable
 Content-Type: text/html;
 	charset=us-ascii
 
 <html><head><meta http-equiv=3D"Content-Type" content=3D"text/html =
 charset=3Dus-ascii"></head><body style=3D"word-wrap: break-word; =
 -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; =
 "><div>That's the change I tried yesterday and had to back out, because =
 there are already contracts that have init-args, but where the use of =
 those classes take advantage of default arguments. &nbsp;(You can try =
 reapplying my earlier commit and see where it breaks if you're =
 interested.)</div><div><br></div><div>Stevie</div><br><div><div>On Apr =
 14, 2013, at 4:52 PM, Robby Findler &lt;<a =
 href=3D"mailto:robby@eecs.northwestern.edu">robby@eecs.northwestern.edu</a=
 >&gt; wrote:</div><br class=3D"Apple-interchange-newline"><blockquote =
 type=3D"cite"><div dir=3D"ltr"><div style=3D"">I'm not sure if this is a =
 stupid question or not, but why not have init arg declarations influence =
 "new" by saying "if I have a class contract on a class that says that x, =
 y, and z are supplied, then they must be actually written down in the =
 'new' expression that also has that class" and "if a class with such a =
 contract is extended, then all of those arguments must be set by the =
 time we reach the super call that gets to that class".</div>
 <div style=3D""><br></div><div style=3D"">That is, we could turn this in =
 code like this:</div><div style=3D""><br></div><div style=3D""><div>#lang =
 racket</div><div><br></div><div>;; returns a class that will signal an =
 error if it doesn't get x,y,z.</div>
 <div>(define (xyz-args-proj %)</div><div>&nbsp; (class =
 %</div><div>&nbsp; &nbsp; (init [x (error "expected an x =
 arg")]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [y (error "expected =
 a y arg")]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [z (error =
 "expected a z arg")])</div>
 <div>&nbsp; &nbsp; (super-new [x x] [y y] [z =
 z])))</div><div><br></div><div><br></div><div>(define =
 c%</div><div>&nbsp; (class object%</div><div>&nbsp; &nbsp; (init x y =
 z)</div><div>&nbsp; &nbsp; (printf "x ~s y ~s z ~s\n" x y =
 z)</div><div>&nbsp; &nbsp; (super-new)))</div>
 <div><br></div><div>(define c-with-contract% (xyz-args-proj =
 c%))</div><div>(define d%</div><div>&nbsp; (class =
 c-with-contract%</div><div>&nbsp; &nbsp; (super-new [x =
 1])))</div><div><br></div><div>(new d% [y 2] [z 3])</div><div>(new d% [y =
 2])</div>
 <div><br></div></div><div style=3D"">I think this approach would handle =
 Stevie's example: if "a" shows up somewhere (either because "... some =
 condition..." is false or because it was true but a was passed to 'new') =
 then there won't be a violation.</div>
 <div style=3D""><br></div><div>---</div><div><br></div>Separately, I =
 think the argument one might posit for it being important to be able to =
 say<div><br></div><div style=3D"">&nbsp; (super-new)</div><div =
 style=3D""><br></div><div style=3D"">and have the arguments just pass =
 thru is to support mixins. That is, I think the standard argument is =
 that we don't want mixins to have to declare which argument sets they =
 work with.</div>
 <div style=3D""><br></div><div style=3D"">But I'm not actually sure if =
 this is a good argument. We have enough code that I'd say that if we can =
 change it to accomodate some restriction than we're in good =
 shape.</div><div style=3D"">
 <br></div><div style=3D"">Robby</div><div =
 class=3D"gmail_extra"><br><br><div class=3D"gmail_quote">On Sun, Apr 14, =
 2013 at 1:41 PM, Stevie Strickland <span dir=3D"ltr">&lt;<a =
 href=3D"mailto:sstrickl@ccs.neu.edu" =
 target=3D"_blank">sstrickl@ccs.neu.edu</a>&gt;</span> wrote:<br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px =
 0.8ex;border-left-width:1px;border-left-color:rgb(204,204,204);border-left=
 -style:solid;padding-left:1ex">Let me clarify, since I realized I'm =
 somewhat mistaken: we could record what initialization arguments have =
 been involved in the class hierarchy, so if the initialization argument =
 was never declared, then yes, we could catch that. &nbsp;However, if we =
 have a class hierarchy similar to the following sketch:<br>
 
 <br>
 (define a%<br>
 &nbsp; (class object%<br>
 &nbsp; &nbsp; (super-new)<br>
 &nbsp; &nbsp; (init a) ...))<br>
 <br>
 (define b%<br>
 &nbsp; (class a%<br>
 &nbsp; &nbsp; (if (... some condition ...)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (super-new)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (super-new [a 3]))<br>
 &nbsp; &nbsp; ...))<br>
 <br>
 Whether or not (new b%) or (new b% [a 4]) is safe or not all depends on =
 that condition, and can't be detected until we at least get to the first =
 spot where that initialization argument was first declared. &nbsp;(Once =
 you throw the fact that initialization arguments with the same name can =
 be redeclared at multiple levels, then it gets even more fun to decide =
 when things have gone wrong.)<br>
 
 <br>
 Now, doing this kind of check would require passing the initialization =
 argument contracts (or at least the fact that there were contracts on =
 certain initialization arguments) upwards through the class hierarchy =
 and checking at each step whether or not those initialization arguments =
 were ever declared, which means additional overhead during object =
 initialization for even uncontracted classes.<br>
 
 <br>
 So I'll grant that we could do some more expensive work here that would =
 catch this issue, but I think it's worth first asking whether we even =
 need (or want) the full power of the current semantics and, if not, =
 figuring out a better, less expressive system.<br>
 
 <span class=3D""><font color=3D"#888888"><br>
 Stevie<br>
 </font></span><div class=3D""><div class=3D"h5"><br>
 On Apr 14, 2013, at 1:47 PM, Stevie Strickland &lt;<a =
 href=3D"mailto:sstrickl@ccs.neu.edu">sstrickl@ccs.neu.edu</a>&gt; =
 wrote:<br>
 <br>
 &gt; On Apr 14, 2013, at 1:35 PM, Matthias Felleisen &lt;<a =
 href=3D"mailto:matthias@ccs.neu.edu">matthias@ccs.neu.edu</a>&gt; =
 wrote:<br>
 &gt;&gt;<br>
 &gt;&gt; On Apr 14, 2013, at 12:52 PM, Stevie Strickland wrote:<br>
 &gt;&gt;<br>
 &gt;&gt;&gt; On Apr 14, 2013, at 12:43 PM, Matthias Felleisen &lt;<a =
 href=3D"mailto:matthias@ccs.neu.edu">matthias@ccs.neu.edu</a>&gt; =
 wrote:<br>
 &gt;&gt;&gt;&gt; 2. I don't quite understand the problem here.<br>
 &gt;&gt;&gt;&gt;<br>
 &gt;&gt;&gt;&gt; Say class Cl has a contract Co that specifies init =
 argument a. Now say Cl doesn't even support a, but supports b.<br>
 &gt;&gt;&gt;<br>
 &gt;&gt;&gt; The problem is that determining whether a given class =
 supports a given initialization argument in our current initialization =
 system is undecidable.<br>
 &gt;&gt;<br>
 &gt;&gt; I see the miscommunication problem.<br>
 &gt;&gt;<br>
 &gt;&gt; I understand that we cannot catch this as a first-order check. =
 But, when a client uses (new Cl [a 1]) in such a situation and the =
 objection creation blows up, the blame should go Cl not the client, =
 correct?<br>
 &gt;<br>
 &gt; Yes, I agree. &nbsp;But currently, that's a runtime error, not a =
 contract error, since we can't even catch it as a higher-order check =
 without putting in an exception handler during initialization that =
 catches the failure when an unused initialization argument reaches =
 object%.<br>
 
 &gt;<br>
 &gt; Stevie<br>
 <br>
 </div></div></blockquote></div><br></div></div>
 </blockquote></div><br></body></html>=
 
 --Apple-Mail=_D51BE0F7-CC9A-4BE3-B91F-F2D7510B71D3--
From: Robby Findler <robby@eecs.northwestern.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields
 (specified) agree with init-fields (supplied)
Date: Sun, 14 Apr 2013 15:52:57 -0500

 --001a11c1ff722d26aa04da5852f7
 Content-Type: text/plain; charset=UTF-8
 
 I'm not sure if this is a stupid question or not, but why not have init arg
 declarations influence "new" by saying "if I have a class contract on a
 class that says that x, y, and z are supplied, then they must be actually
 written down in the 'new' expression that also has that class" and "if a
 class with such a contract is extended, then all of those arguments must be
 set by the time we reach the super call that gets to that class".
 
 That is, we could turn this in code like this:
 
 #lang racket
 
 ;; returns a class that will signal an error if it doesn't get x,y,z.
 (define (xyz-args-proj %)
   (class %
     (init [x (error "expected an x arg")]
           [y (error "expected a y arg")]
           [z (error "expected a z arg")])
     (super-new [x x] [y y] [z z])))
 
 
 (define c%
   (class object%
     (init x y z)
     (printf "x ~s y ~s z ~s\n" x y z)
     (super-new)))
 
 (define c-with-contract% (xyz-args-proj c%))
 (define d%
   (class c-with-contract%
     (super-new [x 1])))
 
 (new d% [y 2] [z 3])
 (new d% [y 2])
 
 I think this approach would handle Stevie's example: if "a" shows up
 somewhere (either because "... some condition..." is false or because it
 was true but a was passed to 'new') then there won't be a violation.
 
 ---
 
 Separately, I think the argument one might posit for it being important to
 be able to say
 
   (super-new)
 
 and have the arguments just pass thru is to support mixins. That is, I
 think the standard argument is that we don't want mixins to have to declare
 which argument sets they work with.
 
 But I'm not actually sure if this is a good argument. We have enough code
 that I'd say that if we can change it to accomodate some restriction than
 we're in good shape.
 
 Robby
 
 
 On Sun, Apr 14, 2013 at 1:41 PM, Stevie Strickland <sstrickl@ccs.neu.edu>wrote:
 
 > Let me clarify, since I realized I'm somewhat mistaken: we could record
 > what initialization arguments have been involved in the class hierarchy, so
 > if the initialization argument was never declared, then yes, we could catch
 > that.  However, if we have a class hierarchy similar to the following
 > sketch:
 >
 > (define a%
 >   (class object%
 >     (super-new)
 >     (init a) ...))
 >
 > (define b%
 >   (class a%
 >     (if (... some condition ...)
 >         (super-new)
 >         (super-new [a 3]))
 >     ...))
 >
 > Whether or not (new b%) or (new b% [a 4]) is safe or not all depends on
 > that condition, and can't be detected until we at least get to the first
 > spot where that initialization argument was first declared.  (Once you
 > throw the fact that initialization arguments with the same name can be
 > redeclared at multiple levels, then it gets even more fun to decide when
 > things have gone wrong.)
 >
 > Now, doing this kind of check would require passing the initialization
 > argument contracts (or at least the fact that there were contracts on
 > certain initialization arguments) upwards through the class hierarchy and
 > checking at each step whether or not those initialization arguments were
 > ever declared, which means additional overhead during object initialization
 > for even uncontracted classes.
 >
 > So I'll grant that we could do some more expensive work here that would
 > catch this issue, but I think it's worth first asking whether we even need
 > (or want) the full power of the current semantics and, if not, figuring out
 > a better, less expressive system.
 >
 > Stevie
 >
 > On Apr 14, 2013, at 1:47 PM, Stevie Strickland <sstrickl@ccs.neu.edu>
 > wrote:
 >
 > > On Apr 14, 2013, at 1:35 PM, Matthias Felleisen <matthias@ccs.neu.edu>
 > wrote:
 > >>
 > >> On Apr 14, 2013, at 12:52 PM, Stevie Strickland wrote:
 > >>
 > >>> On Apr 14, 2013, at 12:43 PM, Matthias Felleisen <matthias@ccs.neu.edu>
 > wrote:
 > >>>> 2. I don't quite understand the problem here.
 > >>>>
 > >>>> Say class Cl has a contract Co that specifies init argument a. Now
 > say Cl doesn't even support a, but supports b.
 > >>>
 > >>> The problem is that determining whether a given class supports a given
 > initialization argument in our current initialization system is undecidable.
 > >>
 > >> I see the miscommunication problem.
 > >>
 > >> I understand that we cannot catch this as a first-order check. But,
 > when a client uses (new Cl [a 1]) in such a situation and the objection
 > creation blows up, the blame should go Cl not the client, correct?
 > >
 > > Yes, I agree.  But currently, that's a runtime error, not a contract
 > error, since we can't even catch it as a higher-order check without putting
 > in an exception handler during initialization that catches the failure when
 > an unused initialization argument reaches object%.
 > >
 > > Stevie
 >
 >
 
 --001a11c1ff722d26aa04da5852f7
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 <div dir=3D"ltr"><div style>I&#39;m not sure if this is a stupid question o=
 r not, but why not have init arg declarations influence &quot;new&quot; by =
 saying &quot;if I have a class contract on a class that says that x, y, and=
  z are supplied, then they must be actually written down in the &#39;new&#3=
 9; expression that also has that class&quot; and &quot;if a class with such=
  a contract is extended, then all of those arguments must be set by the tim=
 e we reach the super call that gets to that class&quot;.</div>
 <div style><br></div><div style>That is, we could turn this in code like th=
 is:</div><div style><br></div><div style><div>#lang racket</div><div><br></=
 div><div>;; returns a class that will signal an error if it doesn&#39;t get=
  x,y,z.</div>
 <div>(define (xyz-args-proj %)</div><div>=C2=A0 (class %</div><div>=C2=A0 =
 =C2=A0 (init [x (error &quot;expected an x arg&quot;)]</div><div>=C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 [y (error &quot;expected a y arg&quot;)]</div><div=
 >=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [z (error &quot;expected a z arg&quot;)=
 ])</div>
 <div>=C2=A0 =C2=A0 (super-new [x x] [y y] [z z])))</div><div><br></div><div=
 ><br></div><div>(define c%</div><div>=C2=A0 (class object%</div><div>=C2=A0=
  =C2=A0 (init x y z)</div><div>=C2=A0 =C2=A0 (printf &quot;x ~s y ~s z ~s\n=
 &quot; x y z)</div><div>=C2=A0 =C2=A0 (super-new)))</div>
 <div><br></div><div>(define c-with-contract% (xyz-args-proj c%))</div><div>=
 (define d%</div><div>=C2=A0 (class c-with-contract%</div><div>=C2=A0 =C2=A0=
  (super-new [x 1])))</div><div><br></div><div>(new d% [y 2] [z 3])</div><di=
 v>(new d% [y 2])</div>
 <div><br></div></div><div style>I think this approach would handle Stevie&#=
 39;s example: if &quot;a&quot; shows up somewhere (either because &quot;...=
  some condition...&quot; is false or because it was true but a was passed t=
 o &#39;new&#39;) then there won&#39;t be a violation.</div>
 <div style><br></div><div>---</div><div><br></div>Separately, I think the a=
 rgument one might posit for it being important to be able to say<div><br></=
 div><div style>=C2=A0 (super-new)</div><div style><br></div><div style>and =
 have the arguments just pass thru is to support mixins. That is, I think th=
 e standard argument is that we don&#39;t want mixins to have to declare whi=
 ch argument sets they work with.</div>
 <div style><br></div><div style>But I&#39;m not actually sure if this is a =
 good argument. We have enough code that I&#39;d say that if we can change i=
 t to accomodate some restriction than we&#39;re in good shape.</div><div st=
 yle>
 <br></div><div style>Robby</div><div class=3D"gmail_extra"><br><br><div cla=
 ss=3D"gmail_quote">On Sun, Apr 14, 2013 at 1:41 PM, Stevie Strickland <span=
  dir=3D"ltr">&lt;<a href=3D"mailto:sstrickl@ccs.neu.edu" target=3D"_blank">=
 sstrickl@ccs.neu.edu</a>&gt;</span> wrote:<br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border-=
 left-width:1px;border-left-color:rgb(204,204,204);border-left-style:solid;p=
 adding-left:1ex">Let me clarify, since I realized I&#39;m somewhat mistaken=
 : we could record what initialization arguments have been involved in the c=
 lass hierarchy, so if the initialization argument was never declared, then =
 yes, we could catch that. =C2=A0However, if we have a class hierarchy simil=
 ar to the following sketch:<br>
 
 <br>
 (define a%<br>
 =C2=A0 (class object%<br>
 =C2=A0 =C2=A0 (super-new)<br>
 =C2=A0 =C2=A0 (init a) ...))<br>
 <br>
 (define b%<br>
 =C2=A0 (class a%<br>
 =C2=A0 =C2=A0 (if (... some condition ...)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (super-new)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (super-new [a 3]))<br>
 =C2=A0 =C2=A0 ...))<br>
 <br>
 Whether or not (new b%) or (new b% [a 4]) is safe or not all depends on tha=
 t condition, and can&#39;t be detected until we at least get to the first s=
 pot where that initialization argument was first declared. =C2=A0(Once you =
 throw the fact that initialization arguments with the same name can be rede=
 clared at multiple levels, then it gets even more fun to decide when things=
  have gone wrong.)<br>
 
 <br>
 Now, doing this kind of check would require passing the initialization argu=
 ment contracts (or at least the fact that there were contracts on certain i=
 nitialization arguments) upwards through the class hierarchy and checking a=
 t each step whether or not those initialization arguments were ever declare=
 d, which means additional overhead during object initialization for even un=
 contracted classes.<br>
 
 <br>
 So I&#39;ll grant that we could do some more expensive work here that would=
  catch this issue, but I think it&#39;s worth first asking whether we even =
 need (or want) the full power of the current semantics and, if not, figurin=
 g out a better, less expressive system.<br>
 
 <span class=3D""><font color=3D"#888888"><br>
 Stevie<br>
 </font></span><div class=3D""><div class=3D"h5"><br>
 On Apr 14, 2013, at 1:47 PM, Stevie Strickland &lt;<a href=3D"mailto:sstric=
 kl@ccs.neu.edu">sstrickl@ccs.neu.edu</a>&gt; wrote:<br>
 <br>
 &gt; On Apr 14, 2013, at 1:35 PM, Matthias Felleisen &lt;<a href=3D"mailto:=
 matthias@ccs.neu.edu">matthias@ccs.neu.edu</a>&gt; wrote:<br>
 &gt;&gt;<br>
 &gt;&gt; On Apr 14, 2013, at 12:52 PM, Stevie Strickland wrote:<br>
 &gt;&gt;<br>
 &gt;&gt;&gt; On Apr 14, 2013, at 12:43 PM, Matthias Felleisen &lt;<a href=
 =3D"mailto:matthias@ccs.neu.edu">matthias@ccs.neu.edu</a>&gt; wrote:<br>
 &gt;&gt;&gt;&gt; 2. I don&#39;t quite understand the problem here.<br>
 &gt;&gt;&gt;&gt;<br>
 &gt;&gt;&gt;&gt; Say class Cl has a contract Co that specifies init argumen=
 t a. Now say Cl doesn&#39;t even support a, but supports b.<br>
 &gt;&gt;&gt;<br>
 &gt;&gt;&gt; The problem is that determining whether a given class supports=
  a given initialization argument in our current initialization system is un=
 decidable.<br>
 &gt;&gt;<br>
 &gt;&gt; I see the miscommunication problem.<br>
 &gt;&gt;<br>
 &gt;&gt; I understand that we cannot catch this as a first-order check. But=
 , when a client uses (new Cl [a 1]) in such a situation and the objection c=
 reation blows up, the blame should go Cl not the client, correct?<br>
 &gt;<br>
 &gt; Yes, I agree. =C2=A0But currently, that&#39;s a runtime error, not a c=
 ontract error, since we can&#39;t even catch it as a higher-order check wit=
 hout putting in an exception handler during initialization that catches the=
  failure when an unused initialization argument reaches object%.<br>
 
 &gt;<br>
 &gt; Stevie<br>
 <br>
 </div></div></blockquote></div><br></div></div>
 
 --001a11c1ff722d26aa04da5852f7--
From: Robby Findler <robby@eecs.northwestern.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields
 (specified) agree with init-fields (supplied)
Date: Sun, 14 Apr 2013 15:59:29 -0500

 --001a11c1ff7292c93e04da5869e6
 Content-Type: text/plain; charset=UTF-8
 
 You mean something like this fragment? If so, then I'd say that the
 contract has to explicitly allow 'x' to be optional, or else it is a bad
 contract.
 
 Is that wrong?
 
 #lang racket
 ;; returns a class that will signal an error if it doesn't get x,y,z.
 (define (xyz-args-proj %)
   (class %
     (init [x (error "expected an x arg")]
           [y (error "expected a y arg")]
           [z (error "expected a z arg")])
     (super-new [x x] [y y] [z z])))
 
 
 (define c%
   (class object%
     (init x y [z 1])
     (printf "x ~s y ~s z ~s\n" x y z)
     (super-new)))
 
 (define c-with-contract% (xyz-args-proj c%))
 (define d%
   (class c-with-contract%
     (super-new)))
 
 (new d% [x 1] [y 2])
 
 
 
 On Sun, Apr 14, 2013 at 3:55 PM, Stevie Strickland <sstrickl@ccs.neu.edu>wrote:
 
 > That's the change I tried yesterday and had to back out, because there are
 > already contracts that have init-args, but where the use of those classes
 > take advantage of default arguments.  (You can try reapplying my earlier
 > commit and see where it breaks if you're interested.)
 >
 > Stevie
 >
 > On Apr 14, 2013, at 4:52 PM, Robby Findler <robby@eecs.northwestern.edu>
 > wrote:
 >
 > I'm not sure if this is a stupid question or not, but why not have init
 > arg declarations influence "new" by saying "if I have a class contract on a
 > class that says that x, y, and z are supplied, then they must be actually
 > written down in the 'new' expression that also has that class" and "if a
 > class with such a contract is extended, then all of those arguments must be
 > set by the time we reach the super call that gets to that class".
 >
 > That is, we could turn this in code like this:
 >
 > #lang racket
 >
 > ;; returns a class that will signal an error if it doesn't get x,y,z.
 > (define (xyz-args-proj %)
 >   (class %
 >     (init [x (error "expected an x arg")]
 >           [y (error "expected a y arg")]
 >           [z (error "expected a z arg")])
 >     (super-new [x x] [y y] [z z])))
 >
 >
 > (define c%
 >   (class object%
 >     (init x y z)
 >     (printf "x ~s y ~s z ~s\n" x y z)
 >     (super-new)))
 >
 > (define c-with-contract% (xyz-args-proj c%))
 > (define d%
 >   (class c-with-contract%
 >     (super-new [x 1])))
 >
 > (new d% [y 2] [z 3])
 > (new d% [y 2])
 >
 > I think this approach would handle Stevie's example: if "a" shows up
 > somewhere (either because "... some condition..." is false or because it
 > was true but a was passed to 'new') then there won't be a violation.
 >
 > ---
 >
 > Separately, I think the argument one might posit for it being important to
 > be able to say
 >
 >   (super-new)
 >
 > and have the arguments just pass thru is to support mixins. That is, I
 > think the standard argument is that we don't want mixins to have to declare
 > which argument sets they work with.
 >
 > But I'm not actually sure if this is a good argument. We have enough code
 > that I'd say that if we can change it to accomodate some restriction than
 > we're in good shape.
 >
 > Robby
 >
 >
 > On Sun, Apr 14, 2013 at 1:41 PM, Stevie Strickland <sstrickl@ccs.neu.edu>wrote:
 >
 >> Let me clarify, since I realized I'm somewhat mistaken: we could record
 >> what initialization arguments have been involved in the class hierarchy, so
 >> if the initialization argument was never declared, then yes, we could catch
 >> that.  However, if we have a class hierarchy similar to the following
 >> sketch:
 >>
 >> (define a%
 >>   (class object%
 >>     (super-new)
 >>     (init a) ...))
 >>
 >> (define b%
 >>   (class a%
 >>     (if (... some condition ...)
 >>         (super-new)
 >>         (super-new [a 3]))
 >>     ...))
 >>
 >> Whether or not (new b%) or (new b% [a 4]) is safe or not all depends on
 >> that condition, and can't be detected until we at least get to the first
 >> spot where that initialization argument was first declared.  (Once you
 >> throw the fact that initialization arguments with the same name can be
 >> redeclared at multiple levels, then it gets even more fun to decide when
 >> things have gone wrong.)
 >>
 >> Now, doing this kind of check would require passing the initialization
 >> argument contracts (or at least the fact that there were contracts on
 >> certain initialization arguments) upwards through the class hierarchy and
 >> checking at each step whether or not those initialization arguments were
 >> ever declared, which means additional overhead during object initialization
 >> for even uncontracted classes.
 >>
 >> So I'll grant that we could do some more expensive work here that would
 >> catch this issue, but I think it's worth first asking whether we even need
 >> (or want) the full power of the current semantics and, if not, figuring out
 >> a better, less expressive system.
 >>
 >> Stevie
 >>
 >> On Apr 14, 2013, at 1:47 PM, Stevie Strickland <sstrickl@ccs.neu.edu>
 >> wrote:
 >>
 >> > On Apr 14, 2013, at 1:35 PM, Matthias Felleisen <matthias@ccs.neu.edu>
 >> wrote:
 >> >>
 >> >> On Apr 14, 2013, at 12:52 PM, Stevie Strickland wrote:
 >> >>
 >> >>> On Apr 14, 2013, at 12:43 PM, Matthias Felleisen <
 >> matthias@ccs.neu.edu> wrote:
 >> >>>> 2. I don't quite understand the problem here.
 >> >>>>
 >> >>>> Say class Cl has a contract Co that specifies init argument a. Now
 >> say Cl doesn't even support a, but supports b.
 >> >>>
 >> >>> The problem is that determining whether a given class supports a
 >> given initialization argument in our current initialization system is
 >> undecidable.
 >> >>
 >> >> I see the miscommunication problem.
 >> >>
 >> >> I understand that we cannot catch this as a first-order check. But,
 >> when a client uses (new Cl [a 1]) in such a situation and the objection
 >> creation blows up, the blame should go Cl not the client, correct?
 >> >
 >> > Yes, I agree.  But currently, that's a runtime error, not a contract
 >> error, since we can't even catch it as a higher-order check without putting
 >> in an exception handler during initialization that catches the failure when
 >> an unused initialization argument reaches object%.
 >> >
 >> > Stevie
 >>
 >>
 >
 >
 
 --001a11c1ff7292c93e04da5869e6
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 <div dir=3D"ltr">You mean something like this fragment? If so, then I&#39;d=
  say that the contract has to explicitly allow &#39;x&#39; to be optional, =
 or else it is a bad contract.=C2=A0<div><br></div><div>Is that wrong?<br><d=
 iv></div>
 <div><br></div><div><div>#lang racket</div><div>;; returns a class that wil=
 l signal an error if it doesn&#39;t get x,y,z.</div><div>(define (xyz-args-=
 proj %)</div><div>=C2=A0 (class %</div><div>=C2=A0 =C2=A0 (init [x (error &=
 quot;expected an x arg&quot;)]</div>
 <div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [y (error &quot;expected a y arg&qu=
 ot;)]</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [z (error &quot;expected=
  a z arg&quot;)])</div><div>=C2=A0 =C2=A0 (super-new [x x] [y y] [z z])))</=
 div><div><br></div><div><br></div><div>(define c%</div><div>
 =C2=A0 (class object%</div><div>=C2=A0 =C2=A0 (init x y [z 1])</div><div>=
 =C2=A0 =C2=A0 (printf &quot;x ~s y ~s z ~s\n&quot; x y z)</div><div>=C2=A0 =
 =C2=A0 (super-new)))</div><div><br></div><div>(define c-with-contract% (xyz=
 -args-proj c%))</div><div>(define d%</div>
 <div>=C2=A0 (class c-with-contract%</div><div>=C2=A0 =C2=A0 (super-new)))</=
 div><div><br></div><div>(new d% [x 1] [y 2])</div></div><div><br></div><div=
  class=3D"gmail_extra"><br><br><div class=3D"gmail_quote">On Sun, Apr 14, 2=
 013 at 3:55 PM, Stevie Strickland <span dir=3D"ltr">&lt;<a href=3D"mailto:s=
 strickl@ccs.neu.edu" target=3D"_blank">sstrickl@ccs.neu.edu</a>&gt;</span> =
 wrote:<br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border-=
 left-width:1px;border-left-color:rgb(204,204,204);border-left-style:solid;p=
 adding-left:1ex"><div style=3D"word-wrap:break-word"><div>That&#39;s the ch=
 ange I tried yesterday and had to back out, because there are already contr=
 acts that have init-args, but where the use of those classes take advantage=
  of default arguments. =C2=A0(You can try reapplying my earlier commit and =
 see where it breaks if you&#39;re interested.)</div>
 <span class=3D""><font color=3D"#888888"><div><br></div><div>Stevie</div></=
 font></span><div><div class=3D"h5"><br><div><div>On Apr 14, 2013, at 4:52 P=
 M, Robby Findler &lt;<a href=3D"mailto:robby@eecs.northwestern.edu" target=
 =3D"_blank">robby@eecs.northwestern.edu</a>&gt; wrote:</div>
 <br><blockquote type=3D"cite"><div dir=3D"ltr"><div>I&#39;m not sure if thi=
 s is a stupid question or not, but why not have init arg declarations influ=
 ence &quot;new&quot; by saying &quot;if I have a class contract on a class =
 that says that x, y, and z are supplied, then they must be actually written=
  down in the &#39;new&#39; expression that also has that class&quot; and &q=
 uot;if a class with such a contract is extended, then all of those argument=
 s must be set by the time we reach the super call that gets to that class&q=
 uot;.</div>
 
 <div><br></div><div>That is, we could turn this in code like this:</div><di=
 v><br></div><div><div>#lang racket</div><div><br></div><div>;; returns a cl=
 ass that will signal an error if it doesn&#39;t get x,y,z.</div>
 <div>(define (xyz-args-proj %)</div><div>=C2=A0 (class %</div><div>=C2=A0 =
 =C2=A0 (init [x (error &quot;expected an x arg&quot;)]</div><div>=C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 [y (error &quot;expected a y arg&quot;)]</div><div=
 >=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [z (error &quot;expected a z arg&quot;)=
 ])</div>
 
 <div>=C2=A0 =C2=A0 (super-new [x x] [y y] [z z])))</div><div><br></div><div=
 ><br></div><div>(define c%</div><div>=C2=A0 (class object%</div><div>=C2=A0=
  =C2=A0 (init x y z)</div><div>=C2=A0 =C2=A0 (printf &quot;x ~s y ~s z ~s\n=
 &quot; x y z)</div><div>=C2=A0 =C2=A0 (super-new)))</div>
 
 <div><br></div><div>(define c-with-contract% (xyz-args-proj c%))</div><div>=
 (define d%</div><div>=C2=A0 (class c-with-contract%</div><div>=C2=A0 =C2=A0=
  (super-new [x 1])))</div><div><br></div><div>(new d% [y 2] [z 3])</div><di=
 v>(new d% [y 2])</div>
 
 <div><br></div></div><div>I think this approach would handle Stevie&#39;s e=
 xample: if &quot;a&quot; shows up somewhere (either because &quot;... some =
 condition...&quot; is false or because it was true but a was passed to &#39=
 ;new&#39;) then there won&#39;t be a violation.</div>
 
 <div><br></div><div>---</div><div><br></div>Separately, I think the argumen=
 t one might posit for it being important to be able to say<div><br></div><d=
 iv>=C2=A0 (super-new)</div><div><br></div><div>and have the arguments just =
 pass thru is to support mixins. That is, I think the standard argument is t=
 hat we don&#39;t want mixins to have to declare which argument sets they wo=
 rk with.</div>
 
 <div><br></div><div>But I&#39;m not actually sure if this is a good argumen=
 t. We have enough code that I&#39;d say that if we can change it to accomod=
 ate some restriction than we&#39;re in good shape.</div><div>
 <br></div><div>Robby</div><div class=3D"gmail_extra"><br><br><div class=3D"=
 gmail_quote">On Sun, Apr 14, 2013 at 1:41 PM, Stevie Strickland <span dir=
 =3D"ltr">&lt;<a href=3D"mailto:sstrickl@ccs.neu.edu" target=3D"_blank">sstr=
 ickl@ccs.neu.edu</a>&gt;</span> wrote:<br>
 
 <blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border-=
 left-width:1px;border-left-color:rgb(204,204,204);border-left-style:solid;p=
 adding-left:1ex">Let me clarify, since I realized I&#39;m somewhat mistaken=
 : we could record what initialization arguments have been involved in the c=
 lass hierarchy, so if the initialization argument was never declared, then =
 yes, we could catch that. =C2=A0However, if we have a class hierarchy simil=
 ar to the following sketch:<br>
 
 
 <br>
 (define a%<br>
 =C2=A0 (class object%<br>
 =C2=A0 =C2=A0 (super-new)<br>
 =C2=A0 =C2=A0 (init a) ...))<br>
 <br>
 (define b%<br>
 =C2=A0 (class a%<br>
 =C2=A0 =C2=A0 (if (... some condition ...)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (super-new)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (super-new [a 3]))<br>
 =C2=A0 =C2=A0 ...))<br>
 <br>
 Whether or not (new b%) or (new b% [a 4]) is safe or not all depends on tha=
 t condition, and can&#39;t be detected until we at least get to the first s=
 pot where that initialization argument was first declared. =C2=A0(Once you =
 throw the fact that initialization arguments with the same name can be rede=
 clared at multiple levels, then it gets even more fun to decide when things=
  have gone wrong.)<br>
 
 
 <br>
 Now, doing this kind of check would require passing the initialization argu=
 ment contracts (or at least the fact that there were contracts on certain i=
 nitialization arguments) upwards through the class hierarchy and checking a=
 t each step whether or not those initialization arguments were ever declare=
 d, which means additional overhead during object initialization for even un=
 contracted classes.<br>
 
 
 <br>
 So I&#39;ll grant that we could do some more expensive work here that would=
  catch this issue, but I think it&#39;s worth first asking whether we even =
 need (or want) the full power of the current semantics and, if not, figurin=
 g out a better, less expressive system.<br>
 
 
 <span><font color=3D"#888888"><br>
 Stevie<br>
 </font></span><div><div><br>
 On Apr 14, 2013, at 1:47 PM, Stevie Strickland &lt;<a href=3D"mailto:sstric=
 kl@ccs.neu.edu" target=3D"_blank">sstrickl@ccs.neu.edu</a>&gt; wrote:<br>
 <br>
 &gt; On Apr 14, 2013, at 1:35 PM, Matthias Felleisen &lt;<a href=3D"mailto:=
 matthias@ccs.neu.edu" target=3D"_blank">matthias@ccs.neu.edu</a>&gt; wrote:=
 <br>
 &gt;&gt;<br>
 &gt;&gt; On Apr 14, 2013, at 12:52 PM, Stevie Strickland wrote:<br>
 &gt;&gt;<br>
 &gt;&gt;&gt; On Apr 14, 2013, at 12:43 PM, Matthias Felleisen &lt;<a href=
 =3D"mailto:matthias@ccs.neu.edu" target=3D"_blank">matthias@ccs.neu.edu</a>=
 &gt; wrote:<br>
 &gt;&gt;&gt;&gt; 2. I don&#39;t quite understand the problem here.<br>
 &gt;&gt;&gt;&gt;<br>
 &gt;&gt;&gt;&gt; Say class Cl has a contract Co that specifies init argumen=
 t a. Now say Cl doesn&#39;t even support a, but supports b.<br>
 &gt;&gt;&gt;<br>
 &gt;&gt;&gt; The problem is that determining whether a given class supports=
  a given initialization argument in our current initialization system is un=
 decidable.<br>
 &gt;&gt;<br>
 &gt;&gt; I see the miscommunication problem.<br>
 &gt;&gt;<br>
 &gt;&gt; I understand that we cannot catch this as a first-order check. But=
 , when a client uses (new Cl [a 1]) in such a situation and the objection c=
 reation blows up, the blame should go Cl not the client, correct?<br>
 &gt;<br>
 &gt; Yes, I agree. =C2=A0But currently, that&#39;s a runtime error, not a c=
 ontract error, since we can&#39;t even catch it as a higher-order check wit=
 hout putting in an exception handler during initialization that catches the=
  failure when an unused initialization argument reaches object%.<br>
 
 
 &gt;<br>
 &gt; Stevie<br>
 <br>
 </div></div></blockquote></div><br></div></div>
 </blockquote></div><br></div></div></div></blockquote></div><br></div></div=
 ></div>
 
 --001a11c1ff7292c93e04da5869e6--
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13693: class/c does not check that init-fields (specified) agree with init-fields (supplied)
Date: Sun, 14 Apr 2013 17:03:50 -0400

 --Apple-Mail=_41FE5E78-78DC-47FB-9258-0EF9FF212A13
 Content-Transfer-Encoding: quoted-printable
 Content-Type: text/plain;
 	charset=us-ascii
 
 Right, my addition just tested to see if there were any init contracts =
 that were _not_ tested, and raised an error if so.  We got some failures =
 in either mred or the framework (don't recall which) because of it.  I'd =
 be fine with adding an #:optional keyword or something to init-arg =
 clauses in class/c to allow the more lax behavior and having the default =
 be strict enforcement, but we'd just have to go through the existing =
 contracts and figure out which should be which.
 
 Stevie
 
 On Apr 14, 2013, at 4:59 PM, Robby Findler <robby@eecs.northwestern.edu> =
 wrote:
 
 > You mean something like this fragment? If so, then I'd say that the =
 contract has to explicitly allow 'x' to be optional, or else it is a bad =
 contract.=20
 >=20
 > Is that wrong?
 >=20
 > #lang racket
 > ;; returns a class that will signal an error if it doesn't get x,y,z.
 > (define (xyz-args-proj %)
 >   (class %
 >     (init [x (error "expected an x arg")]
 >           [y (error "expected a y arg")]
 >           [z (error "expected a z arg")])
 >     (super-new [x x] [y y] [z z])))
 >=20
 >=20
 > (define c%
 >   (class object%
 >     (init x y [z 1])
 >     (printf "x ~s y ~s z ~s\n" x y z)
 >     (super-new)))
 >=20
 > (define c-with-contract% (xyz-args-proj c%))
 > (define d%
 >   (class c-with-contract%
 >     (super-new)))
 >=20
 > (new d% [x 1] [y 2])
 >=20
 >=20
 >=20
 > On Sun, Apr 14, 2013 at 3:55 PM, Stevie Strickland =
 <sstrickl@ccs.neu.edu> wrote:
 > That's the change I tried yesterday and had to back out, because there =
 are already contracts that have init-args, but where the use of those =
 classes take advantage of default arguments.  (You can try reapplying my =
 earlier commit and see where it breaks if you're interested.)
 >=20
 > Stevie
 >=20
 > On Apr 14, 2013, at 4:52 PM, Robby Findler =
 <robby@eecs.northwestern.edu> wrote:
 >=20
 >> I'm not sure if this is a stupid question or not, but why not have =
 init arg declarations influence "new" by saying "if I have a class =
 contract on a class that says that x, y, and z are supplied, then they =
 must be actually written down in the 'new' expression that also has that =
 class" and "if a class with such a contract is extended, then all of =
 those arguments must be set by the time we reach the super call that =
 gets to that class".
 >>=20
 >> That is, we could turn this in code like this:
 >>=20
 >> #lang racket
 >>=20
 >> ;; returns a class that will signal an error if it doesn't get x,y,z.
 >> (define (xyz-args-proj %)
 >>   (class %
 >>     (init [x (error "expected an x arg")]
 >>           [y (error "expected a y arg")]
 >>           [z (error "expected a z arg")])
 >>     (super-new [x x] [y y] [z z])))
 >>=20
 >>=20
 >> (define c%
 >>   (class object%
 >>     (init x y z)
 >>     (printf "x ~s y ~s z ~s\n" x y z)
 >>     (super-new)))
 >>=20
 >> (define c-with-contract% (xyz-args-proj c%))
 >> (define d%
 >>   (class c-with-contract%
 >>     (super-new [x 1])))
 >>=20
 >> (new d% [y 2] [z 3])
 >> (new d% [y 2])
 >>=20
 >> I think this approach would handle Stevie's example: if "a" shows up =
 somewhere (either because "... some condition..." is false or because it =
 was true but a was passed to 'new') then there won't be a violation.
 >>=20
 >> ---
 >>=20
 >> Separately, I think the argument one might posit for it being =
 important to be able to say
 >>=20
 >>   (super-new)
 >>=20
 >> and have the arguments just pass thru is to support mixins. That is, =
 I think the standard argument is that we don't want mixins to have to =
 declare which argument sets they work with.
 >>=20
 >> But I'm not actually sure if this is a good argument. We have enough =
 code that I'd say that if we can change it to accomodate some =
 restriction than we're in good shape.
 >>=20
 >> Robby
 >>=20
 >>=20
 >> On Sun, Apr 14, 2013 at 1:41 PM, Stevie Strickland =
 <sstrickl@ccs.neu.edu> wrote:
 >> Let me clarify, since I realized I'm somewhat mistaken: we could =
 record what initialization arguments have been involved in the class =
 hierarchy, so if the initialization argument was never declared, then =
 yes, we could catch that.  However, if we have a class hierarchy similar =
 to the following sketch:
 >>=20
 >> (define a%
 >>   (class object%
 >>     (super-new)
 >>     (init a) ...))
 >>=20
 >> (define b%
 >>   (class a%
 >>     (if (... some condition ...)
 >>         (super-new)
 >>         (super-new [a 3]))
 >>     ...))
 >>=20
 >> Whether or not (new b%) or (new b% [a 4]) is safe or not all depends =
 on that condition, and can't be detected until we at least get to the =
 first spot where that initialization argument was first declared.  (Once =
 you throw the fact that initialization arguments with the same name can =
 be redeclared at multiple levels, then it gets even more fun to decide =
 when things have gone wrong.)
 >>=20
 >> Now, doing this kind of check would require passing the =
 initialization argument contracts (or at least the fact that there were =
 contracts on certain initialization arguments) upwards through the class =
 hierarchy and checking at each step whether or not those initialization =
 arguments were ever declared, which means additional overhead during =
 object initialization for even uncontracted classes.
 >>=20
 >> So I'll grant that we could do some more expensive work here that =
 would catch this issue, but I think it's worth first asking whether we =
 even need (or want) the full power of the current semantics and, if not, =
 figuring out a better, less expressive system.
 >>=20
 >> Stevie
 >>=20
 >> On Apr 14, 2013, at 1:47 PM, Stevie Strickland <sstrickl@ccs.neu.edu> =
 wrote:
 >>=20
 >> > On Apr 14, 2013, at 1:35 PM, Matthias Felleisen =
 <matthias@ccs.neu.edu> wrote:
 >> >>
 >> >> On Apr 14, 2013, at 12:52 PM, Stevie Strickland wrote:
 >> >>
 >> >>> On Apr 14, 2013, at 12:43 PM, Matthias Felleisen =
 <matthias@ccs.neu.edu> wrote:
 >> >>>> 2. I don't quite understand the problem here.
 >> >>>>
 >> >>>> Say class Cl has a contract Co that specifies init argument a. =
 Now say Cl doesn't even support a, but supports b.
 >> >>>
 >> >>> The problem is that determining whether a given class supports a =
 given initialization argument in our current initialization system is =
 undecidable.
 >> >>
 >> >> I see the miscommunication problem.
 >> >>
 >> >> I understand that we cannot catch this as a first-order check. =
 But, when a client uses (new Cl [a 1]) in such a situation and the =
 objection creation blows up, the blame should go Cl not the client, =
 correct?
 >> >
 >> > Yes, I agree.  But currently, that's a runtime error, not a =
 contract error, since we can't even catch it as a higher-order check =
 without putting in an exception handler during initialization that =
 catches the failure when an unused initialization argument reaches =
 object%.
 >> >
 >> > Stevie
 >>=20
 >>=20
 >=20
 >=20
 
 
 --Apple-Mail=_41FE5E78-78DC-47FB-9258-0EF9FF212A13
 Content-Transfer-Encoding: quoted-printable
 Content-Type: text/html;
 	charset=us-ascii
 
 <html><head><meta http-equiv=3D"Content-Type" content=3D"text/html =
 charset=3Dus-ascii"></head><body style=3D"word-wrap: break-word; =
 -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; =
 "><div>Right, my addition just tested to see if there were any init =
 contracts that were _not_ tested, and raised an error if so. &nbsp;We =
 got some failures in either mred or the framework (don't recall which) =
 because of it. &nbsp;I'd be fine with adding an #:optional keyword or =
 something to init-arg clauses in class/c to allow the more lax behavior =
 and having the default be strict enforcement, but we'd just have to go =
 through the existing contracts and figure out which should be =
 which.</div><div><br></div><div>Stevie</div><br><div><div>On Apr 14, =
 2013, at 4:59 PM, Robby Findler &lt;<a =
 href=3D"mailto:robby@eecs.northwestern.edu">robby@eecs.northwestern.edu</a=
 >&gt; wrote:</div><br class=3D"Apple-interchange-newline"><blockquote =
 type=3D"cite"><div dir=3D"ltr">You mean something like this fragment? If =
 so, then I'd say that the contract has to explicitly allow 'x' to be =
 optional, or else it is a bad contract.&nbsp;<div><br></div><div>Is that =
 wrong?<br><div></div>
 <div><br></div><div><div>#lang racket</div><div>;; returns a class that =
 will signal an error if it doesn't get x,y,z.</div><div>(define =
 (xyz-args-proj %)</div><div>&nbsp; (class %</div><div>&nbsp; &nbsp; =
 (init [x (error "expected an x arg")]</div>
 <div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [y (error "expected a y =
 arg")]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [z (error "expected =
 a z arg")])</div><div>&nbsp; &nbsp; (super-new [x x] [y y] [z =
 z])))</div><div><br></div><div><br></div><div>(define c%</div><div>
 &nbsp; (class object%</div><div>&nbsp; &nbsp; (init x y [z =
 1])</div><div>&nbsp; &nbsp; (printf "x ~s y ~s z ~s\n" x y =
 z)</div><div>&nbsp; &nbsp; =
 (super-new)))</div><div><br></div><div>(define c-with-contract% =
 (xyz-args-proj c%))</div><div>(define d%</div>
 <div>&nbsp; (class c-with-contract%</div><div>&nbsp; &nbsp; =
 (super-new)))</div><div><br></div><div>(new d% [x 1] [y =
 2])</div></div><div><br></div><div class=3D"gmail_extra"><br><br><div =
 class=3D"gmail_quote">On Sun, Apr 14, 2013 at 3:55 PM, Stevie Strickland =
 <span dir=3D"ltr">&lt;<a href=3D"mailto:sstrickl@ccs.neu.edu" =
 target=3D"_blank">sstrickl@ccs.neu.edu</a>&gt;</span> wrote:<br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px =
 0.8ex;border-left-width:1px;border-left-color:rgb(204,204,204);border-left=
 -style:solid;padding-left:1ex"><div =
 style=3D"word-wrap:break-word"><div>That's the change I tried yesterday =
 and had to back out, because there are already contracts that have =
 init-args, but where the use of those classes take advantage of default =
 arguments. &nbsp;(You can try reapplying my earlier commit and see where =
 it breaks if you're interested.)</div>
 <span class=3D""><font =
 color=3D"#888888"><div><br></div><div>Stevie</div></font></span><div><div =
 class=3D"h5"><br><div><div>On Apr 14, 2013, at 4:52 PM, Robby Findler =
 &lt;<a href=3D"mailto:robby@eecs.northwestern.edu" =
 target=3D"_blank">robby@eecs.northwestern.edu</a>&gt; wrote:</div>
 <br><blockquote type=3D"cite"><div dir=3D"ltr"><div>I'm not sure if this =
 is a stupid question or not, but why not have init arg declarations =
 influence "new" by saying "if I have a class contract on a class that =
 says that x, y, and z are supplied, then they must be actually written =
 down in the 'new' expression that also has that class" and "if a class =
 with such a contract is extended, then all of those arguments must be =
 set by the time we reach the super call that gets to that class".</div>
 
 <div><br></div><div>That is, we could turn this in code like =
 this:</div><div><br></div><div><div>#lang =
 racket</div><div><br></div><div>;; returns a class that will signal an =
 error if it doesn't get x,y,z.</div>
 <div>(define (xyz-args-proj %)</div><div>&nbsp; (class =
 %</div><div>&nbsp; &nbsp; (init [x (error "expected an x =
 arg")]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [y (error "expected =
 a y arg")]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [z (error =
 "expected a z arg")])</div>
 
 <div>&nbsp; &nbsp; (super-new [x x] [y y] [z =
 z])))</div><div><br></div><div><br></div><div>(define =
 c%</div><div>&nbsp; (class object%</div><div>&nbsp; &nbsp; (init x y =
 z)</div><div>&nbsp; &nbsp; (printf "x ~s y ~s z ~s\n" x y =
 z)</div><div>&nbsp; &nbsp; (super-new)))</div>
 
 <div><br></div><div>(define c-with-contract% (xyz-args-proj =
 c%))</div><div>(define d%</div><div>&nbsp; (class =
 c-with-contract%</div><div>&nbsp; &nbsp; (super-new [x =
 1])))</div><div><br></div><div>(new d% [y 2] [z 3])</div><div>(new d% [y =
 2])</div>
 
 <div><br></div></div><div>I think this approach would handle Stevie's =
 example: if "a" shows up somewhere (either because "... some =
 condition..." is false or because it was true but a was passed to 'new') =
 then there won't be a violation.</div>
 
 <div><br></div><div>---</div><div><br></div>Separately, I think the =
 argument one might posit for it being important to be able to =
 say<div><br></div><div>&nbsp; (super-new)</div><div><br></div><div>and =
 have the arguments just pass thru is to support mixins. That is, I think =
 the standard argument is that we don't want mixins to have to declare =
 which argument sets they work with.</div>
 
 <div><br></div><div>But I'm not actually sure if this is a good =
 argument. We have enough code that I'd say that if we can change it to =
 accomodate some restriction than we're in good shape.</div><div>
 <br></div><div>Robby</div><div class=3D"gmail_extra"><br><br><div =
 class=3D"gmail_quote">On Sun, Apr 14, 2013 at 1:41 PM, Stevie Strickland =
 <span dir=3D"ltr">&lt;<a href=3D"mailto:sstrickl@ccs.neu.edu" =
 target=3D"_blank">sstrickl@ccs.neu.edu</a>&gt;</span> wrote:<br>
 
 <blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px =
 0.8ex;border-left-width:1px;border-left-color:rgb(204,204,204);border-left=
 -style:solid;padding-left:1ex">Let me clarify, since I realized I'm =
 somewhat mistaken: we could record what initialization arguments have =
 been involved in the class hierarchy, so if the initialization argument =
 was never declared, then yes, we could catch that. &nbsp;However, if we =
 have a class hierarchy similar to the following sketch:<br>
 
 
 <br>
 (define a%<br>
 &nbsp; (class object%<br>
 &nbsp; &nbsp; (super-new)<br>
 &nbsp; &nbsp; (init a) ...))<br>
 <br>
 (define b%<br>
 &nbsp; (class a%<br>
 &nbsp; &nbsp; (if (... some condition ...)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (super-new)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (super-new [a 3]))<br>
 &nbsp; &nbsp; ...))<br>
 <br>
 Whether or not (new b%) or (new b% [a 4]) is safe or not all depends on =
 that condition, and can't be detected until we at least get to the first =
 spot where that initialization argument was first declared. &nbsp;(Once =
 you throw the fact that initialization arguments with the same name can =
 be redeclared at multiple levels, then it gets even more fun to decide =
 when things have gone wrong.)<br>
 
 
 <br>
 Now, doing this kind of check would require passing the initialization =
 argument contracts (or at least the fact that there were contracts on =
 certain initialization arguments) upwards through the class hierarchy =
 and checking at each step whether or not those initialization arguments =
 were ever declared, which means additional overhead during object =
 initialization for even uncontracted classes.<br>
 
 
 <br>
 So I'll grant that we could do some more expensive work here that would =
 catch this issue, but I think it's worth first asking whether we even =
 need (or want) the full power of the current semantics and, if not, =
 figuring out a better, less expressive system.<br>
 
 
 <span><font color=3D"#888888"><br>
 Stevie<br>
 </font></span><div><br>
 On Apr 14, 2013, at 1:47 PM, Stevie Strickland &lt;<a =
 href=3D"mailto:sstrickl@ccs.neu.edu" =
 target=3D"_blank">sstrickl@ccs.neu.edu</a>&gt; wrote:<br>
 <br>
 &gt; On Apr 14, 2013, at 1:35 PM, Matthias Felleisen &lt;<a =
 href=3D"mailto:matthias@ccs.neu.edu" =
 target=3D"_blank">matthias@ccs.neu.edu</a>&gt; wrote:<br>
 &gt;&gt;<br>
 &gt;&gt; On Apr 14, 2013, at 12:52 PM, Stevie Strickland wrote:<br>
 &gt;&gt;<br>
 &gt;&gt;&gt; On Apr 14, 2013, at 12:43 PM, Matthias Felleisen &lt;<a =
 href=3D"mailto:matthias@ccs.neu.edu" =
 target=3D"_blank">matthias@ccs.neu.edu</a>&gt; wrote:<br>
 &gt;&gt;&gt;&gt; 2. I don't quite understand the problem here.<br>
 &gt;&gt;&gt;&gt;<br>
 &gt;&gt;&gt;&gt; Say class Cl has a contract Co that specifies init =
 argument a. Now say Cl doesn't even support a, but supports b.<br>
 &gt;&gt;&gt;<br>
 &gt;&gt;&gt; The problem is that determining whether a given class =
 supports a given initialization argument in our current initialization =
 system is undecidable.<br>
 &gt;&gt;<br>
 &gt;&gt; I see the miscommunication problem.<br>
 &gt;&gt;<br>
 &gt;&gt; I understand that we cannot catch this as a first-order check. =
 But, when a client uses (new Cl [a 1]) in such a situation and the =
 objection creation blows up, the blame should go Cl not the client, =
 correct?<br>
 &gt;<br>
 &gt; Yes, I agree. &nbsp;But currently, that's a runtime error, not a =
 contract error, since we can't even catch it as a higher-order check =
 without putting in an exception handler during initialization that =
 catches the failure when an unused initialization argument reaches =
 object%.<br>
 
 
 &gt;<br>
 &gt; Stevie<br>
 <br>
 </div></blockquote></div><br></div></div>
 =
 </blockquote></div><br></div></div></div></blockquote></div><br></div></di=
 v></div>
 </blockquote></div><br></body></html>=
 
 --Apple-Mail=_41FE5E78-78DC-47FB-9258-0EF9FF212A13--
