From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Wed Sep  5 11:10:57 2012
Received: from mail-ie0-f172.google.com (mail-ie0-f172.google.com [209.85.223.172])
	by champlain.ccs.neu.edu (8.14.4/8.14.4) with ESMTP id q85FAr7X007194
	for <bugs@bugs.plt-scheme.org>; Wed, 5 Sep 2012 11:10:53 -0400
Message-Id: <201209051510.q85FAmMP007188@champlain.ccs.neu.edu>
Date: Wed, 5 Sep 2012 11:10:48 -0400
From: matthias@ccs.neu.edu
To: bugs@racket-lang.org
Subject: element (from xml/xml) sends weird error message

>Number:         13097
>Category:       all
>Synopsis:       element (from xml/xml) sends weird error message
>Class:          sw-bug
>Responsible:    nobody
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Wed Sep 05 11:12:01 -0400 2012
>Closed-Date:    Tue Mar 25 10:33:52 -0400 2014
>Last-Modified:  Tue Mar 25 10:33:52 -0400 2014
>Originator:     matthias
>Organization:
plt
>Submitter-Id:   unknown
>Release:        5.3.0.21--2012-09-03(7d2ce136/d)
>Environment:
macosx "Darwin africa.westell.com 11.4.0 Darwin Kernel Version 11.4.0: Mon Apr  9 19:32:15 PDT 2012; root:xnu-1699.26.8~1/RELEASE_X86_64 x86_64" (x86_64-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 642522080
Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()


Collections:
("/Users/matthias/0Unison/collects/"
 ("._.DS_Store" ".DS_Store" "compiled" "date" "finance" "info-domain" "info.ss" "pdf.ss~" "session" "short" "testing" "tll-collects" "utils" "web"))
("/Users/matthias/Library/Racket/5.3.0.21/collects"
 (non-existent-path))
("/Users/matthias/plt/collects"
 (".gitignore" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compatibility" "compiler" "config" "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "future-visualizer" "games" "graphics" "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" "hierlist" "honu" "htdp" "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" "macro-debugger" "make" "meta" "mred" "mrlib" "mysterx" "mz" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raclog" "raco" "racunit" "reader" "readline" "redex" "repo-time-stamp" "repos-time-stamp" "rnrs" "s-exp" "schelog" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" "string-constants" "swindle" "syntax" "syntax-!
 color" "teachpack" "test-box-recovery" "test-engine" "tests" "tex2page" "texpict" "tool" "trace" "typed" "typed-racket" "typed-scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml" "xrepl"))

Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang racket" #t #t ((main) (test))))
>Description:
When you call element twice in a row on bad data, 
the second call signals a strange internal error. 
>How-To-Repeat:
Welcome to DrRacket, version 5.3.0.21--2012-09-03(7d2ce136/d) [3m].
Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
> (element 0 0 1)
. . make-element34: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 5
  given: 3
  arguments...:
   0
   0
   1
> (element 0 0 1 2 3)
                     
define-values: assignment disallowed;
 cannot re-define a constant
  constant: lifted.10.12
> 
>Fix:
>Audit-Trail:
From: Jay McCarthy <jay.mccarthy@gmail.com>
To: matthias@ccs.neu.edu, bugs@racket-lang.org,
        Robby Findler <robby@eecs.northwestern.edu>
Cc: nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13097: element (from xml/xml) sends weird error message
Date: Wed, 5 Sep 2012 14:45:18 -0600

 I can't reproduce this error in b68fb6f228dd9819a51aecc0a2c6da45219c3d7b.
 
 So, I'll have to update to try.
 
 It looks to me like the lifted version of the contracted function
 isn't done being defined when the error goes and it gets lifted again
 or something. It doesn't seem like it could be related to XML itself.
 
 Jay
 
 On Wed, Sep 5, 2012 at 9:12 AM,  <matthias@ccs.neu.edu> wrote:
 > A new problem report is waiting at
 >   http://bugs.racket-lang.org/query/?cmd=view&pr=13097
 >
 > Reported by matthias for release: 5.3.0.21--2012-09-03(7d2ce136/d)
 >
 > *** Description:
 > When you call element twice in a row on bad data,
 > the second call signals a strange internal error.
 >
 > *** How to repeat:
 > Welcome to DrRacket, version 5.3.0.21--2012-09-03(7d2ce136/d) [3m].
 > Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >> (element 0 0 1)
 > . . make-element34: arity mismatch;
 >  the expected number of arguments does not match the given number
 >   expected: 5
 >   given: 3
 >   arguments...:
 >    0
 >    0
 >    1
 >> (element 0 0 1 2 3)
 >
 > define-values: assignment disallowed;
 >  cannot re-define a constant
 >   constant: lifted.10.12
 >>
 >
 > *** Environment:
 > macosx "Darwin africa.westell.com 11.4.0 Darwin Kernel Version 11.4.0: Mon Apr  9 19:32:15 PDT 2012; root:xnu-1699.26.8~1/RELEASE_X86_64 x86_64" (x86_64-macosx/3m) (get-display-depth) = 32
 > Human Language: english
 > (current-memory-use) 642522080
 > Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()
 >
 >
 > Collections:
 > ("/Users/matthias/0Unison/collects/"
 >  ("._.DS_Store" ".DS_Store" "compiled" "date" "finance" "info-domain" "info.ss" "pdf.ss~" "session" "short" "testing" "tll-collects" "utils" "web"))
 > ("/Users/matthias/Library/Racket/5.3.0.21/collects"
 >  (non-existent-path))
 > ("/Users/matthias/plt/collects"
 >  (".gitignore" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compatibility" "compiler" "config" "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "future-visualizer" "games" "graphics" "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" "hierlist" "honu" "htdp" "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" "macro-debugger" "make" "meta" "mred" "mrlib" "mysterx" "mz" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raclog" "raco" "racunit" "reader" "readline" "redex" "repo-time-stamp" "repos-time-stamp" "rnrs" "s-exp" "schelog" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" "string-constants" "swindle" "syntax" "syntax-!
 >  color" "teachpack" "test-box-recovery" "test-engine" "tests" "tex2page" "texpict" "tool" "trace" "typed" "typed-racket" "typed-scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml" "xrepl"))
 >
 > Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang racket" #t #t ((main) (test))))
 >
 
 
 
 -- 
 Jay McCarthy <jay@cs.byu.edu>
 Assistant Professor / Brigham Young University
 http://faculty.cs.byu.edu/~jay
 
 "The glory of God is Intelligence" - D&C 93
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Jay McCarthy <jay.mccarthy@gmail.com>
Cc: bugs@racket-lang.org, Robby Findler <robby@eecs.northwestern.edu>,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13097: element (from xml/xml) sends weird error message
Date: Wed, 5 Sep 2012 16:50:04 -0400

 --Apple-Mail=_C9AAE42F-E6CE-4C6C-8E81-1FAAE12A7785
 Content-Transfer-Encoding: quoted-printable
 Content-Type: text/plain;
 	charset=us-ascii
 
 
 1. I just ran the program in 2 again and the error is repeatable:=20
 
 Welcome to DrRacket, version 5.3.0.21--2012-09-03(7d2ce136/d) [3m].
 Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 > (element 0 0 1 2 3)
 . . make-element: contract violation
  expected: (or/c location? symbol? #f)
  given: 0
  in: the 1st argument of
       (->
        (or/c location? symbol? #f)
        (or/c location? symbol? #f)
        symbol?
        (listof attribute?)
        (listof
         (or/c
          permissive/c
          pcdata?
          element?
          entity?
          comment?
          cdata?
          p-i?))
        element?)
  contract from:=20
       <collects>/xml/private/structures.rkt
  blaming:=20
       /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 > (element 0 0 1 2 3)
 define-values: assignment disallowed;
  cannot re-define a constant
   constant: lifted.10.12
 
 2.=20
 
 
 #! /bin/sh
 #|
 exec racket -tm "$0" ${1+"$@"}
 |#
 
 #lang racket=20
 
 (provide main)
 
 ;; accept the shortest sequence of LetterKeyEvents that match some =
 regular exp.
 ;; =
 --------------------------------------------------------------------------=
 -------------------------
 
 (require 2htdp/universe 2htdp/image rackunit)
 
 (require xml/xml)
 ;; should come with the above:
 (define-syntax-rule
   (element-named-attributes msg name:id ...)
   ;; XML-Element -> [Listof String]
   (lambda (e)
     (match (element-attributes e)
       [(list-no-order (attribute _ _ 'name:id name:id) ...)
        (values name:id ...)]
       [else (error 'parse (format msg e))])))
 
 ;; XML-Element Symbol *->* [Listof XML-Element]
 ;; retrieve all elements with name n in name*
 (define (elements-named-content e . name*)
   (define c (filter element? (element-content e)))
   (define l=20
     (for/list ((n name*)) (filter (lambda (x) (eq? (element-name x) n)) =
 c)))
   (unless (=3D (- (length c) (apply + (map length l))) 0)
     (displayln (- (length c) (length l)))
     (for ((e c))
       (unless (memq e l)
         (displayln `(not found ,e))))
     (error 'element-named-elements "too many [~s] elements: ~e" name* =
 l))
   (apply values l))
 
 ;; =
 --------------------------------------------------------------------------=
 -------------------------
 ;; THE MAIN FUNCTION=20
 
 ;; String[File] -> "d" or "error"
 (define (main f)
   (with-handlers ((exn:fail? (lambda (e) (displayln (exn-message e)))))
     (define x:xml (with-input-from-file f read-xml/element))
     (define x:fsm (parse x:xml))
     (accept x:fsm)
     (sleep 1)))
    =20
 ;; =
 --------------------------------------------------------------------------=
 -------------------------
 ;; Parse the XML into the internal FSM data structure=20
 
 ;; Any -> FSM=20
 ;; parse the given=20
 
 (module+ test=20
   (define (read-parse xml0:string)
     (parse (read-xml/element (open-input-string xml0:string))))
   (define xml0:string
     #<< eos
     <fsm initial=3D"a">
        <final name=3D"d"></final>
        <transition current=3D"a" next=3D"bc">
           <action value=3D"a"></action>
        </transition>
        <transition current=3D"bc" next=3D"bc">
           <action value=3D"b"></action>
           <action value=3D"c"></action>
        </transition>
        <transition current=3D"bc" next=3D"d">
          <action value=3D"d"></action>
        </transition>
     </fsm>
  eos
     )
   (check-equal? (read-parse xml0:string) fsm0)
  =20
   (define xml0-b:string
     #<< eos
     <fsm initial=3D"a">
        <final name=3D"d" />
        <transition current=3D"a" next=3D"bc">
           <action value=3D"a" />
        </transition>
        <transition current=3D"bc" next=3D"bc">
           <action value=3D"b" />
           <action value=3D"c" />
        </transition>
        <transition current=3D"bc" next=3D"d">
          <action value=3D"d" />
        </transition>
     </fsm>
  eos
     )
   (check-equal? (read-parse xml0-b:string) fsm0))
 
 (define (parse x)
   ;; parse does not check the names of states because all strings are =
 allowed=20
   (define (<fsm> x)
     (define parse-initial=20
       (element-named-attributes "not an initial: ~e" initial))
     (define (<finals> e*)=20
       (map (element-named-attributes "not a final specification: ~e" =
 name) e*))
     (define (<transition*> e*)
       (define (<transition> e)
         (define-values (c n) ((element-named-attributes "not a =
 transition: ~e" current next) e))
         (define k* (elements-named-content e 'action))
         (transition c (map (compose key>>> (element-named-attributes =
 "not an action:" value)) k*) n))
       (map <transition> e*))
     (define (key>>> x)
       (unless (and (=3D (string-length x) 1) (regexp-match =
 #px"\\d|[a-zA-Z]" x))
         (error "not an alphanumeric key: ~e" x))
       x)
     ;; -- IN --=20
     (unless (eq? (element-name x) 'fsm) (error 'parse "not an fsm: ~e" =
 x))
     (define-values (f t) (elements-named-content x 'final 'transition))
     (fsm (parse-initial x) (<finals> f) (<transition*> t)))
   ;; -- IN --=20
   (<fsm> x))
 
 ;; =
 --------------------------------------------------------------------------=
 -------------------------
 ;; deal with one FSM=20
 
 ;; FSM        =3D (fsm State [List-of State] [List-of Transition])
 ;; State      =3D String=20
 ;; Transition =3D (transition State [List-of LetterKeyEvent] State)
 
 (struct fsm (initial finals transitions) #:transparent)
 (struct transition (current keys next) #:transparent)
 
 (define ER "error")
 (define state? string?)
 (define state=3D? string=3D?)
 
 ;; EXAMPLE: a(b|c)*d
 (define AA "a")
 (define BC "bc")
 (define DD "d")
 
 (define t*=20
   (list (transition AA (list "a") BC)
         (transition BC (list "b" "c") BC)
         (transition BC (list "d") DD)))
 (define i0 AA)
 (define f* (list DD))=20
 (define fsm0 (fsm i0 f* t*))
 
 ;; =
 --------------------------------------------------------------------------=
 ---
 ;; GRAPHICAL CONSTANTS
 (define SIZE 100)
 (define white  (square SIZE "solid" "white"))
 (define yellow (square SIZE "solid" "yellow"))
 (define green  (square SIZE "solid" "green"))
 (define red    (square SIZE "solid" "red"))
 
 ;; =
 --------------------------------------------------------------------------=
 ---
 ;; FSM -> State or "unacceptable"
 (define (accept fsm)
   (define i0 (fsm-initial fsm))
   (define f* (fsm-finals fsm))
   (big-bang i0
             (on-key (next (fsm-transitions fsm)))
             (to-draw (image i0 f*))
             (stop-when (lambda (w) (cons? (member w (cons ER f*)))))))
 
 ;; =
 --------------------------------------------------------------------------=
 ---
 ;; Transition* State KeyEvent -> State=20
 ;; retrieve the next state from a (transition ...) in t* such that ...
 ;; if there is no such transition, signal the error "can't happen"
 
 (module+ test=20
   (check-equal? ((next t*) AA "a") BC)
   (check-equal? ((next t*) AA "b") ER)
   (check-equal? ((next t*) AA "c") ER)
   (check-equal? ((next t*) AA "d") ER)
   (check-equal? ((next t*) AA "e") ER)
   (check-equal? ((next t*) AA "left") ER)
  =20
   (check-equal? ((next t*) BC "a") ER)
   (check-equal? ((next t*) BC "b") BC)
   (check-equal? ((next t*) BC "c") BC)
   (check-equal? ((next t*) BC "d") DD)
   (check-equal? ((next t*) BC "e") ER)
   (check-equal? ((next t*) BC "left") ER)
  =20
   (check-equal? ((next t*) DD "a") ER))
 
 (define ((next t*) current ke)
   (or (for/or ((t t*))
         (and (state=3D? (transition-current t) current)=20
              (member ke (transition-keys t))
              (transition-next t)))
       ER))
 
 ;; =
 --------------------------------------------------------------------------=
 ---
 ;; State State [Listof State] -> Image=20
 ;; render state as image=20
 
 (module+ test
   (check-equal? ((image i0 f*) AA) white)
   (check-equal? ((image i0 f*) BC) yellow)
   (check-equal? ((image i0 f*) DD) green)
   (check-equal? ((image i0 f*) ER) red))
 
 (define ((image initial finals) current)
   (cond
     [(state=3D? current initial) white]
     [(member current finals) green]
     [(state=3D? current ER) red]
     [else yellow]))=
 
 --Apple-Mail=_C9AAE42F-E6CE-4C6C-8E81-1FAAE12A7785
 Content-Disposition: attachment;
 	filename=smime.p7s
 Content-Type: application/pkcs7-signature;
 	name=smime.p7s
 Content-Transfer-Encoding: base64
 
 MIAGCSqGSIb3DQEHAqCAMIACAQExCzAJBgUrDgMCGgUAMIAGCSqGSIb3DQEHAQAAoIIMTDCCBVYw
 ggQ+oAMCAQICEHbDqMitQnj5Qd81mMX31uMwDQYJKoZIhvcNAQEFBQAwgd0xCzAJBgNVBAYTAlVT
 MRcwFQYDVQQKEw5WZXJpU2lnbiwgSW5jLjEfMB0GA1UECxMWVmVyaVNpZ24gVHJ1c3QgTmV0d29y
 azE7MDkGA1UECxMyVGVybXMgb2YgdXNlIGF0IGh0dHBzOi8vd3d3LnZlcmlzaWduLmNvbS9ycGEg
 KGMpMDkxHjAcBgNVBAsTFVBlcnNvbmEgTm90IFZhbGlkYXRlZDE3MDUGA1UEAxMuVmVyaVNpZ24g
 Q2xhc3MgMSBJbmRpdmlkdWFsIFN1YnNjcmliZXIgQ0EgLSBHMzAeFw0xMjA3MjYwMDAwMDBaFw0x
 MzA3MjYyMzU5NTlaMIIBGTEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlT
 aWduIFRydXN0IE5ldHdvcmsxRjBEBgNVBAsTPXd3dy52ZXJpc2lnbi5jb20vcmVwb3NpdG9yeS9S
 UEEgSW5jb3JwLiBieSBSZWYuLExJQUIuTFREKGMpOTgxHjAcBgNVBAsTFVBlcnNvbmEgTm90IFZh
 bGlkYXRlZDEzMDEGA1UECxMqRGlnaXRhbCBJRCBDbGFzcyAxIC0gTmV0c2NhcGUgRnVsbCBTZXJ2
 aWNlMRswGQYDVQQDFBJNYXR0aGlhcyBGZWxsZWlzZW4xIzAhBgkqhkiG9w0BCQEWFG1hdHRoaWFz
 QGNjcy5uZXUuZWR1MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxoivceU706ZnD2XD
 JfoNFd4KTbYA9AObozHkSZ6BJLC8oSGjakZu6m11azFwk5LfPOjd7dQIKw9uDhmT1e4q6jP+B1FC
 a1qqwm7Rw9PcFhqYFBlE8MbqJUXJW53Ynw3dK2XiUNqTXFcBa2otI8XxMtrQch4f9oMUy+aIn/fZ
 QQDbkkzuwz3884xSbm0IMDneYUC6FF1OJe2+fkMqHqEDsSgY97RFcjdgTCOB012odwGhxJ3rIGaX
 WUs7ttjnftzyGODVILMIx8RBJpGJ+Ur4R67SJygV8Clpg1RBuRUSNaZAN0tCjO9YSkb9HfF2tAx9
 POWmQXdTtNNjZfJPbTVnkQIDAQABo4HSMIHPMAkGA1UdEwQCMAAwRAYDVR0gBD0wOzA5BgtghkgB
 hvhFAQcXATAqMCgGCCsGAQUFBwIBFhxodHRwczovL3d3dy52ZXJpc2lnbi5jb20vcnBhMAsGA1Ud
 DwQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDBAYIKwYBBQUHAwIwUAYDVR0fBEkwRzBFoEOgQYY/
 aHR0cDovL2luZGMxZGlnaXRhbGlkLWczLWNybC52ZXJpc2lnbi5jb20vSW5kQzFEaWdpdGFsSUQt
 RzMuY3JsMA0GCSqGSIb3DQEBBQUAA4IBAQCeAXGCjjlMmU1wb3Ii4V0yNygujjQcvJstFh7IyVcM
 oD5/5Ar7b36JL1O2tpBosTf0pVZaORKCMPAf1IfBS48CvvqSoeVyXCFG1goXDjr7Ut+ZwosuFXdr
 2gD6u9EftuoUy+UBdz46NcN9YC0WbX7CrRE96XxvYwPfWnGIjsoNY7WqFI4f7HLlM5dCmAOXySsw
 EbPKpflzEGPU8aKf4FqTX9ne+hTzPbCf5CDJdzrdyn5bQkqvSzxw+P3tvQSU9lnyZkG7wZ1cibna
 QIuSNEe+HKOKcEfeTeD50JhLa43RE24nMsaXWdX61VTiPE/2Y9woEVLxXBp+AFpMZjGYsF/yMIIG
 7jCCBdagAwIBAgIQcRVmBUrkkSFN6bxE+azT3DANBgkqhkiG9w0BAQUFADCByjELMAkGA1UEBhMC
 VVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3
 b3JrMTowOAYDVQQLEzEoYykgMTk5OSBWZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVz
 ZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2lnbiBDbGFzcyAxIFB1YmxpYyBQcmltYXJ5IENlcnRpZmlj
 YXRpb24gQXV0aG9yaXR5IC0gRzMwHhcNMDkwNTAxMDAwMDAwWhcNMTkwNDMwMjM1OTU5WjCB3TEL
 MAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBU
 cnVzdCBOZXR3b3JrMTswOQYDVQQLEzJUZXJtcyBvZiB1c2UgYXQgaHR0cHM6Ly93d3cudmVyaXNp
 Z24uY29tL3JwYSAoYykwOTEeMBwGA1UECxMVUGVyc29uYSBOb3QgVmFsaWRhdGVkMTcwNQYDVQQD
 Ey5WZXJpU2lnbiBDbGFzcyAxIEluZGl2aWR1YWwgU3Vic2NyaWJlciBDQSAtIEczMIIBIjANBgkq
 hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7cRH3yooHXwGa7vXITLJbBOP6bGNQU4099oL42r6ZYgg
 CxET6ZvgSU6Lb9UB0F8NR5GKWkx0Pj/GkQm7TDSejW6hglFi92l2WJYHr54UGAdPWr2f0jGyVBlz
 RmoZQhHsEnMhjfXcMM3l2VYKMcU2bSkUl70t2olHGYjYSwQ967Y8Zx50ABMN0Ibak2f4MwOuGjxr
 aXj2wCyO4YM/d/mZ//6fUlrCtIcK2GypR8FUKWVDPkrAlh/Brfd3r2yxBF6+wbaULZeQLSfSux7p
 g2qE9sSyriMGZSalJ1grByK0b6ZiSBp38tVQJ5op05b7KPW6JHZi44xZ6/tu1ULEvkHH9QIDAQAB
 o4ICuTCCArUwNAYIKwYBBQUHAQEEKDAmMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC52ZXJpc2ln
 bi5jb20wEgYDVR0TAQH/BAgwBgEB/wIBADBwBgNVHSAEaTBnMGUGC2CGSAGG+EUBBxcBMFYwKAYI
 KwYBBQUHAgEWHGh0dHBzOi8vd3d3LnZlcmlzaWduLmNvbS9jcHMwKgYIKwYBBQUHAgIwHhocaHR0
 cHM6Ly93d3cudmVyaXNpZ24uY29tL3JwYTA0BgNVHR8ELTArMCmgJ6AlhiNodHRwOi8vY3JsLnZl
 cmlzaWduLmNvbS9wY2ExLWczLmNybDAOBgNVHQ8BAf8EBAMCAQYwbgYIKwYBBQUHAQwEYjBgoV6g
 XDBaMFgwVhYJaW1hZ2UvZ2lmMCEwHzAHBgUrDgMCGgQUS2u5KJYGDLvQUjibKaxLB4shBRgwJhYk
 aHR0cDovL2xvZ28udmVyaXNpZ24uY29tL3ZzbG9nbzEuZ2lmMC4GA1UdEQQnMCWkIzAhMR8wHQYD
 VQQDExZQcml2YXRlTGFiZWw0LTIwNDgtMTE4MB0GA1UdDgQWBBR5R2EIQf04BKJL57XM9UP2SSsR
 +DCB8QYDVR0jBIHpMIHmoYHQpIHNMIHKMQswCQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24s
 IEluYy4xHzAdBgNVBAsTFlZlcmlTaWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5
 IFZlcmlTaWduLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlT
 aWduIENsYXNzIDEgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBHM4IR
 AItbdVaEVIULAM+vOEjOsaQwDQYJKoZIhvcNAQEFBQADggEBADlNz0GZgbWpBbVSOOk5hIls5DSo
 WufYbAlMJBq6WaSHO3Mh8ZOBz79oY1pn/jWFK6HDXaNKwjoZ3TDWzE3v8dKBl8pUWkO/N4t6jhmN
 D0OojPKvYLMVirOVnDzgnrMnmKQ1chfl/Cpdh9OKDcLRRSr4wPSsKpM61a4ScAjr+zvid+zoK2Q1
 ds262uDRyxTWcVibvtU+fbbZ6CTFJGZMXZEfdrMXPn8NxiGJL7M3uKH/XLJtSd5lUkL7DojS7Uod
 v0vj+Mxy+kgOZY5JyNb4mZg7t5Q+MXEGh/psWVMu198r7V9jAKwV7QO4VRaMxmgD5yKocwuxvKDa
 UljdCg5/wYIxggSLMIIEhwIBATCB8jCB3TELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWdu
 LCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTswOQYDVQQLEzJUZXJtcyBv
 ZiB1c2UgYXQgaHR0cHM6Ly93d3cudmVyaXNpZ24uY29tL3JwYSAoYykwOTEeMBwGA1UECxMVUGVy
 c29uYSBOb3QgVmFsaWRhdGVkMTcwNQYDVQQDEy5WZXJpU2lnbiBDbGFzcyAxIEluZGl2aWR1YWwg
 U3Vic2NyaWJlciBDQSAtIEczAhB2w6jIrUJ4+UHfNZjF99bjMAkGBSsOAwIaBQCgggJtMBgGCSqG
 SIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEyMDkwNTIwNTAwNVowIwYJKoZI
 hvcNAQkEMRYEFL5Mmi0YrJibi5gc8XIqdUi904lzMIIBAwYJKwYBBAGCNxAEMYH1MIHyMIHdMQsw
 CQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlTaWduIFRy
 dXN0IE5ldHdvcmsxOzA5BgNVBAsTMlRlcm1zIG9mIHVzZSBhdCBodHRwczovL3d3dy52ZXJpc2ln
 bi5jb20vcnBhIChjKTA5MR4wHAYDVQQLExVQZXJzb25hIE5vdCBWYWxpZGF0ZWQxNzA1BgNVBAMT
 LlZlcmlTaWduIENsYXNzIDEgSW5kaXZpZHVhbCBTdWJzY3JpYmVyIENBIC0gRzMCEHbDqMitQnj5
 Qd81mMX31uMwggEFBgsqhkiG9w0BCRACCzGB9aCB8jCB3TELMAkGA1UEBhMCVVMxFzAVBgNVBAoT
 DlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTswOQYDVQQL
 EzJUZXJtcyBvZiB1c2UgYXQgaHR0cHM6Ly93d3cudmVyaXNpZ24uY29tL3JwYSAoYykwOTEeMBwG
 A1UECxMVUGVyc29uYSBOb3QgVmFsaWRhdGVkMTcwNQYDVQQDEy5WZXJpU2lnbiBDbGFzcyAxIElu
 ZGl2aWR1YWwgU3Vic2NyaWJlciBDQSAtIEczAhB2w6jIrUJ4+UHfNZjF99bjMA0GCSqGSIb3DQEB
 AQUABIIBAC+m6wY2W+28M8xsH3tlV5Gs5BSMFtvatxQwb5zKwP+oFogmE5bxyBQvLRlkYYIlTRPV
 v4DTXEUuNx0/omf6r/Yl6p23IjIHHjuAU2oLDvR0kfbvR70QFnGQ3jY+Z/si9icEomklthZoCefL
 HciKFkOupxcCYQp59iDovU8E0Shg8iomwVmR81peUXppr2JlzszyqOoauK2bdy3HD0ZwA0rkH+LQ
 6aw2SJDmHdk/6jXeZxzA14yp3YzHganci5xukhyQkYzwkFioWJyKsyeDmhPDQBhf20rZmIkYbDRY
 WwsKnN+MpSP94nVuj+LHIr/EiwQRR4AHsXShpTdbd4vzjQEAAAAAAAA=
 
 --Apple-Mail=_C9AAE42F-E6CE-4C6C-8E81-1FAAE12A7785--
From: Jay McCarthy <jay.mccarthy@gmail.com>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: bugs@racket-lang.org, Robby Findler <robby@eecs.northwestern.edu>,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13097: element (from xml/xml) sends weird error message
Date: Wed, 5 Sep 2012 15:54:32 -0600

 Okay, I just updated to the latest git release. I didn't get the
 problem with either your large program or the simple REPL sequence.
 
 Jay
 
 On Wed, Sep 5, 2012 at 2:50 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >
 > 1. I just ran the program in 2 again and the error is repeatable:
 >
 > Welcome to DrRacket, version 5.3.0.21--2012-09-03(7d2ce136/d) [3m].
 > Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >> (element 0 0 1 2 3)
 > . . make-element: contract violation
 >  expected: (or/c location? symbol? #f)
 >  given: 0
 >  in: the 1st argument of
 >       (->
 >        (or/c location? symbol? #f)
 >        (or/c location? symbol? #f)
 >        symbol?
 >        (listof attribute?)
 >        (listof
 >         (or/c
 >          permissive/c
 >          pcdata?
 >          element?
 >          entity?
 >          comment?
 >          cdata?
 >          p-i?))
 >        element?)
 >  contract from:
 >       <collects>/xml/private/structures.rkt
 >  blaming:
 >       /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >> (element 0 0 1 2 3)
 > define-values: assignment disallowed;
 >  cannot re-define a constant
 >   constant: lifted.10.12
 >
 > 2.
 >
 >
 > #! /bin/sh
 > #|
 > exec racket -tm "$0" ${1+"$@"}
 > |#
 >
 > #lang racket
 >
 > (provide main)
 >
 > ;; accept the shortest sequence of LetterKeyEvents that match some regular exp.
 > ;; ---------------------------------------------------------------------------------------------------
 >
 > (require 2htdp/universe 2htdp/image rackunit)
 >
 > (require xml/xml)
 > ;; should come with the above:
 > (define-syntax-rule
 >   (element-named-attributes msg name:id ...)
 >   ;; XML-Element -> [Listof String]
 >   (lambda (e)
 >     (match (element-attributes e)
 >       [(list-no-order (attribute _ _ 'name:id name:id) ...)
 >        (values name:id ...)]
 >       [else (error 'parse (format msg e))])))
 >
 > ;; XML-Element Symbol *->* [Listof XML-Element]
 > ;; retrieve all elements with name n in name*
 > (define (elements-named-content e . name*)
 >   (define c (filter element? (element-content e)))
 >   (define l
 >     (for/list ((n name*)) (filter (lambda (x) (eq? (element-name x) n)) c)))
 >   (unless (= (- (length c) (apply + (map length l))) 0)
 >     (displayln (- (length c) (length l)))
 >     (for ((e c))
 >       (unless (memq e l)
 >         (displayln `(not found ,e))))
 >     (error 'element-named-elements "too many [~s] elements: ~e" name* l))
 >   (apply values l))
 >
 > ;; ---------------------------------------------------------------------------------------------------
 > ;; THE MAIN FUNCTION
 >
 > ;; String[File] -> "d" or "error"
 > (define (main f)
 >   (with-handlers ((exn:fail? (lambda (e) (displayln (exn-message e)))))
 >     (define x:xml (with-input-from-file f read-xml/element))
 >     (define x:fsm (parse x:xml))
 >     (accept x:fsm)
 >     (sleep 1)))
 >
 > ;; ---------------------------------------------------------------------------------------------------
 > ;; Parse the XML into the internal FSM data structure
 >
 > ;; Any -> FSM
 > ;; parse the given
 >
 > (module+ test
 >   (define (read-parse xml0:string)
 >     (parse (read-xml/element (open-input-string xml0:string))))
 >   (define xml0:string
 >     #<< eos
 >     <fsm initial="a">
 >        <final name="d"></final>
 >        <transition current="a" next="bc">
 >           <action value="a"></action>
 >        </transition>
 >        <transition current="bc" next="bc">
 >           <action value="b"></action>
 >           <action value="c"></action>
 >        </transition>
 >        <transition current="bc" next="d">
 >          <action value="d"></action>
 >        </transition>
 >     </fsm>
 >  eos
 >     )
 >   (check-equal? (read-parse xml0:string) fsm0)
 >
 >   (define xml0-b:string
 >     #<< eos
 >     <fsm initial="a">
 >        <final name="d" />
 >        <transition current="a" next="bc">
 >           <action value="a" />
 >        </transition>
 >        <transition current="bc" next="bc">
 >           <action value="b" />
 >           <action value="c" />
 >        </transition>
 >        <transition current="bc" next="d">
 >          <action value="d" />
 >        </transition>
 >     </fsm>
 >  eos
 >     )
 >   (check-equal? (read-parse xml0-b:string) fsm0))
 >
 > (define (parse x)
 >   ;; parse does not check the names of states because all strings are allowed
 >   (define (<fsm> x)
 >     (define parse-initial
 >       (element-named-attributes "not an initial: ~e" initial))
 >     (define (<finals> e*)
 >       (map (element-named-attributes "not a final specification: ~e" name) e*))
 >     (define (<transition*> e*)
 >       (define (<transition> e)
 >         (define-values (c n) ((element-named-attributes "not a transition: ~e" current next) e))
 >         (define k* (elements-named-content e 'action))
 >         (transition c (map (compose key>>> (element-named-attributes "not an action:" value)) k*) n))
 >       (map <transition> e*))
 >     (define (key>>> x)
 >       (unless (and (= (string-length x) 1) (regexp-match #px"\\d|[a-zA-Z]" x))
 >         (error "not an alphanumeric key: ~e" x))
 >       x)
 >     ;; -- IN --
 >     (unless (eq? (element-name x) 'fsm) (error 'parse "not an fsm: ~e" x))
 >     (define-values (f t) (elements-named-content x 'final 'transition))
 >     (fsm (parse-initial x) (<finals> f) (<transition*> t)))
 >   ;; -- IN --
 >   (<fsm> x))
 >
 > ;; ---------------------------------------------------------------------------------------------------
 > ;; deal with one FSM
 >
 > ;; FSM        = (fsm State [List-of State] [List-of Transition])
 > ;; State      = String
 > ;; Transition = (transition State [List-of LetterKeyEvent] State)
 >
 > (struct fsm (initial finals transitions) #:transparent)
 > (struct transition (current keys next) #:transparent)
 >
 > (define ER "error")
 > (define state? string?)
 > (define state=? string=?)
 >
 > ;; EXAMPLE: a(b|c)*d
 > (define AA "a")
 > (define BC "bc")
 > (define DD "d")
 >
 > (define t*
 >   (list (transition AA (list "a") BC)
 >         (transition BC (list "b" "c") BC)
 >         (transition BC (list "d") DD)))
 > (define i0 AA)
 > (define f* (list DD))
 > (define fsm0 (fsm i0 f* t*))
 >
 > ;; -----------------------------------------------------------------------------
 > ;; GRAPHICAL CONSTANTS
 > (define SIZE 100)
 > (define white  (square SIZE "solid" "white"))
 > (define yellow (square SIZE "solid" "yellow"))
 > (define green  (square SIZE "solid" "green"))
 > (define red    (square SIZE "solid" "red"))
 >
 > ;; -----------------------------------------------------------------------------
 > ;; FSM -> State or "unacceptable"
 > (define (accept fsm)
 >   (define i0 (fsm-initial fsm))
 >   (define f* (fsm-finals fsm))
 >   (big-bang i0
 >             (on-key (next (fsm-transitions fsm)))
 >             (to-draw (image i0 f*))
 >             (stop-when (lambda (w) (cons? (member w (cons ER f*)))))))
 >
 > ;; -----------------------------------------------------------------------------
 > ;; Transition* State KeyEvent -> State
 > ;; retrieve the next state from a (transition ...) in t* such that ...
 > ;; if there is no such transition, signal the error "can't happen"
 >
 > (module+ test
 >   (check-equal? ((next t*) AA "a") BC)
 >   (check-equal? ((next t*) AA "b") ER)
 >   (check-equal? ((next t*) AA "c") ER)
 >   (check-equal? ((next t*) AA "d") ER)
 >   (check-equal? ((next t*) AA "e") ER)
 >   (check-equal? ((next t*) AA "left") ER)
 >
 >   (check-equal? ((next t*) BC "a") ER)
 >   (check-equal? ((next t*) BC "b") BC)
 >   (check-equal? ((next t*) BC "c") BC)
 >   (check-equal? ((next t*) BC "d") DD)
 >   (check-equal? ((next t*) BC "e") ER)
 >   (check-equal? ((next t*) BC "left") ER)
 >
 >   (check-equal? ((next t*) DD "a") ER))
 >
 > (define ((next t*) current ke)
 >   (or (for/or ((t t*))
 >         (and (state=? (transition-current t) current)
 >              (member ke (transition-keys t))
 >              (transition-next t)))
 >       ER))
 >
 > ;; -----------------------------------------------------------------------------
 > ;; State State [Listof State] -> Image
 > ;; render state as image
 >
 > (module+ test
 >   (check-equal? ((image i0 f*) AA) white)
 >   (check-equal? ((image i0 f*) BC) yellow)
 >   (check-equal? ((image i0 f*) DD) green)
 >   (check-equal? ((image i0 f*) ER) red))
 >
 > (define ((image initial finals) current)
 >   (cond
 >     [(state=? current initial) white]
 >     [(member current finals) green]
 >     [(state=? current ER) red]
 >     [else yellow]))
 
 
 
 -- 
 Jay McCarthy <jay@cs.byu.edu>
 Assistant Professor / Brigham Young University
 http://faculty.cs.byu.edu/~jay
 
 "The glory of God is Intelligence" - D&C 93
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Jay McCarthy <jay.mccarthy@gmail.com>
Cc: bugs@racket-lang.org, Robby Findler <robby@eecs.northwestern.edu>,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13097: element (from xml/xml) sends weird error message
Date: Wed, 5 Sep 2012 21:05:32 -0400

 I re-build from scratch. I re-ran the program. I get the same bug: see new sha. 
 
 Welcome to DrRacket, version 5.3.0.22--2012-09-05(3d8fc4ad/d) [3m].
 Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 > (element 0 1 2 3 4)
 . . make-element: contract violation
  expected: (or/c location? symbol? #f)
  given: 0
  in: the 1st argument of
       (->
        (or/c location? symbol? #f)
        (or/c location? symbol? #f)
        symbol?
        (listof attribute?)
        (listof
         (or/c
          permissive/c
          pcdata?
          element?
          entity?
          comment?
          cdata?
          p-i?))
        element?)
  contract from: 
       <collects>/xml/private/structures.rkt
  blaming: 
       /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 > (element 0 1 2 3 4)
 define-values: assignment disallowed;
  cannot re-define a constant
   constant: lifted.10.12
 
 
 
 
 
 
 On Sep 5, 2012, at 5:54 PM, Jay McCarthy wrote:
 
 > Okay, I just updated to the latest git release. I didn't get the
 > problem with either your large program or the simple REPL sequence.
 > 
 > Jay
 > 
 > On Wed, Sep 5, 2012 at 2:50 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >> 
 >> 1. I just ran the program in 2 again and the error is repeatable:
 >> 
 >> Welcome to DrRacket, version 5.3.0.21--2012-09-03(7d2ce136/d) [3m].
 >> Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >>> (element 0 0 1 2 3)
 >> . . make-element: contract violation
 >> expected: (or/c location? symbol? #f)
 >> given: 0
 >> in: the 1st argument of
 >>      (->
 >>       (or/c location? symbol? #f)
 >>       (or/c location? symbol? #f)
 >>       symbol?
 >>       (listof attribute?)
 >>       (listof
 >>        (or/c
 >>         permissive/c
 >>         pcdata?
 >>         element?
 >>         entity?
 >>         comment?
 >>         cdata?
 >>         p-i?))
 >>       element?)
 >> contract from:
 >>      <collects>/xml/private/structures.rkt
 >> blaming:
 >>      /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >>> (element 0 0 1 2 3)
 >> define-values: assignment disallowed;
 >> cannot re-define a constant
 >>  constant: lifted.10.12
 >> 
 >> 2.
 >> 
 >> 
 >> #! /bin/sh
 >> #|
 >> exec racket -tm "$0" ${1+"$@"}
 >> |#
 >> 
 >> #lang racket
 >> 
 >> (provide main)
 >> 
 >> ;; accept the shortest sequence of LetterKeyEvents that match some regular exp.
 >> ;; ---------------------------------------------------------------------------------------------------
 >> 
 >> (require 2htdp/universe 2htdp/image rackunit)
 >> 
 >> (require xml/xml)
 >> ;; should come with the above:
 >> (define-syntax-rule
 >>  (element-named-attributes msg name:id ...)
 >>  ;; XML-Element -> [Listof String]
 >>  (lambda (e)
 >>    (match (element-attributes e)
 >>      [(list-no-order (attribute _ _ 'name:id name:id) ...)
 >>       (values name:id ...)]
 >>      [else (error 'parse (format msg e))])))
 >> 
 >> ;; XML-Element Symbol *->* [Listof XML-Element]
 >> ;; retrieve all elements with name n in name*
 >> (define (elements-named-content e . name*)
 >>  (define c (filter element? (element-content e)))
 >>  (define l
 >>    (for/list ((n name*)) (filter (lambda (x) (eq? (element-name x) n)) c)))
 >>  (unless (= (- (length c) (apply + (map length l))) 0)
 >>    (displayln (- (length c) (length l)))
 >>    (for ((e c))
 >>      (unless (memq e l)
 >>        (displayln `(not found ,e))))
 >>    (error 'element-named-elements "too many [~s] elements: ~e" name* l))
 >>  (apply values l))
 >> 
 >> ;; ---------------------------------------------------------------------------------------------------
 >> ;; THE MAIN FUNCTION
 >> 
 >> ;; String[File] -> "d" or "error"
 >> (define (main f)
 >>  (with-handlers ((exn:fail? (lambda (e) (displayln (exn-message e)))))
 >>    (define x:xml (with-input-from-file f read-xml/element))
 >>    (define x:fsm (parse x:xml))
 >>    (accept x:fsm)
 >>    (sleep 1)))
 >> 
 >> ;; ---------------------------------------------------------------------------------------------------
 >> ;; Parse the XML into the internal FSM data structure
 >> 
 >> ;; Any -> FSM
 >> ;; parse the given
 >> 
 >> (module+ test
 >>  (define (read-parse xml0:string)
 >>    (parse (read-xml/element (open-input-string xml0:string))))
 >>  (define xml0:string
 >>    #<< eos
 >>    <fsm initial="a">
 >>       <final name="d"></final>
 >>       <transition current="a" next="bc">
 >>          <action value="a"></action>
 >>       </transition>
 >>       <transition current="bc" next="bc">
 >>          <action value="b"></action>
 >>          <action value="c"></action>
 >>       </transition>
 >>       <transition current="bc" next="d">
 >>         <action value="d"></action>
 >>       </transition>
 >>    </fsm>
 >> eos
 >>    )
 >>  (check-equal? (read-parse xml0:string) fsm0)
 >> 
 >>  (define xml0-b:string
 >>    #<< eos
 >>    <fsm initial="a">
 >>       <final name="d" />
 >>       <transition current="a" next="bc">
 >>          <action value="a" />
 >>       </transition>
 >>       <transition current="bc" next="bc">
 >>          <action value="b" />
 >>          <action value="c" />
 >>       </transition>
 >>       <transition current="bc" next="d">
 >>         <action value="d" />
 >>       </transition>
 >>    </fsm>
 >> eos
 >>    )
 >>  (check-equal? (read-parse xml0-b:string) fsm0))
 >> 
 >> (define (parse x)
 >>  ;; parse does not check the names of states because all strings are allowed
 >>  (define (<fsm> x)
 >>    (define parse-initial
 >>      (element-named-attributes "not an initial: ~e" initial))
 >>    (define (<finals> e*)
 >>      (map (element-named-attributes "not a final specification: ~e" name) e*))
 >>    (define (<transition*> e*)
 >>      (define (<transition> e)
 >>        (define-values (c n) ((element-named-attributes "not a transition: ~e" current next) e))
 >>        (define k* (elements-named-content e 'action))
 >>        (transition c (map (compose key>>> (element-named-attributes "not an action:" value)) k*) n))
 >>      (map <transition> e*))
 >>    (define (key>>> x)
 >>      (unless (and (= (string-length x) 1) (regexp-match #px"\\d|[a-zA-Z]" x))
 >>        (error "not an alphanumeric key: ~e" x))
 >>      x)
 >>    ;; -- IN --
 >>    (unless (eq? (element-name x) 'fsm) (error 'parse "not an fsm: ~e" x))
 >>    (define-values (f t) (elements-named-content x 'final 'transition))
 >>    (fsm (parse-initial x) (<finals> f) (<transition*> t)))
 >>  ;; -- IN --
 >>  (<fsm> x))
 >> 
 >> ;; ---------------------------------------------------------------------------------------------------
 >> ;; deal with one FSM
 >> 
 >> ;; FSM        = (fsm State [List-of State] [List-of Transition])
 >> ;; State      = String
 >> ;; Transition = (transition State [List-of LetterKeyEvent] State)
 >> 
 >> (struct fsm (initial finals transitions) #:transparent)
 >> (struct transition (current keys next) #:transparent)
 >> 
 >> (define ER "error")
 >> (define state? string?)
 >> (define state=? string=?)
 >> 
 >> ;; EXAMPLE: a(b|c)*d
 >> (define AA "a")
 >> (define BC "bc")
 >> (define DD "d")
 >> 
 >> (define t*
 >>  (list (transition AA (list "a") BC)
 >>        (transition BC (list "b" "c") BC)
 >>        (transition BC (list "d") DD)))
 >> (define i0 AA)
 >> (define f* (list DD))
 >> (define fsm0 (fsm i0 f* t*))
 >> 
 >> ;; -----------------------------------------------------------------------------
 >> ;; GRAPHICAL CONSTANTS
 >> (define SIZE 100)
 >> (define white  (square SIZE "solid" "white"))
 >> (define yellow (square SIZE "solid" "yellow"))
 >> (define green  (square SIZE "solid" "green"))
 >> (define red    (square SIZE "solid" "red"))
 >> 
 >> ;; -----------------------------------------------------------------------------
 >> ;; FSM -> State or "unacceptable"
 >> (define (accept fsm)
 >>  (define i0 (fsm-initial fsm))
 >>  (define f* (fsm-finals fsm))
 >>  (big-bang i0
 >>            (on-key (next (fsm-transitions fsm)))
 >>            (to-draw (image i0 f*))
 >>            (stop-when (lambda (w) (cons? (member w (cons ER f*)))))))
 >> 
 >> ;; -----------------------------------------------------------------------------
 >> ;; Transition* State KeyEvent -> State
 >> ;; retrieve the next state from a (transition ...) in t* such that ...
 >> ;; if there is no such transition, signal the error "can't happen"
 >> 
 >> (module+ test
 >>  (check-equal? ((next t*) AA "a") BC)
 >>  (check-equal? ((next t*) AA "b") ER)
 >>  (check-equal? ((next t*) AA "c") ER)
 >>  (check-equal? ((next t*) AA "d") ER)
 >>  (check-equal? ((next t*) AA "e") ER)
 >>  (check-equal? ((next t*) AA "left") ER)
 >> 
 >>  (check-equal? ((next t*) BC "a") ER)
 >>  (check-equal? ((next t*) BC "b") BC)
 >>  (check-equal? ((next t*) BC "c") BC)
 >>  (check-equal? ((next t*) BC "d") DD)
 >>  (check-equal? ((next t*) BC "e") ER)
 >>  (check-equal? ((next t*) BC "left") ER)
 >> 
 >>  (check-equal? ((next t*) DD "a") ER))
 >> 
 >> (define ((next t*) current ke)
 >>  (or (for/or ((t t*))
 >>        (and (state=? (transition-current t) current)
 >>             (member ke (transition-keys t))
 >>             (transition-next t)))
 >>      ER))
 >> 
 >> ;; -----------------------------------------------------------------------------
 >> ;; State State [Listof State] -> Image
 >> ;; render state as image
 >> 
 >> (module+ test
 >>  (check-equal? ((image i0 f*) AA) white)
 >>  (check-equal? ((image i0 f*) BC) yellow)
 >>  (check-equal? ((image i0 f*) DD) green)
 >>  (check-equal? ((image i0 f*) ER) red))
 >> 
 >> (define ((image initial finals) current)
 >>  (cond
 >>    [(state=? current initial) white]
 >>    [(member current finals) green]
 >>    [(state=? current ER) red]
 >>    [else yellow]))
 > 
 > 
 > 
 > -- 
 > Jay McCarthy <jay@cs.byu.edu>
 > Assistant Professor / Brigham Young University
 > http://faculty.cs.byu.edu/~jay
 > 
 > "The glory of God is Intelligence" - D&C 93
 
 
From: Jay McCarthy <jay.mccarthy@gmail.com>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: bugs@racket-lang.org, Robby Findler <robby@eecs.northwestern.edu>,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13097: element (from xml/xml) sends weird error message
Date: Wed, 5 Sep 2012 19:13:26 -0600

 This makes me think it's a Linux vs OS X issue. I'll try to test on OS X.
 
 Jay
 
 On Wed, Sep 5, 2012 at 7:05 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >
 > I re-build from scratch. I re-ran the program. I get the same bug: see new sha.
 >
 > Welcome to DrRacket, version 5.3.0.22--2012-09-05(3d8fc4ad/d) [3m].
 > Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >> (element 0 1 2 3 4)
 > . . make-element: contract violation
 >  expected: (or/c location? symbol? #f)
 >  given: 0
 >  in: the 1st argument of
 >       (->
 >        (or/c location? symbol? #f)
 >        (or/c location? symbol? #f)
 >        symbol?
 >        (listof attribute?)
 >        (listof
 >         (or/c
 >          permissive/c
 >          pcdata?
 >          element?
 >          entity?
 >          comment?
 >          cdata?
 >          p-i?))
 >        element?)
 >  contract from:
 >       <collects>/xml/private/structures.rkt
 >  blaming:
 >       /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >> (element 0 1 2 3 4)
 > define-values: assignment disallowed;
 >  cannot re-define a constant
 >   constant: lifted.10.12
 >
 >
 >
 >
 >
 >
 > On Sep 5, 2012, at 5:54 PM, Jay McCarthy wrote:
 >
 >> Okay, I just updated to the latest git release. I didn't get the
 >> problem with either your large program or the simple REPL sequence.
 >>
 >> Jay
 >>
 >> On Wed, Sep 5, 2012 at 2:50 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >>>
 >>> 1. I just ran the program in 2 again and the error is repeatable:
 >>>
 >>> Welcome to DrRacket, version 5.3.0.21--2012-09-03(7d2ce136/d) [3m].
 >>> Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >>>> (element 0 0 1 2 3)
 >>> . . make-element: contract violation
 >>> expected: (or/c location? symbol? #f)
 >>> given: 0
 >>> in: the 1st argument of
 >>>      (->
 >>>       (or/c location? symbol? #f)
 >>>       (or/c location? symbol? #f)
 >>>       symbol?
 >>>       (listof attribute?)
 >>>       (listof
 >>>        (or/c
 >>>         permissive/c
 >>>         pcdata?
 >>>         element?
 >>>         entity?
 >>>         comment?
 >>>         cdata?
 >>>         p-i?))
 >>>       element?)
 >>> contract from:
 >>>      <collects>/xml/private/structures.rkt
 >>> blaming:
 >>>      /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >>>> (element 0 0 1 2 3)
 >>> define-values: assignment disallowed;
 >>> cannot re-define a constant
 >>>  constant: lifted.10.12
 >>>
 >>> 2.
 >>>
 >>>
 >>> #! /bin/sh
 >>> #|
 >>> exec racket -tm "$0" ${1+"$@"}
 >>> |#
 >>>
 >>> #lang racket
 >>>
 >>> (provide main)
 >>>
 >>> ;; accept the shortest sequence of LetterKeyEvents that match some regular exp.
 >>> ;; ---------------------------------------------------------------------------------------------------
 >>>
 >>> (require 2htdp/universe 2htdp/image rackunit)
 >>>
 >>> (require xml/xml)
 >>> ;; should come with the above:
 >>> (define-syntax-rule
 >>>  (element-named-attributes msg name:id ...)
 >>>  ;; XML-Element -> [Listof String]
 >>>  (lambda (e)
 >>>    (match (element-attributes e)
 >>>      [(list-no-order (attribute _ _ 'name:id name:id) ...)
 >>>       (values name:id ...)]
 >>>      [else (error 'parse (format msg e))])))
 >>>
 >>> ;; XML-Element Symbol *->* [Listof XML-Element]
 >>> ;; retrieve all elements with name n in name*
 >>> (define (elements-named-content e . name*)
 >>>  (define c (filter element? (element-content e)))
 >>>  (define l
 >>>    (for/list ((n name*)) (filter (lambda (x) (eq? (element-name x) n)) c)))
 >>>  (unless (= (- (length c) (apply + (map length l))) 0)
 >>>    (displayln (- (length c) (length l)))
 >>>    (for ((e c))
 >>>      (unless (memq e l)
 >>>        (displayln `(not found ,e))))
 >>>    (error 'element-named-elements "too many [~s] elements: ~e" name* l))
 >>>  (apply values l))
 >>>
 >>> ;; ---------------------------------------------------------------------------------------------------
 >>> ;; THE MAIN FUNCTION
 >>>
 >>> ;; String[File] -> "d" or "error"
 >>> (define (main f)
 >>>  (with-handlers ((exn:fail? (lambda (e) (displayln (exn-message e)))))
 >>>    (define x:xml (with-input-from-file f read-xml/element))
 >>>    (define x:fsm (parse x:xml))
 >>>    (accept x:fsm)
 >>>    (sleep 1)))
 >>>
 >>> ;; ---------------------------------------------------------------------------------------------------
 >>> ;; Parse the XML into the internal FSM data structure
 >>>
 >>> ;; Any -> FSM
 >>> ;; parse the given
 >>>
 >>> (module+ test
 >>>  (define (read-parse xml0:string)
 >>>    (parse (read-xml/element (open-input-string xml0:string))))
 >>>  (define xml0:string
 >>>    #<< eos
 >>>    <fsm initial="a">
 >>>       <final name="d"></final>
 >>>       <transition current="a" next="bc">
 >>>          <action value="a"></action>
 >>>       </transition>
 >>>       <transition current="bc" next="bc">
 >>>          <action value="b"></action>
 >>>          <action value="c"></action>
 >>>       </transition>
 >>>       <transition current="bc" next="d">
 >>>         <action value="d"></action>
 >>>       </transition>
 >>>    </fsm>
 >>> eos
 >>>    )
 >>>  (check-equal? (read-parse xml0:string) fsm0)
 >>>
 >>>  (define xml0-b:string
 >>>    #<< eos
 >>>    <fsm initial="a">
 >>>       <final name="d" />
 >>>       <transition current="a" next="bc">
 >>>          <action value="a" />
 >>>       </transition>
 >>>       <transition current="bc" next="bc">
 >>>          <action value="b" />
 >>>          <action value="c" />
 >>>       </transition>
 >>>       <transition current="bc" next="d">
 >>>         <action value="d" />
 >>>       </transition>
 >>>    </fsm>
 >>> eos
 >>>    )
 >>>  (check-equal? (read-parse xml0-b:string) fsm0))
 >>>
 >>> (define (parse x)
 >>>  ;; parse does not check the names of states because all strings are allowed
 >>>  (define (<fsm> x)
 >>>    (define parse-initial
 >>>      (element-named-attributes "not an initial: ~e" initial))
 >>>    (define (<finals> e*)
 >>>      (map (element-named-attributes "not a final specification: ~e" name) e*))
 >>>    (define (<transition*> e*)
 >>>      (define (<transition> e)
 >>>        (define-values (c n) ((element-named-attributes "not a transition: ~e" current next) e))
 >>>        (define k* (elements-named-content e 'action))
 >>>        (transition c (map (compose key>>> (element-named-attributes "not an action:" value)) k*) n))
 >>>      (map <transition> e*))
 >>>    (define (key>>> x)
 >>>      (unless (and (= (string-length x) 1) (regexp-match #px"\\d|[a-zA-Z]" x))
 >>>        (error "not an alphanumeric key: ~e" x))
 >>>      x)
 >>>    ;; -- IN --
 >>>    (unless (eq? (element-name x) 'fsm) (error 'parse "not an fsm: ~e" x))
 >>>    (define-values (f t) (elements-named-content x 'final 'transition))
 >>>    (fsm (parse-initial x) (<finals> f) (<transition*> t)))
 >>>  ;; -- IN --
 >>>  (<fsm> x))
 >>>
 >>> ;; ---------------------------------------------------------------------------------------------------
 >>> ;; deal with one FSM
 >>>
 >>> ;; FSM        = (fsm State [List-of State] [List-of Transition])
 >>> ;; State      = String
 >>> ;; Transition = (transition State [List-of LetterKeyEvent] State)
 >>>
 >>> (struct fsm (initial finals transitions) #:transparent)
 >>> (struct transition (current keys next) #:transparent)
 >>>
 >>> (define ER "error")
 >>> (define state? string?)
 >>> (define state=? string=?)
 >>>
 >>> ;; EXAMPLE: a(b|c)*d
 >>> (define AA "a")
 >>> (define BC "bc")
 >>> (define DD "d")
 >>>
 >>> (define t*
 >>>  (list (transition AA (list "a") BC)
 >>>        (transition BC (list "b" "c") BC)
 >>>        (transition BC (list "d") DD)))
 >>> (define i0 AA)
 >>> (define f* (list DD))
 >>> (define fsm0 (fsm i0 f* t*))
 >>>
 >>> ;; -----------------------------------------------------------------------------
 >>> ;; GRAPHICAL CONSTANTS
 >>> (define SIZE 100)
 >>> (define white  (square SIZE "solid" "white"))
 >>> (define yellow (square SIZE "solid" "yellow"))
 >>> (define green  (square SIZE "solid" "green"))
 >>> (define red    (square SIZE "solid" "red"))
 >>>
 >>> ;; -----------------------------------------------------------------------------
 >>> ;; FSM -> State or "unacceptable"
 >>> (define (accept fsm)
 >>>  (define i0 (fsm-initial fsm))
 >>>  (define f* (fsm-finals fsm))
 >>>  (big-bang i0
 >>>            (on-key (next (fsm-transitions fsm)))
 >>>            (to-draw (image i0 f*))
 >>>            (stop-when (lambda (w) (cons? (member w (cons ER f*)))))))
 >>>
 >>> ;; -----------------------------------------------------------------------------
 >>> ;; Transition* State KeyEvent -> State
 >>> ;; retrieve the next state from a (transition ...) in t* such that ...
 >>> ;; if there is no such transition, signal the error "can't happen"
 >>>
 >>> (module+ test
 >>>  (check-equal? ((next t*) AA "a") BC)
 >>>  (check-equal? ((next t*) AA "b") ER)
 >>>  (check-equal? ((next t*) AA "c") ER)
 >>>  (check-equal? ((next t*) AA "d") ER)
 >>>  (check-equal? ((next t*) AA "e") ER)
 >>>  (check-equal? ((next t*) AA "left") ER)
 >>>
 >>>  (check-equal? ((next t*) BC "a") ER)
 >>>  (check-equal? ((next t*) BC "b") BC)
 >>>  (check-equal? ((next t*) BC "c") BC)
 >>>  (check-equal? ((next t*) BC "d") DD)
 >>>  (check-equal? ((next t*) BC "e") ER)
 >>>  (check-equal? ((next t*) BC "left") ER)
 >>>
 >>>  (check-equal? ((next t*) DD "a") ER))
 >>>
 >>> (define ((next t*) current ke)
 >>>  (or (for/or ((t t*))
 >>>        (and (state=? (transition-current t) current)
 >>>             (member ke (transition-keys t))
 >>>             (transition-next t)))
 >>>      ER))
 >>>
 >>> ;; -----------------------------------------------------------------------------
 >>> ;; State State [Listof State] -> Image
 >>> ;; render state as image
 >>>
 >>> (module+ test
 >>>  (check-equal? ((image i0 f*) AA) white)
 >>>  (check-equal? ((image i0 f*) BC) yellow)
 >>>  (check-equal? ((image i0 f*) DD) green)
 >>>  (check-equal? ((image i0 f*) ER) red))
 >>>
 >>> (define ((image initial finals) current)
 >>>  (cond
 >>>    [(state=? current initial) white]
 >>>    [(member current finals) green]
 >>>    [(state=? current ER) red]
 >>>    [else yellow]))
 >>
 >>
 >>
 >> --
 >> Jay McCarthy <jay@cs.byu.edu>
 >> Assistant Professor / Brigham Young University
 >> http://faculty.cs.byu.edu/~jay
 >>
 >> "The glory of God is Intelligence" - D&C 93
 >
 
 
 
 -- 
 Jay McCarthy <jay@cs.byu.edu>
 Assistant Professor / Brigham Young University
 http://faculty.cs.byu.edu/~jay
 
 "The glory of God is Intelligence" - D&C 93
From: Robby Findler <robby@eecs.northwestern.edu>
To: Jay McCarthy <jay.mccarthy@gmail.com>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>, bugs@racket-lang.org,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13097: element (from xml/xml) sends weird error message
Date: Thu, 6 Sep 2012 07:25:16 +0200

 Does this happen only in the REPL?
 
 Robby
 
 On Thu, Sep 6, 2012 at 3:13 AM, Jay McCarthy <jay.mccarthy@gmail.com> wrote:
 > This makes me think it's a Linux vs OS X issue. I'll try to test on OS X.
 >
 > Jay
 >
 > On Wed, Sep 5, 2012 at 7:05 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >>
 >> I re-build from scratch. I re-ran the program. I get the same bug: see new sha.
 >>
 >> Welcome to DrRacket, version 5.3.0.22--2012-09-05(3d8fc4ad/d) [3m].
 >> Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >>> (element 0 1 2 3 4)
 >> . . make-element: contract violation
 >>  expected: (or/c location? symbol? #f)
 >>  given: 0
 >>  in: the 1st argument of
 >>       (->
 >>        (or/c location? symbol? #f)
 >>        (or/c location? symbol? #f)
 >>        symbol?
 >>        (listof attribute?)
 >>        (listof
 >>         (or/c
 >>          permissive/c
 >>          pcdata?
 >>          element?
 >>          entity?
 >>          comment?
 >>          cdata?
 >>          p-i?))
 >>        element?)
 >>  contract from:
 >>       <collects>/xml/private/structures.rkt
 >>  blaming:
 >>       /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >>> (element 0 1 2 3 4)
 >> define-values: assignment disallowed;
 >>  cannot re-define a constant
 >>   constant: lifted.10.12
 >>
 >>
 >>
 >>
 >>
 >>
 >> On Sep 5, 2012, at 5:54 PM, Jay McCarthy wrote:
 >>
 >>> Okay, I just updated to the latest git release. I didn't get the
 >>> problem with either your large program or the simple REPL sequence.
 >>>
 >>> Jay
 >>>
 >>> On Wed, Sep 5, 2012 at 2:50 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >>>>
 >>>> 1. I just ran the program in 2 again and the error is repeatable:
 >>>>
 >>>> Welcome to DrRacket, version 5.3.0.21--2012-09-03(7d2ce136/d) [3m].
 >>>> Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >>>>> (element 0 0 1 2 3)
 >>>> . . make-element: contract violation
 >>>> expected: (or/c location? symbol? #f)
 >>>> given: 0
 >>>> in: the 1st argument of
 >>>>      (->
 >>>>       (or/c location? symbol? #f)
 >>>>       (or/c location? symbol? #f)
 >>>>       symbol?
 >>>>       (listof attribute?)
 >>>>       (listof
 >>>>        (or/c
 >>>>         permissive/c
 >>>>         pcdata?
 >>>>         element?
 >>>>         entity?
 >>>>         comment?
 >>>>         cdata?
 >>>>         p-i?))
 >>>>       element?)
 >>>> contract from:
 >>>>      <collects>/xml/private/structures.rkt
 >>>> blaming:
 >>>>      /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >>>>> (element 0 0 1 2 3)
 >>>> define-values: assignment disallowed;
 >>>> cannot re-define a constant
 >>>>  constant: lifted.10.12
 >>>>
 >>>> 2.
 >>>>
 >>>>
 >>>> #! /bin/sh
 >>>> #|
 >>>> exec racket -tm "$0" ${1+"$@"}
 >>>> |#
 >>>>
 >>>> #lang racket
 >>>>
 >>>> (provide main)
 >>>>
 >>>> ;; accept the shortest sequence of LetterKeyEvents that match some regular exp.
 >>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>
 >>>> (require 2htdp/universe 2htdp/image rackunit)
 >>>>
 >>>> (require xml/xml)
 >>>> ;; should come with the above:
 >>>> (define-syntax-rule
 >>>>  (element-named-attributes msg name:id ...)
 >>>>  ;; XML-Element -> [Listof String]
 >>>>  (lambda (e)
 >>>>    (match (element-attributes e)
 >>>>      [(list-no-order (attribute _ _ 'name:id name:id) ...)
 >>>>       (values name:id ...)]
 >>>>      [else (error 'parse (format msg e))])))
 >>>>
 >>>> ;; XML-Element Symbol *->* [Listof XML-Element]
 >>>> ;; retrieve all elements with name n in name*
 >>>> (define (elements-named-content e . name*)
 >>>>  (define c (filter element? (element-content e)))
 >>>>  (define l
 >>>>    (for/list ((n name*)) (filter (lambda (x) (eq? (element-name x) n)) c)))
 >>>>  (unless (= (- (length c) (apply + (map length l))) 0)
 >>>>    (displayln (- (length c) (length l)))
 >>>>    (for ((e c))
 >>>>      (unless (memq e l)
 >>>>        (displayln `(not found ,e))))
 >>>>    (error 'element-named-elements "too many [~s] elements: ~e" name* l))
 >>>>  (apply values l))
 >>>>
 >>>> ;; ---------------------------------------------------------------------------------------------------
 >>>> ;; THE MAIN FUNCTION
 >>>>
 >>>> ;; String[File] -> "d" or "error"
 >>>> (define (main f)
 >>>>  (with-handlers ((exn:fail? (lambda (e) (displayln (exn-message e)))))
 >>>>    (define x:xml (with-input-from-file f read-xml/element))
 >>>>    (define x:fsm (parse x:xml))
 >>>>    (accept x:fsm)
 >>>>    (sleep 1)))
 >>>>
 >>>> ;; ---------------------------------------------------------------------------------------------------
 >>>> ;; Parse the XML into the internal FSM data structure
 >>>>
 >>>> ;; Any -> FSM
 >>>> ;; parse the given
 >>>>
 >>>> (module+ test
 >>>>  (define (read-parse xml0:string)
 >>>>    (parse (read-xml/element (open-input-string xml0:string))))
 >>>>  (define xml0:string
 >>>>    #<< eos
 >>>>    <fsm initial="a">
 >>>>       <final name="d"></final>
 >>>>       <transition current="a" next="bc">
 >>>>          <action value="a"></action>
 >>>>       </transition>
 >>>>       <transition current="bc" next="bc">
 >>>>          <action value="b"></action>
 >>>>          <action value="c"></action>
 >>>>       </transition>
 >>>>       <transition current="bc" next="d">
 >>>>         <action value="d"></action>
 >>>>       </transition>
 >>>>    </fsm>
 >>>> eos
 >>>>    )
 >>>>  (check-equal? (read-parse xml0:string) fsm0)
 >>>>
 >>>>  (define xml0-b:string
 >>>>    #<< eos
 >>>>    <fsm initial="a">
 >>>>       <final name="d" />
 >>>>       <transition current="a" next="bc">
 >>>>          <action value="a" />
 >>>>       </transition>
 >>>>       <transition current="bc" next="bc">
 >>>>          <action value="b" />
 >>>>          <action value="c" />
 >>>>       </transition>
 >>>>       <transition current="bc" next="d">
 >>>>         <action value="d" />
 >>>>       </transition>
 >>>>    </fsm>
 >>>> eos
 >>>>    )
 >>>>  (check-equal? (read-parse xml0-b:string) fsm0))
 >>>>
 >>>> (define (parse x)
 >>>>  ;; parse does not check the names of states because all strings are allowed
 >>>>  (define (<fsm> x)
 >>>>    (define parse-initial
 >>>>      (element-named-attributes "not an initial: ~e" initial))
 >>>>    (define (<finals> e*)
 >>>>      (map (element-named-attributes "not a final specification: ~e" name) e*))
 >>>>    (define (<transition*> e*)
 >>>>      (define (<transition> e)
 >>>>        (define-values (c n) ((element-named-attributes "not a transition: ~e" current next) e))
 >>>>        (define k* (elements-named-content e 'action))
 >>>>        (transition c (map (compose key>>> (element-named-attributes "not an action:" value)) k*) n))
 >>>>      (map <transition> e*))
 >>>>    (define (key>>> x)
 >>>>      (unless (and (= (string-length x) 1) (regexp-match #px"\\d|[a-zA-Z]" x))
 >>>>        (error "not an alphanumeric key: ~e" x))
 >>>>      x)
 >>>>    ;; -- IN --
 >>>>    (unless (eq? (element-name x) 'fsm) (error 'parse "not an fsm: ~e" x))
 >>>>    (define-values (f t) (elements-named-content x 'final 'transition))
 >>>>    (fsm (parse-initial x) (<finals> f) (<transition*> t)))
 >>>>  ;; -- IN --
 >>>>  (<fsm> x))
 >>>>
 >>>> ;; ---------------------------------------------------------------------------------------------------
 >>>> ;; deal with one FSM
 >>>>
 >>>> ;; FSM        = (fsm State [List-of State] [List-of Transition])
 >>>> ;; State      = String
 >>>> ;; Transition = (transition State [List-of LetterKeyEvent] State)
 >>>>
 >>>> (struct fsm (initial finals transitions) #:transparent)
 >>>> (struct transition (current keys next) #:transparent)
 >>>>
 >>>> (define ER "error")
 >>>> (define state? string?)
 >>>> (define state=? string=?)
 >>>>
 >>>> ;; EXAMPLE: a(b|c)*d
 >>>> (define AA "a")
 >>>> (define BC "bc")
 >>>> (define DD "d")
 >>>>
 >>>> (define t*
 >>>>  (list (transition AA (list "a") BC)
 >>>>        (transition BC (list "b" "c") BC)
 >>>>        (transition BC (list "d") DD)))
 >>>> (define i0 AA)
 >>>> (define f* (list DD))
 >>>> (define fsm0 (fsm i0 f* t*))
 >>>>
 >>>> ;; -----------------------------------------------------------------------------
 >>>> ;; GRAPHICAL CONSTANTS
 >>>> (define SIZE 100)
 >>>> (define white  (square SIZE "solid" "white"))
 >>>> (define yellow (square SIZE "solid" "yellow"))
 >>>> (define green  (square SIZE "solid" "green"))
 >>>> (define red    (square SIZE "solid" "red"))
 >>>>
 >>>> ;; -----------------------------------------------------------------------------
 >>>> ;; FSM -> State or "unacceptable"
 >>>> (define (accept fsm)
 >>>>  (define i0 (fsm-initial fsm))
 >>>>  (define f* (fsm-finals fsm))
 >>>>  (big-bang i0
 >>>>            (on-key (next (fsm-transitions fsm)))
 >>>>            (to-draw (image i0 f*))
 >>>>            (stop-when (lambda (w) (cons? (member w (cons ER f*)))))))
 >>>>
 >>>> ;; -----------------------------------------------------------------------------
 >>>> ;; Transition* State KeyEvent -> State
 >>>> ;; retrieve the next state from a (transition ...) in t* such that ...
 >>>> ;; if there is no such transition, signal the error "can't happen"
 >>>>
 >>>> (module+ test
 >>>>  (check-equal? ((next t*) AA "a") BC)
 >>>>  (check-equal? ((next t*) AA "b") ER)
 >>>>  (check-equal? ((next t*) AA "c") ER)
 >>>>  (check-equal? ((next t*) AA "d") ER)
 >>>>  (check-equal? ((next t*) AA "e") ER)
 >>>>  (check-equal? ((next t*) AA "left") ER)
 >>>>
 >>>>  (check-equal? ((next t*) BC "a") ER)
 >>>>  (check-equal? ((next t*) BC "b") BC)
 >>>>  (check-equal? ((next t*) BC "c") BC)
 >>>>  (check-equal? ((next t*) BC "d") DD)
 >>>>  (check-equal? ((next t*) BC "e") ER)
 >>>>  (check-equal? ((next t*) BC "left") ER)
 >>>>
 >>>>  (check-equal? ((next t*) DD "a") ER))
 >>>>
 >>>> (define ((next t*) current ke)
 >>>>  (or (for/or ((t t*))
 >>>>        (and (state=? (transition-current t) current)
 >>>>             (member ke (transition-keys t))
 >>>>             (transition-next t)))
 >>>>      ER))
 >>>>
 >>>> ;; -----------------------------------------------------------------------------
 >>>> ;; State State [Listof State] -> Image
 >>>> ;; render state as image
 >>>>
 >>>> (module+ test
 >>>>  (check-equal? ((image i0 f*) AA) white)
 >>>>  (check-equal? ((image i0 f*) BC) yellow)
 >>>>  (check-equal? ((image i0 f*) DD) green)
 >>>>  (check-equal? ((image i0 f*) ER) red))
 >>>>
 >>>> (define ((image initial finals) current)
 >>>>  (cond
 >>>>    [(state=? current initial) white]
 >>>>    [(member current finals) green]
 >>>>    [(state=? current ER) red]
 >>>>    [else yellow]))
 >>>
 >>>
 >>>
 >>> --
 >>> Jay McCarthy <jay@cs.byu.edu>
 >>> Assistant Professor / Brigham Young University
 >>> http://faculty.cs.byu.edu/~jay
 >>>
 >>> "The glory of God is Intelligence" - D&C 93
 >>
 >
 >
 >
 > --
 > Jay McCarthy <jay@cs.byu.edu>
 > Assistant Professor / Brigham Young University
 > http://faculty.cs.byu.edu/~jay
 >
 > "The glory of God is Intelligence" - D&C 93
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Jay McCarthy <jay.mccarthy@gmail.com>, bugs@racket-lang.org,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13097: element (from xml/xml) sends weird error message
Date: Thu, 6 Sep 2012 08:33:26 -0400

 Only in the REPL. 
 
 
 On Sep 6, 2012, at 1:25 AM, Robby Findler wrote:
 
 > Does this happen only in the REPL?
 > 
 > Robby
 > 
 > On Thu, Sep 6, 2012 at 3:13 AM, Jay McCarthy <jay.mccarthy@gmail.com> wrote:
 >> This makes me think it's a Linux vs OS X issue. I'll try to test on OS X.
 >> 
 >> Jay
 >> 
 >> On Wed, Sep 5, 2012 at 7:05 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >>> 
 >>> I re-build from scratch. I re-ran the program. I get the same bug: see new sha.
 >>> 
 >>> Welcome to DrRacket, version 5.3.0.22--2012-09-05(3d8fc4ad/d) [3m].
 >>> Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >>>> (element 0 1 2 3 4)
 >>> . . make-element: contract violation
 >>> expected: (or/c location? symbol? #f)
 >>> given: 0
 >>> in: the 1st argument of
 >>>      (->
 >>>       (or/c location? symbol? #f)
 >>>       (or/c location? symbol? #f)
 >>>       symbol?
 >>>       (listof attribute?)
 >>>       (listof
 >>>        (or/c
 >>>         permissive/c
 >>>         pcdata?
 >>>         element?
 >>>         entity?
 >>>         comment?
 >>>         cdata?
 >>>         p-i?))
 >>>       element?)
 >>> contract from:
 >>>      <collects>/xml/private/structures.rkt
 >>> blaming:
 >>>      /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >>>> (element 0 1 2 3 4)
 >>> define-values: assignment disallowed;
 >>> cannot re-define a constant
 >>>  constant: lifted.10.12
 >>> 
 >>> 
 >>> 
 >>> 
 >>> 
 >>> 
 >>> On Sep 5, 2012, at 5:54 PM, Jay McCarthy wrote:
 >>> 
 >>>> Okay, I just updated to the latest git release. I didn't get the
 >>>> problem with either your large program or the simple REPL sequence.
 >>>> 
 >>>> Jay
 >>>> 
 >>>> On Wed, Sep 5, 2012 at 2:50 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >>>>> 
 >>>>> 1. I just ran the program in 2 again and the error is repeatable:
 >>>>> 
 >>>>> Welcome to DrRacket, version 5.3.0.21--2012-09-03(7d2ce136/d) [3m].
 >>>>> Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >>>>>> (element 0 0 1 2 3)
 >>>>> . . make-element: contract violation
 >>>>> expected: (or/c location? symbol? #f)
 >>>>> given: 0
 >>>>> in: the 1st argument of
 >>>>>     (->
 >>>>>      (or/c location? symbol? #f)
 >>>>>      (or/c location? symbol? #f)
 >>>>>      symbol?
 >>>>>      (listof attribute?)
 >>>>>      (listof
 >>>>>       (or/c
 >>>>>        permissive/c
 >>>>>        pcdata?
 >>>>>        element?
 >>>>>        entity?
 >>>>>        comment?
 >>>>>        cdata?
 >>>>>        p-i?))
 >>>>>      element?)
 >>>>> contract from:
 >>>>>     <collects>/xml/private/structures.rkt
 >>>>> blaming:
 >>>>>     /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >>>>>> (element 0 0 1 2 3)
 >>>>> define-values: assignment disallowed;
 >>>>> cannot re-define a constant
 >>>>> constant: lifted.10.12
 >>>>> 
 >>>>> 2.
 >>>>> 
 >>>>> 
 >>>>> #! /bin/sh
 >>>>> #|
 >>>>> exec racket -tm "$0" ${1+"$@"}
 >>>>> |#
 >>>>> 
 >>>>> #lang racket
 >>>>> 
 >>>>> (provide main)
 >>>>> 
 >>>>> ;; accept the shortest sequence of LetterKeyEvents that match some regular exp.
 >>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>> 
 >>>>> (require 2htdp/universe 2htdp/image rackunit)
 >>>>> 
 >>>>> (require xml/xml)
 >>>>> ;; should come with the above:
 >>>>> (define-syntax-rule
 >>>>> (element-named-attributes msg name:id ...)
 >>>>> ;; XML-Element -> [Listof String]
 >>>>> (lambda (e)
 >>>>>   (match (element-attributes e)
 >>>>>     [(list-no-order (attribute _ _ 'name:id name:id) ...)
 >>>>>      (values name:id ...)]
 >>>>>     [else (error 'parse (format msg e))])))
 >>>>> 
 >>>>> ;; XML-Element Symbol *->* [Listof XML-Element]
 >>>>> ;; retrieve all elements with name n in name*
 >>>>> (define (elements-named-content e . name*)
 >>>>> (define c (filter element? (element-content e)))
 >>>>> (define l
 >>>>>   (for/list ((n name*)) (filter (lambda (x) (eq? (element-name x) n)) c)))
 >>>>> (unless (= (- (length c) (apply + (map length l))) 0)
 >>>>>   (displayln (- (length c) (length l)))
 >>>>>   (for ((e c))
 >>>>>     (unless (memq e l)
 >>>>>       (displayln `(not found ,e))))
 >>>>>   (error 'element-named-elements "too many [~s] elements: ~e" name* l))
 >>>>> (apply values l))
 >>>>> 
 >>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>> ;; THE MAIN FUNCTION
 >>>>> 
 >>>>> ;; String[File] -> "d" or "error"
 >>>>> (define (main f)
 >>>>> (with-handlers ((exn:fail? (lambda (e) (displayln (exn-message e)))))
 >>>>>   (define x:xml (with-input-from-file f read-xml/element))
 >>>>>   (define x:fsm (parse x:xml))
 >>>>>   (accept x:fsm)
 >>>>>   (sleep 1)))
 >>>>> 
 >>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>> ;; Parse the XML into the internal FSM data structure
 >>>>> 
 >>>>> ;; Any -> FSM
 >>>>> ;; parse the given
 >>>>> 
 >>>>> (module+ test
 >>>>> (define (read-parse xml0:string)
 >>>>>   (parse (read-xml/element (open-input-string xml0:string))))
 >>>>> (define xml0:string
 >>>>>   #<< eos
 >>>>>   <fsm initial="a">
 >>>>>      <final name="d"></final>
 >>>>>      <transition current="a" next="bc">
 >>>>>         <action value="a"></action>
 >>>>>      </transition>
 >>>>>      <transition current="bc" next="bc">
 >>>>>         <action value="b"></action>
 >>>>>         <action value="c"></action>
 >>>>>      </transition>
 >>>>>      <transition current="bc" next="d">
 >>>>>        <action value="d"></action>
 >>>>>      </transition>
 >>>>>   </fsm>
 >>>>> eos
 >>>>>   )
 >>>>> (check-equal? (read-parse xml0:string) fsm0)
 >>>>> 
 >>>>> (define xml0-b:string
 >>>>>   #<< eos
 >>>>>   <fsm initial="a">
 >>>>>      <final name="d" />
 >>>>>      <transition current="a" next="bc">
 >>>>>         <action value="a" />
 >>>>>      </transition>
 >>>>>      <transition current="bc" next="bc">
 >>>>>         <action value="b" />
 >>>>>         <action value="c" />
 >>>>>      </transition>
 >>>>>      <transition current="bc" next="d">
 >>>>>        <action value="d" />
 >>>>>      </transition>
 >>>>>   </fsm>
 >>>>> eos
 >>>>>   )
 >>>>> (check-equal? (read-parse xml0-b:string) fsm0))
 >>>>> 
 >>>>> (define (parse x)
 >>>>> ;; parse does not check the names of states because all strings are allowed
 >>>>> (define (<fsm> x)
 >>>>>   (define parse-initial
 >>>>>     (element-named-attributes "not an initial: ~e" initial))
 >>>>>   (define (<finals> e*)
 >>>>>     (map (element-named-attributes "not a final specification: ~e" name) e*))
 >>>>>   (define (<transition*> e*)
 >>>>>     (define (<transition> e)
 >>>>>       (define-values (c n) ((element-named-attributes "not a transition: ~e" current next) e))
 >>>>>       (define k* (elements-named-content e 'action))
 >>>>>       (transition c (map (compose key>>> (element-named-attributes "not an action:" value)) k*) n))
 >>>>>     (map <transition> e*))
 >>>>>   (define (key>>> x)
 >>>>>     (unless (and (= (string-length x) 1) (regexp-match #px"\\d|[a-zA-Z]" x))
 >>>>>       (error "not an alphanumeric key: ~e" x))
 >>>>>     x)
 >>>>>   ;; -- IN --
 >>>>>   (unless (eq? (element-name x) 'fsm) (error 'parse "not an fsm: ~e" x))
 >>>>>   (define-values (f t) (elements-named-content x 'final 'transition))
 >>>>>   (fsm (parse-initial x) (<finals> f) (<transition*> t)))
 >>>>> ;; -- IN --
 >>>>> (<fsm> x))
 >>>>> 
 >>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>> ;; deal with one FSM
 >>>>> 
 >>>>> ;; FSM        = (fsm State [List-of State] [List-of Transition])
 >>>>> ;; State      = String
 >>>>> ;; Transition = (transition State [List-of LetterKeyEvent] State)
 >>>>> 
 >>>>> (struct fsm (initial finals transitions) #:transparent)
 >>>>> (struct transition (current keys next) #:transparent)
 >>>>> 
 >>>>> (define ER "error")
 >>>>> (define state? string?)
 >>>>> (define state=? string=?)
 >>>>> 
 >>>>> ;; EXAMPLE: a(b|c)*d
 >>>>> (define AA "a")
 >>>>> (define BC "bc")
 >>>>> (define DD "d")
 >>>>> 
 >>>>> (define t*
 >>>>> (list (transition AA (list "a") BC)
 >>>>>       (transition BC (list "b" "c") BC)
 >>>>>       (transition BC (list "d") DD)))
 >>>>> (define i0 AA)
 >>>>> (define f* (list DD))
 >>>>> (define fsm0 (fsm i0 f* t*))
 >>>>> 
 >>>>> ;; -----------------------------------------------------------------------------
 >>>>> ;; GRAPHICAL CONSTANTS
 >>>>> (define SIZE 100)
 >>>>> (define white  (square SIZE "solid" "white"))
 >>>>> (define yellow (square SIZE "solid" "yellow"))
 >>>>> (define green  (square SIZE "solid" "green"))
 >>>>> (define red    (square SIZE "solid" "red"))
 >>>>> 
 >>>>> ;; -----------------------------------------------------------------------------
 >>>>> ;; FSM -> State or "unacceptable"
 >>>>> (define (accept fsm)
 >>>>> (define i0 (fsm-initial fsm))
 >>>>> (define f* (fsm-finals fsm))
 >>>>> (big-bang i0
 >>>>>           (on-key (next (fsm-transitions fsm)))
 >>>>>           (to-draw (image i0 f*))
 >>>>>           (stop-when (lambda (w) (cons? (member w (cons ER f*)))))))
 >>>>> 
 >>>>> ;; -----------------------------------------------------------------------------
 >>>>> ;; Transition* State KeyEvent -> State
 >>>>> ;; retrieve the next state from a (transition ...) in t* such that ...
 >>>>> ;; if there is no such transition, signal the error "can't happen"
 >>>>> 
 >>>>> (module+ test
 >>>>> (check-equal? ((next t*) AA "a") BC)
 >>>>> (check-equal? ((next t*) AA "b") ER)
 >>>>> (check-equal? ((next t*) AA "c") ER)
 >>>>> (check-equal? ((next t*) AA "d") ER)
 >>>>> (check-equal? ((next t*) AA "e") ER)
 >>>>> (check-equal? ((next t*) AA "left") ER)
 >>>>> 
 >>>>> (check-equal? ((next t*) BC "a") ER)
 >>>>> (check-equal? ((next t*) BC "b") BC)
 >>>>> (check-equal? ((next t*) BC "c") BC)
 >>>>> (check-equal? ((next t*) BC "d") DD)
 >>>>> (check-equal? ((next t*) BC "e") ER)
 >>>>> (check-equal? ((next t*) BC "left") ER)
 >>>>> 
 >>>>> (check-equal? ((next t*) DD "a") ER))
 >>>>> 
 >>>>> (define ((next t*) current ke)
 >>>>> (or (for/or ((t t*))
 >>>>>       (and (state=? (transition-current t) current)
 >>>>>            (member ke (transition-keys t))
 >>>>>            (transition-next t)))
 >>>>>     ER))
 >>>>> 
 >>>>> ;; -----------------------------------------------------------------------------
 >>>>> ;; State State [Listof State] -> Image
 >>>>> ;; render state as image
 >>>>> 
 >>>>> (module+ test
 >>>>> (check-equal? ((image i0 f*) AA) white)
 >>>>> (check-equal? ((image i0 f*) BC) yellow)
 >>>>> (check-equal? ((image i0 f*) DD) green)
 >>>>> (check-equal? ((image i0 f*) ER) red))
 >>>>> 
 >>>>> (define ((image initial finals) current)
 >>>>> (cond
 >>>>>   [(state=? current initial) white]
 >>>>>   [(member current finals) green]
 >>>>>   [(state=? current ER) red]
 >>>>>   [else yellow]))
 >>>> 
 >>>> 
 >>>> 
 >>>> --
 >>>> Jay McCarthy <jay@cs.byu.edu>
 >>>> Assistant Professor / Brigham Young University
 >>>> http://faculty.cs.byu.edu/~jay
 >>>> 
 >>>> "The glory of God is Intelligence" - D&C 93
 >>> 
 >> 
 >> 
 >> 
 >> --
 >> Jay McCarthy <jay@cs.byu.edu>
 >> Assistant Professor / Brigham Young University
 >> http://faculty.cs.byu.edu/~jay
 >> 
 >> "The glory of God is Intelligence" - D&C 93
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Jay McCarthy <jay.mccarthy@gmail.com>, bugs@racket-lang.org,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13097: element (from xml/xml) sends weird error message
Date: Thu, 6 Sep 2012 15:48:27 +0200

 Oh, well then this might just be a "the top-level is hopeless" type
 thing. But it seems worth checking to be sure.
 
 I tried this simple program:
 
 #lang racket
 (module x racket
   (provide/contract [f (-> integer? integer?)])
   (define (f x) x))
 
 (require (submod "." x))
 
 and things seem to work at the REPL.
 
 Welcome to DrRacket, version 5.3.0.21--2012-09-06(76a66dc6/d/jf-branch) [3m].
 Language: racket [custom]; memory limit: 128 MB.
 > (f #f)
 . . git/bfetscher/jf-gen/collects/racket/contract/private/blame.rkt:89:0:
 f: contract violation
  expected: integer?
  given: #f
  in: the 1st argument of
       (-> integer? integer?)
  contract from: (anonymous-module x)
  blaming: anonymous-module
  at: unsaved-editor24913:3.21
 > (f 1)
 1
 >
 
 Robby
 
 On Thu, Sep 6, 2012 at 2:33 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >
 > Only in the REPL.
 >
 >
 > On Sep 6, 2012, at 1:25 AM, Robby Findler wrote:
 >
 >> Does this happen only in the REPL?
 >>
 >> Robby
 >>
 >> On Thu, Sep 6, 2012 at 3:13 AM, Jay McCarthy <jay.mccarthy@gmail.com> wrote:
 >>> This makes me think it's a Linux vs OS X issue. I'll try to test on OS X.
 >>>
 >>> Jay
 >>>
 >>> On Wed, Sep 5, 2012 at 7:05 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >>>>
 >>>> I re-build from scratch. I re-ran the program. I get the same bug: see new sha.
 >>>>
 >>>> Welcome to DrRacket, version 5.3.0.22--2012-09-05(3d8fc4ad/d) [3m].
 >>>> Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >>>>> (element 0 1 2 3 4)
 >>>> . . make-element: contract violation
 >>>> expected: (or/c location? symbol? #f)
 >>>> given: 0
 >>>> in: the 1st argument of
 >>>>      (->
 >>>>       (or/c location? symbol? #f)
 >>>>       (or/c location? symbol? #f)
 >>>>       symbol?
 >>>>       (listof attribute?)
 >>>>       (listof
 >>>>        (or/c
 >>>>         permissive/c
 >>>>         pcdata?
 >>>>         element?
 >>>>         entity?
 >>>>         comment?
 >>>>         cdata?
 >>>>         p-i?))
 >>>>       element?)
 >>>> contract from:
 >>>>      <collects>/xml/private/structures.rkt
 >>>> blaming:
 >>>>      /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >>>>> (element 0 1 2 3 4)
 >>>> define-values: assignment disallowed;
 >>>> cannot re-define a constant
 >>>>  constant: lifted.10.12
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>
 >>>> On Sep 5, 2012, at 5:54 PM, Jay McCarthy wrote:
 >>>>
 >>>>> Okay, I just updated to the latest git release. I didn't get the
 >>>>> problem with either your large program or the simple REPL sequence.
 >>>>>
 >>>>> Jay
 >>>>>
 >>>>> On Wed, Sep 5, 2012 at 2:50 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >>>>>>
 >>>>>> 1. I just ran the program in 2 again and the error is repeatable:
 >>>>>>
 >>>>>> Welcome to DrRacket, version 5.3.0.21--2012-09-03(7d2ce136/d) [3m].
 >>>>>> Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >>>>>>> (element 0 0 1 2 3)
 >>>>>> . . make-element: contract violation
 >>>>>> expected: (or/c location? symbol? #f)
 >>>>>> given: 0
 >>>>>> in: the 1st argument of
 >>>>>>     (->
 >>>>>>      (or/c location? symbol? #f)
 >>>>>>      (or/c location? symbol? #f)
 >>>>>>      symbol?
 >>>>>>      (listof attribute?)
 >>>>>>      (listof
 >>>>>>       (or/c
 >>>>>>        permissive/c
 >>>>>>        pcdata?
 >>>>>>        element?
 >>>>>>        entity?
 >>>>>>        comment?
 >>>>>>        cdata?
 >>>>>>        p-i?))
 >>>>>>      element?)
 >>>>>> contract from:
 >>>>>>     <collects>/xml/private/structures.rkt
 >>>>>> blaming:
 >>>>>>     /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >>>>>>> (element 0 0 1 2 3)
 >>>>>> define-values: assignment disallowed;
 >>>>>> cannot re-define a constant
 >>>>>> constant: lifted.10.12
 >>>>>>
 >>>>>> 2.
 >>>>>>
 >>>>>>
 >>>>>> #! /bin/sh
 >>>>>> #|
 >>>>>> exec racket -tm "$0" ${1+"$@"}
 >>>>>> |#
 >>>>>>
 >>>>>> #lang racket
 >>>>>>
 >>>>>> (provide main)
 >>>>>>
 >>>>>> ;; accept the shortest sequence of LetterKeyEvents that match some regular exp.
 >>>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>>>
 >>>>>> (require 2htdp/universe 2htdp/image rackunit)
 >>>>>>
 >>>>>> (require xml/xml)
 >>>>>> ;; should come with the above:
 >>>>>> (define-syntax-rule
 >>>>>> (element-named-attributes msg name:id ...)
 >>>>>> ;; XML-Element -> [Listof String]
 >>>>>> (lambda (e)
 >>>>>>   (match (element-attributes e)
 >>>>>>     [(list-no-order (attribute _ _ 'name:id name:id) ...)
 >>>>>>      (values name:id ...)]
 >>>>>>     [else (error 'parse (format msg e))])))
 >>>>>>
 >>>>>> ;; XML-Element Symbol *->* [Listof XML-Element]
 >>>>>> ;; retrieve all elements with name n in name*
 >>>>>> (define (elements-named-content e . name*)
 >>>>>> (define c (filter element? (element-content e)))
 >>>>>> (define l
 >>>>>>   (for/list ((n name*)) (filter (lambda (x) (eq? (element-name x) n)) c)))
 >>>>>> (unless (= (- (length c) (apply + (map length l))) 0)
 >>>>>>   (displayln (- (length c) (length l)))
 >>>>>>   (for ((e c))
 >>>>>>     (unless (memq e l)
 >>>>>>       (displayln `(not found ,e))))
 >>>>>>   (error 'element-named-elements "too many [~s] elements: ~e" name* l))
 >>>>>> (apply values l))
 >>>>>>
 >>>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>>> ;; THE MAIN FUNCTION
 >>>>>>
 >>>>>> ;; String[File] -> "d" or "error"
 >>>>>> (define (main f)
 >>>>>> (with-handlers ((exn:fail? (lambda (e) (displayln (exn-message e)))))
 >>>>>>   (define x:xml (with-input-from-file f read-xml/element))
 >>>>>>   (define x:fsm (parse x:xml))
 >>>>>>   (accept x:fsm)
 >>>>>>   (sleep 1)))
 >>>>>>
 >>>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>>> ;; Parse the XML into the internal FSM data structure
 >>>>>>
 >>>>>> ;; Any -> FSM
 >>>>>> ;; parse the given
 >>>>>>
 >>>>>> (module+ test
 >>>>>> (define (read-parse xml0:string)
 >>>>>>   (parse (read-xml/element (open-input-string xml0:string))))
 >>>>>> (define xml0:string
 >>>>>>   #<< eos
 >>>>>>   <fsm initial="a">
 >>>>>>      <final name="d"></final>
 >>>>>>      <transition current="a" next="bc">
 >>>>>>         <action value="a"></action>
 >>>>>>      </transition>
 >>>>>>      <transition current="bc" next="bc">
 >>>>>>         <action value="b"></action>
 >>>>>>         <action value="c"></action>
 >>>>>>      </transition>
 >>>>>>      <transition current="bc" next="d">
 >>>>>>        <action value="d"></action>
 >>>>>>      </transition>
 >>>>>>   </fsm>
 >>>>>> eos
 >>>>>>   )
 >>>>>> (check-equal? (read-parse xml0:string) fsm0)
 >>>>>>
 >>>>>> (define xml0-b:string
 >>>>>>   #<< eos
 >>>>>>   <fsm initial="a">
 >>>>>>      <final name="d" />
 >>>>>>      <transition current="a" next="bc">
 >>>>>>         <action value="a" />
 >>>>>>      </transition>
 >>>>>>      <transition current="bc" next="bc">
 >>>>>>         <action value="b" />
 >>>>>>         <action value="c" />
 >>>>>>      </transition>
 >>>>>>      <transition current="bc" next="d">
 >>>>>>        <action value="d" />
 >>>>>>      </transition>
 >>>>>>   </fsm>
 >>>>>> eos
 >>>>>>   )
 >>>>>> (check-equal? (read-parse xml0-b:string) fsm0))
 >>>>>>
 >>>>>> (define (parse x)
 >>>>>> ;; parse does not check the names of states because all strings are allowed
 >>>>>> (define (<fsm> x)
 >>>>>>   (define parse-initial
 >>>>>>     (element-named-attributes "not an initial: ~e" initial))
 >>>>>>   (define (<finals> e*)
 >>>>>>     (map (element-named-attributes "not a final specification: ~e" name) e*))
 >>>>>>   (define (<transition*> e*)
 >>>>>>     (define (<transition> e)
 >>>>>>       (define-values (c n) ((element-named-attributes "not a transition: ~e" current next) e))
 >>>>>>       (define k* (elements-named-content e 'action))
 >>>>>>       (transition c (map (compose key>>> (element-named-attributes "not an action:" value)) k*) n))
 >>>>>>     (map <transition> e*))
 >>>>>>   (define (key>>> x)
 >>>>>>     (unless (and (= (string-length x) 1) (regexp-match #px"\\d|[a-zA-Z]" x))
 >>>>>>       (error "not an alphanumeric key: ~e" x))
 >>>>>>     x)
 >>>>>>   ;; -- IN --
 >>>>>>   (unless (eq? (element-name x) 'fsm) (error 'parse "not an fsm: ~e" x))
 >>>>>>   (define-values (f t) (elements-named-content x 'final 'transition))
 >>>>>>   (fsm (parse-initial x) (<finals> f) (<transition*> t)))
 >>>>>> ;; -- IN --
 >>>>>> (<fsm> x))
 >>>>>>
 >>>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>>> ;; deal with one FSM
 >>>>>>
 >>>>>> ;; FSM        = (fsm State [List-of State] [List-of Transition])
 >>>>>> ;; State      = String
 >>>>>> ;; Transition = (transition State [List-of LetterKeyEvent] State)
 >>>>>>
 >>>>>> (struct fsm (initial finals transitions) #:transparent)
 >>>>>> (struct transition (current keys next) #:transparent)
 >>>>>>
 >>>>>> (define ER "error")
 >>>>>> (define state? string?)
 >>>>>> (define state=? string=?)
 >>>>>>
 >>>>>> ;; EXAMPLE: a(b|c)*d
 >>>>>> (define AA "a")
 >>>>>> (define BC "bc")
 >>>>>> (define DD "d")
 >>>>>>
 >>>>>> (define t*
 >>>>>> (list (transition AA (list "a") BC)
 >>>>>>       (transition BC (list "b" "c") BC)
 >>>>>>       (transition BC (list "d") DD)))
 >>>>>> (define i0 AA)
 >>>>>> (define f* (list DD))
 >>>>>> (define fsm0 (fsm i0 f* t*))
 >>>>>>
 >>>>>> ;; -----------------------------------------------------------------------------
 >>>>>> ;; GRAPHICAL CONSTANTS
 >>>>>> (define SIZE 100)
 >>>>>> (define white  (square SIZE "solid" "white"))
 >>>>>> (define yellow (square SIZE "solid" "yellow"))
 >>>>>> (define green  (square SIZE "solid" "green"))
 >>>>>> (define red    (square SIZE "solid" "red"))
 >>>>>>
 >>>>>> ;; -----------------------------------------------------------------------------
 >>>>>> ;; FSM -> State or "unacceptable"
 >>>>>> (define (accept fsm)
 >>>>>> (define i0 (fsm-initial fsm))
 >>>>>> (define f* (fsm-finals fsm))
 >>>>>> (big-bang i0
 >>>>>>           (on-key (next (fsm-transitions fsm)))
 >>>>>>           (to-draw (image i0 f*))
 >>>>>>           (stop-when (lambda (w) (cons? (member w (cons ER f*)))))))
 >>>>>>
 >>>>>> ;; -----------------------------------------------------------------------------
 >>>>>> ;; Transition* State KeyEvent -> State
 >>>>>> ;; retrieve the next state from a (transition ...) in t* such that ...
 >>>>>> ;; if there is no such transition, signal the error "can't happen"
 >>>>>>
 >>>>>> (module+ test
 >>>>>> (check-equal? ((next t*) AA "a") BC)
 >>>>>> (check-equal? ((next t*) AA "b") ER)
 >>>>>> (check-equal? ((next t*) AA "c") ER)
 >>>>>> (check-equal? ((next t*) AA "d") ER)
 >>>>>> (check-equal? ((next t*) AA "e") ER)
 >>>>>> (check-equal? ((next t*) AA "left") ER)
 >>>>>>
 >>>>>> (check-equal? ((next t*) BC "a") ER)
 >>>>>> (check-equal? ((next t*) BC "b") BC)
 >>>>>> (check-equal? ((next t*) BC "c") BC)
 >>>>>> (check-equal? ((next t*) BC "d") DD)
 >>>>>> (check-equal? ((next t*) BC "e") ER)
 >>>>>> (check-equal? ((next t*) BC "left") ER)
 >>>>>>
 >>>>>> (check-equal? ((next t*) DD "a") ER))
 >>>>>>
 >>>>>> (define ((next t*) current ke)
 >>>>>> (or (for/or ((t t*))
 >>>>>>       (and (state=? (transition-current t) current)
 >>>>>>            (member ke (transition-keys t))
 >>>>>>            (transition-next t)))
 >>>>>>     ER))
 >>>>>>
 >>>>>> ;; -----------------------------------------------------------------------------
 >>>>>> ;; State State [Listof State] -> Image
 >>>>>> ;; render state as image
 >>>>>>
 >>>>>> (module+ test
 >>>>>> (check-equal? ((image i0 f*) AA) white)
 >>>>>> (check-equal? ((image i0 f*) BC) yellow)
 >>>>>> (check-equal? ((image i0 f*) DD) green)
 >>>>>> (check-equal? ((image i0 f*) ER) red))
 >>>>>>
 >>>>>> (define ((image initial finals) current)
 >>>>>> (cond
 >>>>>>   [(state=? current initial) white]
 >>>>>>   [(member current finals) green]
 >>>>>>   [(state=? current ER) red]
 >>>>>>   [else yellow]))
 >>>>>
 >>>>>
 >>>>>
 >>>>> --
 >>>>> Jay McCarthy <jay@cs.byu.edu>
 >>>>> Assistant Professor / Brigham Young University
 >>>>> http://faculty.cs.byu.edu/~jay
 >>>>>
 >>>>> "The glory of God is Intelligence" - D&C 93
 >>>>
 >>>
 >>>
 >>>
 >>> --
 >>> Jay McCarthy <jay@cs.byu.edu>
 >>> Assistant Professor / Brigham Young University
 >>> http://faculty.cs.byu.edu/~jay
 >>>
 >>> "The glory of God is Intelligence" - D&C 93
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Jay McCarthy <jay.mccarthy@gmail.com>, bugs@racket-lang.org,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/13097: element (from xml/xml) sends weird error message
Date: Thu, 6 Sep 2012 10:57:08 -0400

 In this particular case, this sounds awful. 
 
 On Sep 6, 2012, at 9:48 AM, Robby Findler wrote:
 
 > Oh, well then this might just be a "the top-level is hopeless" type
 > thing. But it seems worth checking to be sure.
 > 
 > I tried this simple program:
 > 
 > #lang racket
 > (module x racket
 >  (provide/contract [f (-> integer? integer?)])
 >  (define (f x) x))
 > 
 > (require (submod "." x))
 > 
 > and things seem to work at the REPL.
 > 
 > Welcome to DrRacket, version 5.3.0.21--2012-09-06(76a66dc6/d/jf-branch) [3m].
 > Language: racket [custom]; memory limit: 128 MB.
 >> (f #f)
 > . . git/bfetscher/jf-gen/collects/racket/contract/private/blame.rkt:89:0:
 > f: contract violation
 > expected: integer?
 > given: #f
 > in: the 1st argument of
 >      (-> integer? integer?)
 > contract from: (anonymous-module x)
 > blaming: anonymous-module
 > at: unsaved-editor24913:3.21
 >> (f 1)
 > 1
 >> 
 > 
 > Robby
 > 
 > On Thu, Sep 6, 2012 at 2:33 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >> 
 >> Only in the REPL.
 >> 
 >> 
 >> On Sep 6, 2012, at 1:25 AM, Robby Findler wrote:
 >> 
 >>> Does this happen only in the REPL?
 >>> 
 >>> Robby
 >>> 
 >>> On Thu, Sep 6, 2012 at 3:13 AM, Jay McCarthy <jay.mccarthy@gmail.com> wrote:
 >>>> This makes me think it's a Linux vs OS X issue. I'll try to test on OS X.
 >>>> 
 >>>> Jay
 >>>> 
 >>>> On Wed, Sep 5, 2012 at 7:05 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >>>>> 
 >>>>> I re-build from scratch. I re-ran the program. I get the same bug: see new sha.
 >>>>> 
 >>>>> Welcome to DrRacket, version 5.3.0.22--2012-09-05(3d8fc4ad/d) [3m].
 >>>>> Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >>>>>> (element 0 1 2 3 4)
 >>>>> . . make-element: contract violation
 >>>>> expected: (or/c location? symbol? #f)
 >>>>> given: 0
 >>>>> in: the 1st argument of
 >>>>>     (->
 >>>>>      (or/c location? symbol? #f)
 >>>>>      (or/c location? symbol? #f)
 >>>>>      symbol?
 >>>>>      (listof attribute?)
 >>>>>      (listof
 >>>>>       (or/c
 >>>>>        permissive/c
 >>>>>        pcdata?
 >>>>>        element?
 >>>>>        entity?
 >>>>>        comment?
 >>>>>        cdata?
 >>>>>        p-i?))
 >>>>>      element?)
 >>>>> contract from:
 >>>>>     <collects>/xml/private/structures.rkt
 >>>>> blaming:
 >>>>>     /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >>>>>> (element 0 1 2 3 4)
 >>>>> define-values: assignment disallowed;
 >>>>> cannot re-define a constant
 >>>>> constant: lifted.10.12
 >>>>> 
 >>>>> 
 >>>>> 
 >>>>> 
 >>>>> 
 >>>>> 
 >>>>> On Sep 5, 2012, at 5:54 PM, Jay McCarthy wrote:
 >>>>> 
 >>>>>> Okay, I just updated to the latest git release. I didn't get the
 >>>>>> problem with either your large program or the simple REPL sequence.
 >>>>>> 
 >>>>>> Jay
 >>>>>> 
 >>>>>> On Wed, Sep 5, 2012 at 2:50 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >>>>>>> 
 >>>>>>> 1. I just ran the program in 2 again and the error is repeatable:
 >>>>>>> 
 >>>>>>> Welcome to DrRacket, version 5.3.0.21--2012-09-03(7d2ce136/d) [3m].
 >>>>>>> Language:  /bin/sh #| exec racket -tm "$0" ${1+"$@"} |# #lang racket.
 >>>>>>>> (element 0 0 1 2 3)
 >>>>>>> . . make-element: contract violation
 >>>>>>> expected: (or/c location? symbol? #f)
 >>>>>>> given: 0
 >>>>>>> in: the 1st argument of
 >>>>>>>    (->
 >>>>>>>     (or/c location? symbol? #f)
 >>>>>>>     (or/c location? symbol? #f)
 >>>>>>>     symbol?
 >>>>>>>     (listof attribute?)
 >>>>>>>     (listof
 >>>>>>>      (or/c
 >>>>>>>       permissive/c
 >>>>>>>       pcdata?
 >>>>>>>       element?
 >>>>>>>       entity?
 >>>>>>>       comment?
 >>>>>>>       cdata?
 >>>>>>>       p-i?))
 >>>>>>>     element?)
 >>>>>>> contract from:
 >>>>>>>    <collects>/xml/private/structures.rkt
 >>>>>>> blaming:
 >>>>>>>    /Users/matthias/0Unison/0Web/7400-f12/Assignments/1/1.rkt
 >>>>>>>> (element 0 0 1 2 3)
 >>>>>>> define-values: assignment disallowed;
 >>>>>>> cannot re-define a constant
 >>>>>>> constant: lifted.10.12
 >>>>>>> 
 >>>>>>> 2.
 >>>>>>> 
 >>>>>>> 
 >>>>>>> #! /bin/sh
 >>>>>>> #|
 >>>>>>> exec racket -tm "$0" ${1+"$@"}
 >>>>>>> |#
 >>>>>>> 
 >>>>>>> #lang racket
 >>>>>>> 
 >>>>>>> (provide main)
 >>>>>>> 
 >>>>>>> ;; accept the shortest sequence of LetterKeyEvents that match some regular exp.
 >>>>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>>>> 
 >>>>>>> (require 2htdp/universe 2htdp/image rackunit)
 >>>>>>> 
 >>>>>>> (require xml/xml)
 >>>>>>> ;; should come with the above:
 >>>>>>> (define-syntax-rule
 >>>>>>> (element-named-attributes msg name:id ...)
 >>>>>>> ;; XML-Element -> [Listof String]
 >>>>>>> (lambda (e)
 >>>>>>>  (match (element-attributes e)
 >>>>>>>    [(list-no-order (attribute _ _ 'name:id name:id) ...)
 >>>>>>>     (values name:id ...)]
 >>>>>>>    [else (error 'parse (format msg e))])))
 >>>>>>> 
 >>>>>>> ;; XML-Element Symbol *->* [Listof XML-Element]
 >>>>>>> ;; retrieve all elements with name n in name*
 >>>>>>> (define (elements-named-content e . name*)
 >>>>>>> (define c (filter element? (element-content e)))
 >>>>>>> (define l
 >>>>>>>  (for/list ((n name*)) (filter (lambda (x) (eq? (element-name x) n)) c)))
 >>>>>>> (unless (= (- (length c) (apply + (map length l))) 0)
 >>>>>>>  (displayln (- (length c) (length l)))
 >>>>>>>  (for ((e c))
 >>>>>>>    (unless (memq e l)
 >>>>>>>      (displayln `(not found ,e))))
 >>>>>>>  (error 'element-named-elements "too many [~s] elements: ~e" name* l))
 >>>>>>> (apply values l))
 >>>>>>> 
 >>>>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>>>> ;; THE MAIN FUNCTION
 >>>>>>> 
 >>>>>>> ;; String[File] -> "d" or "error"
 >>>>>>> (define (main f)
 >>>>>>> (with-handlers ((exn:fail? (lambda (e) (displayln (exn-message e)))))
 >>>>>>>  (define x:xml (with-input-from-file f read-xml/element))
 >>>>>>>  (define x:fsm (parse x:xml))
 >>>>>>>  (accept x:fsm)
 >>>>>>>  (sleep 1)))
 >>>>>>> 
 >>>>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>>>> ;; Parse the XML into the internal FSM data structure
 >>>>>>> 
 >>>>>>> ;; Any -> FSM
 >>>>>>> ;; parse the given
 >>>>>>> 
 >>>>>>> (module+ test
 >>>>>>> (define (read-parse xml0:string)
 >>>>>>>  (parse (read-xml/element (open-input-string xml0:string))))
 >>>>>>> (define xml0:string
 >>>>>>>  #<< eos
 >>>>>>>  <fsm initial="a">
 >>>>>>>     <final name="d"></final>
 >>>>>>>     <transition current="a" next="bc">
 >>>>>>>        <action value="a"></action>
 >>>>>>>     </transition>
 >>>>>>>     <transition current="bc" next="bc">
 >>>>>>>        <action value="b"></action>
 >>>>>>>        <action value="c"></action>
 >>>>>>>     </transition>
 >>>>>>>     <transition current="bc" next="d">
 >>>>>>>       <action value="d"></action>
 >>>>>>>     </transition>
 >>>>>>>  </fsm>
 >>>>>>> eos
 >>>>>>>  )
 >>>>>>> (check-equal? (read-parse xml0:string) fsm0)
 >>>>>>> 
 >>>>>>> (define xml0-b:string
 >>>>>>>  #<< eos
 >>>>>>>  <fsm initial="a">
 >>>>>>>     <final name="d" />
 >>>>>>>     <transition current="a" next="bc">
 >>>>>>>        <action value="a" />
 >>>>>>>     </transition>
 >>>>>>>     <transition current="bc" next="bc">
 >>>>>>>        <action value="b" />
 >>>>>>>        <action value="c" />
 >>>>>>>     </transition>
 >>>>>>>     <transition current="bc" next="d">
 >>>>>>>       <action value="d" />
 >>>>>>>     </transition>
 >>>>>>>  </fsm>
 >>>>>>> eos
 >>>>>>>  )
 >>>>>>> (check-equal? (read-parse xml0-b:string) fsm0))
 >>>>>>> 
 >>>>>>> (define (parse x)
 >>>>>>> ;; parse does not check the names of states because all strings are allowed
 >>>>>>> (define (<fsm> x)
 >>>>>>>  (define parse-initial
 >>>>>>>    (element-named-attributes "not an initial: ~e" initial))
 >>>>>>>  (define (<finals> e*)
 >>>>>>>    (map (element-named-attributes "not a final specification: ~e" name) e*))
 >>>>>>>  (define (<transition*> e*)
 >>>>>>>    (define (<transition> e)
 >>>>>>>      (define-values (c n) ((element-named-attributes "not a transition: ~e" current next) e))
 >>>>>>>      (define k* (elements-named-content e 'action))
 >>>>>>>      (transition c (map (compose key>>> (element-named-attributes "not an action:" value)) k*) n))
 >>>>>>>    (map <transition> e*))
 >>>>>>>  (define (key>>> x)
 >>>>>>>    (unless (and (= (string-length x) 1) (regexp-match #px"\\d|[a-zA-Z]" x))
 >>>>>>>      (error "not an alphanumeric key: ~e" x))
 >>>>>>>    x)
 >>>>>>>  ;; -- IN --
 >>>>>>>  (unless (eq? (element-name x) 'fsm) (error 'parse "not an fsm: ~e" x))
 >>>>>>>  (define-values (f t) (elements-named-content x 'final 'transition))
 >>>>>>>  (fsm (parse-initial x) (<finals> f) (<transition*> t)))
 >>>>>>> ;; -- IN --
 >>>>>>> (<fsm> x))
 >>>>>>> 
 >>>>>>> ;; ---------------------------------------------------------------------------------------------------
 >>>>>>> ;; deal with one FSM
 >>>>>>> 
 >>>>>>> ;; FSM        = (fsm State [List-of State] [List-of Transition])
 >>>>>>> ;; State      = String
 >>>>>>> ;; Transition = (transition State [List-of LetterKeyEvent] State)
 >>>>>>> 
 >>>>>>> (struct fsm (initial finals transitions) #:transparent)
 >>>>>>> (struct transition (current keys next) #:transparent)
 >>>>>>> 
 >>>>>>> (define ER "error")
 >>>>>>> (define state? string?)
 >>>>>>> (define state=? string=?)
 >>>>>>> 
 >>>>>>> ;; EXAMPLE: a(b|c)*d
 >>>>>>> (define AA "a")
 >>>>>>> (define BC "bc")
 >>>>>>> (define DD "d")
 >>>>>>> 
 >>>>>>> (define t*
 >>>>>>> (list (transition AA (list "a") BC)
 >>>>>>>      (transition BC (list "b" "c") BC)
 >>>>>>>      (transition BC (list "d") DD)))
 >>>>>>> (define i0 AA)
 >>>>>>> (define f* (list DD))
 >>>>>>> (define fsm0 (fsm i0 f* t*))
 >>>>>>> 
 >>>>>>> ;; -----------------------------------------------------------------------------
 >>>>>>> ;; GRAPHICAL CONSTANTS
 >>>>>>> (define SIZE 100)
 >>>>>>> (define white  (square SIZE "solid" "white"))
 >>>>>>> (define yellow (square SIZE "solid" "yellow"))
 >>>>>>> (define green  (square SIZE "solid" "green"))
 >>>>>>> (define red    (square SIZE "solid" "red"))
 >>>>>>> 
 >>>>>>> ;; -----------------------------------------------------------------------------
 >>>>>>> ;; FSM -> State or "unacceptable"
 >>>>>>> (define (accept fsm)
 >>>>>>> (define i0 (fsm-initial fsm))
 >>>>>>> (define f* (fsm-finals fsm))
 >>>>>>> (big-bang i0
 >>>>>>>          (on-key (next (fsm-transitions fsm)))
 >>>>>>>          (to-draw (image i0 f*))
 >>>>>>>          (stop-when (lambda (w) (cons? (member w (cons ER f*)))))))
 >>>>>>> 
 >>>>>>> ;; -----------------------------------------------------------------------------
 >>>>>>> ;; Transition* State KeyEvent -> State
 >>>>>>> ;; retrieve the next state from a (transition ...) in t* such that ...
 >>>>>>> ;; if there is no such transition, signal the error "can't happen"
 >>>>>>> 
 >>>>>>> (module+ test
 >>>>>>> (check-equal? ((next t*) AA "a") BC)
 >>>>>>> (check-equal? ((next t*) AA "b") ER)
 >>>>>>> (check-equal? ((next t*) AA "c") ER)
 >>>>>>> (check-equal? ((next t*) AA "d") ER)
 >>>>>>> (check-equal? ((next t*) AA "e") ER)
 >>>>>>> (check-equal? ((next t*) AA "left") ER)
 >>>>>>> 
 >>>>>>> (check-equal? ((next t*) BC "a") ER)
 >>>>>>> (check-equal? ((next t*) BC "b") BC)
 >>>>>>> (check-equal? ((next t*) BC "c") BC)
 >>>>>>> (check-equal? ((next t*) BC "d") DD)
 >>>>>>> (check-equal? ((next t*) BC "e") ER)
 >>>>>>> (check-equal? ((next t*) BC "left") ER)
 >>>>>>> 
 >>>>>>> (check-equal? ((next t*) DD "a") ER))
 >>>>>>> 
 >>>>>>> (define ((next t*) current ke)
 >>>>>>> (or (for/or ((t t*))
 >>>>>>>      (and (state=? (transition-current t) current)
 >>>>>>>           (member ke (transition-keys t))
 >>>>>>>           (transition-next t)))
 >>>>>>>    ER))
 >>>>>>> 
 >>>>>>> ;; -----------------------------------------------------------------------------
 >>>>>>> ;; State State [Listof State] -> Image
 >>>>>>> ;; render state as image
 >>>>>>> 
 >>>>>>> (module+ test
 >>>>>>> (check-equal? ((image i0 f*) AA) white)
 >>>>>>> (check-equal? ((image i0 f*) BC) yellow)
 >>>>>>> (check-equal? ((image i0 f*) DD) green)
 >>>>>>> (check-equal? ((image i0 f*) ER) red))
 >>>>>>> 
 >>>>>>> (define ((image initial finals) current)
 >>>>>>> (cond
 >>>>>>>  [(state=? current initial) white]
 >>>>>>>  [(member current finals) green]
 >>>>>>>  [(state=? current ER) red]
 >>>>>>>  [else yellow]))
 >>>>>> 
 >>>>>> 
 >>>>>> 
 >>>>>> --
 >>>>>> Jay McCarthy <jay@cs.byu.edu>
 >>>>>> Assistant Professor / Brigham Young University
 >>>>>> http://faculty.cs.byu.edu/~jay
 >>>>>> 
 >>>>>> "The glory of God is Intelligence" - D&C 93
 >>>>> 
 >>>> 
 >>>> 
 >>>> 
 >>>> --
 >>>> Jay McCarthy <jay@cs.byu.edu>
 >>>> Assistant Professor / Brigham Young University
 >>>> http://faculty.cs.byu.edu/~jay
 >>>> 
 >>>> "The glory of God is Intelligence" - D&C 93
 >> 
 
 

State changed from "open" to "closed" by samth at Tue, 25 Mar 2014 10:33:52 -0400
Reason>>> This seems to have been fixed.  I tried the reproduction
steps, and got exactly the desired behavior every time. I
used the full file that Matthias included.

For reference, the file I used is at:
https://gist.github.com/9763066 since Gnats has mangled the
one here.

