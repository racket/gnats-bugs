From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Sat Nov 19 19:30:20 2011
Received: from mail-gx0-f172.google.com (mail-gx0-f172.google.com [209.85.161.172])
	by champlain.ccs.neu.edu (8.14.4/8.14.4) with ESMTP id pAK0UDDg015486
	for <bugs@bugs.plt-scheme.org>; Sat, 19 Nov 2011 19:30:13 -0500
Message-Id: <201111200030.pAK0U8q9015480@champlain.ccs.neu.edu>
Date: Sat, 19 Nov 2011 19:30:08 -0500
From: matthias@ccs.neu.edu
To: bugs@racket-lang.org
Subject: drracket diverges when 'view | split'

>Number:         12386
>Category:       all
>Synopsis:       drracket diverges when 'view | split'
>Class:          sw-bug
>Responsible:    samth
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Sat Nov 19 19:32:01 -0500 2011
>Closed-Date:    Sun Nov 20 09:17:58 -0500 2011
>Last-Modified:  Mon Feb 18 23:27:14 -0500 2013
>Originator:     matthias
>Organization:
plt
>Submitter-Id:   unknown
>Release:        5.2.0.3--2011-11-16(8483b8e/g)
>Environment:
macosx "Darwin africa.westell.com 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7 16:33:36 PDT 2011; root:xnu-1504.15.3~1/RELEASE_I386 i386" (x86_64-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 656759072
Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()


Collections:
("/Users/matthias/0Unison/collects/"
 ("._.DS_Store" ".DS_Store" "compiled" "date" "finance" "info-domain" "info.ss" "pdf.ss~" "session" "short" "testing" "tll-collects" "utils" "web"))
("/Users/matthias/Library/Racket/5.2.0.3/collects"
 (non-existent-path))
("/Users/matthias/plt/collects"
 (".gitignore" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compiler" "config" "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "games" "graphics" "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" "hierlist" "honu" "htdp" "html" "icons" "info-domain" "lang" "launcher" "lazy" "macro-debugger" "make" "meta" "mred" "mrlib" "mysterx" "mz" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raclog" "raco" "racunit" "reader" "readline" "redex" "repo-time-stamp" "repos-time-stamp" "rnrs" "s-exp" "schelog" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" "string-constants" "swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engine"!
  "tests" "tex2page" "texpict" "tool" "trace" "typed" "typed-racket" "typed-scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml" "xrepl"))

Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug/profile) (default) #() "#lang racket\n" #f #t))
>Description:
It happens on the below file, repeatedly. 
Start drracket. Split view. Consumes 100%
cpu no response. 
>How-To-Repeat:
#lang racket

(require 2htdp/universe 2htdp/image)

#|
This module implements the Dice of Doom game

It is a mulitplayer turn-based game. Each player owns hexagonal fields, 
which are arranged into a plane board. Each field comes with a number of 
dice. When it is a player's turn, she selects a field that she owns to 
attack a neigboring field of some other player. An attack is enabled as 
long as the attacking field has more dice than the defending field. The 
effect of the attack is that the field changes ownership and that all but
one of the attack dice are moved to the newly conquered field. A player may
continue her turn as long as she can launch attacks. Optionally, she may 
choose to pass -- meaning she ends her turn -- as long as she has launched
at least one attack. At the end of a turn, a number of dices are randomly 
distributed across the player's fields. The game is over when a player whose 
turn it is cannot attack on her first move. 

The software supports any number of players. Launch the game with 

 (roll-the-dice Name1 Name2 ...)

where Name1, Name2, etc are strings. If you launch the game via 

 (roll-the-dice)

you get a default configuration for two players. 

A player can use the following five keys to play the game:
-- with ← and → (arrow keys), the player changes the field focus 
-- with enter, the player marks a tile as a place
   from which to launch an attack or what to attack
-- with the "d" key, the player unmarks a tile
-- with the "p" key the player passes 
Once a player passes, the game announces whose turn it is next. 

|#



;                                                                                  
;                                                                                  
;                                                                                  
;                                                                                  
;   ;;;;       ;                            ;;; ;;;                   ;;        ;; 
;    ;  ;                                    ;   ;                     ;         ; 
;    ;   ;   ;;;     ;;; ;   ;;;;            ;   ;   ;;;;   ;; ;;;     ;     ;;; ; 
;    ;   ;     ;    ;   ;;  ;    ;           ; ; ;  ;    ;   ;;        ;    ;   ;; 
;    ;   ;     ;    ;       ;;;;;;           ; ; ;  ;    ;   ;         ;    ;    ; 
;    ;   ;     ;    ;       ;                ; ; ;  ;    ;   ;         ;    ;    ; 
;    ;  ;      ;    ;    ;  ;                ; ; ;  ;    ;   ;         ;    ;   ;; 
;   ;;;;     ;;;;;   ;;;;    ;;;;;            ; ;    ;;;;   ;;;;;    ;;;;;   ;;; ;;
;                                                                                  
;                                                                                  
;                                                                                  
;                                                                                  

;; -----------------------------------------------------------------------------
;; Data

(struct dice-world (src board gt) #:transparent)
;; A DiceWorld is a (dice-world Number Board GameTree)
;; the first field is number the tile the current player has selected 
;;     to attack with #f if no selection has been made
;; the second is the board
;; the third is the current game-tree

;; A Board is a [List-of field]
;; the first field in the list is the field currently selected

(struct field (index player dice x y) #:transparent)
;; A field is a (field Number Player Dice Number Number)
;; first field is a unique number identifying the field and its initial location
;;   in the board
;; the second field is the player who owns this field
;; the third field is the number of dice on this board
;; the fourth field is the x coordiate of this tile in pixels
;; the fifth field is the y coordiate of this tile in pixels

;; A Player is a number from [0, NUM-PLAYERS)

(struct game (board player moves) #:transparent)
;; A GameTree is a (game Board Player [list-of Move])
;; the first field is the board this gametree represents
;; the second field is the player whos turn it is
;; the third field is a list of possible moves on that board by that player

(struct move (action gt) #:transparent)
;; A Move is a (move Action GameTree)
;; the first field is the action this move represents
;; the second field is the gametree resulting from that move.

;; an Action is one of
;; -'()                    a passing move
;; -(list Number Number)   The move where the first attacks the second

;; -----------------------------------------------------------------------------
;; Constants

; initalization constants
(define PLAYER# 2)
(define MAX-DICE 3)
(define BOARD-SIZE 2)
(define GRID (* BOARD-SIZE BOARD-SIZE))
(define INIT-PLAYER 0)
(define INIT-SPARE-DICE 10)

; graphical constants: fields
(define DICE-OFFSET 6)
(define BSIZE 75)
(define BWIDTH 
  (image-width 
   (rotate 30 (regular-polygon BSIZE 6 "solid" "black"))))
(define X-OFFSET BWIDTH)
(define BHEIGHT 
  (image-height 
   (rotate 30 (regular-polygon BSIZE 6 "solid" "black"))))
(define Y-OFFSET (* BHEIGHT 3/4))
(define INITIAL-OFFSET (* 2 BSIZE))
(define FIELD-ROTATION 30)
(define POLY-SIZE 6)

; graphical constants: Colors
(define COLORS 
  (list (make-color 255 0 0 100) 
        (make-color 0 255 0 100) 
        (make-color 0 0 255 100)))

; graphical constants: Selector image
(define SELECT 
  (rotate FIELD-ROTATION (regular-polygon BSIZE 6 "outline" "black")))

;; Images: dice
(define D1 (bitmap "graphics/dice1.png"))
(define D2 (bitmap "graphics/dice2.png"))
(define D3 (bitmap "graphics/dice3.png"))
(define D4 (bitmap "graphics/dice4.png"))
(define IMG-LIST (list D1 D2 D3 D4))

;; text
(define TEXT-SIZE 15)
(define TEXT-COLOR "black")
(define INSTRUCT 
  (string-append "press ← and → to select fieldes, "
                 "enter to select tiles, "
                 "d to deselect tiles and p to pass"))
(define PLAYER-DRAW-TEXT "Current Player: ")
(define INFO-X-OFFSET 100)
(define INFO-Y-OFFSET 50)

; graphical constants: world
(define WIDTH 600)
(define HEIGHT 600)
(define ISCENE (place-image (text INSTRUCT TEXT-SIZE TEXT-COLOR)
                            (* .5 WIDTH) (* .9 HEIGHT)
                            (empty-scene WIDTH HEIGHT)))

;                                  
;                                  
;                                  
;                                  
;   ;;; ;;;            ;           
;    ;; ;;                         
;    ;; ;;   ;;;;    ;;;    ;; ;;  
;    ; ; ;  ;    ;     ;     ;;  ; 
;    ; ; ;   ;;;;;     ;     ;   ; 
;    ;   ;  ;    ;     ;     ;   ; 
;    ;   ;  ;   ;;     ;     ;   ; 
;   ;;; ;;;  ;;; ;;  ;;;;;  ;;; ;;;
;                                  
;                                  
;                                  
;                                  

;; start the game 
(define (roll-the-dice)
  (big-bang (get-a-world)             
            (on-key interact-with-board)
            (on-draw draw-dice-world)
            (stop-when no-more-moves?
                       end-of-game-drawer)))

;;  -> DiceWorld
;; Returns a randomly generated world. If the world that
;; has been generated starts as a tie, the world is regenerated.
;; property: world is not in endgame state (no-more-moves? returns false)
(define (get-a-world)
  (define board (field-build))
  (define gamet (game-tree board INIT-PLAYER INIT-SPARE-DICE))
  (define w (dice-world #f board gamet))
  (if (no-more-moves? w)
      (get-a-world)
      w))

;; DiceWorld Key -> DiceWorld
;; Handles key events from a player
(define (interact-with-board w k)
  (cond [(or (key=? "left" k) (key=? "right" k))
         (select-tile-action w k)]
        [(key=? "p" k)
         (pass-action w)]
        [(key=? "\r" k)
         (mark-action w)]
        [(key=? "d" k)
         (unmark w)
         w]
        [else w]))

;; DiceWorld -> DiceWorld
;; unmarks a marked tile
(define (unmark w)
  (dice-world #f
              (dice-world-board w)
              (dice-world-gt w)))

;; Diceworld -> Scene
;; draws the world
(define (draw-dice-world w)
  (draw-player-info
   (game-player (dice-world-gt w))
   (field->scene (dice-world-board w) ISCENE)))

;; DiceWorld -> Boolean
;; is the game over? ie no moves can be made
(define (no-more-moves? w)
  (empty? (game-moves (dice-world-gt w))))

;; DiceWorld -> Image
;; render the endgame screen
(define (end-of-game-drawer w)
  (place-image
   (text (won (dice-world-board w)) TEXT-SIZE TEXT-COLOR)
   (/ WIDTH 2) (/ HEIGHT 2) ISCENE))

;                                  
;                                  
;                                  
;                                  
;    ;;;;;             ;           
;      ;                     ;     
;      ;    ;; ;;    ;;;    ;;;;;  
;      ;     ;;  ;     ;     ;     
;      ;     ;   ;     ;     ;     
;      ;     ;   ;     ;     ;     
;      ;     ;   ;     ;     ;   ; 
;    ;;;;;  ;;; ;;;  ;;;;;    ;;;  
;                                  
;                                  
;                                  
;                                  

;; -----------------------------------------------------------------------------
;; Making A Board

;; -> [List-of field]
;; Creates a list of fields the size of GRID with given x and y coordinates
;; properties: dice is (0,MAX-DICE]
;;             returns list of size GRID
(define (field-build)
  (for/list ([n (in-range GRID)])
    (define x (+ INITIAL-OFFSET
                 (get-x-offset n)
                 (* X-OFFSET (modulo n BOARD-SIZE))))
    (define y (+ INITIAL-OFFSET
                 (* Y-OFFSET (get-row n))))
    (define p (modulo n PLAYER#))
    (define d (add1 (random MAX-DICE)))
    (field n p d x y)))

;; Number -> Number
;; gets the offset for a field based on row
;; > (get-x-offset 2)
;; (/ X-OFFSET 2)
(define (get-x-offset field-index)
  (if (odd? (get-row field-index))
      0
      (/ X-OFFSET 2)))

;; -----------------------------------------------------------------------------
;; Making a Game Tree

;; Board Player Natural -> GameTree
;; creates a complete game-tree from the given board, player, and spare dice
(define (game-tree board player dice)
  ;; create tree of attacks from this position; add passing move
  (define (attacks board) 
    (for*/list ([src board]
                [dst (neighbors (field-index src))]
                #:when (attackable? board player src dst))
      (define from (field-index src))
      (define newb (attack board player from dst (field-dice src)))
      (define more (cons (passes newb) (attacks newb)))
      (move (list from dst) (game newb player more))))
  ;; create a passing move and the rest of the game tree 
  (define (passes board)
    (define-values (new-dice newb) (distribute board player dice))
    (move '() (game-tree newb (switch player) new-dice)))
  ;; -- IN -- 
  (game board player (attacks board)))

;; player -> player
;; switches from one player to annother
;; > (switch 0)
;; 2
(define (switch player)
  (modulo (add1 player) PLAYER#))

;; Board Player Number -> Number Board
;; adds reinforcements to the game board
;; > (add-new-dice (list (field 0 2 2 87 0)) 2 2))
;; (list (field 0 2 2 87 0))
(define (distribute board player spare-dice)
  (for/fold ([dice spare-dice]
             [accu empty])
    ([b board])
    (if (and (= (field-player b) player)
             (< (field-dice b) MAX-DICE)
             (not (zero? dice)))
        (values (sub1 dice)
                (cons (add-to-field b) accu))
        (values dice
                (cons b accu)))))

;; field Player Natnum -> field
;; adds dice to the given field
;; > (add-to-field (field 0 1 2 87 0))
;; (field 0 1 2 87 0)
(define (add-to-field bhx)
  (field (field-index bhx)
         (field-player bhx)
         (add1 (field-dice bhx))
         (field-x bhx)
         (field-y bhx)))

;; Board Player field Number -> Boolean
;; is an attack from src to dst valid for cur-player?
;; > (is-move? (list (field 0 0 2 87 0) (field 3 1 1 87 0)) 0 (field 0 0 2 87 0) 3)
;; #t
;; > (is-move? (list (field 0 0 2 87 0) (field 5 1 1 87 0)) 1 (field 0 0 2 87 0) 5)
;; #f
(define (attackable? board player src dst)
  (and (= (field-player src) player)
       (not (= (field-player (field-lookup board dst)) player))
       (> (field-dice src) (field-dice (field-lookup board dst)))
       (member dst (neighbors (field-index src)))))

;; Board Number Number Number Number -> Board
;; Creates a new board after an attack
;; updates only src and dst
(define (attack board player src dst dice)
  (for/list ([bhx board])
    (cond [(= (field-index bhx) src)
           (field (field-index bhx) player 1
                  (field-x bhx) (field-y bhx))]
          [(= (field-index bhx) dst)
           (field (field-index bhx) player (sub1 dice)
                  (field-x bhx) (field-y bhx))]
          [else bhx])))

;; -----------------------------------------------------------------------------
;; Getting Neigbors

;; Number -> [List-of Number]
;; Returns the neighbors of the current spot
;; > (neighbors 0)
;; '(1 2 3)
(define (neighbors pos)  
  (define top? (< pos BOARD-SIZE))
  (define bottom? (= (get-row pos) (sub1 BOARD-SIZE)))
  (define even-row? (zero? (modulo (get-row pos) 2)))
  (define right? (zero? (modulo (add1 pos) BOARD-SIZE)))
  (define left? (zero? (modulo pos BOARD-SIZE)))
  (if even-row?
      (handle-even-row pos top? bottom? right? left?)
      (handle-odd-row pos top? bottom? right? left?)))

;; Number Boolean Boolean Boolean Boolean -> [Listof Numbers]
;; gets the neighbors for a territory on an even row
(define (handle-even-row pos top? bottom? right? left?)
  (append (add (or top? right?)
               (add1 (- pos BOARD-SIZE)))
          (add (or bottom? right?)
               (add1(+ pos BOARD-SIZE)))
          (add top? 
               (- pos BOARD-SIZE))
          (add bottom? 
               (+ pos BOARD-SIZE))
          (add right? (add1 pos))
          (add left? (sub1 pos))))

;; Number Boolean Boolean Boolean Boolean -> [Listof Numbers]
;; gets the neighbors for a territory on an even odd
(define (handle-odd-row pos top? bottom? right? left?)
  (append (add top?
               (- pos BOARD-SIZE))
          (add bottom?
               (+ pos BOARD-SIZE))
          (add (or top? left?) 
               (sub1 (- pos BOARD-SIZE)))
          (add (or bottom? left?) 
               (sub1 (+ pos BOARD-SIZE)))
          (add right? (add1 pos))
          (add left? (sub1 pos))))

;; Boolean X -> [Listof X]
;; returns (list x) if (not b) else empty
(define (add b x)
  (if b
      empty
      (list x)))

;                                                                          
;                                                                          
;                                                                          
;                                                                          
;   ;;; ;;;                 ;;;;;;                                         
;    ;   ;                   ;   ;                           ;             
;    ;  ;    ;;;;   ;;; ;;;  ; ;   ;;;  ;;;  ;;;;   ;; ;;   ;;;;;    ;;;;; 
;    ; ;    ;    ;   ;   ;   ;;;    ;    ;  ;    ;   ;;  ;   ;      ;    ; 
;    ;;;    ;;;;;;   ;   ;   ; ;     ;  ;   ;;;;;;   ;   ;   ;       ;;;;  
;    ;  ;   ;         ; ;    ;       ;  ;   ;        ;   ;   ;           ; 
;    ;   ;  ;         ; ;    ;   ;    ;;    ;        ;   ;   ;   ;  ;    ; 
;   ;;;  ;;  ;;;;;     ;    ;;;;;;    ;;     ;;;;;  ;;; ;;;   ;;;   ;;;;;  
;                      ;                                                   
;                    ;;;                                                   
;                                                                          
;                                                                          

;; -----------------------------------------------------------------------------
;; Tile Selection

;; DiceWorld [or "left" "right"] -> World
;; Creates a new World that has a rotated field list
;; > (select-tile-action (dice-world -1 (list (field 0 0 1 87 0) (field 0 0 1 87 2) ...) [Game-Tree]) "left")
;; (dice-world -1 (list (field 0 0 1 87 2) ... (field 0 0 1 87 0)) [Game-Tree])
;; > (select-tile-action (dice-world -1 (list (field 0 0 1 87 2) ... (field 0 0 1 87 0)) [Game-Tree]) "left")
;; (dice-world -1 (list (field 0 0 1 87 0) (field 0 0 1 87 2) ...) [Game-Tree])
(define (select-tile-action w k)
  (define source (dice-world-src w))
  (define board  (dice-world-board w))
  (define tree   (dice-world-gt w))
  (define owner? (owner=occupier? (game-player tree) (not source)))
  (define new-board
    (rotate-until owner? board 
                  (cond [(key=? k "left") left]
                        [(key=? k "right") right])))
  (dice-world source new-board tree))

;; [Player -> Boolean] [Listof Field] ([Listof Field] -> [Listof Field]) -> [Listof Field]
;; rotate until the first element of the list satisfies owned-by 
(define (rotate-until owned-by lobh rotate)
  (define next-list (rotate lobh))
  (if (owned-by (field-player (first next-list))) 
      next-list
      (rotate-until owned-by next-list rotate)))

;; [Listof Field] -> [Listof Field]
;; rotate a list to the left 
(define (left l)
  (append (rest l) (list (first l))))

;; [Listof Field] -> [Listof Field]
;; rotate a list to the right
(define (right l)
  (reverse (left (reverse l))))

;; Number Player -> (Any -> Boolean)
;; creates a function that test if p is = to given player
(define ((owner=occupier? player theres?) tile-id)
  (if theres? (= tile-id player) (not (= tile-id player))))

;; -----------------------------------------------------------------------------
;; Handling Moves

;; [List-of Moves] [or '() [List Number Number]] -> [or #f Game-tree] 
;; find the move from the current list of moves
;; > (find-move empty (list 1 2)
;; #f
(define (find-move moves current)
  (define mv 
    (findf (lambda (m) (equal? (move-action m) current)) moves))
  (if mv (move-gt mv) mv))

;; DiceWorld -> DiceWorld
;; Adds a passing move to the World
;; > (pass-action (dice-world [Number] [Board] [Move]) empty)
;; (dice-world [Number] [Board] empty)
;; > (pass-action [World] (game [Board] 0 [Listof Moves]))
;; (dice-world -1 [Board] (game [Board] 0 [Listof Moves]))
(define (pass-action w)
  (define m  (find-move (game-moves (dice-world-gt w)) '()))
  (if (false? m) w (dice-world #f (game-board m) m)))

;; DiceWorld -> DiceWorld
;; Moves the gametree to the next attacking move, or changes tile selection
;; > (mark-action (dice-world -1 (list (field 0 0 1 87 0) ...) [Some-Game-Tree]) [Some-Move])
;;(dice-world 0 (list (field 0 0 1 87 0) ...) [Some-Game-Tree])
;; > (mark-action [Some-World] #f)
;; [Some-World]
(define (mark-action w)
  (define tree   (dice-world-gt w))
  (define board  (dice-world-board w))
  (define source (dice-world-src w))
  (define target (field-index (first board)))
  (cond [(not source) (dice-world target board tree)]
        [else 
         (define feasible (game-moves (dice-world-gt w)))
         (define attack   (list source target))
         (define next     (find-move feasible attack))
         (cond
           [(false? next) w]
           [else (dice-world #f (game-board next) next)])]))

;                                                                          
;                                                                          
;                                                                          
;                                                                          
;   ;;;;;                       ;;                     ;                   
;    ;   ;                       ;                                         
;    ;   ;   ;;;;   ;; ;;    ;;; ;   ;;;;   ;; ;;;   ;;;    ;; ;;    ;;; ;;
;    ;   ;  ;    ;   ;;  ;  ;   ;;  ;    ;   ;;        ;     ;;  ;  ;   ;; 
;    ;;;;   ;;;;;;   ;   ;  ;    ;  ;;;;;;   ;         ;     ;   ;  ;    ; 
;    ;  ;   ;        ;   ;  ;    ;  ;        ;         ;     ;   ;  ;    ; 
;    ;   ;  ;        ;   ;  ;   ;;  ;        ;         ;     ;   ;  ;   ;; 
;   ;;;   ;  ;;;;;  ;;; ;;;  ;;; ;;  ;;;;;  ;;;;;    ;;;;;  ;;; ;;;  ;;; ; 
;                                                                        ; 
;                                                                    ;;;;  
;                                                                          
;                                            

;; Player Scene-> Scene
;; Draws the world
(define (draw-player-info player scn)
  (define str 
    (string-append PLAYER-DRAW-TEXT (number->string player)))
  (define txt 
    (text str TEXT-SIZE TEXT-COLOR))
  (place-image txt (- WIDTH INFO-X-OFFSET) INFO-Y-OFFSET scn))

;; Board Scene -> Scene
;; folds through the board and creates an image representation of it
(define (field->scene board scn)
  (define one (first board))
  (define img (overlay SELECT (draw-field one)))
  (define base 
    (place-image img (field-x one) (field-y one) scn))
  (for/fold ([base base]) ([b (rest board)])
    (place-image (draw-field b) (field-x b) (field-y b) base)))

;; Position -> Image
;; creates a single tile
(define (draw-field bh)
  (define die-image (get-die-img (field-dice bh)))
  (overlay
   (draw-fieldagon bh)
   (draw-dice (field-dice bh) (/ BSIZE 3) die-image)))

;; field -> Image
;; takes a field and returns a fieldagon with the proper color
(define (draw-fieldagon bh)
  (rotate FIELD-ROTATION
          (regular-polygon BSIZE POLY-SIZE "solid"
                           (color-chooser (field-player bh)))))

;; Player -> Color
;; Determines a color for each player
(define (color-chooser p)
  (list-ref COLORS p))

;; Number Number Image -> Image
;; draws all of the dice except the first for a field onto acc
(define (draw-dice num offset acc)
  (for/fold ([scn acc])
    ([i (in-range (sub1 num))])
    (overlay/offset (get-die-img i) 0 
                    (dice-offset offset i) scn)))

;; Number Number -> Number
;; gets the offset for overlaying dice
(define (dice-offset initial-offset count)
  (+ initial-offset (* (/ BSIZE DICE-OFFSET) count)))

;; Number -> Image
;; returns a random image of a dice
(define (get-die-img num)
  (list-ref IMG-LIST num))

;                                                  
;                                                  
;                                                  
;                                                  
;   ;;;;;;              ;;     ;                   
;    ;   ;               ;                         
;    ; ;    ;; ;;    ;;; ;   ;;;    ;; ;;    ;;; ;;
;    ;;;     ;;  ;  ;   ;;     ;     ;;  ;  ;   ;; 
;    ; ;     ;   ;  ;    ;     ;     ;   ;  ;    ; 
;    ;       ;   ;  ;    ;     ;     ;   ;  ;    ; 
;    ;   ;   ;   ;  ;   ;;     ;     ;   ;  ;   ;; 
;   ;;;;;;  ;;; ;;;  ;;; ;;  ;;;;;  ;;; ;;;  ;;; ; 
;                                                ; 
;                                            ;;;;  
;                                                  
;                                                  

;; [List-of field] -> String
;; Which player has won the game.
;; >(won (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)))
;; "Player 1 Wins!"
;; > (won (list (field 0 0 1 87 0) (field 1 0 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)))
;; "Tie"
(define (won board)
  (define winner (winners board))
  (if (> (length winner) 2)
      "Tie"
      (string-append "Player "
                     (number->string (second winner))
                     " wins with "
                     (number->string (first winner))
                     " tiles!")))

;; FIXME: alittle confusing. ask about algo to do this...
;; Board -> [or (list Player Number) #f]
;; the winner of the game with there territory count or #f on tie
;; > (winners (list (field 0 0 1 87 0) (field 0 0 1 87 1)))
;; (list 2 0)
;; > (winners (list (field 0 1 1 87 0) (field 0 0 1 87 1)))
;; (list 1 0 1)
(define (winners board)
  (for/fold ([res empty])
    ([p (in-range PLAYER#)])
    (define count (sum-tile board p))
    (cond [(zero? p) (list count p)]
          [(> count (first res)) (list count p)]
          [(< count (first res)) res]
          [else (append res (list p))])))

;; Board Player -> Number
;; counts the number of tiles the player owns
;; > (sum-tile (list (field 0 1 1 87 0) (field 0 1 1 87 1)) 1)
;; 2
(define (sum-tile board player)
  (for/fold ([res 0])
    ([bhx board])
    (if (= player (field-player bhx))
        (add1 res)
        res)))

;                                  
;                                  
;                                  
;                                  
;     ;;                           
;      ;                           
;     ; ;   ;;  ;;  ;;  ;;   ;;;;; 
;     ; ;    ;   ;   ;  ;   ;    ; 
;     ; ;    ;   ;    ;;     ;;;;  
;     ;;;    ;   ;    ;;         ; 
;    ;   ;   ;  ;;   ;  ;   ;    ; 
;   ;;; ;;;   ;; ;; ;;  ;;  ;;;;;  
;                                  
;                                  
;                                  
;                                  

;; Board Number -> field
;; gets a field by its id number
;; Invariant: assumes field is in list.
;; > (field-lookup (list (field 0 "a" 2 87 0) (field 5 "b" 1 87 0) ...) 5)
;; (field 5 "b" 1 87 0)
(define (field-lookup board pos)
  (findf (lambda (b) 
           (= (field-index b) pos)) board))

;; Number -> Number
;; gets the row that field is on, indexed from 0
;; [test vary on current board-size]
(define (get-row pos)
  (quotient pos BOARD-SIZE))

;                                                    
;                                                    
;                                                    
;                                                    
;                                                    
;   ;;;;;;;                        ;                 
;   ;  ;  ;                        ;                 
;   ;  ;  ;     ;;;      ;;;; ;  ;;;;;;;     ;;;; ;  
;   ;  ;  ;    ;   ;    ;    ;;    ;        ;    ;;  
;      ;      ;     ;   ;          ;        ;        
;      ;      ;;;;;;;    ;;;;;     ;         ;;;;;   
;      ;      ;               ;    ;              ;  
;      ;       ;    ;   ;     ;    ;    ;   ;     ;  
;    ;;;;;      ;;;;    ;;;;;;      ;;;;    ;;;;;;   
;                                                    
;                                                    
;                                                    
;                                                    

(require rackunit rackunit/text-ui)

;; Test Macros & Functions
(define (distribute/list a b c)
  (define-values (x y) (distribute a b c))
  (list x y))

;; (-> any) -> void
;; runs the thunk PROP-NUM times
(define (check-property t)
  (test-begin (for ((i 50)) (t))))

;; Properties
(define (property:starting-world-playable)
  (unless (and (= BOARD-SIZE 2) (= PLAYER# 2))
    (error 'starting-world-playable "BOARD-SIZE != 2 or PLAYERS# != 2"))
  (check-false (no-more-moves? (get-a-world))))

(define (property:dice-in-range)
  (check-true (andmap (λ (b) (>= MAX-DICE (field-dice b) 1)) (field-build))
              "dice out of range"))

(define (property:board-correct-size)
  (check-equal? (length (field-build)) GRID
                "board incorrect-size"))

(define (property:no-pass-on-first-move)
  (define (move-action? m) (equal? (move-action m) '()))
  (check-true (not (memf move-action? (game-moves (game-tree (field-build) 0 0))))
              "no pass on first move"))

(define (property:attack-location-valid)
  (define moves (game-moves (game-tree (field-build) 0 0)))
  (check-true (and (for/and ([m moves])
                     (define m1 (move-action m))
                     (member (second m1) (neighbors (first m1))))
                   #t)
              "invalid attack location"))

(define (property:attack-dice-in-range)
  (define board (field-build))
  (define gt (game-tree board 0 0))
  (check-true (for/and ([m (game-moves gt)])
                (define m1 (move-action m))
                (> (field-dice (field-lookup board (first m1)))
                   (field-dice (field-lookup board (second m1)))))
              "dice count to low on attack"))

(define (property:add-to-field-always-up-one)
  (define r (random 10000))
  (check-equal? (add-to-field (field 0 0 r 0 0))
                (field 0 0 (add1 r) 0 0)
                "add to field always up one"))

;; Test Suites
;; ---------------------------------------------------------------------------------------------------
; Test Values

(define board0 (list (field 0 0 1 87 0) (field 1 1 2 174 0) (field 2 0 2 43.5 75) (field 3 1 1 130.5 75)))
(define board1 (list (field 0 0 1 87 0) (field 1 1 1 174 0) (field 2 0 1 43.5 75) (field 3 1 1 130.5 75)))
(define bard1+ (list (field 0 0 1 87 0) (field 1 1 2 174 0) (field 2 0 1 43.5 75) (field 3 1 2 130.5 75)))
(define board2 (list (field 0 0 1 87 0) (field 1 1 1 174 0) (field 2 0 3 43.5 75) (field 3 1 1 130.5 75)))

(define gametree1 (game board1 0 '()))
(define gametree2 (game-tree board0 0 0))

(define world1 (dice-world #f board1 gametree1))
(define world2 (dice-world #f board2 gametree2))

(define-test-suite --initialization
  (check-equal? (field-index (first (field-build))) 0)
  (check-equal? (field-player (first (field-build))) 0)
  (check-equal? (field-index (second (field-build))) 1)
  (check-equal? (field-player (second (field-build))) 1)
  (check-equal? (field-index (third (field-build))) 2)
  (check-equal? (field-player (third (field-build))) 0)
  (check-equal? (field-index (fourth (field-build))) 3)
  (check-equal? (field-player (fourth (field-build))) 1)
  
  (check-property property:starting-world-playable)
  (check-property property:board-correct-size)
  (check-property property:dice-in-range)
  (check-property property:no-pass-on-first-move))

(define-test-suite --field-manipulation
  (check-equal? (get-x-offset 12)
                (/ X-OFFSET 2))
  (check-equal? (get-x-offset 8)
                (/ X-OFFSET 2))
  (check-equal? (get-x-offset 44)
                (/ X-OFFSET 2))
  (check-equal? (get-x-offset 9)
                (/ X-OFFSET 2))
  (check-equal? (get-x-offset 13)
                (/ X-OFFSET 2))
  (check-equal? (get-x-offset 90)
                0)
  (check-equal? (get-x-offset 3)
                0)
  (check-equal? (get-x-offset 7)
                0)
  (check-equal? (get-x-offset 6)
                0)
  
  ;; field-lookup
  (check-equal? (field-lookup (list (field 0 0 2 87 0) (field 5 1 1 87 0)) 5) (field 5 1 1 87 0))
  (check-equal? (field-lookup board1 0) (field 0 0 1 87 0))
  (check-equal? (field-lookup board1 3) (field 3 1 1 130.5 75))
  
  ;; legal?
  (check-true 
   (cons? (attackable? (list (field 0 0 2 87 0) (field 3 1 1 87 0)) 0 (field 0 0 2 87 0) 3)))
  (check-false
   (attackable? (list (field 0 0 2 87 0) (field 1 0 1 87 0) (field 3 1 1 87 0)) 0 (field 0 0 2 87 0) 1))
  (check-false
   (attackable? (list (field 0 0 2 87 0) (field 3 1 1 87 0)) 0 (field 0 0 2 87 0) 0))
  (check-false
   (attackable? (list (field 0 0 2 87 0) (field 5 1 1 87 0)) 1 (field 0 0 2 87 0) 5))
  (check-exn
   exn:fail? (λ () (attackable? '() 0 (field 0 0 1 97 0) 2)))
  
  ;; get-row
  (check-equal? (get-row 0) 0)
  (check-equal? (get-row 1) 0)
  (check-equal? (get-row 2) 1)
  (check-equal? (get-row 3) 1)
  (check-equal? (get-row 12) 6) ;; checks math. actually invalid on board of size 2
  (check-equal? (get-row 11) 5) ;; checks math. actually invalid on board of size 2
  (check-equal? (get-row 13) 6) ;; checks math. actually invalid on board of size 2
  (check-equal? (get-row 14) 7)) ;; checks math. actually invalid on board of size 2

(define board3
  (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 3 43.5 75) (field 3 1 1 130.5 75)))

(define-test-suite --tree-generation
  ;; game-tree
  (check-equal? (game-tree board1 0 0) gametree1)
  (check-equal? (game-tree board3 1 0) (game board3 1 '()))
  (check-equal? (game-tree board3 0 0) (game board3 0 '()))
  
  ;; find-move
  (check-false (find-move '() '()))
  (check-equal? (find-move (list (move '() (game '() 0 '()))) '())
                (game '() 0 '()))
  ;; Attacking-Moves
  (check-property property:attack-location-valid)
  (check-property property:attack-dice-in-range)
  
  ;; switch-players
  (check-equal? (switch 0) 1)
  (check-equal? (switch 1) 0)
  
  ;; Add-New-Dice
  (check-equal? 
   (distribute/list (game-board gametree1) 0 3)
   (list 1
         (reverse (list (field 0 0 2 87 0)
                  (field 1 1 1 174 0)
                  (field 2 0 2 43.5 75)
                  (field 3 1 1 130.5 75)))))
  (check-equal? 
   (distribute/list (game-board gametree1) 1 2)
   (list 0 (reverse bard1+)))
  (check-equal? 
   (distribute/list (game-board gametree2) 1 2)
   (list 0
   (reverse (list (field 0 0 1 87 0)
                  (field 1 1 3 174 0)
                  (field 2 0 2 43.5 75)
                  (field 3 1 2 130.5 75)))))
  (check-equal? 
   (distribute/list (list (field 0 0 1 87 0)
                     (field 1 1 2 174 0)
                     (field 2 0 3 43.5 75)
                     (field 3 1 2 130.5 75)) 0 0)
   (list 0
   (reverse (list (field 0 0 1 87 0)
                  (field 1 1 2 174 0)
                  (field 2 0 3 43.5 75)
                  (field 3 1 2 130.5 75)))))
  
  ;; add-to-field
  (check-equal? (add-to-field (field 0 1 2 87 0))
                (field 0 1 3 87 0))
  (check-equal? (add-to-field (field 0 1 1 87 0))
                (field 0 1 2 87 0))
  (check-equal? (add-to-field (field 0 1 5 87 0))
                (field 0 1 6 87 0))
  (check-property property:add-to-field-always-up-one))

(define-test-suite --attacking
  ;; board-attack
  (check-equal? (attack (list (field 0 0 1 87 0)
                              (field 1 1 1 174 0)
                              (field 2 0 2 43.5 75)
                              (field 3 1 1 130.5 75)) 0 2 1 2)
                (list (field 0 0 1 87 0)
                      (field 1 0 1 174 0)
                      (field 2 0 1 43.5 75)
                      (field 3 1 1 130.5 75)))
  (check-equal? (attack (list (field 0 1 1 87 0)
                              (field 1 1 1 174 0)
                              (field 2 0 3 43.5 75)
                              (field 3 1 1 130.5 75)) 0 2 1 3)
                (list (field 0 1 1 87 0)
                      (field 1 0 2 174 0)
                      (field 2 0 1 43.5 75)
                      (field 3 1 1 130.5 75)))
  (check-equal? (attack (list (field 0 0 1 87 0)
                              (field 1 1 1 174 0)
                              (field 2 0 2 43.5 75)
                              (field 3 0 1 130.5 75)) 0 2 1 2)
                (list (field 0 0 1 87 0)
                      (field 1 0 1 174 0)
                      (field 2 0 1 43.5 75)
                      (field 3 0 1 130.5 75)))
  
  (check-equal? (attack (list (field 0 0 1 87 0)
                              (field 1 1 3 174 0)
                              (field 2 0 2 43.5 75)
                              (field 3 1 1 130.5 75)) 1 1 0 3)
                (list(field 0 1 2 87 0)
                     (field 1 1 1 174 0)
                     (field 2 0 2 43.5 75)
                     (field 3 1 1 130.5 75)))
  
  ;; Neighbors
  (check-equal? (neighbors 2) '(0 3))
  (check-equal? (neighbors 0) '(3 2 1))
  (check-equal? (neighbors 1) '(3 0)) 
  (check-equal? (neighbors 3) '(1 0 2)))

(define-test-suite --tile-selection
  ;; interact-with-board
  (check-equal? (interact-with-board world2 "\r") (dice-world (field-index (car (dice-world-board world2))) (dice-world-board world2) gametree2))
  (check-equal? (interact-with-board world2 "p") world2)

  ;; select-tile-action
  (check-equal? (select-tile-action (dice-world #f (list (field 0 0 1 87 0) (field 0 0 1 87 2)) gametree1) "left")
                (dice-world #f (list (field 0 0 1 87 2) (field 0 0 1 87 0)) gametree1))
  (check-equal? (select-tile-action (dice-world #f (list (field 0 0 1 87 2) (field 0 1 1 87 0)) gametree1) "right")
                (dice-world #f (list (field 0 0 1 87 2) (field 0 1 1 87 0)) gametree1))
  (check-equal? (select-tile-action (dice-world 0
                                                (list (field 0 0 1 87 2) 
                                                      (field 1 0 1 87 0)
                                                      (field 2 2 1 87 0)) gametree1)
                                    "left")
                (dice-world 0 (list (field 2 2 1 87 0)
                                    (field 0 0 1 87 2) 
                                    (field 1 0 1 87 0)) gametree1))
  
  (check-equal? (select-tile-action (dice-world 0 (list (field 0 0 1 87 2) (field 0 1 1 87 0)) gametree1) "left")
                (dice-world 0 (list  (field 0 1 1 87 0) (field 0 0 1 87 2)) gametree1))
  (check-equal? (select-tile-action (dice-world 0 (list(field 0 0 1 87 2) (field 0 1 1 87 0)) gametree1) "right")
                (dice-world 0 (list  (field 0 1 1 87 0) (field 0 0 1 87 2)) gametree1))
  
  ;;unmark
  (check-equal? (unmark (dice-world 1 (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)) gametree1))
                (dice-world #f (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)) gametree1))
  (check-equal? (unmark (dice-world 1 (list (field 0 1 1 87 0) (field 1 1 1 174 0)) gametree1))
                (dice-world #f (list (field 0 1 1 87 0) (field 1 1 1 174 0)) gametree1))
  (check-equal? (unmark (dice-world 0 (list (field 0 1 1 87 0)) gametree1))
                (dice-world #f (list (field 0 1 1 87 0)) gametree1))
  (check-equal? (unmark (dice-world #f (list (field 0 1 1 87 0)) gametree1))
                (dice-world #f (list (field 0 1 1 87 0)) gametree1)))

(define-test-suite --winnning-the-game
  ;; won
  (check-equal? (won (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)))
                "Player 1 wins with 4 tiles!")
  (check-equal? (won (list (field 0 0 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)))
                "Player 1 wins with 3 tiles!")
  (check-equal? (won (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 0 1 130.5 75)))
                "Player 1 wins with 3 tiles!")
  (check-equal? (won (list (field 0 0 1 87 0) (field 1 0 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)))
                "Tie")
  
  ;; winners
  (check-equal? (winners (list (field 0 0 1 87 0) (field 0 0 1 87 1)))
                (list 2 0))
  (check-equal? (winners (list (field 0 1 1 87 0) (field 0 0 1 87 1)))
                (list 1 0 1))
  (check-equal? (winners (list (field 0 1 1 87 0) (field 0 0 1 87 1) (field 0 1 1 87 0) (field 0 0 1 87 1)))
                (list 2 0 1))
  (check-equal? (winners (list (field 0 1 1 87 0) (field 0 0 1 87 1) (field 0 0 1 87 1)))
                (list 2 0))
  
  ;; sum-tile
  (check-equal? (sum-tile (list (field 0 0 1 87 0) (field 0 0 1 87 1)) 0)
                2)
  (check-equal? (sum-tile (list (field 0 0 1 87 0) (field 0 0 1 87 1)) 1)
                0)
  (check-equal? (sum-tile (list (field 0 0 1 87 0) (field 0 0 1 87 1)) 2)
                0)
  (check-equal? (sum-tile (list (field 0 1 1 87 0) (field 0 0 1 87 1)) 1)
                1)
  (check-equal? (sum-tile (list (field 0 1 1 87 0) (field 0 0 1 87 1)) 0)
                1)
  (check-equal? (sum-tile (list (field 0 1 1 87 0) (field 0 0 1 87 1) (field 0 0 1 87 1)) 0)
                2)
  (check-equal? (sum-tile (list (field 0 1 1 87 0) (field 0 0 1 87 1) (field 0 0 1 87 1)) 1)
                1)
  
  
  ;; dice-offset 
  (check-equal? (dice-offset 5 3) 85/2)
  (check-equal? (dice-offset 9 2) 34)
  (check-equal? (dice-offset 1 0) 1))

(define-test-suite --rendering
  ;; draw-dice
  (check-equal? (draw-dice 1 0 (draw-fieldagon (field 0 0 0 0 0))) (draw-fieldagon (field 0 0 0 0 0)))
  (check-equal? (draw-dice 2 0 (draw-fieldagon (field 0 0 0 0 0))) 
                (overlay(first IMG-LIST)(draw-fieldagon (field 0 0 0 0 0))))
  
  (check-equal? (draw-dice 3 0 (draw-fieldagon (field 0 0 0 0 0)))
                (overlay/offset
                 (second IMG-LIST)
                 0
                 12.5
                 (overlay(first IMG-LIST)(draw-fieldagon (field 0 0 0 0 0)))))
  
  ;; draw-field
  (check-equal? (draw-field (field 0 0 1 0 0))
                (overlay 
                 (rotate 30 (regular-polygon BSIZE 6 "solid"
                                             (first COLORS)))
                 (second IMG-LIST)))
  )

(run-tests --initialization)
(run-tests --rendering)
(run-tests --tile-selection)
(run-tests --field-manipulation)
(run-tests --attacking)
(run-tests --winnning-the-game)
(run-tests --tree-generation)
>Fix:
>Audit-Trail:
From: Robby Findler <robby@eecs.northwestern.edu>
To: matthias@ccs.neu.edu, bugs@racket-lang.org
Cc: nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12386: drracket diverges when 'view | split'
Date: Sat, 19 Nov 2011 21:58:03 -0600

 I think that Neil T's commit may have fixed this and I see your
 version is older than that.
 
 Robby
 
 On Sat, Nov 19, 2011 at 6:32 PM,  <matthias@ccs.neu.edu> wrote:
 > A new problem report is waiting at
 >  http://bugs.racket-lang.org/query/?cmd=view&pr=12386
 >
 > Reported by matthias for release: 5.2.0.3--2011-11-16(8483b8e/g)
 >
 > *** Description:
 > It happens on the below file, repeatedly.
 > Start drracket. Split view. Consumes 100%
 > cpu no response.
 >
 > *** How to repeat:
 > #lang racket
 >
 > (require 2htdp/universe 2htdp/image)
 >
 > #|
 > This module implements the Dice of Doom game
 >
 > It is a mulitplayer turn-based game. Each player owns hexagonal fields,
 > which are arranged into a plane board. Each field comes with a number of
 > dice. When it is a player's turn, she selects a field that she owns to
 > attack a neigboring field of some other player. An attack is enabled as
 > long as the attacking field has more dice than the defending field. The
 > effect of the attack is that the field changes ownership and that all but
 > one of the attack dice are moved to the newly conquered field. A player may
 > continue her turn as long as she can launch attacks. Optionally, she may
 > choose to pass -- meaning she ends her turn -- as long as she has launched
 > at least one attack. At the end of a turn, a number of dices are randomly
 > distributed across the player's fields. The game is over when a player whose
 > turn it is cannot attack on her first move.
 >
 > The software supports any number of players. Launch the game with
 >
 >  (roll-the-dice Name1 Name2 ...)
 >
 > where Name1, Name2, etc are strings. If you launch the game via
 >
 >  (roll-the-dice)
 >
 > you get a default configuration for two players.
 >
 > A player can use the following five keys to play the game:
 > -- with ← and → (arrow keys), the player changes the field focus
 > -- with enter, the player marks a tile as a place
 >   from which to launch an attack or what to attack
 > -- with the "d" key, the player unmarks a tile
 > -- with the "p" key the player passes
 > Once a player passes, the game announces whose turn it is next.
 >
 > |#
 >
 >
 >
 > ;
 > ;
 > ;
 > ;
 > ;   ;;;;       ;                            ;;; ;;;                   ;;        ;;
 > ;    ;  ;                                    ;   ;                     ;         ;
 > ;    ;   ;   ;;;     ;;; ;   ;;;;            ;   ;   ;;;;   ;; ;;;     ;     ;;; ;
 > ;    ;   ;     ;    ;   ;;  ;    ;           ; ; ;  ;    ;   ;;        ;    ;   ;;
 > ;    ;   ;     ;    ;       ;;;;;;           ; ; ;  ;    ;   ;         ;    ;    ;
 > ;    ;   ;     ;    ;       ;                ; ; ;  ;    ;   ;         ;    ;    ;
 > ;    ;  ;      ;    ;    ;  ;                ; ; ;  ;    ;   ;         ;    ;   ;;
 > ;   ;;;;     ;;;;;   ;;;;    ;;;;;            ; ;    ;;;;   ;;;;;    ;;;;;   ;;; ;;
 > ;
 > ;
 > ;
 > ;
 >
 > ;; -----------------------------------------------------------------------------
 > ;; Data
 >
 > (struct dice-world (src board gt) #:transparent)
 > ;; A DiceWorld is a (dice-world Number Board GameTree)
 > ;; the first field is number the tile the current player has selected
 > ;;     to attack with #f if no selection has been made
 > ;; the second is the board
 > ;; the third is the current game-tree
 >
 > ;; A Board is a [List-of field]
 > ;; the first field in the list is the field currently selected
 >
 > (struct field (index player dice x y) #:transparent)
 > ;; A field is a (field Number Player Dice Number Number)
 > ;; first field is a unique number identifying the field and its initial location
 > ;;   in the board
 > ;; the second field is the player who owns this field
 > ;; the third field is the number of dice on this board
 > ;; the fourth field is the x coordiate of this tile in pixels
 > ;; the fifth field is the y coordiate of this tile in pixels
 >
 > ;; A Player is a number from [0, NUM-PLAYERS)
 >
 > (struct game (board player moves) #:transparent)
 > ;; A GameTree is a (game Board Player [list-of Move])
 > ;; the first field is the board this gametree represents
 > ;; the second field is the player whos turn it is
 > ;; the third field is a list of possible moves on that board by that player
 >
 > (struct move (action gt) #:transparent)
 > ;; A Move is a (move Action GameTree)
 > ;; the first field is the action this move represents
 > ;; the second field is the gametree resulting from that move.
 >
 > ;; an Action is one of
 > ;; -'()                    a passing move
 > ;; -(list Number Number)   The move where the first attacks the second
 >
 > ;; -----------------------------------------------------------------------------
 > ;; Constants
 >
 > ; initalization constants
 > (define PLAYER# 2)
 > (define MAX-DICE 3)
 > (define BOARD-SIZE 2)
 > (define GRID (* BOARD-SIZE BOARD-SIZE))
 > (define INIT-PLAYER 0)
 > (define INIT-SPARE-DICE 10)
 >
 > ; graphical constants: fields
 > (define DICE-OFFSET 6)
 > (define BSIZE 75)
 > (define BWIDTH
 >  (image-width
 >   (rotate 30 (regular-polygon BSIZE 6 "solid" "black"))))
 > (define X-OFFSET BWIDTH)
 > (define BHEIGHT
 >  (image-height
 >   (rotate 30 (regular-polygon BSIZE 6 "solid" "black"))))
 > (define Y-OFFSET (* BHEIGHT 3/4))
 > (define INITIAL-OFFSET (* 2 BSIZE))
 > (define FIELD-ROTATION 30)
 > (define POLY-SIZE 6)
 >
 > ; graphical constants: Colors
 > (define COLORS
 >  (list (make-color 255 0 0 100)
 >        (make-color 0 255 0 100)
 >        (make-color 0 0 255 100)))
 >
 > ; graphical constants: Selector image
 > (define SELECT
 >  (rotate FIELD-ROTATION (regular-polygon BSIZE 6 "outline" "black")))
 >
 > ;; Images: dice
 > (define D1 (bitmap "graphics/dice1.png"))
 > (define D2 (bitmap "graphics/dice2.png"))
 > (define D3 (bitmap "graphics/dice3.png"))
 > (define D4 (bitmap "graphics/dice4.png"))
 > (define IMG-LIST (list D1 D2 D3 D4))
 >
 > ;; text
 > (define TEXT-SIZE 15)
 > (define TEXT-COLOR "black")
 > (define INSTRUCT
 >  (string-append "press ← and → to select fieldes, "
 >                 "enter to select tiles, "
 >                 "d to deselect tiles and p to pass"))
 > (define PLAYER-DRAW-TEXT "Current Player: ")
 > (define INFO-X-OFFSET 100)
 > (define INFO-Y-OFFSET 50)
 >
 > ; graphical constants: world
 > (define WIDTH 600)
 > (define HEIGHT 600)
 > (define ISCENE (place-image (text INSTRUCT TEXT-SIZE TEXT-COLOR)
 >                            (* .5 WIDTH) (* .9 HEIGHT)
 >                            (empty-scene WIDTH HEIGHT)))
 >
 > ;
 > ;
 > ;
 > ;
 > ;   ;;; ;;;            ;
 > ;    ;; ;;
 > ;    ;; ;;   ;;;;    ;;;    ;; ;;
 > ;    ; ; ;  ;    ;     ;     ;;  ;
 > ;    ; ; ;   ;;;;;     ;     ;   ;
 > ;    ;   ;  ;    ;     ;     ;   ;
 > ;    ;   ;  ;   ;;     ;     ;   ;
 > ;   ;;; ;;;  ;;; ;;  ;;;;;  ;;; ;;;
 > ;
 > ;
 > ;
 > ;
 >
 > ;; start the game
 > (define (roll-the-dice)
 >  (big-bang (get-a-world)
 >            (on-key interact-with-board)
 >            (on-draw draw-dice-world)
 >            (stop-when no-more-moves?
 >                       end-of-game-drawer)))
 >
 > ;;  -> DiceWorld
 > ;; Returns a randomly generated world. If the world that
 > ;; has been generated starts as a tie, the world is regenerated.
 > ;; property: world is not in endgame state (no-more-moves? returns false)
 > (define (get-a-world)
 >  (define board (field-build))
 >  (define gamet (game-tree board INIT-PLAYER INIT-SPARE-DICE))
 >  (define w (dice-world #f board gamet))
 >  (if (no-more-moves? w)
 >      (get-a-world)
 >      w))
 >
 > ;; DiceWorld Key -> DiceWorld
 > ;; Handles key events from a player
 > (define (interact-with-board w k)
 >  (cond [(or (key=? "left" k) (key=? "right" k))
 >         (select-tile-action w k)]
 >        [(key=? "p" k)
 >         (pass-action w)]
 >        [(key=? "\r" k)
 >         (mark-action w)]
 >        [(key=? "d" k)
 >         (unmark w)
 >         w]
 >        [else w]))
 >
 > ;; DiceWorld -> DiceWorld
 > ;; unmarks a marked tile
 > (define (unmark w)
 >  (dice-world #f
 >              (dice-world-board w)
 >              (dice-world-gt w)))
 >
 > ;; Diceworld -> Scene
 > ;; draws the world
 > (define (draw-dice-world w)
 >  (draw-player-info
 >   (game-player (dice-world-gt w))
 >   (field->scene (dice-world-board w) ISCENE)))
 >
 > ;; DiceWorld -> Boolean
 > ;; is the game over? ie no moves can be made
 > (define (no-more-moves? w)
 >  (empty? (game-moves (dice-world-gt w))))
 >
 > ;; DiceWorld -> Image
 > ;; render the endgame screen
 > (define (end-of-game-drawer w)
 >  (place-image
 >   (text (won (dice-world-board w)) TEXT-SIZE TEXT-COLOR)
 >   (/ WIDTH 2) (/ HEIGHT 2) ISCENE))
 >
 > ;
 > ;
 > ;
 > ;
 > ;    ;;;;;             ;
 > ;      ;                     ;
 > ;      ;    ;; ;;    ;;;    ;;;;;
 > ;      ;     ;;  ;     ;     ;
 > ;      ;     ;   ;     ;     ;
 > ;      ;     ;   ;     ;     ;
 > ;      ;     ;   ;     ;     ;   ;
 > ;    ;;;;;  ;;; ;;;  ;;;;;    ;;;
 > ;
 > ;
 > ;
 > ;
 >
 > ;; -----------------------------------------------------------------------------
 > ;; Making A Board
 >
 > ;; -> [List-of field]
 > ;; Creates a list of fields the size of GRID with given x and y coordinates
 > ;; properties: dice is (0,MAX-DICE]
 > ;;             returns list of size GRID
 > (define (field-build)
 >  (for/list ([n (in-range GRID)])
 >    (define x (+ INITIAL-OFFSET
 >                 (get-x-offset n)
 >                 (* X-OFFSET (modulo n BOARD-SIZE))))
 >    (define y (+ INITIAL-OFFSET
 >                 (* Y-OFFSET (get-row n))))
 >    (define p (modulo n PLAYER#))
 >    (define d (add1 (random MAX-DICE)))
 >    (field n p d x y)))
 >
 > ;; Number -> Number
 > ;; gets the offset for a field based on row
 > ;; > (get-x-offset 2)
 > ;; (/ X-OFFSET 2)
 > (define (get-x-offset field-index)
 >  (if (odd? (get-row field-index))
 >      0
 >      (/ X-OFFSET 2)))
 >
 > ;; -----------------------------------------------------------------------------
 > ;; Making a Game Tree
 >
 > ;; Board Player Natural -> GameTree
 > ;; creates a complete game-tree from the given board, player, and spare dice
 > (define (game-tree board player dice)
 >  ;; create tree of attacks from this position; add passing move
 >  (define (attacks board)
 >    (for*/list ([src board]
 >                [dst (neighbors (field-index src))]
 >                #:when (attackable? board player src dst))
 >      (define from (field-index src))
 >      (define newb (attack board player from dst (field-dice src)))
 >      (define more (cons (passes newb) (attacks newb)))
 >      (move (list from dst) (game newb player more))))
 >  ;; create a passing move and the rest of the game tree
 >  (define (passes board)
 >    (define-values (new-dice newb) (distribute board player dice))
 >    (move '() (game-tree newb (switch player) new-dice)))
 >  ;; -- IN --
 >  (game board player (attacks board)))
 >
 > ;; player -> player
 > ;; switches from one player to annother
 > ;; > (switch 0)
 > ;; 2
 > (define (switch player)
 >  (modulo (add1 player) PLAYER#))
 >
 > ;; Board Player Number -> Number Board
 > ;; adds reinforcements to the game board
 > ;; > (add-new-dice (list (field 0 2 2 87 0)) 2 2))
 > ;; (list (field 0 2 2 87 0))
 > (define (distribute board player spare-dice)
 >  (for/fold ([dice spare-dice]
 >             [accu empty])
 >    ([b board])
 >    (if (and (= (field-player b) player)
 >             (< (field-dice b) MAX-DICE)
 >             (not (zero? dice)))
 >        (values (sub1 dice)
 >                (cons (add-to-field b) accu))
 >        (values dice
 >                (cons b accu)))))
 >
 > ;; field Player Natnum -> field
 > ;; adds dice to the given field
 > ;; > (add-to-field (field 0 1 2 87 0))
 > ;; (field 0 1 2 87 0)
 > (define (add-to-field bhx)
 >  (field (field-index bhx)
 >         (field-player bhx)
 >         (add1 (field-dice bhx))
 >         (field-x bhx)
 >         (field-y bhx)))
 >
 > ;; Board Player field Number -> Boolean
 > ;; is an attack from src to dst valid for cur-player?
 > ;; > (is-move? (list (field 0 0 2 87 0) (field 3 1 1 87 0)) 0 (field 0 0 2 87 0) 3)
 > ;; #t
 > ;; > (is-move? (list (field 0 0 2 87 0) (field 5 1 1 87 0)) 1 (field 0 0 2 87 0) 5)
 > ;; #f
 > (define (attackable? board player src dst)
 >  (and (= (field-player src) player)
 >       (not (= (field-player (field-lookup board dst)) player))
 >       (> (field-dice src) (field-dice (field-lookup board dst)))
 >       (member dst (neighbors (field-index src)))))
 >
 > ;; Board Number Number Number Number -> Board
 > ;; Creates a new board after an attack
 > ;; updates only src and dst
 > (define (attack board player src dst dice)
 >  (for/list ([bhx board])
 >    (cond [(= (field-index bhx) src)
 >           (field (field-index bhx) player 1
 >                  (field-x bhx) (field-y bhx))]
 >          [(= (field-index bhx) dst)
 >           (field (field-index bhx) player (sub1 dice)
 >                  (field-x bhx) (field-y bhx))]
 >          [else bhx])))
 >
 > ;; -----------------------------------------------------------------------------
 > ;; Getting Neigbors
 >
 > ;; Number -> [List-of Number]
 > ;; Returns the neighbors of the current spot
 > ;; > (neighbors 0)
 > ;; '(1 2 3)
 > (define (neighbors pos)
 >  (define top? (< pos BOARD-SIZE))
 >  (define bottom? (= (get-row pos) (sub1 BOARD-SIZE)))
 >  (define even-row? (zero? (modulo (get-row pos) 2)))
 >  (define right? (zero? (modulo (add1 pos) BOARD-SIZE)))
 >  (define left? (zero? (modulo pos BOARD-SIZE)))
 >  (if even-row?
 >      (handle-even-row pos top? bottom? right? left?)
 >      (handle-odd-row pos top? bottom? right? left?)))
 >
 > ;; Number Boolean Boolean Boolean Boolean -> [Listof Numbers]
 > ;; gets the neighbors for a territory on an even row
 > (define (handle-even-row pos top? bottom? right? left?)
 >  (append (add (or top? right?)
 >               (add1 (- pos BOARD-SIZE)))
 >          (add (or bottom? right?)
 >               (add1(+ pos BOARD-SIZE)))
 >          (add top?
 >               (- pos BOARD-SIZE))
 >          (add bottom?
 >               (+ pos BOARD-SIZE))
 >          (add right? (add1 pos))
 >          (add left? (sub1 pos))))
 >
 > ;; Number Boolean Boolean Boolean Boolean -> [Listof Numbers]
 > ;; gets the neighbors for a territory on an even odd
 > (define (handle-odd-row pos top? bottom? right? left?)
 >  (append (add top?
 >               (- pos BOARD-SIZE))
 >          (add bottom?
 >               (+ pos BOARD-SIZE))
 >          (add (or top? left?)
 >               (sub1 (- pos BOARD-SIZE)))
 >          (add (or bottom? left?)
 >               (sub1 (+ pos BOARD-SIZE)))
 >          (add right? (add1 pos))
 >          (add left? (sub1 pos))))
 >
 > ;; Boolean X -> [Listof X]
 > ;; returns (list x) if (not b) else empty
 > (define (add b x)
 >  (if b
 >      empty
 >      (list x)))
 >
 > ;
 > ;
 > ;
 > ;
 > ;   ;;; ;;;                 ;;;;;;
 > ;    ;   ;                   ;   ;                           ;
 > ;    ;  ;    ;;;;   ;;; ;;;  ; ;   ;;;  ;;;  ;;;;   ;; ;;   ;;;;;    ;;;;;
 > ;    ; ;    ;    ;   ;   ;   ;;;    ;    ;  ;    ;   ;;  ;   ;      ;    ;
 > ;    ;;;    ;;;;;;   ;   ;   ; ;     ;  ;   ;;;;;;   ;   ;   ;       ;;;;
 > ;    ;  ;   ;         ; ;    ;       ;  ;   ;        ;   ;   ;           ;
 > ;    ;   ;  ;         ; ;    ;   ;    ;;    ;        ;   ;   ;   ;  ;    ;
 > ;   ;;;  ;;  ;;;;;     ;    ;;;;;;    ;;     ;;;;;  ;;; ;;;   ;;;   ;;;;;
 > ;                      ;
 > ;                    ;;;
 > ;
 > ;
 >
 > ;; -----------------------------------------------------------------------------
 > ;; Tile Selection
 >
 > ;; DiceWorld [or "left" "right"] -> World
 > ;; Creates a new World that has a rotated field list
 > ;; > (select-tile-action (dice-world -1 (list (field 0 0 1 87 0) (field 0 0 1 87 2) ...) [Game-Tree]) "left")
 > ;; (dice-world -1 (list (field 0 0 1 87 2) ... (field 0 0 1 87 0)) [Game-Tree])
 > ;; > (select-tile-action (dice-world -1 (list (field 0 0 1 87 2) ... (field 0 0 1 87 0)) [Game-Tree]) "left")
 > ;; (dice-world -1 (list (field 0 0 1 87 0) (field 0 0 1 87 2) ...) [Game-Tree])
 > (define (select-tile-action w k)
 >  (define source (dice-world-src w))
 >  (define board  (dice-world-board w))
 >  (define tree   (dice-world-gt w))
 >  (define owner? (owner=occupier? (game-player tree) (not source)))
 >  (define new-board
 >    (rotate-until owner? board
 >                  (cond [(key=? k "left") left]
 >                        [(key=? k "right") right])))
 >  (dice-world source new-board tree))
 >
 > ;; [Player -> Boolean] [Listof Field] ([Listof Field] -> [Listof Field]) -> [Listof Field]
 > ;; rotate until the first element of the list satisfies owned-by
 > (define (rotate-until owned-by lobh rotate)
 >  (define next-list (rotate lobh))
 >  (if (owned-by (field-player (first next-list)))
 >      next-list
 >      (rotate-until owned-by next-list rotate)))
 >
 > ;; [Listof Field] -> [Listof Field]
 > ;; rotate a list to the left
 > (define (left l)
 >  (append (rest l) (list (first l))))
 >
 > ;; [Listof Field] -> [Listof Field]
 > ;; rotate a list to the right
 > (define (right l)
 >  (reverse (left (reverse l))))
 >
 > ;; Number Player -> (Any -> Boolean)
 > ;; creates a function that test if p is = to given player
 > (define ((owner=occupier? player theres?) tile-id)
 >  (if theres? (= tile-id player) (not (= tile-id player))))
 >
 > ;; -----------------------------------------------------------------------------
 > ;; Handling Moves
 >
 > ;; [List-of Moves] [or '() [List Number Number]] -> [or #f Game-tree]
 > ;; find the move from the current list of moves
 > ;; > (find-move empty (list 1 2)
 > ;; #f
 > (define (find-move moves current)
 >  (define mv
 >    (findf (lambda (m) (equal? (move-action m) current)) moves))
 >  (if mv (move-gt mv) mv))
 >
 > ;; DiceWorld -> DiceWorld
 > ;; Adds a passing move to the World
 > ;; > (pass-action (dice-world [Number] [Board] [Move]) empty)
 > ;; (dice-world [Number] [Board] empty)
 > ;; > (pass-action [World] (game [Board] 0 [Listof Moves]))
 > ;; (dice-world -1 [Board] (game [Board] 0 [Listof Moves]))
 > (define (pass-action w)
 >  (define m  (find-move (game-moves (dice-world-gt w)) '()))
 >  (if (false? m) w (dice-world #f (game-board m) m)))
 >
 > ;; DiceWorld -> DiceWorld
 > ;; Moves the gametree to the next attacking move, or changes tile selection
 > ;; > (mark-action (dice-world -1 (list (field 0 0 1 87 0) ...) [Some-Game-Tree]) [Some-Move])
 > ;;(dice-world 0 (list (field 0 0 1 87 0) ...) [Some-Game-Tree])
 > ;; > (mark-action [Some-World] #f)
 > ;; [Some-World]
 > (define (mark-action w)
 >  (define tree   (dice-world-gt w))
 >  (define board  (dice-world-board w))
 >  (define source (dice-world-src w))
 >  (define target (field-index (first board)))
 >  (cond [(not source) (dice-world target board tree)]
 >        [else
 >         (define feasible (game-moves (dice-world-gt w)))
 >         (define attack   (list source target))
 >         (define next     (find-move feasible attack))
 >         (cond
 >           [(false? next) w]
 >           [else (dice-world #f (game-board next) next)])]))
 >
 > ;
 > ;
 > ;
 > ;
 > ;   ;;;;;                       ;;                     ;
 > ;    ;   ;                       ;
 > ;    ;   ;   ;;;;   ;; ;;    ;;; ;   ;;;;   ;; ;;;   ;;;    ;; ;;    ;;; ;;
 > ;    ;   ;  ;    ;   ;;  ;  ;   ;;  ;    ;   ;;        ;     ;;  ;  ;   ;;
 > ;    ;;;;   ;;;;;;   ;   ;  ;    ;  ;;;;;;   ;         ;     ;   ;  ;    ;
 > ;    ;  ;   ;        ;   ;  ;    ;  ;        ;         ;     ;   ;  ;    ;
 > ;    ;   ;  ;        ;   ;  ;   ;;  ;        ;         ;     ;   ;  ;   ;;
 > ;   ;;;   ;  ;;;;;  ;;; ;;;  ;;; ;;  ;;;;;  ;;;;;    ;;;;;  ;;; ;;;  ;;; ;
 > ;                                                                        ;
 > ;                                                                    ;;;;
 > ;
 > ;
 >
 > ;; Player Scene-> Scene
 > ;; Draws the world
 > (define (draw-player-info player scn)
 >  (define str
 >    (string-append PLAYER-DRAW-TEXT (number->string player)))
 >  (define txt
 >    (text str TEXT-SIZE TEXT-COLOR))
 >  (place-image txt (- WIDTH INFO-X-OFFSET) INFO-Y-OFFSET scn))
 >
 > ;; Board Scene -> Scene
 > ;; folds through the board and creates an image representation of it
 > (define (field->scene board scn)
 >  (define one (first board))
 >  (define img (overlay SELECT (draw-field one)))
 >  (define base
 >    (place-image img (field-x one) (field-y one) scn))
 >  (for/fold ([base base]) ([b (rest board)])
 >    (place-image (draw-field b) (field-x b) (field-y b) base)))
 >
 > ;; Position -> Image
 > ;; creates a single tile
 > (define (draw-field bh)
 >  (define die-image (get-die-img (field-dice bh)))
 >  (overlay
 >   (draw-fieldagon bh)
 >   (draw-dice (field-dice bh) (/ BSIZE 3) die-image)))
 >
 > ;; field -> Image
 > ;; takes a field and returns a fieldagon with the proper color
 > (define (draw-fieldagon bh)
 >  (rotate FIELD-ROTATION
 >          (regular-polygon BSIZE POLY-SIZE "solid"
 >                           (color-chooser (field-player bh)))))
 >
 > ;; Player -> Color
 > ;; Determines a color for each player
 > (define (color-chooser p)
 >  (list-ref COLORS p))
 >
 > ;; Number Number Image -> Image
 > ;; draws all of the dice except the first for a field onto acc
 > (define (draw-dice num offset acc)
 >  (for/fold ([scn acc])
 >    ([i (in-range (sub1 num))])
 >    (overlay/offset (get-die-img i) 0
 >                    (dice-offset offset i) scn)))
 >
 > ;; Number Number -> Number
 > ;; gets the offset for overlaying dice
 > (define (dice-offset initial-offset count)
 >  (+ initial-offset (* (/ BSIZE DICE-OFFSET) count)))
 >
 > ;; Number -> Image
 > ;; returns a random image of a dice
 > (define (get-die-img num)
 >  (list-ref IMG-LIST num))
 >
 > ;
 > ;
 > ;
 > ;
 > ;   ;;;;;;              ;;     ;
 > ;    ;   ;               ;
 > ;    ; ;    ;; ;;    ;;; ;   ;;;    ;; ;;    ;;; ;;
 > ;    ;;;     ;;  ;  ;   ;;     ;     ;;  ;  ;   ;;
 > ;    ; ;     ;   ;  ;    ;     ;     ;   ;  ;    ;
 > ;    ;       ;   ;  ;    ;     ;     ;   ;  ;    ;
 > ;    ;   ;   ;   ;  ;   ;;     ;     ;   ;  ;   ;;
 > ;   ;;;;;;  ;;; ;;;  ;;; ;;  ;;;;;  ;;; ;;;  ;;; ;
 > ;                                                ;
 > ;                                            ;;;;
 > ;
 > ;
 >
 > ;; [List-of field] -> String
 > ;; Which player has won the game.
 > ;; >(won (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)))
 > ;; "Player 1 Wins!"
 > ;; > (won (list (field 0 0 1 87 0) (field 1 0 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)))
 > ;; "Tie"
 > (define (won board)
 >  (define winner (winners board))
 >  (if (> (length winner) 2)
 >      "Tie"
 >      (string-append "Player "
 >                     (number->string (second winner))
 >                     " wins with "
 >                     (number->string (first winner))
 >                     " tiles!")))
 >
 > ;; FIXME: alittle confusing. ask about algo to do this...
 > ;; Board -> [or (list Player Number) #f]
 > ;; the winner of the game with there territory count or #f on tie
 > ;; > (winners (list (field 0 0 1 87 0) (field 0 0 1 87 1)))
 > ;; (list 2 0)
 > ;; > (winners (list (field 0 1 1 87 0) (field 0 0 1 87 1)))
 > ;; (list 1 0 1)
 > (define (winners board)
 >  (for/fold ([res empty])
 >    ([p (in-range PLAYER#)])
 >    (define count (sum-tile board p))
 >    (cond [(zero? p) (list count p)]
 >          [(> count (first res)) (list count p)]
 >          [(< count (first res)) res]
 >          [else (append res (list p))])))
 >
 > ;; Board Player -> Number
 > ;; counts the number of tiles the player owns
 > ;; > (sum-tile (list (field 0 1 1 87 0) (field 0 1 1 87 1)) 1)
 > ;; 2
 > (define (sum-tile board player)
 >  (for/fold ([res 0])
 >    ([bhx board])
 >    (if (= player (field-player bhx))
 >        (add1 res)
 >        res)))
 >
 > ;
 > ;
 > ;
 > ;
 > ;     ;;
 > ;      ;
 > ;     ; ;   ;;  ;;  ;;  ;;   ;;;;;
 > ;     ; ;    ;   ;   ;  ;   ;    ;
 > ;     ; ;    ;   ;    ;;     ;;;;
 > ;     ;;;    ;   ;    ;;         ;
 > ;    ;   ;   ;  ;;   ;  ;   ;    ;
 > ;   ;;; ;;;   ;; ;; ;;  ;;  ;;;;;
 > ;
 > ;
 > ;
 > ;
 >
 > ;; Board Number -> field
 > ;; gets a field by its id number
 > ;; Invariant: assumes field is in list.
 > ;; > (field-lookup (list (field 0 "a" 2 87 0) (field 5 "b" 1 87 0) ...) 5)
 > ;; (field 5 "b" 1 87 0)
 > (define (field-lookup board pos)
 >  (findf (lambda (b)
 >           (= (field-index b) pos)) board))
 >
 > ;; Number -> Number
 > ;; gets the row that field is on, indexed from 0
 > ;; [test vary on current board-size]
 > (define (get-row pos)
 >  (quotient pos BOARD-SIZE))
 >
 > ;
 > ;
 > ;
 > ;
 > ;
 > ;   ;;;;;;;                        ;
 > ;   ;  ;  ;                        ;
 > ;   ;  ;  ;     ;;;      ;;;; ;  ;;;;;;;     ;;;; ;
 > ;   ;  ;  ;    ;   ;    ;    ;;    ;        ;    ;;
 > ;      ;      ;     ;   ;          ;        ;
 > ;      ;      ;;;;;;;    ;;;;;     ;         ;;;;;
 > ;      ;      ;               ;    ;              ;
 > ;      ;       ;    ;   ;     ;    ;    ;   ;     ;
 > ;    ;;;;;      ;;;;    ;;;;;;      ;;;;    ;;;;;;
 > ;
 > ;
 > ;
 > ;
 >
 > (require rackunit rackunit/text-ui)
 >
 > ;; Test Macros & Functions
 > (define (distribute/list a b c)
 >  (define-values (x y) (distribute a b c))
 >  (list x y))
 >
 > ;; (-> any) -> void
 > ;; runs the thunk PROP-NUM times
 > (define (check-property t)
 >  (test-begin (for ((i 50)) (t))))
 >
 > ;; Properties
 > (define (property:starting-world-playable)
 >  (unless (and (= BOARD-SIZE 2) (= PLAYER# 2))
 >    (error 'starting-world-playable "BOARD-SIZE != 2 or PLAYERS# != 2"))
 >  (check-false (no-more-moves? (get-a-world))))
 >
 > (define (property:dice-in-range)
 >  (check-true (andmap (λ (b) (>= MAX-DICE (field-dice b) 1)) (field-build))
 >              "dice out of range"))
 >
 > (define (property:board-correct-size)
 >  (check-equal? (length (field-build)) GRID
 >                "board incorrect-size"))
 >
 > (define (property:no-pass-on-first-move)
 >  (define (move-action? m) (equal? (move-action m) '()))
 >  (check-true (not (memf move-action? (game-moves (game-tree (field-build) 0 0))))
 >              "no pass on first move"))
 >
 > (define (property:attack-location-valid)
 >  (define moves (game-moves (game-tree (field-build) 0 0)))
 >  (check-true (and (for/and ([m moves])
 >                     (define m1 (move-action m))
 >                     (member (second m1) (neighbors (first m1))))
 >                   #t)
 >              "invalid attack location"))
 >
 > (define (property:attack-dice-in-range)
 >  (define board (field-build))
 >  (define gt (game-tree board 0 0))
 >  (check-true (for/and ([m (game-moves gt)])
 >                (define m1 (move-action m))
 >                (> (field-dice (field-lookup board (first m1)))
 >                   (field-dice (field-lookup board (second m1)))))
 >              "dice count to low on attack"))
 >
 > (define (property:add-to-field-always-up-one)
 >  (define r (random 10000))
 >  (check-equal? (add-to-field (field 0 0 r 0 0))
 >                (field 0 0 (add1 r) 0 0)
 >                "add to field always up one"))
 >
 > ;; Test Suites
 > ;; ---------------------------------------------------------------------------------------------------
 > ; Test Values
 >
 > (define board0 (list (field 0 0 1 87 0) (field 1 1 2 174 0) (field 2 0 2 43.5 75) (field 3 1 1 130.5 75)))
 > (define board1 (list (field 0 0 1 87 0) (field 1 1 1 174 0) (field 2 0 1 43.5 75) (field 3 1 1 130.5 75)))
 > (define bard1+ (list (field 0 0 1 87 0) (field 1 1 2 174 0) (field 2 0 1 43.5 75) (field 3 1 2 130.5 75)))
 > (define board2 (list (field 0 0 1 87 0) (field 1 1 1 174 0) (field 2 0 3 43.5 75) (field 3 1 1 130.5 75)))
 >
 > (define gametree1 (game board1 0 '()))
 > (define gametree2 (game-tree board0 0 0))
 >
 > (define world1 (dice-world #f board1 gametree1))
 > (define world2 (dice-world #f board2 gametree2))
 >
 > (define-test-suite --initialization
 >  (check-equal? (field-index (first (field-build))) 0)
 >  (check-equal? (field-player (first (field-build))) 0)
 >  (check-equal? (field-index (second (field-build))) 1)
 >  (check-equal? (field-player (second (field-build))) 1)
 >  (check-equal? (field-index (third (field-build))) 2)
 >  (check-equal? (field-player (third (field-build))) 0)
 >  (check-equal? (field-index (fourth (field-build))) 3)
 >  (check-equal? (field-player (fourth (field-build))) 1)
 >
 >  (check-property property:starting-world-playable)
 >  (check-property property:board-correct-size)
 >  (check-property property:dice-in-range)
 >  (check-property property:no-pass-on-first-move))
 >
 > (define-test-suite --field-manipulation
 >  (check-equal? (get-x-offset 12)
 >                (/ X-OFFSET 2))
 >  (check-equal? (get-x-offset 8)
 >                (/ X-OFFSET 2))
 >  (check-equal? (get-x-offset 44)
 >                (/ X-OFFSET 2))
 >  (check-equal? (get-x-offset 9)
 >                (/ X-OFFSET 2))
 >  (check-equal? (get-x-offset 13)
 >                (/ X-OFFSET 2))
 >  (check-equal? (get-x-offset 90)
 >                0)
 >  (check-equal? (get-x-offset 3)
 >                0)
 >  (check-equal? (get-x-offset 7)
 >                0)
 >  (check-equal? (get-x-offset 6)
 >                0)
 >
 >  ;; field-lookup
 >  (check-equal? (field-lookup (list (field 0 0 2 87 0) (field 5 1 1 87 0)) 5) (field 5 1 1 87 0))
 >  (check-equal? (field-lookup board1 0) (field 0 0 1 87 0))
 >  (check-equal? (field-lookup board1 3) (field 3 1 1 130.5 75))
 >
 >  ;; legal?
 >  (check-true
 >   (cons? (attackable? (list (field 0 0 2 87 0) (field 3 1 1 87 0)) 0 (field 0 0 2 87 0) 3)))
 >  (check-false
 >   (attackable? (list (field 0 0 2 87 0) (field 1 0 1 87 0) (field 3 1 1 87 0)) 0 (field 0 0 2 87 0) 1))
 >  (check-false
 >   (attackable? (list (field 0 0 2 87 0) (field 3 1 1 87 0)) 0 (field 0 0 2 87 0) 0))
 >  (check-false
 >   (attackable? (list (field 0 0 2 87 0) (field 5 1 1 87 0)) 1 (field 0 0 2 87 0) 5))
 >  (check-exn
 >   exn:fail? (λ () (attackable? '() 0 (field 0 0 1 97 0) 2)))
 >
 >  ;; get-row
 >  (check-equal? (get-row 0) 0)
 >  (check-equal? (get-row 1) 0)
 >  (check-equal? (get-row 2) 1)
 >  (check-equal? (get-row 3) 1)
 >  (check-equal? (get-row 12) 6) ;; checks math. actually invalid on board of size 2
 >  (check-equal? (get-row 11) 5) ;; checks math. actually invalid on board of size 2
 >  (check-equal? (get-row 13) 6) ;; checks math. actually invalid on board of size 2
 >  (check-equal? (get-row 14) 7)) ;; checks math. actually invalid on board of size 2
 >
 > (define board3
 >  (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 3 43.5 75) (field 3 1 1 130.5 75)))
 >
 > (define-test-suite --tree-generation
 >  ;; game-tree
 >  (check-equal? (game-tree board1 0 0) gametree1)
 >  (check-equal? (game-tree board3 1 0) (game board3 1 '()))
 >  (check-equal? (game-tree board3 0 0) (game board3 0 '()))
 >
 >  ;; find-move
 >  (check-false (find-move '() '()))
 >  (check-equal? (find-move (list (move '() (game '() 0 '()))) '())
 >                (game '() 0 '()))
 >  ;; Attacking-Moves
 >  (check-property property:attack-location-valid)
 >  (check-property property:attack-dice-in-range)
 >
 >  ;; switch-players
 >  (check-equal? (switch 0) 1)
 >  (check-equal? (switch 1) 0)
 >
 >  ;; Add-New-Dice
 >  (check-equal?
 >   (distribute/list (game-board gametree1) 0 3)
 >   (list 1
 >         (reverse (list (field 0 0 2 87 0)
 >                  (field 1 1 1 174 0)
 >                  (field 2 0 2 43.5 75)
 >                  (field 3 1 1 130.5 75)))))
 >  (check-equal?
 >   (distribute/list (game-board gametree1) 1 2)
 >   (list 0 (reverse bard1+)))
 >  (check-equal?
 >   (distribute/list (game-board gametree2) 1 2)
 >   (list 0
 >   (reverse (list (field 0 0 1 87 0)
 >                  (field 1 1 3 174 0)
 >                  (field 2 0 2 43.5 75)
 >                  (field 3 1 2 130.5 75)))))
 >  (check-equal?
 >   (distribute/list (list (field 0 0 1 87 0)
 >                     (field 1 1 2 174 0)
 >                     (field 2 0 3 43.5 75)
 >                     (field 3 1 2 130.5 75)) 0 0)
 >   (list 0
 >   (reverse (list (field 0 0 1 87 0)
 >                  (field 1 1 2 174 0)
 >                  (field 2 0 3 43.5 75)
 >                  (field 3 1 2 130.5 75)))))
 >
 >  ;; add-to-field
 >  (check-equal? (add-to-field (field 0 1 2 87 0))
 >                (field 0 1 3 87 0))
 >  (check-equal? (add-to-field (field 0 1 1 87 0))
 >                (field 0 1 2 87 0))
 >  (check-equal? (add-to-field (field 0 1 5 87 0))
 >                (field 0 1 6 87 0))
 >  (check-property property:add-to-field-always-up-one))
 >
 > (define-test-suite --attacking
 >  ;; board-attack
 >  (check-equal? (attack (list (field 0 0 1 87 0)
 >                              (field 1 1 1 174 0)
 >                              (field 2 0 2 43.5 75)
 >                              (field 3 1 1 130.5 75)) 0 2 1 2)
 >                (list (field 0 0 1 87 0)
 >                      (field 1 0 1 174 0)
 >                      (field 2 0 1 43.5 75)
 >                      (field 3 1 1 130.5 75)))
 >  (check-equal? (attack (list (field 0 1 1 87 0)
 >                              (field 1 1 1 174 0)
 >                              (field 2 0 3 43.5 75)
 >                              (field 3 1 1 130.5 75)) 0 2 1 3)
 >                (list (field 0 1 1 87 0)
 >                      (field 1 0 2 174 0)
 >                      (field 2 0 1 43.5 75)
 >                      (field 3 1 1 130.5 75)))
 >  (check-equal? (attack (list (field 0 0 1 87 0)
 >                              (field 1 1 1 174 0)
 >                              (field 2 0 2 43.5 75)
 >                              (field 3 0 1 130.5 75)) 0 2 1 2)
 >                (list (field 0 0 1 87 0)
 >                      (field 1 0 1 174 0)
 >                      (field 2 0 1 43.5 75)
 >                      (field 3 0 1 130.5 75)))
 >
 >  (check-equal? (attack (list (field 0 0 1 87 0)
 >                              (field 1 1 3 174 0)
 >                              (field 2 0 2 43.5 75)
 >                              (field 3 1 1 130.5 75)) 1 1 0 3)
 >                (list(field 0 1 2 87 0)
 >                     (field 1 1 1 174 0)
 >                     (field 2 0 2 43.5 75)
 >                     (field 3 1 1 130.5 75)))
 >
 >  ;; Neighbors
 >  (check-equal? (neighbors 2) '(0 3))
 >  (check-equal? (neighbors 0) '(3 2 1))
 >  (check-equal? (neighbors 1) '(3 0))
 >  (check-equal? (neighbors 3) '(1 0 2)))
 >
 > (define-test-suite --tile-selection
 >  ;; interact-with-board
 >  (check-equal? (interact-with-board world2 "\r") (dice-world (field-index (car (dice-world-board world2))) (dice-world-board world2) gametree2))
 >  (check-equal? (interact-with-board world2 "p") world2)
 >
 >  ;; select-tile-action
 >  (check-equal? (select-tile-action (dice-world #f (list (field 0 0 1 87 0) (field 0 0 1 87 2)) gametree1) "left")
 >                (dice-world #f (list (field 0 0 1 87 2) (field 0 0 1 87 0)) gametree1))
 >  (check-equal? (select-tile-action (dice-world #f (list (field 0 0 1 87 2) (field 0 1 1 87 0)) gametree1) "right")
 >                (dice-world #f (list (field 0 0 1 87 2) (field 0 1 1 87 0)) gametree1))
 >  (check-equal? (select-tile-action (dice-world 0
 >                                                (list (field 0 0 1 87 2)
 >                                                      (field 1 0 1 87 0)
 >                                                      (field 2 2 1 87 0)) gametree1)
 >                                    "left")
 >                (dice-world 0 (list (field 2 2 1 87 0)
 >                                    (field 0 0 1 87 2)
 >                                    (field 1 0 1 87 0)) gametree1))
 >
 >  (check-equal? (select-tile-action (dice-world 0 (list (field 0 0 1 87 2) (field 0 1 1 87 0)) gametree1) "left")
 >                (dice-world 0 (list  (field 0 1 1 87 0) (field 0 0 1 87 2)) gametree1))
 >  (check-equal? (select-tile-action (dice-world 0 (list(field 0 0 1 87 2) (field 0 1 1 87 0)) gametree1) "right")
 >                (dice-world 0 (list  (field 0 1 1 87 0) (field 0 0 1 87 2)) gametree1))
 >
 >  ;;unmark
 >  (check-equal? (unmark (dice-world 1 (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)) gametree1))
 >                (dice-world #f (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)) gametree1))
 >  (check-equal? (unmark (dice-world 1 (list (field 0 1 1 87 0) (field 1 1 1 174 0)) gametree1))
 >                (dice-world #f (list (field 0 1 1 87 0) (field 1 1 1 174 0)) gametree1))
 >  (check-equal? (unmark (dice-world 0 (list (field 0 1 1 87 0)) gametree1))
 >                (dice-world #f (list (field 0 1 1 87 0)) gametree1))
 >  (check-equal? (unmark (dice-world #f (list (field 0 1 1 87 0)) gametree1))
 >                (dice-world #f (list (field 0 1 1 87 0)) gametree1)))
 >
 > (define-test-suite --winnning-the-game
 >  ;; won
 >  (check-equal? (won (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)))
 >                "Player 1 wins with 4 tiles!")
 >  (check-equal? (won (list (field 0 0 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)))
 >                "Player 1 wins with 3 tiles!")
 >  (check-equal? (won (list (field 0 1 1 87 0) (field 1 1 1 174 0) (field 2 1 1 43.5 75) (field 3 0 1 130.5 75)))
 >                "Player 1 wins with 3 tiles!")
 >  (check-equal? (won (list (field 0 0 1 87 0) (field 1 0 1 174 0) (field 2 1 1 43.5 75) (field 3 1 1 130.5 75)))
 >                "Tie")
 >
 >  ;; winners
 >  (check-equal? (winners (list (field 0 0 1 87 0) (field 0 0 1 87 1)))
 >                (list 2 0))
 >  (check-equal? (winners (list (field 0 1 1 87 0) (field 0 0 1 87 1)))
 >                (list 1 0 1))
 >  (check-equal? (winners (list (field 0 1 1 87 0) (field 0 0 1 87 1) (field 0 1 1 87 0) (field 0 0 1 87 1)))
 >                (list 2 0 1))
 >  (check-equal? (winners (list (field 0 1 1 87 0) (field 0 0 1 87 1) (field 0 0 1 87 1)))
 >                (list 2 0))
 >
 >  ;; sum-tile
 >  (check-equal? (sum-tile (list (field 0 0 1 87 0) (field 0 0 1 87 1)) 0)
 >                2)
 >  (check-equal? (sum-tile (list (field 0 0 1 87 0) (field 0 0 1 87 1)) 1)
 >                0)
 >  (check-equal? (sum-tile (list (field 0 0 1 87 0) (field 0 0 1 87 1)) 2)
 >                0)
 >  (check-equal? (sum-tile (list (field 0 1 1 87 0) (field 0 0 1 87 1)) 1)
 >                1)
 >  (check-equal? (sum-tile (list (field 0 1 1 87 0) (field 0 0 1 87 1)) 0)
 >                1)
 >  (check-equal? (sum-tile (list (field 0 1 1 87 0) (field 0 0 1 87 1) (field 0 0 1 87 1)) 0)
 >                2)
 >  (check-equal? (sum-tile (list (field 0 1 1 87 0) (field 0 0 1 87 1) (field 0 0 1 87 1)) 1)
 >                1)
 >
 >
 >  ;; dice-offset
 >  (check-equal? (dice-offset 5 3) 85/2)
 >  (check-equal? (dice-offset 9 2) 34)
 >  (check-equal? (dice-offset 1 0) 1))
 >
 > (define-test-suite --rendering
 >  ;; draw-dice
 >  (check-equal? (draw-dice 1 0 (draw-fieldagon (field 0 0 0 0 0))) (draw-fieldagon (field 0 0 0 0 0)))
 >  (check-equal? (draw-dice 2 0 (draw-fieldagon (field 0 0 0 0 0)))
 >                (overlay(first IMG-LIST)(draw-fieldagon (field 0 0 0 0 0))))
 >
 >  (check-equal? (draw-dice 3 0 (draw-fieldagon (field 0 0 0 0 0)))
 >                (overlay/offset
 >                 (second IMG-LIST)
 >                 0
 >                 12.5
 >                 (overlay(first IMG-LIST)(draw-fieldagon (field 0 0 0 0 0)))))
 >
 >  ;; draw-field
 >  (check-equal? (draw-field (field 0 0 1 0 0))
 >                (overlay
 >                 (rotate 30 (regular-polygon BSIZE 6 "solid"
 >                                             (first COLORS)))
 >                 (second IMG-LIST)))
 >  )
 >
 > (run-tests --initialization)
 > (run-tests --rendering)
 > (run-tests --tile-selection)
 > (run-tests --field-manipulation)
 > (run-tests --attacking)
 > (run-tests --winnning-the-game)
 > (run-tests --tree-generation)
 >
 > *** Environment:
 > macosx "Darwin africa.westell.com 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7 16:33:36 PDT 2011; root:xnu-1504.15.3~1/RELEASE_I386 i386" (x86_64-macosx/3m) (get-display-depth) = 32
 > Human Language: english
 > (current-memory-use) 656759072
 > Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()
 >
 >
 > Collections:
 > ("/Users/matthias/0Unison/collects/"
 >  ("._.DS_Store" ".DS_Store" "compiled" "date" "finance" "info-domain" "info.ss" "pdf.ss~" "session" "short" "testing" "tll-collects" "utils" "web"))
 > ("/Users/matthias/Library/Racket/5.2.0.3/collects"
 >  (non-existent-path))
 > ("/Users/matthias/plt/collects"
 >  (".gitignore" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compiler" "config" "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "games" "graphics" "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" "hierlist" "honu" "htdp" "html" "icons" "info-domain" "lang" "launcher" "lazy" "macro-debugger" "make" "meta" "mred" "mrlib" "mysterx" "mz" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raclog" "raco" "racunit" "reader" "readline" "redex" "repo-time-stamp" "repos-time-stamp" "rnrs" "s-exp" "schelog" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" "string-constants" "swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engine"!
 >  "tests" "tex2page" "texpict" "tool" "trace" "typed" "typed-racket" "typed-scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml" "xrepl"))
 >
 > Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug/profile) (default) #() "#lang racket\n" #f #t))
 >
 >
 
From: Neil Toronto <neil.toronto@gmail.com>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: matthias@ccs.neu.edu, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12386: drracket diverges when 'view | split'
Date: Sat, 19 Nov 2011 21:06:58 -0700

 I just tested it, and my commit does fix it.
 
 Neil T
 
 On 11/19/2011 08:58 PM, Robby Findler wrote:
 > I think that Neil T's commit may have fixed this and I see your
 > version is older than that.
 >
 > Robby
 >
 > On Sat, Nov 19, 2011 at 6:32 PM,<matthias@ccs.neu.edu>  wrote:
 >> A new problem report is waiting at
 >>   http://bugs.racket-lang.org/query/?cmd=view&pr=12386
 >>
 >> Reported by matthias for release: 5.2.0.3--2011-11-16(8483b8e/g)
 >>
 >> *** Description:
 >> It happens on the below file, repeatedly.
 >> Start drracket. Split view. Consumes 100%
 >> cpu no response.
 >>
 >> *** How to repeat:
 >> *snip*

State changed from "open" to "closed" by samth at Sun, 20 Nov 2011 09:17:58 -0500
Reason>>> fixed


Responsible changed from "nobody" to "samth" by eli at Mon, 18 Feb 2013 23:27:14 -0500
Reason>>> samth closed

