From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Wed Nov 28 19:11:30 2012
Received: from mail-ia0-f172.google.com (mail-ia0-f172.google.com [209.85.210.172])
	by champlain.ccs.neu.edu (8.14.4/8.14.4) with ESMTP id qAT0BQj6026287
	for <bugs@bugs.plt-scheme.org>; Wed, 28 Nov 2012 19:11:26 -0500
Message-Id: <201211290011.qAT0BOkW026280@champlain.ccs.neu.edu>
Date: Wed, 28 Nov 2012 19:11:24 -0500
From: mulhern@cs.wisc.edu
To: bugs@racket-lang.org
Subject: Internal racket error while debugging

>Number:         13321
>Category:       all
>Synopsis:       Internal racket error while debugging
>Class:          sw-bug
>Responsible:    nobody
>Severity:       serious
>Priority:       medium
>State:          open
>Confidential:   no
>Arrival-Date:   Wed Nov 28 19:12:01 -0500 2012
>Last-Modified:  Fri Nov 30 20:52:01 -0500 2012
>Originator:     mulhern
>Organization:
plt
>Submitter-Id:   unknown
>Release:        5.3.1
>Environment:
macosx "Darwin mulhern-lowell.local 11.4.2 Darwin Kernel Version 11.4.2: Thu Aug 23 16:25:48 PDT 2012; root:xnu-1699.32.7~1/RELEASE_X86_64 x86_64 i386" (i386-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 189359852
Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()


Collections:
("/Users/mulhern/Library/Racket/5.3.1/collects"
 (non-existent-path))
("/Applications/Racket v5.3.1/collects"
 ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config" "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist" "htdp" "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" "macro-debugger" "make" "mred" "mrlib" "mysterx" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raco" "reader" "readline" "redex" "rnrs" "s-exp" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax" "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed" "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme" "xml" "xrepl"))

Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t #t ((main) (test))))
>Description:
Stack trace looks like this:

meth: contract violation
 expected: (and/c real? (not/c negative?))
 given: -12.0
 which isn't: (not/c negative?)
 in: the 3rd argument of
      (->m
       real?
       real?
       (and/c real? (not/c negative?))
       (and/c real? (not/c negative?))
       void?)
 contract from: (class dc%)
 blaming: 
      <collects>/mred/private/wx/cocoa/canvas.rkt
  context...:
   /Applications/Racket v5.3.1/collects/racket/contract/private/blame.rkt:89:0: raise-blame-error
   /Applications/Racket v5.3.1/collects/racket/contract/private/prop.rkt:221:10
   /Applications/Racket v5.3.1/collects/gui-debugger/debug-tool.rkt:485:8: on-paint method in ...ugger/debug-tool.rkt:174:6
   /Applications/Racket v5.3.1/collects/mred/private/wxme/text.rkt:5230:18: paint-done
   /Applications/Racket v5.3.1/collects/mred/private/wxme/text.rkt:5051:2: refresh method in text%
   /Applications/Racket v5.3.1/collects/mred/private/wxme/editor-canvas.rkt:609:2: redraw method in editor-canvas%
   /Applications/Racket v5.3.1/collects/gui-debugger/debug-tool.rkt:1503:8: on-tab-change method in ...ugger/debug-tool.rkt:1139:6
   /Applications/Racket v5.3.1/collects/drracket/private/syncheck/gui.rkt:1502:8: on-tab-change method in ...ate/syncheck/gui.rkt:1494:6
   /Applications/Racket v5.3.1/collects/drracket/private/module-language-tools.rkt:77:6: on-tab-change method in ...e-language-tools.rkt:55:4
   /Applications/Racket v5.3.1/collects/drracket/private/tracing.rkt:169:6: on-tab-change method in .../private/tracing.rkt:164:4
   /Applications/Racket v5.3.1/collects/drracket/private/debug.rkt:1708:6: on-tab-change method in ...et/private/debug.rkt:1630:4
   /Applications/Racket v5.3.1/collects/drracket/private/unit.rkt:2916:6: change-to-tab method in ...ket/private/unit.rkt:1355:4
   /Applications/Racket v5.3.1/collects/framework/private/handler.rkt:93:5
   /Applications/Racket v5.3.1/collects/mred/private/wx/common/queue.rkt:445:6
   /Applications/Racket v5.3.1/collects/mred/private/wx/common/queue.rkt:485:32
   /Applications/Racket v5.3.1/collects/mred/private/wx/common/queue.rkt:633:3
>How-To-Repeat:
Load the file below into Dr. Racket and hit the Debug button.

#lang plai

(define-type FWAE
  [bool (v boolean?)]
  [num (n number?)]
  [eqn (lhs FWAE?) (rhs FWAE?)]
  [add (lhs FWAE?) (rhs FWAE?)]
  [sub (lhs FWAE?) (rhs FWAE?)]
  [with (name symbol?) (named-expr FWAE?) (body FWAE?)]
  [id (name symbol?)]
  [ifb (c FWAE?) (l FWAE?) (r FWAE?)]
  [fun (param symbol?) (body FWAE?)]
  [app (fun-expr FWAE?) (arg-expr FWAE?)])

(define parse-binop
  (lambda (an-sexp)
    (if (not (= (length an-sexp) 3))
        (error 'parse-binop "Binary operator must have exactly two arguments.")
        (let ([build-binop
               (lambda (op)
                 (op (parse (second an-sexp))
                     (parse (third an-sexp))))])
          (case (first an-sexp)
            [(+) (build-binop add)]
            [(=) (build-binop eqn)]
            [(-) (build-binop sub)]
            [else (error 'parse-binop "Unexpected operator.")])))))

(define parse-with
  (lambda (an-sexp)
    (if (not (= (length an-sexp) 3))
        (error 'parse-with "With-expression must have exactly two arguments.")
        (let ([binding (second an-sexp)])
          (let ([binding-instance (first binding)])
            (if (symbol? binding-instance)
                (with
                 binding-instance
                 (parse (second binding))
                 (parse (third an-sexp)))
                (error 'parse-with "Element in identifier position not a symbol.")))))))

(define parse-fun
  (lambda (an-sexp)
    (if
     (and
      (= (length an-sexp) 3)
      (symbol? (first (second an-sexp))))
     (fun
      (first (second an-sexp))
      (parse (third an-sexp)))
     (error 'parse "Error parsing fun."))))

(define parse-app
  (lambda (an-sexp)
    (if (= (length an-sexp) 2)
        (app (parse (first an-sexp))
             (parse (second an-sexp)))
        (error 'parse "Error parsing application."))))

(define parse-if
  (lambda (an-sexp)
    (if (= (length an-sexp) 4)
        (ifb
         (parse (second an-sexp))
         (parse (third an-sexp))
         (parse (fourth an-sexp)))
        (error 'parse "Error parsing if."))))


(define parse-list
  (lambda (an-sexp)
    (if (empty? an-sexp)
        (error 'parse-list "Can't parse an empty list.")
        (case (first an-sexp)
          [(+ =) (parse-binop an-sexp)]
          [(with) (parse-with an-sexp)]
          [(fun) (parse-fun an-sexp)]
          [(if) (parse-if an-sexp)]
          [else (parse-app an-sexp)]))))

(define parse
  (lambda (an-sexp)
    (cond
      [(number? an-sexp) (num an-sexp)]
      [(symbol? an-sexp) (id an-sexp)]
      [(boolean? an-sexp) (bool an-sexp)]
      [(list? an-sexp) (parse-list an-sexp)]
      [else (error 'parse "Unexpected element.")])))

(define (subst expr sub-id val)
  (type-case FWAE expr
    [num (n) expr]
    [bool (v) expr]
    [add (l r) (add (subst l sub-id val)
                    (subst r sub-id val))]
    [sub (l r) (sub (subst l sub-id val)
                    (subst r sub-id val))]
    [eqn (l r) (eqn (subst l sub-id val)
                    (subst l sub-id val))]
    [with (bound-id named-expr bound-body)
          (with
           bound-id
           (subst named-expr sub-id val)
           (if (symbol=? bound-id sub-id)
               bound-body
               (subst bound-body sub-id val)))]
    [ifb (c l r)
         (ifb
          (subst c sub-id val)
          (subst l sub-id val)
          (subst r sub-id val))]
    [id (v)
        (if (symbol=? v sub-id)
            val
            expr)]
    [fun (x body)
         (fun
          x
          (if (symbol=? sub-id x)
              body
              (subst body sub-id val)))]
    [app (l r)
         (app
          (subst l sub-id val)
          (subst r sub-id val))]))

(define arith-numbers
  (lambda (op l r)
    (if
     (and (num? l) (num? r))
     (num (op (num-n l) (num-n r)))
     (error
      'add-numbers
      "Left or right side of addition expression is not a number."))))

(define check-equal
  (lambda (l r)
    (if 
     (and (num? l) (num? r))
     (if (= (num-n l) (num-n r))
         (bool #t)
         (bool #f))
     (error
      'interp
      "Left or right side of equals expression is not a number."))))

(define (interp expr)
  (type-case FWAE expr
    [num (n) expr]
    [bool (v) expr]
    [add (l r) (arith-numbers + (interp l) (interp r))]
    [sub (l r) (arith-numbers - (interp l) (interp r))]
    [eqn (l r) (check-equal (interp l) (interp r))]
    [ifb (c l r)
         (let ([res (interp c)])
           (if (bool? res)
               (if (false? (bool-v res))
                   (interp r)
                   (interp l))
               (error 'interp "If-condition not a boolean.")))]
    [with (bound-id named-expr bound-body)
          (interp (subst bound-body
                         bound-id
                         (interp named-expr)))]
    [id (v) (error 'interp "free identifier")]
    [fun (bound-id bound-body)
         expr]
    [app (fun-expr arg-expr)
         (let ([fun-val (interp fun-expr)])
           (if (fun? fun-val)
               (interp
                (subst
                 (fun-body fun-val)
                 (fun-param fun-val)
                 (interp arg-expr)))
               (error
                'interp
                "Left side of application is not a function.")))]))

(interp (parse
         '{with {factorial
                 {fun {n}
                      {if {= n 0}
                          1
                          {+ {factorial {- n 1}}}}}}
                {factorial 0}}))
>Fix:
>Audit-Trail:
From: Robby Findler <robby@eecs.northwestern.edu>
To: "mulhern@cs.wisc.edu" <mulhern@cs.wisc.edu>,
        "bugs@racket-lang.org" <bugs@racket-lang.org>
Cc: "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13321: Internal racket error while debugging
Date: Fri, 30 Nov 2012 18:33:09 -0600

 --e89a8fb1ff161d49c104cfbfa9ee
 Content-Type: text/plain; charset=UTF-8
 
 I don't see this and, unfortunately, there was bug in the contract system
 (since fixed, right Asumu? Or should I be asking someone else?) that puts
 "meth" into the error message instead of the name of the message, so this
 is hard to track down.
 
 Looking at the code, i guess this is the draw-ellipse call, but I don't see
 how it could get negative arguments unless something else is wrong
 elsewhere.
 
 So I guess I'll need more help to reproduce this.
 
 Does it happen every time mulhern?
 
 Robby
 
 On Wednesday, November 28, 2012, wrote:
 
 > A new problem report is waiting at
 >   http://bugs.racket-lang.org/query/?cmd=view&pr=13321
 >
 > Reported by mulhern for release: 5.3.1
 >
 > *** Description:
 > Stack trace looks like this:
 >
 > meth: contract violation
 >  expected: (and/c real? (not/c negative?))
 >  given: -12.0
 >  which isn't: (not/c negative?)
 >  in: the 3rd argument of
 >       (->m
 >        real?
 >        real?
 >        (and/c real? (not/c negative?))
 >        (and/c real? (not/c negative?))
 >        void?)
 >  contract from: (class dc%)
 >  blaming:
 >       <collects>/mred/private/wx/cocoa/canvas.rkt
 >   context...:
 >    /Applications/Racket
 > v5.3.1/collects/racket/contract/private/blame.rkt:89:0: raise-blame-error
 >    /Applications/Racket
 > v5.3.1/collects/racket/contract/private/prop.rkt:221:10
 >    /Applications/Racket v5.3.1/collects/gui-debugger/debug-tool.rkt:485:8:
 > on-paint method in ...ugger/debug-tool.rkt:174:6
 >    /Applications/Racket
 > v5.3.1/collects/mred/private/wxme/text.rkt:5230:18: paint-done
 >    /Applications/Racket v5.3.1/collects/mred/private/wxme/text.rkt:5051:2:
 > refresh method in text%
 >    /Applications/Racket
 > v5.3.1/collects/mred/private/wxme/editor-canvas.rkt:609:2: redraw method in
 > editor-canvas%
 >    /Applications/Racket
 > v5.3.1/collects/gui-debugger/debug-tool.rkt:1503:8: on-tab-change method in
 > ...ugger/debug-tool.rkt:1139:6
 >    /Applications/Racket
 > v5.3.1/collects/drracket/private/syncheck/gui.rkt:1502:8: on-tab-change
 > method in ...ate/syncheck/gui.rkt:1494:6
 >    /Applications/Racket
 > v5.3.1/collects/drracket/private/module-language-tools.rkt:77:6:
 > on-tab-change method in ...e-language-tools.rkt:55:4
 >    /Applications/Racket
 > v5.3.1/collects/drracket/private/tracing.rkt:169:6: on-tab-change method in
 > .../private/tracing.rkt:164:4
 >    /Applications/Racket v5.3.1/collects/drracket/private/debug.rkt:1708:6:
 > on-tab-change method in ...et/private/debug.rkt:1630:4
 >    /Applications/Racket v5.3.1/collects/drracket/private/unit.rkt:2916:6:
 > change-to-tab method in ...ket/private/unit.rkt:1355:4
 >    /Applications/Racket v5.3.1/collects/framework/private/handler.rkt:93:5
 >    /Applications/Racket
 > v5.3.1/collects/mred/private/wx/common/queue.rkt:445:6
 >    /Applications/Racket
 > v5.3.1/collects/mred/private/wx/common/queue.rkt:485:32
 >    /Applications/Racket
 > v5.3.1/collects/mred/private/wx/common/queue.rkt:633:3
 >
 > *** How to repeat:
 > Load the file below into Dr. Racket and hit the Debug button.
 >
 > #lang plai
 >
 > (define-type FWAE
 >   [bool (v boolean?)]
 >   [num (n number?)]
 >   [eqn (lhs FWAE?) (rhs FWAE?)]
 >   [add (lhs FWAE?) (rhs FWAE?)]
 >   [sub (lhs FWAE?) (rhs FWAE?)]
 >   [with (name symbol?) (named-expr FWAE?) (body FWAE?)]
 >   [id (name symbol?)]
 >   [ifb (c FWAE?) (l FWAE?) (r FWAE?)]
 >   [fun (param symbol?) (body FWAE?)]
 >   [app (fun-expr FWAE?) (arg-expr FWAE?)])
 >
 > (define parse-binop
 >   (lambda (an-sexp)
 >     (if (not (= (length an-sexp) 3))
 >         (error 'parse-binop "Binary operator must have exactly two
 > arguments.")
 >         (let ([build-binop
 >                (lambda (op)
 >                  (op (parse (second an-sexp))
 >                      (parse (third an-sexp))))])
 >           (case (first an-sexp)
 >             [(+) (build-binop add)]
 >             [(=) (build-binop eqn)]
 >             [(-) (build-binop sub)]
 >             [else (error 'parse-binop "Unexpected operator.")])))))
 >
 > (define parse-with
 >   (lambda (an-sexp)
 >     (if (not (= (length an-sexp) 3))
 >         (error 'parse-with "With-expression must have exactly two
 > arguments.")
 >         (let ([binding (second an-sexp)])
 >           (let ([binding-instance (first binding)])
 >             (if (symbol? binding-instance)
 >                 (with
 >                  binding-instance
 >                  (parse (second binding))
 >                  (parse (third an-sexp)))
 >                 (error 'parse-with "Element in identifier position not a
 > symbol.")))))))
 >
 > (define parse-fun
 >   (lambda (an-sexp)
 >     (if
 >      (and
 >       (= (length an-sexp) 3)
 >       (symbol? (first (second an-sexp))))
 >      (fun
 >       (first (second an-sexp))
 >       (parse (third an-sexp)))
 >      (error 'parse "Error parsing fun."))))
 >
 > (define parse-app
 >   (lambda (an-sexp)
 >     (if (= (length an-sexp) 2)
 >         (app (parse (first an-sexp))
 >              (parse (second an-sexp)))
 >         (error 'parse "Error parsing application."))))
 >
 > (define parse-if
 >   (lambda (an-sexp)
 >     (if (= (length an-sexp) 4)
 >         (ifb
 >          (parse (second an-sexp))
 >          (parse (third an-sexp))
 >          (parse (fourth an-sexp)))
 >         (error 'parse "Error parsing if."))))
 >
 >
 > (define parse-list
 >   (lambda (an-sexp)
 >     (if (empty? an-sexp)
 >         (error 'parse-list "Can't parse an empty list.")
 >         (case (first an-sexp)
 >           [(+ =) (parse-binop an-sexp)]
 >           [(with) (parse-with an-sexp)]
 >           [(fun) (parse-fun an-sexp)]
 >           [(if) (parse-if an-sexp)]
 >           [else (parse-app an-sexp)]))))
 >
 > (define parse
 >   (lambda (an-sexp)
 >     (cond
 >       [(number? an-sexp) (num an-sexp)]
 >       [(symbol? an-sexp) (id an-sexp)]
 >       [(boolean? an-sexp) (bool an-sexp)]
 >       [(list? an-sexp) (parse-list an-sexp)]
 >       [else (error 'parse "Unexpected element.")])))
 >
 > (define (subst expr sub-id val)
 >   (type-case FWAE expr
 >     [num (n) expr]
 >     [bool (v) expr]
 >     [add (l r) (add (subst l sub-id val)
 >                     (subst r sub-id val))]
 >     [sub (l r) (sub (subst l sub-id val)
 >                     (subst r sub-id val))]
 >     [eqn (l r) (eqn (subst l sub-id val)
 >                     (subst l sub-id val))]
 >     [with (bound-id named-expr bound-body)
 >           (with
 >            bound-id
 >            (subst named-expr sub-id val)
 >            (if (symbol=? bound-id sub-id)
 >                bound-body
 >                (subst bound-body sub-id val)))]
 >     [ifb (c l r)
 >          (ifb
 >           (subst c sub-id val)
 >           (subst l sub-id val)
 >           (subst r sub-id val))]
 >     [id (v)
 >         (if (symbol=? v sub-id)
 >             val
 >             expr)]
 >     [fun (x body)
 >          (fun
 >           x
 >           (if (symbol=? sub-id x)
 >               body
 >               (subst body sub-id val)))]
 >     [app (l r)
 >          (app
 >           (subst l sub-id val)
 >           (subst r sub-id val))]))
 >
 > (define arith-numbers
 >   (lambda (op l r)
 >     (if
 >      (and (num? l) (num? r))
 >      (num (op (num-n l) (num-n r)))
 >      (error
 >       'add-numbers
 >       "Left or right side of addition expression is not a number."))))
 >
 > (define check-equal
 >   (lambda (l r)
 >     (if
 >      (and (num? l) (num? r))
 >      (if (= (num-n l) (num-n r))
 >          (bool #t)
 >          (bool #f))
 >      (error
 >       'interp
 >       "Left or right side of equals expression is not a number."))))
 >
 > (define (interp expr)
 >   (type-case FWAE expr
 >     [num (n) expr]
 >     [bool (v) expr]
 >     [add (l r) (arith-numbers + (interp l) (interp r))]
 >     [sub (l r) (arith-numbers - (interp l) (interp r))]
 >     [eqn (l r) (check-equal (interp l) (interp r))]
 >     [ifb (c l r)
 >          (let ([res (interp c)])
 >            (if (bool? res)
 >                (if (false? (bool-v res))
 >                    (interp r)
 >                    (interp l))
 >                (error 'interp "If-condition not a boolean.")))]
 >     [with (bound-id named-expr bound-body)
 >           (interp (subst bound-body
 >                          bound-id
 >                          (interp named-expr)))]
 >     [id (v) (error 'interp "free identifier")]
 >     [fun (bound-id bound-body)
 >          expr]
 >     [app (fun-expr arg-expr)
 >          (let ([fun-val (interp fun-expr)])
 >            (if (fun? fun-val)
 >                (interp
 >                 (subst
 >                  (fun-body fun-val)
 >                  (fun-param fun-val)
 >                  (interp arg-expr)))
 >                (error
 >                 'interp
 >                 "Left side of application is not a function.")))]))
 >
 > (interp (parse
 >          '{with {factorial
 >                  {fun {n}
 >                       {if {= n 0}
 >                           1
 >                           {+ {factorial {- n 1}}}}}}
 >                 {factorial 0}}))
 >
 > *** Environment:
 > macosx "Darwin mulhern-lowell.local 11.4.2 Darwin Kernel Version 11.4.2:
 > Thu Aug 23 16:25:48 PDT 2012; root:xnu-1699.32.7~1/RELEASE_X86_64 x86_64
 > i386" (i386-macosx/3m) (get-display-depth) = 32
 > Human Language: english
 > (current-memory-use) 189359852
 > Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = ();
 > (links #:user? #f #:root? #t) = ()
 >
 >
 > Collections:
 > ("/Users/mulhern/Library/Racket/5.3.1/collects"
 >  (non-existent-path))
 > ("/Applications/Racket v5.3.1/collects"
 >  ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config"
 > "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme"
 > "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework"
 > "frtime" "future-visualizer" "games" "graphics" "gui-debugger" "help"
 > "hierlist" "htdp" "html" "icons" "images" "info-domain" "json" "lang"
 > "launcher" "lazy" "macro-debugger" "make" "mred" "mrlib" "mysterx" "mzcom"
 > "mzlib" "mzscheme" "net" "openssl" "parser-tools" "picturing-programs"
 > "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket"
 > "racklog" "rackunit" "raco" "reader" "readline" "redex" "rnrs" "s-exp"
 > "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl"
 > "slatex" "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax"
 > "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed"
 > "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme"
 > "xml" "xrepl"))
 >
 > Computer Language: (("Determine language from source") (#(#t print
 > mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t #t ((main)
 > (test))))
 >
 >
 
 --e89a8fb1ff161d49c104cfbfa9ee
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 I don&#39;t see this and, unfortunately, there was bug in the contract syst=
 em (since fixed, right Asumu? Or should I be asking someone else?) that put=
 s &quot;meth&quot; into the error message instead of the name of the messag=
 e, so this is hard to track down.<div>
 <br></div><div>Looking at the code, i guess this is the draw-ellipse call, =
 but I don&#39;t see how it could get negative arguments unless something el=
 se is wrong elsewhere.</div><div><br></div><div>So I guess I&#39;ll need mo=
 re help to reproduce this.</div>
 <div><br></div><div>Does it happen every time mulhern?</div><div><br></div>=
 <div>Robby<br><br>On Wednesday, November 28, 2012,   wrote:<br><blockquote =
 class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid=
 ;padding-left:1ex">
 A new problem report is waiting at<br>
 =C2=A0 <a href=3D"http://bugs.racket-lang.org/query/?cmd=3Dview&amp;pr=3D13=
 321" target=3D"_blank">http://bugs.racket-lang.org/query/?cmd=3Dview&amp;pr=
 =3D13321</a><br>
 <br>
 Reported by mulhern for release: 5.3.1<br>
 <br>
 *** Description:<br>
 Stack trace looks like this:<br>
 <br>
 meth: contract violation<br>
 =C2=A0expected: (and/c real? (not/c negative?))<br>
 =C2=A0given: -12.0<br>
 =C2=A0which isn&#39;t: (not/c negative?)<br>
 =C2=A0in: the 3rd argument of<br>
 =C2=A0 =C2=A0 =C2=A0 (-&gt;m<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0real?<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0real?<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0(and/c real? (not/c negative?))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0(and/c real? (not/c negative?))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0void?)<br>
 =C2=A0contract from: (class dc%)<br>
 =C2=A0blaming:<br>
 =C2=A0 =C2=A0 =C2=A0 &lt;collects&gt;/mred/private/wx/cocoa/canvas.rkt<br>
 =C2=A0 context...:<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/racket/contract/private/b=
 lame.rkt:89:0: raise-blame-error<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/racket/contract/private/p=
 rop.rkt:221:10<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/gui-debugger/debug-tool.r=
 kt:485:8: on-paint method in ...ugger/debug-tool.rkt:174:6<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/mred/private/wxme/text.rk=
 t:5230:18: paint-done<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/mred/private/wxme/text.rk=
 t:5051:2: refresh method in text%<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/mred/private/wxme/editor-=
 canvas.rkt:609:2: redraw method in editor-canvas%<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/gui-debugger/debug-tool.r=
 kt:1503:8: on-tab-change method in ...ugger/debug-tool.rkt:1139:6<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/drracket/private/syncheck=
 /gui.rkt:1502:8: on-tab-change method in ...ate/syncheck/gui.rkt:1494:6<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/drracket/private/module-l=
 anguage-tools.rkt:77:6: on-tab-change method in ...e-language-tools.rkt:55:=
 4<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/drracket/private/tracing.=
 rkt:169:6: on-tab-change method in .../private/tracing.rkt:164:4<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/drracket/private/debug.rk=
 t:1708:6: on-tab-change method in ...et/private/debug.rkt:1630:4<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/drracket/private/unit.rkt=
 :2916:6: change-to-tab method in ...ket/private/unit.rkt:1355:4<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/framework/private/handler=
 .rkt:93:5<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/mred/private/wx/common/qu=
 eue.rkt:445:6<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/mred/private/wx/common/qu=
 eue.rkt:485:32<br>
 =C2=A0 =C2=A0/Applications/Racket v5.3.1/collects/mred/private/wx/common/qu=
 eue.rkt:633:3<br>
 <br>
 *** How to repeat:<br>
 Load the file below into Dr. Racket and hit the Debug button.<br>
 <br>
 #lang plai<br>
 <br>
 (define-type FWAE<br>
 =C2=A0 [bool (v boolean?)]<br>
 =C2=A0 [num (n number?)]<br>
 =C2=A0 [eqn (lhs FWAE?) (rhs FWAE?)]<br>
 =C2=A0 [add (lhs FWAE?) (rhs FWAE?)]<br>
 =C2=A0 [sub (lhs FWAE?) (rhs FWAE?)]<br>
 =C2=A0 [with (name symbol?) (named-expr FWAE?) (body FWAE?)]<br>
 =C2=A0 [id (name symbol?)]<br>
 =C2=A0 [ifb (c FWAE?) (l FWAE?) (r FWAE?)]<br>
 =C2=A0 [fun (param symbol?) (body FWAE?)]<br>
 =C2=A0 [app (fun-expr FWAE?) (arg-expr FWAE?)])<br>
 <br>
 (define parse-binop<br>
 =C2=A0 (lambda (an-sexp)<br>
 =C2=A0 =C2=A0 (if (not (=3D (length an-sexp) 3))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (error &#39;parse-binop &quot;Binary operator m=
 ust have exactly two arguments.&quot;)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (let ([build-binop<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(lambda (op)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(op (parse (s=
 econd an-sexp))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0(parse (third an-sexp))))])<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (case (first an-sexp)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [(+) (build-binop add)]<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [(=3D) (build-binop eqn)]<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [(-) (build-binop sub)]<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [else (error &#39;parse-binop &qu=
 ot;Unexpected operator.&quot;)])))))<br>
 <br>
 (define parse-with<br>
 =C2=A0 (lambda (an-sexp)<br>
 =C2=A0 =C2=A0 (if (not (=3D (length an-sexp) 3))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (error &#39;parse-with &quot;With-expression mu=
 st have exactly two arguments.&quot;)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (let ([binding (second an-sexp)])<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (let ([binding-instance (first binding)]=
 )<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (if (symbol? binding-instance)<br=
 >
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (with<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0binding-insta=
 nce<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(parse (secon=
 d binding))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(parse (third=
  an-sexp)))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (error &#39;parse-w=
 ith &quot;Element in identifier position not a symbol.&quot;)))))))<br>
 <br>
 (define parse-fun<br>
 =C2=A0 (lambda (an-sexp)<br>
 =C2=A0 =C2=A0 (if<br>
 =C2=A0 =C2=A0 =C2=A0(and<br>
 =C2=A0 =C2=A0 =C2=A0 (=3D (length an-sexp) 3)<br>
 =C2=A0 =C2=A0 =C2=A0 (symbol? (first (second an-sexp))))<br>
 =C2=A0 =C2=A0 =C2=A0(fun<br>
 =C2=A0 =C2=A0 =C2=A0 (first (second an-sexp))<br>
 =C2=A0 =C2=A0 =C2=A0 (parse (third an-sexp)))<br>
 =C2=A0 =C2=A0 =C2=A0(error &#39;parse &quot;Error parsing fun.&quot;))))<br=
 >
 <br>
 (define parse-app<br>
 =C2=A0 (lambda (an-sexp)<br>
 =C2=A0 =C2=A0 (if (=3D (length an-sexp) 2)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (app (parse (first an-sexp))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(parse (second an-sexp)))<b=
 r>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (error &#39;parse &quot;Error parsing applicati=
 on.&quot;))))<br>
 <br>
 (define parse-if<br>
 =C2=A0 (lambda (an-sexp)<br>
 =C2=A0 =C2=A0 (if (=3D (length an-sexp) 4)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (ifb<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(parse (second an-sexp))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(parse (third an-sexp))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(parse (fourth an-sexp)))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (error &#39;parse &quot;Error parsing if.&quot;=
 ))))<br>
 <br>
 <br>
 (define parse-list<br>
 =C2=A0 (lambda (an-sexp)<br>
 =C2=A0 =C2=A0 (if (empty? an-sexp)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (error &#39;parse-list &quot;Can&#39;t parse an=
  empty list.&quot;)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (case (first an-sexp)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [(+ =3D) (parse-binop an-sexp)]<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [(with) (parse-with an-sexp)]<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [(fun) (parse-fun an-sexp)]<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [(if) (parse-if an-sexp)]<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [else (parse-app an-sexp)]))))<br>
 <br>
 (define parse<br>
 =C2=A0 (lambda (an-sexp)<br>
 =C2=A0 =C2=A0 (cond<br>
 =C2=A0 =C2=A0 =C2=A0 [(number? an-sexp) (num an-sexp)]<br>
 =C2=A0 =C2=A0 =C2=A0 [(symbol? an-sexp) (id an-sexp)]<br>
 =C2=A0 =C2=A0 =C2=A0 [(boolean? an-sexp) (bool an-sexp)]<br>
 =C2=A0 =C2=A0 =C2=A0 [(list? an-sexp) (parse-list an-sexp)]<br>
 =C2=A0 =C2=A0 =C2=A0 [else (error &#39;parse &quot;Unexpected element.&quot=
 ;)])))<br>
 <br>
 (define (subst expr sub-id val)<br>
 =C2=A0 (type-case FWAE expr<br>
 =C2=A0 =C2=A0 [num (n) expr]<br>
 =C2=A0 =C2=A0 [bool (v) expr]<br>
 =C2=A0 =C2=A0 [add (l r) (add (subst l sub-id val)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (subs=
 t r sub-id val))]<br>
 =C2=A0 =C2=A0 [sub (l r) (sub (subst l sub-id val)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (subs=
 t r sub-id val))]<br>
 =C2=A0 =C2=A0 [eqn (l r) (eqn (subst l sub-id val)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (subs=
 t l sub-id val))]<br>
 =C2=A0 =C2=A0 [with (bound-id named-expr bound-body)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (with<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0bound-id<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(subst named-expr sub-id val)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(if (symbol=3D? bound-id sub-id)<b=
 r>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0bound-body<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(subst bound-body su=
 b-id val)))]<br>
 =C2=A0 =C2=A0 [ifb (c l r)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(ifb<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (subst c sub-id val)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (subst l sub-id val)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (subst r sub-id val))]<br>
 =C2=A0 =C2=A0 [id (v)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (if (symbol=3D? v sub-id)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 val<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 expr)]<br>
 =C2=A0 =C2=A0 [fun (x body)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(fun<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 x<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (if (symbol=3D? sub-id x)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 body<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (subst body sub-id val)))]=
 <br>
 =C2=A0 =C2=A0 [app (l r)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(app<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (subst l sub-id val)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (subst r sub-id val))]))<br>
 <br>
 (define arith-numbers<br>
 =C2=A0 (lambda (op l r)<br>
 =C2=A0 =C2=A0 (if<br>
 =C2=A0 =C2=A0 =C2=A0(and (num? l) (num? r))<br>
 =C2=A0 =C2=A0 =C2=A0(num (op (num-n l) (num-n r)))<br>
 =C2=A0 =C2=A0 =C2=A0(error<br>
 =C2=A0 =C2=A0 =C2=A0 &#39;add-numbers<br>
 =C2=A0 =C2=A0 =C2=A0 &quot;Left or right side of addition expression is not=
  a number.&quot;))))<br>
 <br>
 (define check-equal<br>
 =C2=A0 (lambda (l r)<br>
 =C2=A0 =C2=A0 (if<br>
 =C2=A0 =C2=A0 =C2=A0(and (num? l) (num? r))<br>
 =C2=A0 =C2=A0 =C2=A0(if (=3D (num-n l) (num-n r))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(bool #t)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(bool #f))<br>
 =C2=A0 =C2=A0 =C2=A0(error<br>
 =C2=A0 =C2=A0 =C2=A0 &#39;interp<br>
 =C2=A0 =C2=A0 =C2=A0 &quot;Left or right side of equals expression is not a=
  number.&quot;))))<br>
 <br>
 (define (interp expr)<br>
 =C2=A0 (type-case FWAE expr<br>
 =C2=A0 =C2=A0 [num (n) expr]<br>
 =C2=A0 =C2=A0 [bool (v) expr]<br>
 =C2=A0 =C2=A0 [add (l r) (arith-numbers + (interp l) (interp r))]<br>
 =C2=A0 =C2=A0 [sub (l r) (arith-numbers - (interp l) (interp r))]<br>
 =C2=A0 =C2=A0 [eqn (l r) (check-equal (interp l) (interp r))]<br>
 =C2=A0 =C2=A0 [ifb (c l r)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(let ([res (interp c)])<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(if (bool? res)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(if (false? (bool-v =
 res))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(inter=
 p r)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(inter=
 p l))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(error &#39;interp &=
 quot;If-condition not a boolean.&quot;)))]<br>
 =C2=A0 =C2=A0 [with (bound-id named-expr bound-body)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (interp (subst bound-body<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0bound-id<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0(interp named-expr)))]<br>
 =C2=A0 =C2=A0 [id (v) (error &#39;interp &quot;free identifier&quot;)]<br>
 =C2=A0 =C2=A0 [fun (bound-id bound-body)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0expr]<br>
 =C2=A0 =C2=A0 [app (fun-expr arg-expr)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(let ([fun-val (interp fun-expr)])<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(if (fun? fun-val)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(interp<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (subst<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(fun-body fun=
 -val)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(fun-param fu=
 n-val)<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(interp arg-e=
 xpr)))<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(error<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 &#39;interp<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 &quot;Left side of =
 application is not a function.&quot;)))]))<br>
 <br>
 (interp (parse<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0&#39;{with {factorial<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0{fun {n}<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 {if {=3D n 0}<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 1<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 {+ {factorial {- n 1}}}}}}<br>
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 {factorial 0}}))<br=
 >
 <br>
 *** Environment:<br>
 macosx &quot;Darwin mulhern-lowell.local 11.4.2 Darwin Kernel Version 11.4.=
 2: Thu Aug 23 16:25:48 PDT 2012; root:xnu-1699.32.7~1/RELEASE_X86_64 x86_64=
  i386&quot; (i386-macosx/3m) (get-display-depth) =3D 32<br>
 Human Language: english<br>
 (current-memory-use) 189359852<br>
 Links: (links) =3D (); (links #:user? #f) =3D (); (links #:root? #t) =3D ()=
 ; (links #:user? #f #:root? #t) =3D ()<br>
 <br>
 <br>
 Collections:<br>
 (&quot;/Users/mulhern/Library/Racket/5.3.1/collects&quot;<br>
 =C2=A0(non-existent-path))<br>
 (&quot;/Applications/Racket v5.3.1/collects&quot;<br>
 =C2=A0(&quot;2htdp&quot; &quot;algol60&quot; &quot;at-exp&quot; &quot;brows=
 er&quot; &quot;compatibility&quot; &quot;compiler&quot; &quot;config&quot; =
 &quot;data&quot; &quot;datalog&quot; &quot;db&quot; &quot;defaults&quot; &q=
 uot;deinprogramm&quot; &quot;drracket&quot; &quot;drscheme&quot; &quot;dyne=
 xt&quot; &quot;embedded-gui&quot; &quot;eopl&quot; &quot;errortrace&quot; &=
 quot;ffi&quot; &quot;file&quot; &quot;framework&quot; &quot;frtime&quot; &q=
 uot;future-visualizer&quot; &quot;games&quot; &quot;graphics&quot; &quot;gu=
 i-debugger&quot; &quot;help&quot; &quot;hierlist&quot; &quot;htdp&quot; &qu=
 ot;html&quot; &quot;icons&quot; &quot;images&quot; &quot;info-domain&quot; =
 &quot;json&quot; &quot;lang&quot; &quot;launcher&quot; &quot;lazy&quot; &qu=
 ot;macro-debugger&quot; &quot;make&quot; &quot;mred&quot; &quot;mrlib&quot;=
  &quot;mysterx&quot; &quot;mzcom&quot; &quot;mzlib&quot; &quot;mzscheme&quo=
 t; &quot;net&quot; &quot;openssl&quot; &quot;parser-tools&quot; &quot;pictu=
 ring-programs&quot; &quot;plai&quot; &quot;planet&quot; &quot;plot&quot; &q=
 uot;preprocessor&quot; &quot;profile&quot; &quot;r5rs&quot; &quot;r6rs&quot=
 ; &quot;racket&quot; &quot;racklog&quot; &quot;rackunit&quot; &quot;raco&qu=
 ot; &quot;reader&quot; &quot;readline&quot; &quot;redex&quot; &quot;rnrs&qu=
 ot; &quot;s-exp&quot; &quot;scheme&quot; &quot;schemeunit&quot; &quot;scrib=
 ble&quot; &quot;scribblings&quot; &quot;scriblib&quot; &quot;setup&quot; &q=
 uot;sgl&quot; &quot;slatex&quot; &quot;slideshow&quot; &quot;srfi&quot; &qu=
 ot;stepper&quot; &quot;string-constants&quot; &quot;swindle&quot; &quot;syn=
 tax&quot; &quot;syntax-color&quot; &quot;teachpack&quot; &quot;test-engine&=
 quot; &quot;texpict&quot; &quot;trace&quot; &quot;typed&quot; &quot;typed-r=
 acket&quot; &quot;typed-scheme&quot; &quot;unstable&quot; &quot;version&quo=
 t; &quot;web-server&quot; &quot;wxme&quot; &quot;xml&quot; &quot;xrepl&quot=
 ;))<br>
 
 <br>
 Computer Language: ((&quot;Determine language from source&quot;) (#(#t prin=
 t mixed-fraction-e #f #t debug) (default) #() &quot;#lang racket\n&quot; #t=
  #t ((main) (test))))<br>
 <br>
 </blockquote></div>
 
 --e89a8fb1ff161d49c104cfbfa9ee--
From: mulhern <mulhern@cs.wisc.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: "bugs@racket-lang.org" <bugs@racket-lang.org>,
        "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13321: Internal racket error while debugging
Date: Fri, 30 Nov 2012 20:42:08 -0500

 --Apple-Mail=_62A72226-A3E1-4FC3-AB06-C14EF27FE383
 Content-Transfer-Encoding: quoted-printable
 Content-Type: text/plain;
 	charset=us-ascii
 
 Yes. Without fail and across multiple DrRacket restarts.
 
 - mulhern
 
 On Nov 30, 2012, at 7:33 PM, Robby Findler wrote:
 
 > I don't see this and, unfortunately, there was bug in the contract =
 system (since fixed, right Asumu? Or should I be asking someone else?) =
 that puts "meth" into the error message instead of the name of the =
 message, so this is hard to track down.
 >=20
 > Looking at the code, i guess this is the draw-ellipse call, but I =
 don't see how it could get negative arguments unless something else is =
 wrong elsewhere.
 >=20
 > So I guess I'll need more help to reproduce this.
 >=20
 > Does it happen every time mulhern?
 >=20
 > Robby
 >=20
 > On Wednesday, November 28, 2012, wrote:
 > A new problem report is waiting at
 >   http://bugs.racket-lang.org/query/?cmd=3Dview&pr=3D13321
 >=20
 > Reported by mulhern for release: 5.3.1
 >=20
 > *** Description:
 > Stack trace looks like this:
 >=20
 > meth: contract violation
 >  expected: (and/c real? (not/c negative?))
 >  given: -12.0
 >  which isn't: (not/c negative?)
 >  in: the 3rd argument of
 >       (->m
 >        real?
 >        real?
 >        (and/c real? (not/c negative?))
 >        (and/c real? (not/c negative?))
 >        void?)
 >  contract from: (class dc%)
 >  blaming:
 >       <collects>/mred/private/wx/cocoa/canvas.rkt
 >   context...:
 >    /Applications/Racket =
 v5.3.1/collects/racket/contract/private/blame.rkt:89:0: =
 raise-blame-error
 >    /Applications/Racket =
 v5.3.1/collects/racket/contract/private/prop.rkt:221:10
 >    /Applications/Racket =
 v5.3.1/collects/gui-debugger/debug-tool.rkt:485:8: on-paint method in =
 ...ugger/debug-tool.rkt:174:6
 >    /Applications/Racket =
 v5.3.1/collects/mred/private/wxme/text.rkt:5230:18: paint-done
 >    /Applications/Racket =
 v5.3.1/collects/mred/private/wxme/text.rkt:5051:2: refresh method in =
 text%
 >    /Applications/Racket =
 v5.3.1/collects/mred/private/wxme/editor-canvas.rkt:609:2: redraw method =
 in editor-canvas%
 >    /Applications/Racket =
 v5.3.1/collects/gui-debugger/debug-tool.rkt:1503:8: on-tab-change method =
 in ...ugger/debug-tool.rkt:1139:6
 >    /Applications/Racket =
 v5.3.1/collects/drracket/private/syncheck/gui.rkt:1502:8: on-tab-change =
 method in ...ate/syncheck/gui.rkt:1494:6
 >    /Applications/Racket =
 v5.3.1/collects/drracket/private/module-language-tools.rkt:77:6: =
 on-tab-change method in ...e-language-tools.rkt:55:4
 >    /Applications/Racket =
 v5.3.1/collects/drracket/private/tracing.rkt:169:6: on-tab-change method =
 in .../private/tracing.rkt:164:4
 >    /Applications/Racket =
 v5.3.1/collects/drracket/private/debug.rkt:1708:6: on-tab-change method =
 in ...et/private/debug.rkt:1630:4
 >    /Applications/Racket =
 v5.3.1/collects/drracket/private/unit.rkt:2916:6: change-to-tab method =
 in ...ket/private/unit.rkt:1355:4
 >    /Applications/Racket =
 v5.3.1/collects/framework/private/handler.rkt:93:5
 >    /Applications/Racket =
 v5.3.1/collects/mred/private/wx/common/queue.rkt:445:6
 >    /Applications/Racket =
 v5.3.1/collects/mred/private/wx/common/queue.rkt:485:32
 >    /Applications/Racket =
 v5.3.1/collects/mred/private/wx/common/queue.rkt:633:3
 >=20
 > *** How to repeat:
 > Load the file below into Dr. Racket and hit the Debug button.
 >=20
 > #lang plai
 >=20
 > (define-type FWAE
 >   [bool (v boolean?)]
 >   [num (n number?)]
 >   [eqn (lhs FWAE?) (rhs FWAE?)]
 >   [add (lhs FWAE?) (rhs FWAE?)]
 >   [sub (lhs FWAE?) (rhs FWAE?)]
 >   [with (name symbol?) (named-expr FWAE?) (body FWAE?)]
 >   [id (name symbol?)]
 >   [ifb (c FWAE?) (l FWAE?) (r FWAE?)]
 >   [fun (param symbol?) (body FWAE?)]
 >   [app (fun-expr FWAE?) (arg-expr FWAE?)])
 >=20
 > (define parse-binop
 >   (lambda (an-sexp)
 >     (if (not (=3D (length an-sexp) 3))
 >         (error 'parse-binop "Binary operator must have exactly two =
 arguments.")
 >         (let ([build-binop
 >                (lambda (op)
 >                  (op (parse (second an-sexp))
 >                      (parse (third an-sexp))))])
 >           (case (first an-sexp)
 >             [(+) (build-binop add)]
 >             [(=3D) (build-binop eqn)]
 >             [(-) (build-binop sub)]
 >             [else (error 'parse-binop "Unexpected operator.")])))))
 >=20
 > (define parse-with
 >   (lambda (an-sexp)
 >     (if (not (=3D (length an-sexp) 3))
 >         (error 'parse-with "With-expression must have exactly two =
 arguments.")
 >         (let ([binding (second an-sexp)])
 >           (let ([binding-instance (first binding)])
 >             (if (symbol? binding-instance)
 >                 (with
 >                  binding-instance
 >                  (parse (second binding))
 >                  (parse (third an-sexp)))
 >                 (error 'parse-with "Element in identifier position not =
 a symbol.")))))))
 >=20
 > (define parse-fun
 >   (lambda (an-sexp)
 >     (if
 >      (and
 >       (=3D (length an-sexp) 3)
 >       (symbol? (first (second an-sexp))))
 >      (fun
 >       (first (second an-sexp))
 >       (parse (third an-sexp)))
 >      (error 'parse "Error parsing fun."))))
 >=20
 > (define parse-app
 >   (lambda (an-sexp)
 >     (if (=3D (length an-sexp) 2)
 >         (app (parse (first an-sexp))
 >              (parse (second an-sexp)))
 >         (error 'parse "Error parsing application."))))
 >=20
 > (define parse-if
 >   (lambda (an-sexp)
 >     (if (=3D (length an-sexp) 4)
 >         (ifb
 >          (parse (second an-sexp))
 >          (parse (third an-sexp))
 >          (parse (fourth an-sexp)))
 >         (error 'parse "Error parsing if."))))
 >=20
 >=20
 > (define parse-list
 >   (lambda (an-sexp)
 >     (if (empty? an-sexp)
 >         (error 'parse-list "Can't parse an empty list.")
 >         (case (first an-sexp)
 >           [(+ =3D) (parse-binop an-sexp)]
 >           [(with) (parse-with an-sexp)]
 >           [(fun) (parse-fun an-sexp)]
 >           [(if) (parse-if an-sexp)]
 >           [else (parse-app an-sexp)]))))
 >=20
 > (define parse
 >   (lambda (an-sexp)
 >     (cond
 >       [(number? an-sexp) (num an-sexp)]
 >       [(symbol? an-sexp) (id an-sexp)]
 >       [(boolean? an-sexp) (bool an-sexp)]
 >       [(list? an-sexp) (parse-list an-sexp)]
 >       [else (error 'parse "Unexpected element.")])))
 >=20
 > (define (subst expr sub-id val)
 >   (type-case FWAE expr
 >     [num (n) expr]
 >     [bool (v) expr]
 >     [add (l r) (add (subst l sub-id val)
 >                     (subst r sub-id val))]
 >     [sub (l r) (sub (subst l sub-id val)
 >                     (subst r sub-id val))]
 >     [eqn (l r) (eqn (subst l sub-id val)
 >                     (subst l sub-id val))]
 >     [with (bound-id named-expr bound-body)
 >           (with
 >            bound-id
 >            (subst named-expr sub-id val)
 >            (if (symbol=3D? bound-id sub-id)
 >                bound-body
 >                (subst bound-body sub-id val)))]
 >     [ifb (c l r)
 >          (ifb
 >           (subst c sub-id val)
 >           (subst l sub-id val)
 >           (subst r sub-id val))]
 >     [id (v)
 >         (if (symbol=3D? v sub-id)
 >             val
 >             expr)]
 >     [fun (x body)
 >          (fun
 >           x
 >           (if (symbol=3D? sub-id x)
 >               body
 >               (subst body sub-id val)))]
 >     [app (l r)
 >          (app
 >           (subst l sub-id val)
 >           (subst r sub-id val))]))
 >=20
 > (define arith-numbers
 >   (lambda (op l r)
 >     (if
 >      (and (num? l) (num? r))
 >      (num (op (num-n l) (num-n r)))
 >      (error
 >       'add-numbers
 >       "Left or right side of addition expression is not a number."))))
 >=20
 > (define check-equal
 >   (lambda (l r)
 >     (if
 >      (and (num? l) (num? r))
 >      (if (=3D (num-n l) (num-n r))
 >          (bool #t)
 >          (bool #f))
 >      (error
 >       'interp
 >       "Left or right side of equals expression is not a number."))))
 >=20
 > (define (interp expr)
 >   (type-case FWAE expr
 >     [num (n) expr]
 >     [bool (v) expr]
 >     [add (l r) (arith-numbers + (interp l) (interp r))]
 >     [sub (l r) (arith-numbers - (interp l) (interp r))]
 >     [eqn (l r) (check-equal (interp l) (interp r))]
 >     [ifb (c l r)
 >          (let ([res (interp c)])
 >            (if (bool? res)
 >                (if (false? (bool-v res))
 >                    (interp r)
 >                    (interp l))
 >                (error 'interp "If-condition not a boolean.")))]
 >     [with (bound-id named-expr bound-body)
 >           (interp (subst bound-body
 >                          bound-id
 >                          (interp named-expr)))]
 >     [id (v) (error 'interp "free identifier")]
 >     [fun (bound-id bound-body)
 >          expr]
 >     [app (fun-expr arg-expr)
 >          (let ([fun-val (interp fun-expr)])
 >            (if (fun? fun-val)
 >                (interp
 >                 (subst
 >                  (fun-body fun-val)
 >                  (fun-param fun-val)
 >                  (interp arg-expr)))
 >                (error
 >                 'interp
 >                 "Left side of application is not a function.")))]))
 >=20
 > (interp (parse
 >          '{with {factorial
 >                  {fun {n}
 >                       {if {=3D n 0}
 >                           1
 >                           {+ {factorial {- n 1}}}}}}
 >                 {factorial 0}}))
 >=20
 > *** Environment:
 > macosx "Darwin mulhern-lowell.local 11.4.2 Darwin Kernel Version =
 11.4.2: Thu Aug 23 16:25:48 PDT 2012; =
 root:xnu-1699.32.7~1/RELEASE_X86_64 x86_64 i386" (i386-macosx/3m) =
 (get-display-depth) =3D 32
 > Human Language: english
 > (current-memory-use) 189359852
 > Links: (links) =3D (); (links #:user? #f) =3D (); (links #:root? #t) =3D=
  (); (links #:user? #f #:root? #t) =3D ()
 >=20
 >=20
 > Collections:
 > ("/Users/mulhern/Library/Racket/5.3.1/collects"
 >  (non-existent-path))
 > ("/Applications/Racket v5.3.1/collects"
 >  ("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" =
 "config" "data" "datalog" "db" "defaults" "deinprogramm" "drracket" =
 "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" =
 "framework" "frtime" "future-visualizer" "games" "graphics" =
 "gui-debugger" "help" "hierlist" "htdp" "html" "icons" "images" =
 "info-domain" "json" "lang" "launcher" "lazy" "macro-debugger" "make" =
 "mred" "mrlib" "mysterx" "mzcom" "mzlib" "mzscheme" "net" "openssl" =
 "parser-tools" "picturing-programs" "plai" "planet" "plot" =
 "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" =
 "raco" "reader" "readline" "redex" "rnrs" "s-exp" "scheme" "schemeunit" =
 "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" "slideshow" =
 "srfi" "stepper" "string-constants" "swindle" "syntax" "syntax-color" =
 "teachpack" "test-engine" "texpict" "trace" "typed" "typed-racket" =
 "typed-scheme" "unstable" "version" "web-server" "wxme" "xml" "xrepl"))
 >=20
 > Computer Language: (("Determine language from source") (#(#t print =
 mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t #t =
 ((main) (test))))
 >=20
 
 
 --Apple-Mail=_62A72226-A3E1-4FC3-AB06-C14EF27FE383
 Content-Transfer-Encoding: 7bit
 Content-Type: text/html;
 	charset=us-ascii
 
 <html><head></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">Yes. Without fail and across multiple DrRacket restarts.<div><br></div><div>- mulhern<br><div><div><br></div><div><div><div>On Nov 30, 2012, at 7:33 PM, Robby Findler wrote:</div><br class="Apple-interchange-newline"><blockquote type="cite">I don't see this and, unfortunately, there was bug in the contract system (since fixed, right Asumu? Or should I be asking someone else?) that puts "meth" into the error message instead of the name of the message, so this is hard to track down.<div>
 <br></div><div>Looking at the code, i guess this is the draw-ellipse call, but I don't see how it could get negative arguments unless something else is wrong elsewhere.</div><div><br></div><div>So I guess I'll need more help to reproduce this.</div>
 <div><br></div><div>Does it happen every time mulhern?</div><div><br></div><div>Robby<br><br>On Wednesday, November 28, 2012,   wrote:<br><blockquote class="gmail_quote" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0.8ex; border-left-width: 1px; border-left-color: rgb(204, 204, 204); border-left-style: solid; padding-left: 1ex; position: static; z-index: auto; ">
 A new problem report is waiting at<br>
 &nbsp; <a href="http://bugs.racket-lang.org/query/?cmd=view&amp;pr=13321" target="_blank">http://bugs.racket-lang.org/query/?cmd=view&amp;pr=13321</a><br>
 <br>
 Reported by mulhern for release: 5.3.1<br>
 <br>
 *** Description:<br>
 Stack trace looks like this:<br>
 <br>
 meth: contract violation<br>
 &nbsp;expected: (and/c real? (not/c negative?))<br>
 &nbsp;given: -12.0<br>
 &nbsp;which isn't: (not/c negative?)<br>
 &nbsp;in: the 3rd argument of<br>
 &nbsp; &nbsp; &nbsp; (-&gt;m<br>
 &nbsp; &nbsp; &nbsp; &nbsp;real?<br>
 &nbsp; &nbsp; &nbsp; &nbsp;real?<br>
 &nbsp; &nbsp; &nbsp; &nbsp;(and/c real? (not/c negative?))<br>
 &nbsp; &nbsp; &nbsp; &nbsp;(and/c real? (not/c negative?))<br>
 &nbsp; &nbsp; &nbsp; &nbsp;void?)<br>
 &nbsp;contract from: (class dc%)<br>
 &nbsp;blaming:<br>
 &nbsp; &nbsp; &nbsp; &lt;collects&gt;/mred/private/wx/cocoa/canvas.rkt<br>
 &nbsp; context...:<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/racket/contract/private/blame.rkt:89:0: raise-blame-error<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/racket/contract/private/prop.rkt:221:10<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/gui-debugger/debug-tool.rkt:485:8: on-paint method in ...ugger/debug-tool.rkt:174:6<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/mred/private/wxme/text.rkt:5230:18: paint-done<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/mred/private/wxme/text.rkt:5051:2: refresh method in text%<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/mred/private/wxme/editor-canvas.rkt:609:2: redraw method in editor-canvas%<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/gui-debugger/debug-tool.rkt:1503:8: on-tab-change method in ...ugger/debug-tool.rkt:1139:6<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/drracket/private/syncheck/gui.rkt:1502:8: on-tab-change method in ...ate/syncheck/gui.rkt:1494:6<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/drracket/private/module-language-tools.rkt:77:6: on-tab-change method in ...e-language-tools.rkt:55:4<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/drracket/private/tracing.rkt:169:6: on-tab-change method in .../private/tracing.rkt:164:4<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/drracket/private/debug.rkt:1708:6: on-tab-change method in ...et/private/debug.rkt:1630:4<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/drracket/private/unit.rkt:2916:6: change-to-tab method in ...ket/private/unit.rkt:1355:4<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/framework/private/handler.rkt:93:5<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/mred/private/wx/common/queue.rkt:445:6<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/mred/private/wx/common/queue.rkt:485:32<br>
 &nbsp; &nbsp;/Applications/Racket v5.3.1/collects/mred/private/wx/common/queue.rkt:633:3<br>
 <br>
 *** How to repeat:<br>
 Load the file below into Dr. Racket and hit the Debug button.<br>
 <br>
 #lang plai<br>
 <br>
 (define-type FWAE<br>
 &nbsp; [bool (v boolean?)]<br>
 &nbsp; [num (n number?)]<br>
 &nbsp; [eqn (lhs FWAE?) (rhs FWAE?)]<br>
 &nbsp; [add (lhs FWAE?) (rhs FWAE?)]<br>
 &nbsp; [sub (lhs FWAE?) (rhs FWAE?)]<br>
 &nbsp; [with (name symbol?) (named-expr FWAE?) (body FWAE?)]<br>
 &nbsp; [id (name symbol?)]<br>
 &nbsp; [ifb (c FWAE?) (l FWAE?) (r FWAE?)]<br>
 &nbsp; [fun (param symbol?) (body FWAE?)]<br>
 &nbsp; [app (fun-expr FWAE?) (arg-expr FWAE?)])<br>
 <br>
 (define parse-binop<br>
 &nbsp; (lambda (an-sexp)<br>
 &nbsp; &nbsp; (if (not (= (length an-sexp) 3))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (error 'parse-binop "Binary operator must have exactly two arguments.")<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (let ([build-binop<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(lambda (op)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(op (parse (second an-sexp))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(parse (third an-sexp))))])<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (case (first an-sexp)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(+) (build-binop add)]<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(=) (build-binop eqn)]<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(-) (build-binop sub)]<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (error 'parse-binop "Unexpected operator.")])))))<br>
 <br>
 (define parse-with<br>
 &nbsp; (lambda (an-sexp)<br>
 &nbsp; &nbsp; (if (not (= (length an-sexp) 3))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (error 'parse-with "With-expression must have exactly two arguments.")<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (let ([binding (second an-sexp)])<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (let ([binding-instance (first binding)])<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if (symbol? binding-instance)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (with<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;binding-instance<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(parse (second binding))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(parse (third an-sexp)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (error 'parse-with "Element in identifier position not a symbol.")))))))<br>
 <br>
 (define parse-fun<br>
 &nbsp; (lambda (an-sexp)<br>
 &nbsp; &nbsp; (if<br>
 &nbsp; &nbsp; &nbsp;(and<br>
 &nbsp; &nbsp; &nbsp; (= (length an-sexp) 3)<br>
 &nbsp; &nbsp; &nbsp; (symbol? (first (second an-sexp))))<br>
 &nbsp; &nbsp; &nbsp;(fun<br>
 &nbsp; &nbsp; &nbsp; (first (second an-sexp))<br>
 &nbsp; &nbsp; &nbsp; (parse (third an-sexp)))<br>
 &nbsp; &nbsp; &nbsp;(error 'parse "Error parsing fun."))))<br>
 <br>
 (define parse-app<br>
 &nbsp; (lambda (an-sexp)<br>
 &nbsp; &nbsp; (if (= (length an-sexp) 2)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (app (parse (first an-sexp))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(parse (second an-sexp)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (error 'parse "Error parsing application."))))<br>
 <br>
 (define parse-if<br>
 &nbsp; (lambda (an-sexp)<br>
 &nbsp; &nbsp; (if (= (length an-sexp) 4)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (ifb<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(parse (second an-sexp))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(parse (third an-sexp))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(parse (fourth an-sexp)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (error 'parse "Error parsing if."))))<br>
 <br>
 <br>
 (define parse-list<br>
 &nbsp; (lambda (an-sexp)<br>
 &nbsp; &nbsp; (if (empty? an-sexp)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (error 'parse-list "Can't parse an empty list.")<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (case (first an-sexp)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(+ =) (parse-binop an-sexp)]<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(with) (parse-with an-sexp)]<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(fun) (parse-fun an-sexp)]<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(if) (parse-if an-sexp)]<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (parse-app an-sexp)]))))<br>
 <br>
 (define parse<br>
 &nbsp; (lambda (an-sexp)<br>
 &nbsp; &nbsp; (cond<br>
 &nbsp; &nbsp; &nbsp; [(number? an-sexp) (num an-sexp)]<br>
 &nbsp; &nbsp; &nbsp; [(symbol? an-sexp) (id an-sexp)]<br>
 &nbsp; &nbsp; &nbsp; [(boolean? an-sexp) (bool an-sexp)]<br>
 &nbsp; &nbsp; &nbsp; [(list? an-sexp) (parse-list an-sexp)]<br>
 &nbsp; &nbsp; &nbsp; [else (error 'parse "Unexpected element.")])))<br>
 <br>
 (define (subst expr sub-id val)<br>
 &nbsp; (type-case FWAE expr<br>
 &nbsp; &nbsp; [num (n) expr]<br>
 &nbsp; &nbsp; [bool (v) expr]<br>
 &nbsp; &nbsp; [add (l r) (add (subst l sub-id val)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subst r sub-id val))]<br>
 &nbsp; &nbsp; [sub (l r) (sub (subst l sub-id val)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subst r sub-id val))]<br>
 &nbsp; &nbsp; [eqn (l r) (eqn (subst l sub-id val)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subst l sub-id val))]<br>
 &nbsp; &nbsp; [with (bound-id named-expr bound-body)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (with<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bound-id<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(subst named-expr sub-id val)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(if (symbol=? bound-id sub-id)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bound-body<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(subst bound-body sub-id val)))]<br>
 &nbsp; &nbsp; [ifb (c l r)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(ifb<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subst c sub-id val)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subst l sub-id val)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subst r sub-id val))]<br>
 &nbsp; &nbsp; [id (v)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (if (symbol=? v sub-id)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr)]<br>
 &nbsp; &nbsp; [fun (x body)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(fun<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if (symbol=? sub-id x)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; body<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subst body sub-id val)))]<br>
 &nbsp; &nbsp; [app (l r)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(app<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subst l sub-id val)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subst r sub-id val))]))<br>
 <br>
 (define arith-numbers<br>
 &nbsp; (lambda (op l r)<br>
 &nbsp; &nbsp; (if<br>
 &nbsp; &nbsp; &nbsp;(and (num? l) (num? r))<br>
 &nbsp; &nbsp; &nbsp;(num (op (num-n l) (num-n r)))<br>
 &nbsp; &nbsp; &nbsp;(error<br>
 &nbsp; &nbsp; &nbsp; 'add-numbers<br>
 &nbsp; &nbsp; &nbsp; "Left or right side of addition expression is not a number."))))<br>
 <br>
 (define check-equal<br>
 &nbsp; (lambda (l r)<br>
 &nbsp; &nbsp; (if<br>
 &nbsp; &nbsp; &nbsp;(and (num? l) (num? r))<br>
 &nbsp; &nbsp; &nbsp;(if (= (num-n l) (num-n r))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(bool #t)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(bool #f))<br>
 &nbsp; &nbsp; &nbsp;(error<br>
 &nbsp; &nbsp; &nbsp; 'interp<br>
 &nbsp; &nbsp; &nbsp; "Left or right side of equals expression is not a number."))))<br>
 <br>
 (define (interp expr)<br>
 &nbsp; (type-case FWAE expr<br>
 &nbsp; &nbsp; [num (n) expr]<br>
 &nbsp; &nbsp; [bool (v) expr]<br>
 &nbsp; &nbsp; [add (l r) (arith-numbers + (interp l) (interp r))]<br>
 &nbsp; &nbsp; [sub (l r) (arith-numbers - (interp l) (interp r))]<br>
 &nbsp; &nbsp; [eqn (l r) (check-equal (interp l) (interp r))]<br>
 &nbsp; &nbsp; [ifb (c l r)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(let ([res (interp c)])<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(if (bool? res)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(if (false? (bool-v res))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(interp r)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(interp l))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(error 'interp "If-condition not a boolean.")))]<br>
 &nbsp; &nbsp; [with (bound-id named-expr bound-body)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (interp (subst bound-body<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bound-id<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(interp named-expr)))]<br>
 &nbsp; &nbsp; [id (v) (error 'interp "free identifier")]<br>
 &nbsp; &nbsp; [fun (bound-id bound-body)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;expr]<br>
 &nbsp; &nbsp; [app (fun-expr arg-expr)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(let ([fun-val (interp fun-expr)])<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(if (fun? fun-val)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(interp<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subst<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(fun-body fun-val)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(fun-param fun-val)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(interp arg-expr)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(error<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'interp<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "Left side of application is not a function.")))]))<br>
 <br>
 (interp (parse<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'{with {factorial<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{fun {n}<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {if {= n 0}<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {+ {factorial {- n 1}}}}}}<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {factorial 0}}))<br>
 <br>
 *** Environment:<br>
 macosx "Darwin mulhern-lowell.local 11.4.2 Darwin Kernel Version 11.4.2: Thu Aug 23 16:25:48 PDT 2012; root:xnu-1699.32.7~1/RELEASE_X86_64 x86_64 i386" (i386-macosx/3m) (get-display-depth) = 32<br>
 Human Language: english<br>
 (current-memory-use) 189359852<br>
 Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()<br>
 <br>
 <br>
 Collections:<br>
 ("/Users/mulhern/Library/Racket/5.3.1/collects"<br>
 &nbsp;(non-existent-path))<br>
 ("/Applications/Racket v5.3.1/collects"<br>
 &nbsp;("2htdp" "algol60" "at-exp" "browser" "compatibility" "compiler" "config" "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "future-visualizer" "games" "graphics" "gui-debugger" "help" "hierlist" "htdp" "html" "icons" "images" "info-domain" "json" "lang" "launcher" "lazy" "macro-debugger" "make" "mred" "mrlib" "mysterx" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raco" "reader" "readline" "redex" "rnrs" "s-exp" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax" "syntax-color" "teachpack" "test-engine" "texpict" "trace" "typed" "typed-racket" "typed-scheme" "unstable" "version" "web-server" "wxme" "xml" "xrepl"))<br>
 
 <br>
 Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t #t ((main) (test))))<br>
 <br>
 </blockquote></div>
 </blockquote></div><br></div></div></div></body></html>
 --Apple-Mail=_62A72226-A3E1-4FC3-AB06-C14EF27FE383--
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: "mulhern@cs.wisc.edu" <mulhern@cs.wisc.edu>,
        "bugs@racket-lang.org" <bugs@racket-lang.org>,
        "nobody@racket-lang.org" <nobody@racket-lang.org>,
        "bug-notification@racket-lang.org" <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13321: Internal racket error while debugging
Date: Fri, 30 Nov 2012 20:48:28 -0500

 On Nov 30, 2012, at 7:33 PM, Robby Findler <robby@eecs.northwestern.edu> wrote:
 
 > I don't see this and, unfortunately, there was bug in the contract system (since fixed, right Asumu? Or should I be asking someone else?) that puts "meth" into the error message instead of the name of the message, so this is hard to track down.
 
 It has since been fixed.  I'll see if I can reproduce the error in a local build of v5.3.1, and if so, apply the fix so I can get you the appropriate error message.
 
 Stevie
 
 
