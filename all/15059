From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Mon May 11 01:15:11 2015
Received: from mail-ie0-f179.google.com (mail-ie0-f179.google.com [209.85.223.179])
	by winooski.ccs.neu.edu (8.14.7/8.14.7) with ESMTP id t4B5EfBw009733
	for <bugs@bugs.plt-scheme.org>; Mon, 11 May 2015 01:14:41 -0400
Message-Id: <201505110514.t4B5EZlo009726@winooski.ccs.neu.edu>
Date: Mon, 11 May 2015 01:14:35 -0400
From: michael.tiedtke@o2online.de
To: bugs@racket-lang.org
Subject: Color Database (color-database<%>) Name Mix up

>Number:         15059
>Category:       all
>Synopsis:       Color Database (color-database<%>) Name Mix up
>Class:          sw-bug
>Responsible:    nobody
>Severity:       non-critical
>Priority:       medium
>State:          open
>Confidential:   no
>Arrival-Date:   Mon May 11 01:16:01 -0400 2015
>Last-Modified:  Mon May 11 14:16:01 -0400 2015
>Originator:     Michael Tit-ke
>Organization:
plt
>Submitter-Id:   unknown
>Release:        6.1
>Environment:
macosx "Darwin nPing.local 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7 16:33:36 PDT 2011; root:xnu-1504.15.3~1/RELEASE_I386 i386" (x86_64-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 440017348
raco pkg (show):
Installation-wide:
 Package              Checksum                                    Source
 main-distribution    f07e2d4bf2708c1085be38eca18aa9eb6755e547    (catalog main-distribution)
 racket-lib           41c7b3221006758c5a840a18dcc0d265632f14c2    (catalog racket-lib)
 [178 auto-installed packages not shown]
User-specific for installation "6.1":
 [none]



Collections:
("/Users/mt/Library/Racket/6.1/collects"
 (non-existent-path))
("/Applications/Racket v6.1/collects"
 (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))

Recent Internal Errors: 
Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t #t ((test) (main)) #t))
>Description:
Oops, Racket's color database seems to have been hacked: a
little name mix up: Cornflower Blue is Lavender where Lavender
probably is azzurro (in italian) where the database has a french
sounding entry named azure. The other CornflowerBlue is alright
but the way things are you're now allowed to pick any colors not
only the ones named after flowers.
Just changing the names again would probably not be the right solution. Steps to reproduce might contain other issues (Redrw
>How-To-Repeat:
#lang racket

;; This is the message passing approach to the patience solitaire game
;; Flower Garden.
;;
;; This is the variant Flower Venus Garden with a relaxed ruleset.  You
;; can move only one card at time but from anywhere to anywhere.
;; Sequences in the flower beds have to be build by suit.  The
;; foundations are built from ace to king but cards can be moved back
;; into the game. You can double click a card and if possible it will
;; find its place in the foundations. You can place up to sixteen
;; cards in the bouquet. There is a good chance of winning the game.
;;
;; (The layout of the bouquet, i.e. the reserve of cards at the bottom
;; of the table is done automatically but only after a card has been
;; moved successfully. Rethinking and correcting this is left as
;; exercise for the interested player.)
;;
;; Description & Rules
;;
;; One deck of 52 cards.
;;
;; < from wikipedia
;; Thirty-six cards are dealt in to six columns, each containing six
;; cards. The columns are called the "flower beds" and the entire
;; tableau is sometimes called "the garden." The sixteen leftover
;; cards become the reserve, or "the bouquet."
;;
;; The top cards of each flower-bed and all of the cards in the
;; bouquet are available for play. Cards can only be moved one at a
;; time and can be built either on the foundations or on the other
;; flower beds. The foundations are built up by suit, from Ace to King
;; (a general idea of the game is to release the aces first). The
;; cards in the garden, on the other hand, can be built down
;; regardless of suit and any empty flower bed can be filled with any
;; card. The cards in the bouquet can be used to aid in building, be
;; put into the foundations, or fill an empty flower bed.
;;
;; The game is won when all cards end up in the foundations.
;; > end from wikipedia
;;

;;
;; Technical Note: While it is written in a rather traditional way
;; without mixins, traits or an emphasis on surrogates it might
;; contain ideas, concepts and terms that go beyond today's message
;; passing "customs". A new message passing primitive "broadcast" and
;; the term hub for certain classes are consequences of thinking about
;; the future of message passing, parallel objects and one new program
;; code abstraction system "to rule them all" especially when it comes
;; to open source and the user's ability to adapt and program the
;; shiny some thousand money units worth machine in front of him. From
;; LISP machines to BSD to Mach message passing microkernel to
;; NextStep to ... but that is far away: for me it was from QBASIC to
;; RISC assembler to NetBeans to Dr. Racket to whatever comes in
;; handy.
;;

;;
;; Description of the User Interaction
;;
;; Most of the event handling is done by the views card<%>, table<%>
;; and region. (See Event Handling)
;;
;; According to the rules only one card may be moved at any time.
;;

;;
;; Bugs and Maintenance
;;
;; Bug (unreproducible): in a new game after program start the second
;; card in a flower bed which was face down could be moved. As
;; reconfigure-cards in the flower-bed class is rather clear about
;; this issue and because it happened during the animation of an
;; unrelated move and is part of the Virtual Card Library's special
;; behaviours.

;;;
;;; Modules and Dependencies
;;;

(require games/cards racket/gui racket/class racket/unit)

;(load "card-logic.rkt")
;(include (file "card-logic.rkt"))


;;;
;;; Extension of the Algorithmic Language Scheme
;;;

;; (define (broadcast object-list method . arguments)
;;   {define (apply-messages object)
;;     (send/apply object method arguments)}
;;   (map apply-messages object-list))

(define-syntax cast (syntax-rules () ((_ type) (cdr type))))
(define-syntax broadcast
  (syntax-rules ()
    ((_ object-list method ...)
     (map {lambda (object) (send object method ...)}
          object-list))))
(define-syntax broadcast*
  (syntax-rules ()
    ((_ object-list method ...)
     (map {lambda (object) (send* object method ...)}
          object-list))))

(define (repeat n closure)
  "Execute closure n times."
  (if (not (and (exact? n) (integer? n)  ; 'integer?' does not check for exactness ...
                (>= n 0)))
      (error "repeat: the parameter n must be an exact natural number or zero.")
      {let loop ((i 0))
        (when (< i n)
          (closure)
          (loop (add1 i)))} ))

(define (half numerical) (/ numerical 2))

(define wheels
  ;; Every car has four wheels.
  car)

;;
;; The Virtual Card Library wants us to program in assembler
;; style. This is how we escape it.
(define (w/o-cart-animation table closure)
  "Don't let the car's movement be shown."
  (let ((returned-value void))
    (send table begin-card-sequence)	; determine the winning card sequence
    (set! returned-value (closure))
    (send table end-card-sequence)
    returned-value))

(define-syntax w/o-cart-animation*
  (syntax-rules ()
    ((_ table first-expression ...)
     ;; 'returned-value' was accessible by the expressions in the expansion;
     ;; that was a shortcoming.
     ;; It might even have shadowed a definition for that symbol at the
     ;; position of the expansion. That would have beeen a pity.
     ;;
     ;; We're now creating a closure for the expressions.
     ;; This should be safe, hygienic or however you want to call it.
     (let* ([closure {lambda ()
                       first-expression
                       ...}]
            [returned-value void]) 
       (send table begin-card-sequence)
       (set! returned-value (closure))
       (send table end-card-sequence)
       returned-value) )))

(define create-cell-and-attach cons)

;; That is "sea cat" but where is "bee cat"?
;; (You might even find "a cat").
(define sea-cat create-cell-and-attach)


;;;
;;; Card Logic
;;;

;;
;; Card Suits and Colors: Predicates and Utility Procedures

(define (suit-color suit-symbol)
  "Return 'red for 'heart and 'club. Return 'black for 'diamond or 'spade. Else false."
  (case suit-symbol
    [(hearts diamonds) 'red]
    [(clubs spades) 'black]
    [(unknown) (debug "card logic: suit-color: unknown suit") #f] ; this entry exists for completeness as card<%> get-suit might return 'unknown
    [else (warning "card logic: suit-color: suit not found: " suit-symbol) #f]))

(define (card-color card)
  "Return the color of the card's suit like suit-color."
  (suit-color (send card get-suit)))

(define (card-is-red? card)
  "Return true if the color of the card's suit is red."
  (eq? (card-color card) 'red))

(define (card-is-black? card)
  "Return true if the color of the card's suit is black."
  (eq? (card-color card) 'black))


;;
;; Card Rank Predicates

(define (card-is-ace? card)
  "Return true if the card is an ace."
  (= (send card get-value) 1))

(define (card-is-king? card)
  "Return true if the card is a king."
  (= (send card get-value) 13))

(define (card-is-queen? card)
  "Return true if the card is a queen."
  (= (send card get-value) 12))

(define (card-is-joker? card)
  "Reutrn true if the card is a joker."
  (= (send card get-value) 11))

(define (card-is-ten? card) "Return true if the card is a ten."
  (= (send card get-value) 10))

(define (card-is-nine? card) "Return true if the card is a nine."
  (= (send card get-value) 9))

(define (card-is-eight? card) "Return true if the card is an eight."
  (= (send card get-value) 8))

(define (card-is-seven? card) "Return true if the card is a seven."
  (= (send card get-value) 7))

(define (card-is-six? card) "Return true if the card is a six."
  (= (send card get-value) 6))

(define (card-is-five? card) "Return true if the card is a five."
  (= (send card get-value) 5))

(define (card-is-four? card) "Return true if the card is a four."
  (= (send card get-value) 4))

(define (card-is-three? card) "Return true if the card is a three."
  (= (send card get-value) 3))

(define (card-is-two? card) "Return true if the card is a two."
  (= (send card get-value 2)))


;;;
;;; Card Binary Predicates

;; Card Rank Binary Predicates

(define (card-one-rank-below? first-card second-card)
  "Return true if the first-card is one rank below the second-card."
  (let ((first-value (send first-card get-value))
        (second-value (send second-card get-value)))
    (= 1 (- second-value first-value))))

(define (card-one-rank-above? first-card second-card)
  "Return true if the first-card is one rank above the second-card."
  (card-one-rank-below? second-card first-card))

(define (card-next-rank? first-card second-card)
  "Return true if the first card is one rank above or below the second-card."
  (or (card-one-rank-below? first-card second-card)
      (card-one-rank-above? first-card second-card)))

(define (card-circular-one-rank-below? first-card second-card)
  "Return true if card-one-rank-below? is true or if the first-card is a king and second-card is an ace."
  (or (card-one-rank-below? first-card second-card)
      (and (card-is-king? first-card)
           (card-is-ace? second-card))))

(define (card-circular-one-rank-above? first-card second-card)
  "Return true if card-one-rank-above? is true or if the first-card is an ace and the second-card is a king."
  (or (card-one-rank-above? first-card second-card)
      (and (card-is-ace? first-card)
           (card-is-king? second-card))))

(define (card-circular-next-rank? first-card second-card)
  "Return true if card-next-rank? is true or if the two cards are a king and an ace."
  (or (card-next-rank? first-card second-card)
      (or (and (card-is-king? first-card) (card-is-ace? second-card))
          (and (card-is-ace? first-card) (card-is-king? second-card)))))


;; Card Color and Suit Binary Predicates

(define (card-same-color? first-card second-card)
  "Return true if the color of the first-card's suit is the same as the one of the second-card."
  (eq? (card-color first-card)
       (card-color second-card)))

(define (card-same-suit? first-card second-card)
  "Return true if the suit of the first-card is the same as the one of the second-card."
  (eq? (send first-card get-suit)
       (send second-card get-suit)))


;;;
;;; Debugging and other Developer Utilities
;;;

(define (debug . args)
  (display "Flower Garden: ")
  (for-each {lambda (arg) (display arg)}
            args)
  (newline))

(define (warning . args)
  (apply debug "WARNING: " args))

;;; End of Pretext

;;
;; Layout
;;
;; This abstract layout hub class keeps the layout in one spot.
;; This approach rips open the encapsulation of the other classes
;; but in this case it's more important to seperate layout from logic.
;;
;; As a general layout message passing protocol objects requesting
;; layout information send themselves as arguments even if this is
;; right now unecessary in some cases. In most cases though this
;; layout hub needs more information from the object, e.g. the index
;; of a stack to provide the correct layout information.
;;
;; About this layout for Flower Garden:
;;
;; The layout is hardcoded: it will not adapt to a change in the
;; number of stacks. A different number of stacks would be a different
;; game anyway. It should be rather easy to exchange the meaning of
;; row and column in this layout though. But it might even be
;; intertwined: not always following its inner logic.
;;
;; The layout is completely based on the playing card dimensions:
;;  for this it needs one unit card to retrieve the dimensions.
;;
;; There is an upper border and a left border.
;; There are six columns with intercolumn spacing.
;; There are three rows with interrow spacing.
;;  The first row contains the centered four foundations.
;;  The second row contains the six flower beds.
;;  The third row contains the bouquet.

{define layout%
  (class
      object%
    (init unit-card)
    (super-new)
    (define card-width (send unit-card card-width))
    (define card-height (send unit-card card-height))
    ;; ??? perhaps we should release unit-card here
    
    (define default-spacing-unit (/ card-width 7)) ; confront with table width
    
    (define upper-border default-spacing-unit)
    (define left-border default-spacing-unit)
    (define intercolumn-space default-spacing-unit)
    (define interrow-space (* 2 default-spacing-unit))
    
    (define (column-n-x n)
      "Return the x coordinate of the left border of the n'th column."
      (+ left-border (* (+ card-width intercolumn-space)
                        (sub1 n))) )
    
    ;;
    ;; Layout of the Table
    
    ;; One card width for each column plus one for spacing.
    (define/public (get-table-width garden) 7)
    
    ;; One card height for the foundations, one for the bouquet, one
    ;; for spacing and four card heights for the flower bed.
    (define/public (get-table-height garden) 7)

    ;; Table Background
    (define fixed-window-border 0)
    (define flower "Lavender")
    (define/public (get-background-x-coordinate garden)
      fixed-window-border)
    (define/public (get-background-y-coordinate garden)
      fixed-window-border)
    (define/public (get-background-width garden)
      (- (* card-width (get-table-width garden))
         (* 2 fixed-window-border)))
    (define/public (get-background-height garden)
      (- (* card-height (get-table-height garden))
         (* 2 fixed-window-border)))
    (define/public (get-background-paint-callback garden)
      ;; This is design and not only layout.
      ;; See the documentation of color-database<%> for color names.
      ;; (But you're only allowed to use colors named after flowers. ;-)
      {lambda (drawing-context x y width height)
	;; XXX there is some redrawing shortcoming at the right border
	;; and at the lower border
	(send drawing-context set-background flower)
        (send drawing-context clear)
	}) 
    (define/public (flower-present selected-flower)
      (set! flower selected-flower))
    
    ;;
    ;; Layout of the Foundations
    (define foundation-top-line
      upper-border)
    (define/public (get-foundation-x-coordinate foundation)
      (let ((foundation-index (send foundation get-foundation-index)))
        (column-n-x (+ foundation-index 1))))
    (define/public (get-foundation-y-coordinate foundation)
      foundation-top-line)
    (define/public (get-foundation-width foundation)
      card-width)
    (define foundation-height card-height)
    (define/public (get-foundation-height foundation)
      foundation-height)
    
    ;;
    ;; Layout of the Flower Beds
    (define flower-bed-top-line
      (+ foundation-top-line
         foundation-height
         interrow-space))
    (define/public (get-flower-bed-x-coordinate flower-bed)
      (let ((flower-bed-index (send flower-bed get-flower-bed-index)))
        (column-n-x flower-bed-index)))
    (define/public (get-flower-bed-y-coordinate flower-bed)
      flower-bed-top-line)
    (define flower-bed-width card-width)
    (define/public (get-flower-bed-width flower-bed)
      flower-bed-width)
    ;; Each flower bed needs to accomodate up to 18 cards.
    (define flower-bed-card-y-offset (/ card-height 3))
    (define flower-bed-height (+ (* 1  card-height)
                                 (* 8 flower-bed-card-y-offset)))
    (define/public (get-flower-bed-height flower-bed)
      flower-bed-height)
    
    ;;
    ;; Layout of the Bouquet
    (define bucket-top-line
      (+ flower-bed-top-line
         flower-bed-height
         (* 3/2 interrow-space)))	; this extra space makes it look better
    (define/public (get-bucket-x-coordinate bucket)
      (column-n-x 1)) ; bucket's left border is aligned to the first column
    (define/public (get-bucket-y-coordinate bucket)
      bucket-top-line)
    (define/public (get-bucket-width bucket)
      (- (+ (column-n-x 6) flower-bed-width)
         left-border)) ; bucket's right border is aligned to the last column
    (define/public (get-bucket-height bucket)
      [+ (* 3/4 default-spacing-unit) ; there is no sense if not asthetic sense
         (* 3/2 card-height)]) ; give the user some space and fill the table
    
    ;;
    ;; Card Layout
    (define (stack-layout-cards! foundation)
      (let ((cards (reverse (send foundation get-cards)))
            (region (send foundation get-region)))
        (send* (send (send foundation get-garden)
                     get-table)
          (stack-cards (reverse cards)) ; z-axis-stacking
          (move-cards cards
                      (region-x region)
                      (region-y region)))))
    (define foundation-layout-cards! stack-layout-cards!)
    
    (define (flower-bed-layout-cards! flower-bed)
      (let* ((cards (reverse (send flower-bed get-cards)))
             (region (send flower-bed get-region))       
             (number-of-cards (length cards))
             ;(card-height (send (wheels cards) card-height))
             (offset flower-bed-card-y-offset)
             (height (region-h region)))
        (when (> (+ card-height (* number-of-cards offset))
                 height)
          ;					; y = ch + (nc-1)*of
          ;					; y-ch / (nc-1) = of
          (set! offset (/ (- height card-height)
                          (sub1 number-of-cards))))
        (send* (send (send flower-bed get-garden) get-table)
          (stack-cards (reverse cards)) ; z-axis-stacking
          (move-cards cards
                      (region-x region)
                      (region-y region)
                      {lambda (n)
                        (values 0 (* offset n)) } ))))
    
    
    ;; Preserve x-axis order and DO NOT preserve the y-coordinates
    ;(define (x-selector x y) x)
    ;   (define (get-card-x-coordinate card table) 
    ;     (call-with-values (lambda ()
    ;                         (send table card-location card))
    ;                       (lambda (x y) x)))
    (define bucket-card-top-line (+ bucket-top-line
                                    (* 2 default-spacing-unit)))
    (define (bucket-layout-cards! bucket)
      (let* ((table (send (send bucket get-garden) get-table))
             (cards (sort (send bucket get-cards)
                          [lambda (first-card second-card)
                            (let-values (([x1 y1] (send table card-location first-card))
                                         ([x2 y2] (send table card-location second-card)))
                              (< x1 x2))]))
;             (y-coordinates (list->vector
;                             (map {lambda (card) ; retrieve sorted y-coordinates
;                                    (let-values
;                                        ([(x y)
;                                          (send table card-location card)])
;                                      (if (< y bucket-card-top-line)
;                                          (* 2 default-spacing-unit)
;                                          (- y bucket-top-line)))}
;                                  cards)))
             (number-of-cards (send bucket number-of-cards))       
             (region (send bucket get-region))
             ;(card-height (send (wheels cards) card-height))
             (width (region-w region))
             ;; Racket doesn't know how to divide by zero so we have to
             ;; check and in the case of a too small number of cards we
             ;; use infinity as the offset for the other cards
             ;; that do not even exist. But infinity is bigger than the
             ;; the maximum offset and that is what we want. Thus dividing
             ;; by zero should (at least as an option) yield infinity because
             ;; well behaved algorithms can continue correctly and might
             ;; even depend on the mathematical consequences of using the
             ;; "symbol" or concept of infinity.
             [offset (if (> number-of-cards 1)
                         (begin (/ (- width (* 1 card-width))
                                   (sub1 number-of-cards)))
                         ; This is correct when number-of-cards is one.
                         ; This is wrong for number-of-cards less than
                         ; or equal to 0 which should not happen. 
                         +inf.0)]
             [maximum-offset (* 3/2 card-width)]
             [centered-x-offset 0])
        (cond
;              [[> offset maximum-offset]
;               ;; This is difficult to test as the situation arises only
;               ;; later on in the game.
;               (set! offset maximum-offset)
;               (set! centered-x-offset
;                     {half [- (region-w region)
;                              {+ card-width [* offset (- number-of-cards 1)]}]} )]
              ;; When the offset is too close to card-width it looks better
              ;; not to put one card next to the other but to fan them.
              ([> offset (* 2/3 card-width)]
               (set! offset (* 2/3 card-width))
               (set! centered-x-offset
                     {half [- (region-w region)
                              {+ card-width [* offset (- number-of-cards 1)]}]} )))
        (send* (send (send bucket get-garden) get-table)
          (stack-cards (reverse cards)) ; z-axis-stacking
          (move-cards cards
                      (+ (region-x region) centered-x-offset)
                      (region-y region)
                      {lambda (n)
                        (values (* offset n)
                                (* 2 default-spacing-unit))
                                ;(vector-ref y-coordinates n))
                                } ))))
    
    (define/public (layout-cards! stack)
      (cond ([is-a? stack foundation%] (foundation-layout-cards! stack))
            ([is-a? stack flower-bed%] (flower-bed-layout-cards! stack))
            ([is-a? stack bucket%] (bucket-layout-cards! stack))
            (else
             (warning "layout%: layout-cards!:"
                      " no registered card layout found for type: "
                      (object-interface stack)
                      ": using fallback: stack-layout-cards!")
             (stack-layout-cards! stack))))
    )}

;;
;; Flowers
;;
;; Now this is the stupid approach to class redefinition (see
;; Guile/GOOPS). We need each card object to have a back link to its
;; stack. While card% does feature a home-region where region is the
;; "view" of the stack the region structure does not provide a list of
;; cards and thus it does not keep track of the sequence of cards. We
;; do this in the model with a list (see stack%). Then the message
;; passing protocol for the region callbacks gives us a list of cards
;; dragged to a region and we can add these cards to the stack of the
;; target. But how do we remove these cards from the stack where the
;; cards came from? BTW The implementation of Spider loops through all
;; stacks. We do that with broadcast.

(define (reset-flowers flowers)
  (broadcast* flowers
              (face-down)
              (user-can-flip #f)
              (snap-back-after-move #t)
              (user-can-move #f))
  flowers)

(define (make-flowers flowers)
  (reset-flowers flowers))

(define flower-dialog%
  {class
   dialog%
   (init garden)
   (define my-garden garden)
   (super-new [label "Flowers"]
	      [parent (send my-garden get-table)]
	      [stretchable-width #f]
	      [stretchable-height #f])
   ;; See the documentation of color-database<%> for color names.
   ;; (But you're only allowed to use colors named after flowers. ;-)
   ;; Oops, Racket's color database seems to have been hacked: a
   ;; little name mix up: Cornflower Blue is Lavender where Lavender
   ;; probably is azzurro (in italian) where the database has a french
   ;; sounding entry named azure. The other CornflowerBlue is alright
   ;; but the way things are you're now allowed to pick any colors not
   ;; only the ones named after flowers.
   (define flowers
     (list
      ;"Pale Green" ; you might take this for the infamous Mint Green
      "Lavender"
      "FloralWhite"
      "MistyRose"
      "Cornflower Blue" 
      "Orchid"
      "Violet Red"
      ))
   (define flower-chooser
    (new radio-box%
	 [label #f]
	 [parent (new group-box-panel%
		      [parent this]
		      [label "You can pick a flower!"]
		      [stretchable-width #f]
		      [stretchable-height #f])]
	 [choices flowers]))
   (define bottom-panel
     (new horizontal-panel%
	  [parent this]
	  [alignment '(center center)]
	  [stretchable-height #f]))
   (new button%
       [parent bottom-panel]
       [label "&Ok"]
       [style '(border)]
       [callback {lambda (b e)
		   (send my-garden flower-picked
			 (vector-ref (list->vector flowers)
				     (send flower-chooser get-selection)))
		   (send this show #f)} ])

   (define/public (flower-present)
     ;(set! flowers (shuffle-list *flower-list* 12))
     (send this center)
     (send this show #t))
})

;;
;; Stacks
;;
;; There are three kinds of stacks: foundations, flower beds and
;; bouquet. Layouting is done with the help of the layout hub object
;; as retrieved from the hosting garden object.
;;
;; While each card<%> object knows about its home-region, the regions
;; are not aware of these cards. To get all the cards in one region on
;; the table we could ask each card individually or keep track of all
;; the moves and maintain the missing list of cards for each stack.
;;
;; NB Asking all card objects on the table about their home-region is
;; not too time consuming, i.e. O(n), where each deck brings only 52
;; objects into the game.

(define stack%
  {class
      object%
    (init garden)
    (super-new)
    
    ;;
    ;; Fields
    (define cards null)
    (define my-region null)
    (define my-garden garden)
    
    ;; Accessors
    (define/public (get-garden) my-garden)
    (define/public (get-layout)
      (send my-garden get-layout))
    
    (define/public (add-card card-to-add)
      (send (send this get-garden) syncronize-stacks card-to-add)
      (set! cards (sea-cat card-to-add cards))
      (send* card-to-add
        (home-region my-region)
        ;(stay-in-region my-region)
        )
      (send (get-layout) layout-cards! this)
      )
    
    (define/public (remove-card! card-to-remove)
      (set! cards (filter {lambda (card) (not (eq? card card-to-remove))} cards)))
    
    (define/public (move-done)
      ;(send (get-layout) layout-cards! this)
      #t)
    
    (define/public (number-of-cards) (length cards))
    (define/public (empty?) (null? cards))
    (define/public (get-cards) cards)
    
    ;;    (define/public (syncronize-cards-on-region)
    ;;      (set! cards (filter (lambda (card)
    ;;                            (equal? (send card home-region)
    ;;                                    my-region))
    ;;                          cards)))
    
    ;;   (define/public (after-or-before-drag finished-on-region? cards)
    ;;     #t)
    (define/public (get-region) my-region)
    (define/public (set-region new-region)
      (set! my-region new-region)
      ;     (set-region-interactive-callback!
      ;      my-region
      ;      {lambda (finished-on-region? cards)
      ;	(send this after-or-before-drag finished-on-region? cards)})
      )
    })

(define foundation%
  {class
      stack%
    (init foundation-index)
    (super-new)
    
    (define my-index foundation-index) 
    
    (define (foundation-region-callback cards)
      (send (send this get-garden) place-on-foundation-request (wheels cards) this))
    
    (let ((layout (send this get-layout)))
      (send this set-region
            (make-region
             (send layout get-foundation-x-coordinate this)
             (send layout get-foundation-y-coordinate this)
             (send layout get-foundation-width this)
             (send layout get-foundation-height this)
             "Foundation"
             foundation-region-callback)))
    (send (send (send this get-garden) get-table)
          add-region (send this get-region))
    
    (define/public (get-foundation-index) my-index)
    })

(define flower-bed%
  {class
      stack%
    (init flower-bed-index)
    (super-new)
    
    (define my-index flower-bed-index) 
    
    (define (flower-bed-region-callback cards)
      (send (send this get-garden) place-on-flower-bed-request (wheels cards) this))
    
    (let ((layout (send this get-layout)))
      (send this set-region
            (make-region
             (send layout get-flower-bed-x-coordinate this)
             (send layout get-flower-bed-y-coordinate this)
             (send layout get-flower-bed-width this)
             (send layout get-flower-bed-height this)
             #f ;"Flower Bed"
             flower-bed-region-callback)))
    (send (send (send this get-garden) get-table)
          add-region (send this get-region))
    
    (define/public (get-flower-bed-index) my-index)
    
    (define (reconfigure-cards)
      (let ((my-cards (send this get-cards)))
        (broadcast* my-cards
                    (user-can-move #f)
                    (snap-back-after-move #t))
        (when (not (null? my-cards))
          (let ((top-card (wheels my-cards)))
            (when (send top-card face-down?) (send top-card face-up))
            (send top-card user-can-move #t)) )))
    
    (define/override (move-done)
      (reconfigure-cards))
    ;(send (send this get-layout) layout-cards! this))
    })

;; According to the game play bucket% might not even be a
;; stack%. Technically speaking it does not impose any useful order
;; onto the cards but is the reserve and its layout could be done by
;; the user. Quality assurance (me when I just want to play) assured
;; us though that doing the layout by hand isn't much fun and they
;; would prefer us to do the layout for the user.
(define bucket%
  {class
      stack%
    (super-new)
    
    (define (bucket-region-callback cards)
      (send (send this get-garden) place-on-bucket-request (wheels cards) this))
    
    (let ((layout (send this get-layout)))
      (send this set-region
            (make-region
             (send layout get-bucket-x-coordinate this)
             (send layout get-bucket-y-coordinate this)
             (send layout get-bucket-width this)
             (send layout get-bucket-height this)
             #f ;"Bouquet"
             bucket-region-callback)))
    (send (send (send this get-garden) get-table)
          add-region (send this get-region))
    
    (define (prepare-card-for-bucket card)
      (when (send card face-down?) (send card face-up))
      (send* card
        ;(face-up)
        (snap-back-after-move #f)
        (user-can-move #t)
        ))
    
    (define/override (add-card card)
      (prepare-card-for-bucket card)
      (super add-card card))
    
    (define/override (move-done)
      (send (send this get-layout) layout-cards! this))
    
    ;;    (define/override (after-drag finished-on-region? cards)
    ;;      (send (send this get-layout) layout-cards! this))
    })

;;
;; Garbage Collection
;;
;; Sometimes the garbage collector (3m) starts running in the midst of
;; an animation or worse in the middle of a user interaction like a
;; drag. To avoid that this happens we call the garbage collector in
;; right after the initial deal. The user interface effects of the
;; initial deal show up only after the garbage collector returned. For
;; this the user might stare at a gray empty window for a short period
;; of time.
;;
;; Usually after each move-done there should be enough time to run the
;; garbage collector because the user thinks about his next move or is
;; on the way of reacting to the visual feedback (if we were talking
;; about milliseconds) BUT: user interface changes are only shown
;; after the event handler returned (to the internal event handling
;; loop) AND the garbage collector seems to be really slow. Starting
;; Flower Garden from the command line instead of running it in the
;; IDE reduces the time the garbage collector takes noticeably but
;; it's still too slow on a 2.4 GHz Dual Core. Racket and the used
;; libraries/modules/packages do need a lot of RAM - about 200 MB but
;; running the garbage collector all the time (at each move-done) does
;; not reduce the time it needs. (BTW It's still 2015 by the time of
;; this writing or should I say: already 2015)?
;;
;; Fast memory allocation might be a performance issue for one-way win
;; the race scientific applications but for end user applications like
;; this it would be better to have fast garbage collection which
;; doesn't need ages - especially when there is nothing to be done and
;; next to no changes in the data structures since the last run.

;;
;; Program Action Hub
{define garden%
  (class
      object%
    (super-new)
    
    (define number-of-foundations 4)
    (define number-of-flower-beds 6)
    
    (define flower-selection #f)
    
    (define flowers (make-flowers (make-deck)))
    (define layout (new layout% (unit-card (wheels flowers))))
    
    ;; ;; ;; ;; ;; ;; ;; ;;
    ;; This should be a subclass of table% named
    ;; flower-garden-table%
    ;; But make-table won't let us do this conveniently ???
    (define garden (make-table
                    "Flower Venus Garden" ; title
                    (send layout get-table-width this)
                    (send layout get-table-height this) ))
    
    ;; Redefine mouse interaction. See documentation.
    (send* garden
      (set-button-action 'left 'drag-raise/one)
      (set-button-action 'middle 'drag-raise/one)
      (set-button-action 'right 'drag-raise/one))
    
    (define (dummy-mouse-event-handler card)
      #t)
    
    ;; Event Handling
    ;;
    ;; There is no documented message passing protocol for the event
    ;; stream coming from region and table objects. There is no well
    ;; defined order but we can look at the order of events arriving
    ;; and think about it. A drag starts out with a single click
    ;; event. That single click event might or might not match our
    ;; interactor model but we need to make its consequences unhappen
    ;; because the user did not click but drag and we got to know about
    ;; this only later on. There is a place to do that: see
    ;; set-interactive-region-callback! in stack% add-region.
    ;;
    ;; A double click is a time and coordinate dependent event usually
    ;; composed of two single clicks. Depending on the libraries and
    ;; low level routines in use we might expect to see the following
    ;; sequences in the event stream on the same card in a short time
    ;; interval: a period "." denotes a single click event, a colon ":"
    ;; denotes a double click event
    ;;
    ;; ..  two clicks no double click event
    ;; :   one double click event - no single click events
    ;; .:  one single click event and one double click event
    ;; ..: two single click events and one double click event
    ;; :.. one double click event and two single click events
    ;; .:. one single click event then a double click event then
    ;;      a single click event again
    ;;
    ;; We can adapt our interaction model or Interactor (see Garnet) to
    ;; avoid misinterpreting events. A single click sets the selection
    ;; and the next click clears the selection. A double click clears
    ;; the selection. With this behaviour in mind there remain two
    ;; cases of event sequences which are not handled in the right way:
    ;; the first one (..) which is degenerate because there is no
    ;; double click event at all. We could try to look at the time
    ;; codes of the events and determine if it was a double click or
    ;; not but we cannot check the pointer coordinates here which is
    ;; crucial to recognize double clicks and drags. Then the last
    ;; sequence (.:.) is problematic, too. And testing suggests that
    ;; this is our favourite one and only sequence of events. On the
    ;; developer's machine each double click event is surrouned by
    ;; single clicks and we end up with a card that has already been
    ;; moved by the double click event which cleared selection and we
    ;; now receive a single click event for that card: it ends up
    ;; selected (in a foundation). Please bear in mind that a click
    ;; event is a synthesized composed event itself: usually a click is
    ;; defined as the following sequence of low level events: mouse
    ;; button down, mouse button up (within the same spot region in
    ;; screen coordinates). The Virtual Card Library does not use that
    ;; definition of a click. Another aspect of our event handling here
    ;; to keep in mind is the fact that we do not recieve a stream of
    ;; events as a stream of events but the user defined thunks are
    ;; invoked as event handlers at certain not well defined moments
    ;; not in time but in the execution order of the Virtual Card
    ;; Library routines intertwined with garbage collection and
    ;; operating system interaction.
    ;;
    ;; Interaction Models have to be learned by the user. Some are
    ;; nowadays common accepted standard (even if not well documented)
    ;; but everything changes: where you're favourite lisp based action
    ;; game developing environment from back then allowed you to choose
    ;; one of a set of actions and then apply it on some object today
    ;; we expect to select the object.e.g. file and then choose one of
    ;; its associated actions, e.g. delete. This is true on most modern
    ;; graphical user interaction shells. But when you do graphic
    ;; design and photo retouch we first choose the action or tool and
    ;; then apply it to some part of the object to design. Vice verse
    ;; these behaviours and people will tell you that it's completely
    ;; broken even if they're already used to both interaction models.
    ;; I don't touch I click - but that's another chapter and out of
    ;; the scope of this little card game.
    ;;
    ;; Some interaction models to not work out anyway: the select card
    ;; then destination approach falls for Moon Flower Garden because
    ;; the bucket is full of cards. Do you want to move the flower to
    ;; the bucket or do you want to select a card in the bucket?
    
    (send* garden
      (set-double-click-action ;dummy-mouse-event-handler)
       {lambda (flower)
         ;(debug "flower-garden-table%: double-click-action")
         (send this rescue-request flower)})
      (set-single-click-action dummy-mouse-event-handler) )
    ;; 	   {lambda (flower)
    ;;              (debug "flower-garden-table%: single-click-action")
    ;; 	     (send this selection-request flower)}))

    (send garden add-region
	  (make-background-region
	   (send layout get-background-x-coordinate garden)
	   (send layout get-background-y-coordinate garden)
	   (send layout get-background-width garden)
	   (send layout get-background-height garden)
	   (send layout get-background-paint-callback garden)))
 
    ;;
    ;; Animations
    ;;
    ;; It seems the animation of the Virtual Card Library are
    ;; primarily intended to visualize algorithms or better: their
    ;; time ordered consequences. There is a problem where the
    ;; animation of a dragged card doesn't start at the final position
    ;; of the drag when/where the handler is called but it starts at
    ;; the original location of the card which might be percieved as
    ;; an unpleasant flickering. That behaviour of the animation
    ;; engine depends on a set home-region but not only. Not setting
    ;; the home-region at all in the class definition of stack% gives
    ;; us the correct starting positions for the animations after a
    ;; drag from the Bouquet to a Flower Bed. All drags originating
    ;; from Flower Beds do still animate with the described wrong
    ;; starting position. This might have to do with one of the
    ;; messages in reconfigure-cards but after all: the animation
    ;; engine does not feature any fine grained control and is abusing
    ;; the cards<%> configuration in an undocumented way. Nevertheless
    ;; the wrong starting position seems to be a real bug of the
    ;; animation engine. BTW It doesn't animate snap backs either ...
    ;; Perhaps they want to fix it.

    ;(send garden animated #f)  ; turn animation off altogether
    
    ;; End of pseudo subclass flower-garden-table%
    ;; ;; ;; ;; ;; ;; ;; ;;

    (define my-bouquet (new flower-dialog% (garden this)))
    
    ;;
    ;; Create the Foundations
    ;; We could loop here or abbreviate with some lambda form
    ;; but I like to hardcode these things. A different number
    ;; of foundations makes a different game.
    (define foundations
      (list (new foundation% (garden this) (foundation-index 1))
            (new foundation% (garden this) (foundation-index 2))
            (new foundation% (garden this) (foundation-index 3))
            (new foundation% (garden this) (foundation-index 4))))
    
    ;;
    ;; Create the Flower Beds
    (define flower-beds
      (map {lambda (flower-bed-index)
             (new flower-bed%
                  (garden this)
                  (flower-bed-index flower-bed-index))}
           (list 1 2 3 4 5 6)))
    
    ;;
    ;; Create the bouquet.
    (define bouquet (new bucket% [garden this]))
    
    
    ;; ;; ;; ;; ;; ;; ;; ;;
    ;; This sort of extra stack handling is needed because of our
    ;; inability to subclass card% conveniently. See Flowers (flower%).
    (define stack-register (append (list bouquet) flower-beds foundations))
    (define/public (syncronize-stacks card)
      (broadcast stack-register remove-card! card))
    ;; ;; ;; ;; ;; ;; ;; ;;
    
    
    ;;
    ;; Internal Interface
    
    (define/public (get-layout) layout)
    (define/public (get-table) garden)
    (define/public (card-face-up card)	;; XXX
      (send garden card-face-up card))
    (define/public (flower-picked flower)
      (send layout flower-present flower))

    
    
    ;;
    ;; Rule Implementation Interface
    ;;
    ;; Where one part of a card game's rules usually becomes the game
    ;; mechanic, i.e. layout and user interaction, another part becomes
    ;; the game's logic. For convenience this is implemented here as
    ;; something that resembles a controller.
    ;;
    ;; To allow different difficulty levels we might want to introduce
    ;; flower-garden-ruleset<%> objects and delegate these calls to the
    ;; one representing the current ruleset.
    
    (define empty? null?)
    
    (define (initial-deal)
      ;; Prepare our card game.
      (set! flowers (shuffle-list flowers 6))
      
      ;; Throw the seeds. It's reversed to make them fly over not
      ;; under. This deals the cards visually from the bottom of the
      ;; deck. But when dealing from its top we would have to
      ;; re-stack-cards, i.e. changing the z-axis ordering, for the
      ;; whole table all the time.
      (send garden add-cards (reverse flowers) 0 0)
      
      (let ((flowers flowers))
        ;; Deal 6 cards on each flower bed.
        (repeat 6 {lambda ()
                    (for-each {lambda (flower-bed)
                                (send flower-bed add-card
                                      (wheels flowers))
                                (set! flowers (cast flowers))}
                              flower-beds)} )
        ;; Cut the flowers' wheels.
        (broadcast (map wheels (broadcast flower-beds get-cards))
                   face-up)
        ;; Deal the remaining cards into the bucket.
        (for-each {lambda (flower)
                    (send bouquet add-card flower)}
                  flowers))
      ;(clear-selection)
      (broadcast stack-register move-done)
      ;(collect-garbage)
      ) ; end of initial deal
    
    (define/public (place-on-flower-bed-request flower flower-bed)
      (let ((stacked (send flower-bed get-cards)))
        (when (or (empty? stacked)
                  (and (card-one-rank-below? flower (wheels stacked)) 
                       (card-same-suit? flower (wheels stacked))))
          (send flower-bed add-card flower)
          (broadcast stack-register move-done) )))
    
    (define (game-is-won?)
      (define (foundation-full? foundation)
        (let ((stacked (send foundation get-cards)))
          (and (not (null? stacked))
               (card-is-king? (wheels stacked))) ))
      (define (game-is-won? foundations)
        (if (null? foundations)
            #t
            (and (foundation-full? (wheels foundations))
                 (game-is-won? (cast foundations))) )) ; not tail recursive
      (game-is-won? foundations))
    
    (define/public (place-on-foundation-request flower foundation)
      (let ((stacked (send foundation get-cards)))
        (when [or (and (empty? stacked)
                       (card-is-ace? flower))
                  (and (not (empty? stacked))
                       (card-same-suit? flower (wheels stacked))
                       (card-one-rank-above? flower (wheels stacked)))]
          (send foundation add-card flower)
          ;(clear-selection)
          (broadcast stack-register move-done)
	  (when (game-is-won?) 
		(send my-bouquet flower-present)
		(reset-game) )) ))
    
    (define (is-playable? flower)
      (and (send flower user-can-move)
           (not (send flower face-down?))))
    
    (define/public (rescue-request flower)
      (when (is-playable? flower)
        ;; It's a bit like brute force but it's terse and readable.
        ;; (and with animation it looks really funny which makes
        ;; you lough and that is a good thing [for a card game]!)
        (for-each {lambda (foundation)
                    (place-on-foundation-request flower foundation)}
                  foundations)))
    
    
    (define/public (place-on-bucket-request flower bucket)
      (when [< (send bucket number-of-cards) 16]
        (send bucket add-card flower)
        ;(clear-selection)
        (broadcast stack-register move-done) ))
    
    ;;
    ;; DEFUNCT Selection Handling Interface
    
    ;;    (define/public (clear-selection)
    ;;      ;(debug "garden%: clear-selection called; flower-selection: " flower-selection)
    ;;      ;(broadcast flowers dim #f)
    ;;      (when flower-selection
    ;; 	   (debug "garden%: clear-selection: clearing selection")
    ;; 	   ;(send flower-selection dim #f)
    ;;            ;(broadcast flowers dim #f)
    ;; 	   (set! flower-selection #f)))
    
    ;;    (define/public (selection-request flower)
    ;;      (debug "garden%: selection-request called")
    ;;      (if [and (eq? flower-selection flower)
    ;; 	      (send flower-selection dim)]
    ;; 	 (clear-selection)
    ;; 	 (when [is-playable? flower]
    ;; 	       (clear-selection)
    ;; 	       (set! flower-selection flower)
    ;; 	       (send flower dim #t)) ))
    
    
    ;;;
    ;;; Application Interface
    
    (define/public (grow)
      (send garden show #t)
      (w/o-cart-animation garden initial-deal))
    ;(initial-deal))
    
    (define/public (reset-game)
      [w/o-cart-animation* garden
                           ;; remove cards from the stacks (from the model)
                           (for-each {lambda (card)
                                       ;; ??? perhaps it's better to implement reset in
                                       ;; stack%
                                       (broadcast stack-register remove-card! card)}
                                     flowers)
                           ;; remove cards from the table (from the view)
                           (send garden remove-cards flowers)
                           
                           (reset-flowers flowers)
                           (initial-deal)])

    )}


;;
;; Application Class / Menu and System Interface
;;

(define flower-garden%
  {class
      object%
    (super-new)
    
    (define garden (new garden%))
    (define main-frame (send garden get-table))
    (define my-menu-bar (make-object menu-bar% main-frame))
    (define my-game-menu (make-object menu% "Game" my-menu-bar))
    (new menu-item%
         [label "Reset Game..."]
         [parent my-game-menu]
         [callback
          {lambda (i e)
            (when (eq? 'yes (message-box "Reset Game"
                                         "Are you sure you want to reset the game?"
                                         main-frame
                                         '(yes-no)))
              (send garden reset-game))}])
    (new separator-menu-item% [parent my-game-menu])
    (new menu-item%
         [label "Quit"]
         [parent my-game-menu]
         [callback {lambda (i e)
                     (send main-frame show #f)
                     (exit)}])
    
    
    (send garden grow)
    })

(define sort-by-suit (new flower-garden%))
>Fix:
>Audit-Trail:
From: Matthew Flatt <mflatt@cs.utah.edu>
To: michael.tiedtke@o2online.de, bugs@racket-lang.org
Cc: nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/15059: Color Database (color-database<%>) Name Mix up
Date: Mon, 11 May 2015 09:57:39 -0600

 Thanks for the report!
 
 "Cornflower Blue" is definitely a problem, and "Cadet Blue" is also
 slightly off from "CadetBlue". I think "Lavender" and "Azure" are
 mapped in the same way as standards, though.
 
 Colors mappings that don't match HTML 4.01:
 
            HTML            racket/draw
  Green     (0 128 0)       (0 255 0)
  Gray      (128 128 128)   (190 190 190)
  Maroon    (128 0 0)       (176 48 96)
  Purple    (128 0 128)     (160 32 240)
  Navy      (0 0 128)       (36 36 140)
 
 Other colors that are not part of the HTML standard, but are part of
 the SVG standard and supported by most browsers for HTML:
 
                 SVG            racket/draw
  Brown          (165 42 42)    (132 60 36)
  RebeccaPurple  (102 51 153)   [missing]
  Aquamarine     (127 255 212)  (112 216 144)
  DarkSeaGreen   (143 188 143)  (143 188 139)
 
 I'm not yet sure what to do. The mismatch seems bad, but changing the
 meaning of color names (which could break existing programs, especially
 for "Green") also seems bad.
 
 
 At Mon, 11 May 2015 01:16:02 -0400, michael.tiedtke@o2online.de wrote:
 > A new problem report is waiting at
 >   http://bugs.racket-lang.org/query/?cmd=view&pr=15059
 > 
 > Reported by Michael Tit-ke for release: 6.1
 > 
 > *** Description:
 > Oops, Racket's color database seems to have been hacked: a
 > little name mix up: Cornflower Blue is Lavender where Lavender
 > probably is azzurro (in italian) where the database has a french
 > sounding entry named azure. The other CornflowerBlue is alright
 > but the way things are you're now allowed to pick any colors not
 > only the ones named after flowers.
 > Just changing the names again would probably not be the right solution. Steps 
 > to reproduce might contain other issues (Redrw
 > 
 > *** How to repeat:
 > #lang racket
 > 
 > ;; This is the message passing approach to the patience solitaire game
 > ;; Flower Garden.
 > ;;
 > ;; This is the variant Flower Venus Garden with a relaxed ruleset.  You
 > ;; can move only one card at time but from anywhere to anywhere.
 > ;; Sequences in the flower beds have to be build by suit.  The
 > ;; foundations are built from ace to king but cards can be moved back
 > ;; into the game. You can double click a card and if possible it will
 > ;; find its place in the foundations. You can place up to sixteen
 > ;; cards in the bouquet. There is a good chance of winning the game.
 > ;;
 > ;; (The layout of the bouquet, i.e. the reserve of cards at the bottom
 > ;; of the table is done automatically but only after a card has been
 > ;; moved successfully. Rethinking and correcting this is left as
 > ;; exercise for the interested player.)
 > ;;
 > ;; Description & Rules
 > ;;
 > ;; One deck of 52 cards.
 > ;;
 > ;; < from wikipedia
 > ;; Thirty-six cards are dealt in to six columns, each containing six
 > ;; cards. The columns are called the "flower beds" and the entire
 > ;; tableau is sometimes called "the garden." The sixteen leftover
 > ;; cards become the reserve, or "the bouquet."
 > ;;
 > ;; The top cards of each flower-bed and all of the cards in the
 > ;; bouquet are available for play. Cards can only be moved one at a
 > ;; time and can be built either on the foundations or on the other
 > ;; flower beds. The foundations are built up by suit, from Ace to King
 > ;; (a general idea of the game is to release the aces first). The
 > ;; cards in the garden, on the other hand, can be built down
 > ;; regardless of suit and any empty flower bed can be filled with any
 > ;; card. The cards in the bouquet can be used to aid in building, be
 > ;; put into the foundations, or fill an empty flower bed.
 > ;;
 > ;; The game is won when all cards end up in the foundations.
 > ;; > end from wikipedia
 > ;;
 > 
 > ;;
 > ;; Technical Note: While it is written in a rather traditional way
 > ;; without mixins, traits or an emphasis on surrogates it might
 > ;; contain ideas, concepts and terms that go beyond today's message
 > ;; passing "customs". A new message passing primitive "broadcast" and
 > ;; the term hub for certain classes are consequences of thinking about
 > ;; the future of message passing, parallel objects and one new program
 > ;; code abstraction system "to rule them all" especially when it comes
 > ;; to open source and the user's ability to adapt and program the
 > ;; shiny some thousand money units worth machine in front of him. From
 > ;; LISP machines to BSD to Mach message passing microkernel to
 > ;; NextStep to ... but that is far away: for me it was from QBASIC to
 > ;; RISC assembler to NetBeans to Dr. Racket to whatever comes in
 > ;; handy.
 > ;;
 > 
 > ;;
 > ;; Description of the User Interaction
 > ;;
 > ;; Most of the event handling is done by the views card<%>, table<%>
 > ;; and region. (See Event Handling)
 > ;;
 > ;; According to the rules only one card may be moved at any time.
 > ;;
 > 
 > ;;
 > ;; Bugs and Maintenance
 > ;;
 > ;; Bug (unreproducible): in a new game after program start the second
 > ;; card in a flower bed which was face down could be moved. As
 > ;; reconfigure-cards in the flower-bed class is rather clear about
 > ;; this issue and because it happened during the animation of an
 > ;; unrelated move and is part of the Virtual Card Library's special
 > ;; behaviours.
 > 
 > ;;;
 > ;;; Modules and Dependencies
 > ;;;
 > 
 > (require games/cards racket/gui racket/class racket/unit)
 > 
 > ;(load "card-logic.rkt")
 > ;(include (file "card-logic.rkt"))
 > 
 > 
 > ;;;
 > ;;; Extension of the Algorithmic Language Scheme
 > ;;;
 > 
 > ;; (define (broadcast object-list method . arguments)
 > ;;   {define (apply-messages object)
 > ;;     (send/apply object method arguments)}
 > ;;   (map apply-messages object-list))
 > 
 > (define-syntax cast (syntax-rules () ((_ type) (cdr type))))
 > (define-syntax broadcast
 >   (syntax-rules ()
 >     ((_ object-list method ...)
 >      (map {lambda (object) (send object method ...)}
 >           object-list))))
 > (define-syntax broadcast*
 >   (syntax-rules ()
 >     ((_ object-list method ...)
 >      (map {lambda (object) (send* object method ...)}
 >           object-list))))
 > 
 > (define (repeat n closure)
 >   "Execute closure n times."
 >   (if (not (and (exact? n) (integer? n)  ; 'integer?' does not check for 
 > exactness ...
 >                 (>= n 0)))
 >       (error "repeat: the parameter n must be an exact natural number or zero.")
 >       {let loop ((i 0))
 >         (when (< i n)
 >           (closure)
 >           (loop (add1 i)))} ))
 > 
 > (define (half numerical) (/ numerical 2))
 > 
 > (define wheels
 >   ;; Every car has four wheels.
 >   car)
 > 
 > ;;
 > ;; The Virtual Card Library wants us to program in assembler
 > ;; style. This is how we escape it.
 > (define (w/o-cart-animation table closure)
 >   "Don't let the car's movement be shown."
 >   (let ((returned-value void))
 >     (send table begin-card-sequence)	; determine the winning card sequence
 >     (set! returned-value (closure))
 >     (send table end-card-sequence)
 >     returned-value))
 > 
 > (define-syntax w/o-cart-animation*
 >   (syntax-rules ()
 >     ((_ table first-expression ...)
 >      ;; 'returned-value' was accessible by the expressions in the expansion;
 >      ;; that was a shortcoming.
 >      ;; It might even have shadowed a definition for that symbol at the
 >      ;; position of the expansion. That would have beeen a pity.
 >      ;;
 >      ;; We're now creating a closure for the expressions.
 >      ;; This should be safe, hygienic or however you want to call it.
 >      (let* ([closure {lambda ()
 >                        first-expression
 >                        ...}]
 >             [returned-value void]) 
 >        (send table begin-card-sequence)
 >        (set! returned-value (closure))
 >        (send table end-card-sequence)
 >        returned-value) )))
 > 
 > (define create-cell-and-attach cons)
 > 
 > ;; That is "sea cat" but where is "bee cat"?
 > ;; (You might even find "a cat").
 > (define sea-cat create-cell-and-attach)
 > 
 > 
 > ;;;
 > ;;; Card Logic
 > ;;;
 > 
 > ;;
 > ;; Card Suits and Colors: Predicates and Utility Procedures
 > 
 > (define (suit-color suit-symbol)
 >   "Return 'red for 'heart and 'club. Return 'black for 'diamond or 'spade. Else 
 > false."
 >   (case suit-symbol
 >     [(hearts diamonds) 'red]
 >     [(clubs spades) 'black]
 >     [(unknown) (debug "card logic: suit-color: unknown suit") #f] ; this entry 
 > exists for completeness as card<%> get-suit might return 'unknown
 >     [else (warning "card logic: suit-color: suit not found: " suit-symbol) #f]))
 > 
 > (define (card-color card)
 >   "Return the color of the card's suit like suit-color."
 >   (suit-color (send card get-suit)))
 > 
 > (define (card-is-red? card)
 >   "Return true if the color of the card's suit is red."
 >   (eq? (card-color card) 'red))
 > 
 > (define (card-is-black? card)
 >   "Return true if the color of the card's suit is black."
 >   (eq? (card-color card) 'black))
 > 
 > 
 > ;;
 > ;; Card Rank Predicates
 > 
 > (define (card-is-ace? card)
 >   "Return true if the card is an ace."
 >   (= (send card get-value) 1))
 > 
 > (define (card-is-king? card)
 >   "Return true if the card is a king."
 >   (= (send card get-value) 13))
 > 
 > (define (card-is-queen? card)
 >   "Return true if the card is a queen."
 >   (= (send card get-value) 12))
 > 
 > (define (card-is-joker? card)
 >   "Reutrn true if the card is a joker."
 >   (= (send card get-value) 11))
 > 
 > (define (card-is-ten? card) "Return true if the card is a ten."
 >   (= (send card get-value) 10))
 > 
 > (define (card-is-nine? card) "Return true if the card is a nine."
 >   (= (send card get-value) 9))
 > 
 > (define (card-is-eight? card) "Return true if the card is an eight."
 >   (= (send card get-value) 8))
 > 
 > (define (card-is-seven? card) "Return true if the card is a seven."
 >   (= (send card get-value) 7))
 > 
 > (define (card-is-six? card) "Return true if the card is a six."
 >   (= (send card get-value) 6))
 > 
 > (define (card-is-five? card) "Return true if the card is a five."
 >   (= (send card get-value) 5))
 > 
 > (define (card-is-four? card) "Return true if the card is a four."
 >   (= (send card get-value) 4))
 > 
 > (define (card-is-three? card) "Return true if the card is a three."
 >   (= (send card get-value) 3))
 > 
 > (define (card-is-two? card) "Return true if the card is a two."
 >   (= (send card get-value 2)))
 > 
 > 
 > ;;;
 > ;;; Card Binary Predicates
 > 
 > ;; Card Rank Binary Predicates
 > 
 > (define (card-one-rank-below? first-card second-card)
 >   "Return true if the first-card is one rank below the second-card."
 >   (let ((first-value (send first-card get-value))
 >         (second-value (send second-card get-value)))
 >     (= 1 (- second-value first-value))))
 > 
 > (define (card-one-rank-above? first-card second-card)
 >   "Return true if the first-card is one rank above the second-card."
 >   (card-one-rank-below? second-card first-card))
 > 
 > (define (card-next-rank? first-card second-card)
 >   "Return true if the first card is one rank above or below the second-card."
 >   (or (card-one-rank-below? first-card second-card)
 >       (card-one-rank-above? first-card second-card)))
 > 
 > (define (card-circular-one-rank-below? first-card second-card)
 >   "Return true if card-one-rank-below? is true or if the first-card is a king 
 > and second-card is an ace."
 >   (or (card-one-rank-below? first-card second-card)
 >       (and (card-is-king? first-card)
 >            (card-is-ace? second-card))))
 > 
 > (define (card-circular-one-rank-above? first-card second-card)
 >   "Return true if card-one-rank-above? is true or if the first-card is an ace 
 > and the second-card is a king."
 >   (or (card-one-rank-above? first-card second-card)
 >       (and (card-is-ace? first-card)
 >            (card-is-king? second-card))))
 > 
 > (define (card-circular-next-rank? first-card second-card)
 >   "Return true if card-next-rank? is true or if the two cards are a king and an 
 > ace."
 >   (or (card-next-rank? first-card second-card)
 >       (or (and (card-is-king? first-card) (card-is-ace? second-card))
 >           (and (card-is-ace? first-card) (card-is-king? second-card)))))
 > 
 > 
 > ;; Card Color and Suit Binary Predicates
 > 
 > (define (card-same-color? first-card second-card)
 >   "Return true if the color of the first-card's suit is the same as the one of 
 > the second-card."
 >   (eq? (card-color first-card)
 >        (card-color second-card)))
 > 
 > (define (card-same-suit? first-card second-card)
 >   "Return true if the suit of the first-card is the same as the one of the 
 > second-card."
 >   (eq? (send first-card get-suit)
 >        (send second-card get-suit)))
 > 
 > 
 > ;;;
 > ;;; Debugging and other Developer Utilities
 > ;;;
 > 
 > (define (debug . args)
 >   (display "Flower Garden: ")
 >   (for-each {lambda (arg) (display arg)}
 >             args)
 >   (newline))
 > 
 > (define (warning . args)
 >   (apply debug "WARNING: " args))
 > 
 > ;;; End of Pretext
 > 
 > ;;
 > ;; Layout
 > ;;
 > ;; This abstract layout hub class keeps the layout in one spot.
 > ;; This approach rips open the encapsulation of the other classes
 > ;; but in this case it's more important to seperate layout from logic.
 > ;;
 > ;; As a general layout message passing protocol objects requesting
 > ;; layout information send themselves as arguments even if this is
 > ;; right now unecessary in some cases. In most cases though this
 > ;; layout hub needs more information from the object, e.g. the index
 > ;; of a stack to provide the correct layout information.
 > ;;
 > ;; About this layout for Flower Garden:
 > ;;
 > ;; The layout is hardcoded: it will not adapt to a change in the
 > ;; number of stacks. A different number of stacks would be a different
 > ;; game anyway. It should be rather easy to exchange the meaning of
 > ;; row and column in this layout though. But it might even be
 > ;; intertwined: not always following its inner logic.
 > ;;
 > ;; The layout is completely based on the playing card dimensions:
 > ;;  for this it needs one unit card to retrieve the dimensions.
 > ;;
 > ;; There is an upper border and a left border.
 > ;; There are six columns with intercolumn spacing.
 > ;; There are three rows with interrow spacing.
 > ;;  The first row contains the centered four foundations.
 > ;;  The second row contains the six flower beds.
 > ;;  The third row contains the bouquet.
 > 
 > {define layout%
 >   (class
 >       object%
 >     (init unit-card)
 >     (super-new)
 >     (define card-width (send unit-card card-width))
 >     (define card-height (send unit-card card-height))
 >     ;; ??? perhaps we should release unit-card here
 >     
 >     (define default-spacing-unit (/ card-width 7)) ; confront with table width
 >     
 >     (define upper-border default-spacing-unit)
 >     (define left-border default-spacing-unit)
 >     (define intercolumn-space default-spacing-unit)
 >     (define interrow-space (* 2 default-spacing-unit))
 >     
 >     (define (column-n-x n)
 >       "Return the x coordinate of the left border of the n'th column."
 >       (+ left-border (* (+ card-width intercolumn-space)
 >                         (sub1 n))) )
 >     
 >     ;;
 >     ;; Layout of the Table
 >     
 >     ;; One card width for each column plus one for spacing.
 >     (define/public (get-table-width garden) 7)
 >     
 >     ;; One card height for the foundations, one for the bouquet, one
 >     ;; for spacing and four card heights for the flower bed.
 >     (define/public (get-table-height garden) 7)
 > 
 >     ;; Table Background
 >     (define fixed-window-border 0)
 >     (define flower "Lavender")
 >     (define/public (get-background-x-coordinate garden)
 >       fixed-window-border)
 >     (define/public (get-background-y-coordinate garden)
 >       fixed-window-border)
 >     (define/public (get-background-width garden)
 >       (- (* card-width (get-table-width garden))
 >          (* 2 fixed-window-border)))
 >     (define/public (get-background-height garden)
 >       (- (* card-height (get-table-height garden))
 >          (* 2 fixed-window-border)))
 >     (define/public (get-background-paint-callback garden)
 >       ;; This is design and not only layout.
 >       ;; See the documentation of color-database<%> for color names.
 >       ;; (But you're only allowed to use colors named after flowers. ;-)
 >       {lambda (drawing-context x y width height)
 > 	;; XXX there is some redrawing shortcoming at the right border
 > 	;; and at the lower border
 > 	(send drawing-context set-background flower)
 >         (send drawing-context clear)
 > 	}) 
 >     (define/public (flower-present selected-flower)
 >       (set! flower selected-flower))
 >     
 >     ;;
 >     ;; Layout of the Foundations
 >     (define foundation-top-line
 >       upper-border)
 >     (define/public (get-foundation-x-coordinate foundation)
 >       (let ((foundation-index (send foundation get-foundation-index)))
 >         (column-n-x (+ foundation-index 1))))
 >     (define/public (get-foundation-y-coordinate foundation)
 >       foundation-top-line)
 >     (define/public (get-foundation-width foundation)
 >       card-width)
 >     (define foundation-height card-height)
 >     (define/public (get-foundation-height foundation)
 >       foundation-height)
 >     
 >     ;;
 >     ;; Layout of the Flower Beds
 >     (define flower-bed-top-line
 >       (+ foundation-top-line
 >          foundation-height
 >          interrow-space))
 >     (define/public (get-flower-bed-x-coordinate flower-bed)
 >       (let ((flower-bed-index (send flower-bed get-flower-bed-index)))
 >         (column-n-x flower-bed-index)))
 >     (define/public (get-flower-bed-y-coordinate flower-bed)
 >       flower-bed-top-line)
 >     (define flower-bed-width card-width)
 >     (define/public (get-flower-bed-width flower-bed)
 >       flower-bed-width)
 >     ;; Each flower bed needs to accomodate up to 18 cards.
 >     (define flower-bed-card-y-offset (/ card-height 3))
 >     (define flower-bed-height (+ (* 1  card-height)
 >                                  (* 8 flower-bed-card-y-offset)))
 >     (define/public (get-flower-bed-height flower-bed)
 >       flower-bed-height)
 >     
 >     ;;
 >     ;; Layout of the Bouquet
 >     (define bucket-top-line
 >       (+ flower-bed-top-line
 >          flower-bed-height
 >          (* 3/2 interrow-space)))	; this extra space makes it look better
 >     (define/public (get-bucket-x-coordinate bucket)
 >       (column-n-x 1)) ; bucket's left border is aligned to the first column
 >     (define/public (get-bucket-y-coordinate bucket)
 >       bucket-top-line)
 >     (define/public (get-bucket-width bucket)
 >       (- (+ (column-n-x 6) flower-bed-width)
 >          left-border)) ; bucket's right border is aligned to the last column
 >     (define/public (get-bucket-height bucket)
 >       [+ (* 3/4 default-spacing-unit) ; there is no sense if not asthetic sense
 >          (* 3/2 card-height)]) ; give the user some space and fill the table
 >     
 >     ;;
 >     ;; Card Layout
 >     (define (stack-layout-cards! foundation)
 >       (let ((cards (reverse (send foundation get-cards)))
 >             (region (send foundation get-region)))
 >         (send* (send (send foundation get-garden)
 >                      get-table)
 >           (stack-cards (reverse cards)) ; z-axis-stacking
 >           (move-cards cards
 >                       (region-x region)
 >                       (region-y region)))))
 >     (define foundation-layout-cards! stack-layout-cards!)
 >     
 >     (define (flower-bed-layout-cards! flower-bed)
 >       (let* ((cards (reverse (send flower-bed get-cards)))
 >              (region (send flower-bed get-region))       
 >              (number-of-cards (length cards))
 >              ;(card-height (send (wheels cards) card-height))
 >              (offset flower-bed-card-y-offset)
 >              (height (region-h region)))
 >         (when (> (+ card-height (* number-of-cards offset))
 >                  height)
 >           ;					; y = ch + (nc-1)*of
 >           ;					; y-ch / (nc-1) = of
 >           (set! offset (/ (- height card-height)
 >                           (sub1 number-of-cards))))
 >         (send* (send (send flower-bed get-garden) get-table)
 >           (stack-cards (reverse cards)) ; z-axis-stacking
 >           (move-cards cards
 >                       (region-x region)
 >                       (region-y region)
 >                       {lambda (n)
 >                         (values 0 (* offset n)) } ))))
 >     
 >     
 >     ;; Preserve x-axis order and DO NOT preserve the y-coordinates
 >     ;(define (x-selector x y) x)
 >     ;   (define (get-card-x-coordinate card table) 
 >     ;     (call-with-values (lambda ()
 >     ;                         (send table card-location card))
 >     ;                       (lambda (x y) x)))
 >     (define bucket-card-top-line (+ bucket-top-line
 >                                     (* 2 default-spacing-unit)))
 >     (define (bucket-layout-cards! bucket)
 >       (let* ((table (send (send bucket get-garden) get-table))
 >              (cards (sort (send bucket get-cards)
 >                           [lambda (first-card second-card)
 >                             (let-values (([x1 y1] (send table card-location 
 > first-card))
 >                                          ([x2 y2] (send table card-location 
 > second-card)))
 >                               (< x1 x2))]))
 > ;             (y-coordinates (list->vector
 > ;                             (map {lambda (card) ; retrieve sorted 
 > y-coordinates
 > ;                                    (let-values
 > ;                                        ([(x y)
 > ;                                          (send table card-location card)])
 > ;                                      (if (< y bucket-card-top-line)
 > ;                                          (* 2 default-spacing-unit)
 > ;                                          (- y bucket-top-line)))}
 > ;                                  cards)))
 >              (number-of-cards (send bucket number-of-cards))       
 >              (region (send bucket get-region))
 >              ;(card-height (send (wheels cards) card-height))
 >              (width (region-w region))
 >              ;; Racket doesn't know how to divide by zero so we have to
 >              ;; check and in the case of a too small number of cards we
 >              ;; use infinity as the offset for the other cards
 >              ;; that do not even exist. But infinity is bigger than the
 >              ;; the maximum offset and that is what we want. Thus dividing
 >              ;; by zero should (at least as an option) yield infinity because
 >              ;; well behaved algorithms can continue correctly and might
 >              ;; even depend on the mathematical consequences of using the
 >              ;; "symbol" or concept of infinity.
 >              [offset (if (> number-of-cards 1)
 >                          (begin (/ (- width (* 1 card-width))
 >                                    (sub1 number-of-cards)))
 >                          ; This is correct when number-of-cards is one.
 >                          ; This is wrong for number-of-cards less than
 >                          ; or equal to 0 which should not happen. 
 >                          +inf.0)]
 >              [maximum-offset (* 3/2 card-width)]
 >              [centered-x-offset 0])
 >         (cond
 > ;              [[> offset maximum-offset]
 > ;               ;; This is difficult to test as the situation arises only
 > ;               ;; later on in the game.
 > ;               (set! offset maximum-offset)
 > ;               (set! centered-x-offset
 > ;                     {half [- (region-w region)
 > ;                              {+ card-width [* offset (- number-of-cards 
 > 1)]}]} )]
 >               ;; When the offset is too close to card-width it looks better
 >               ;; not to put one card next to the other but to fan them.
 >               ([> offset (* 2/3 card-width)]
 >                (set! offset (* 2/3 card-width))
 >                (set! centered-x-offset
 >                      {half [- (region-w region)
 >                               {+ card-width [* offset (- number-of-cards 1)]}]} 
 > )))
 >         (send* (send (send bucket get-garden) get-table)
 >           (stack-cards (reverse cards)) ; z-axis-stacking
 >           (move-cards cards
 >                       (+ (region-x region) centered-x-offset)
 >                       (region-y region)
 >                       {lambda (n)
 >                         (values (* offset n)
 >                                 (* 2 default-spacing-unit))
 >                                 ;(vector-ref y-coordinates n))
 >                                 } ))))
 >     
 >     (define/public (layout-cards! stack)
 >       (cond ([is-a? stack foundation%] (foundation-layout-cards! stack))
 >             ([is-a? stack flower-bed%] (flower-bed-layout-cards! stack))
 >             ([is-a? stack bucket%] (bucket-layout-cards! stack))
 >             (else
 >              (warning "layout%: layout-cards!:"
 >                       " no registered card layout found for type: "
 >                       (object-interface stack)
 >                       ": using fallback: stack-layout-cards!")
 >              (stack-layout-cards! stack))))
 >     )}
 > 
 > ;;
 > ;; Flowers
 > ;;
 > ;; Now this is the stupid approach to class redefinition (see
 > ;; Guile/GOOPS). We need each card object to have a back link to its
 > ;; stack. While card% does feature a home-region where region is the
 > ;; "view" of the stack the region structure does not provide a list of
 > ;; cards and thus it does not keep track of the sequence of cards. We
 > ;; do this in the model with a list (see stack%). Then the message
 > ;; passing protocol for the region callbacks gives us a list of cards
 > ;; dragged to a region and we can add these cards to the stack of the
 > ;; target. But how do we remove these cards from the stack where the
 > ;; cards came from? BTW The implementation of Spider loops through all
 > ;; stacks. We do that with broadcast.
 > 
 > (define (reset-flowers flowers)
 >   (broadcast* flowers
 >               (face-down)
 >               (user-can-flip #f)
 >               (snap-back-after-move #t)
 >               (user-can-move #f))
 >   flowers)
 > 
 > (define (make-flowers flowers)
 >   (reset-flowers flowers))
 > 
 > (define flower-dialog%
 >   {class
 >    dialog%
 >    (init garden)
 >    (define my-garden garden)
 >    (super-new [label "Flowers"]
 > 	      [parent (send my-garden get-table)]
 > 	      [stretchable-width #f]
 > 	      [stretchable-height #f])
 >    ;; See the documentation of color-database<%> for color names.
 >    ;; (But you're only allowed to use colors named after flowers. ;-)
 >    ;; Oops, Racket's color database seems to have been hacked: a
 >    ;; little name mix up: Cornflower Blue is Lavender where Lavender
 >    ;; probably is azzurro (in italian) where the database has a french
 >    ;; sounding entry named azure. The other CornflowerBlue is alright
 >    ;; but the way things are you're now allowed to pick any colors not
 >    ;; only the ones named after flowers.
 >    (define flowers
 >      (list
 >       ;"Pale Green" ; you might take this for the infamous Mint Green
 >       "Lavender"
 >       "FloralWhite"
 >       "MistyRose"
 >       "Cornflower Blue" 
 >       "Orchid"
 >       "Violet Red"
 >       ))
 >    (define flower-chooser
 >     (new radio-box%
 > 	 [label #f]
 > 	 [parent (new group-box-panel%
 > 		      [parent this]
 > 		      [label "You can pick a flower!"]
 > 		      [stretchable-width #f]
 > 		      [stretchable-height #f])]
 > 	 [choices flowers]))
 >    (define bottom-panel
 >      (new horizontal-panel%
 > 	  [parent this]
 > 	  [alignment '(center center)]
 > 	  [stretchable-height #f]))
 >    (new button%
 >        [parent bottom-panel]
 >        [label "&Ok"]
 >        [style '(border)]
 >        [callback {lambda (b e)
 > 		   (send my-garden flower-picked
 > 			 (vector-ref (list->vector flowers)
 > 				     (send flower-chooser get-selection)))
 > 		   (send this show #f)} ])
 > 
 >    (define/public (flower-present)
 >      ;(set! flowers (shuffle-list *flower-list* 12))
 >      (send this center)
 >      (send this show #t))
 > })
 > 
 > ;;
 > ;; Stacks
 > ;;
 > ;; There are three kinds of stacks: foundations, flower beds and
 > ;; bouquet. Layouting is done with the help of the layout hub object
 > ;; as retrieved from the hosting garden object.
 > ;;
 > ;; While each card<%> object knows about its home-region, the regions
 > ;; are not aware of these cards. To get all the cards in one region on
 > ;; the table we could ask each card individually or keep track of all
 > ;; the moves and maintain the missing list of cards for each stack.
 > ;;
 > ;; NB Asking all card objects on the table about their home-region is
 > ;; not too time consuming, i.e. O(n), where each deck brings only 52
 > ;; objects into the game.
 > 
 > (define stack%
 >   {class
 >       object%
 >     (init garden)
 >     (super-new)
 >     
 >     ;;
 >     ;; Fields
 >     (define cards null)
 >     (define my-region null)
 >     (define my-garden garden)
 >     
 >     ;; Accessors
 >     (define/public (get-garden) my-garden)
 >     (define/public (get-layout)
 >       (send my-garden get-layout))
 >     
 >     (define/public (add-card card-to-add)
 >       (send (send this get-garden) syncronize-stacks card-to-add)
 >       (set! cards (sea-cat card-to-add cards))
 >       (send* card-to-add
 >         (home-region my-region)
 >         ;(stay-in-region my-region)
 >         )
 >       (send (get-layout) layout-cards! this)
 >       )
 >     
 >     (define/public (remove-card! card-to-remove)
 >       (set! cards (filter {lambda (card) (not (eq? card card-to-remove))} 
 > cards)))
 >     
 >     (define/public (move-done)
 >       ;(send (get-layout) layout-cards! this)
 >       #t)
 >     
 >     (define/public (number-of-cards) (length cards))
 >     (define/public (empty?) (null? cards))
 >     (define/public (get-cards) cards)
 >     
 >     ;;    (define/public (syncronize-cards-on-region)
 >     ;;      (set! cards (filter (lambda (card)
 >     ;;                            (equal? (send card home-region)
 >     ;;                                    my-region))
 >     ;;                          cards)))
 >     
 >     ;;   (define/public (after-or-before-drag finished-on-region? cards)
 >     ;;     #t)
 >     (define/public (get-region) my-region)
 >     (define/public (set-region new-region)
 >       (set! my-region new-region)
 >       ;     (set-region-interactive-callback!
 >       ;      my-region
 >       ;      {lambda (finished-on-region? cards)
 >       ;	(send this after-or-before-drag finished-on-region? cards)})
 >       )
 >     })
 > 
 > (define foundation%
 >   {class
 >       stack%
 >     (init foundation-index)
 >     (super-new)
 >     
 >     (define my-index foundation-index) 
 >     
 >     (define (foundation-region-callback cards)
 >       (send (send this get-garden) place-on-foundation-request (wheels cards) 
 > this))
 >     
 >     (let ((layout (send this get-layout)))
 >       (send this set-region
 >             (make-region
 >              (send layout get-foundation-x-coordinate this)
 >              (send layout get-foundation-y-coordinate this)
 >              (send layout get-foundation-width this)
 >              (send layout get-foundation-height this)
 >              "Foundation"
 >              foundation-region-callback)))
 >     (send (send (send this get-garden) get-table)
 >           add-region (send this get-region))
 >     
 >     (define/public (get-foundation-index) my-index)
 >     })
 > 
 > (define flower-bed%
 >   {class
 >       stack%
 >     (init flower-bed-index)
 >     (super-new)
 >     
 >     (define my-index flower-bed-index) 
 >     
 >     (define (flower-bed-region-callback cards)
 >       (send (send this get-garden) place-on-flower-bed-request (wheels cards) 
 > this))
 >     
 >     (let ((layout (send this get-layout)))
 >       (send this set-region
 >             (make-region
 >              (send layout get-flower-bed-x-coordinate this)
 >              (send layout get-flower-bed-y-coordinate this)
 >              (send layout get-flower-bed-width this)
 >              (send layout get-flower-bed-height this)
 >              #f ;"Flower Bed"
 >              flower-bed-region-callback)))
 >     (send (send (send this get-garden) get-table)
 >           add-region (send this get-region))
 >     
 >     (define/public (get-flower-bed-index) my-index)
 >     
 >     (define (reconfigure-cards)
 >       (let ((my-cards (send this get-cards)))
 >         (broadcast* my-cards
 >                     (user-can-move #f)
 >                     (snap-back-after-move #t))
 >         (when (not (null? my-cards))
 >           (let ((top-card (wheels my-cards)))
 >             (when (send top-card face-down?) (send top-card face-up))
 >             (send top-card user-can-move #t)) )))
 >     
 >     (define/override (move-done)
 >       (reconfigure-cards))
 >     ;(send (send this get-layout) layout-cards! this))
 >     })
 > 
 > ;; According to the game play bucket% might not even be a
 > ;; stack%. Technically speaking it does not impose any useful order
 > ;; onto the cards but is the reserve and its layout could be done by
 > ;; the user. Quality assurance (me when I just want to play) assured
 > ;; us though that doing the layout by hand isn't much fun and they
 > ;; would prefer us to do the layout for the user.
 > (define bucket%
 >   {class
 >       stack%
 >     (super-new)
 >     
 >     (define (bucket-region-callback cards)
 >       (send (send this get-garden) place-on-bucket-request (wheels cards) this))
 >     
 >     (let ((layout (send this get-layout)))
 >       (send this set-region
 >             (make-region
 >              (send layout get-bucket-x-coordinate this)
 >              (send layout get-bucket-y-coordinate this)
 >              (send layout get-bucket-width this)
 >              (send layout get-bucket-height this)
 >              #f ;"Bouquet"
 >              bucket-region-callback)))
 >     (send (send (send this get-garden) get-table)
 >           add-region (send this get-region))
 >     
 >     (define (prepare-card-for-bucket card)
 >       (when (send card face-down?) (send card face-up))
 >       (send* card
 >         ;(face-up)
 >         (snap-back-after-move #f)
 >         (user-can-move #t)
 >         ))
 >     
 >     (define/override (add-card card)
 >       (prepare-card-for-bucket card)
 >       (super add-card card))
 >     
 >     (define/override (move-done)
 >       (send (send this get-layout) layout-cards! this))
 >     
 >     ;;    (define/override (after-drag finished-on-region? cards)
 >     ;;      (send (send this get-layout) layout-cards! this))
 >     })
 > 
 > ;;
 > ;; Garbage Collection
 > ;;
 > ;; Sometimes the garbage collector (3m) starts running in the midst of
 > ;; an animation or worse in the middle of a user interaction like a
 > ;; drag. To avoid that this happens we call the garbage collector in
 > ;; right after the initial deal. The user interface effects of the
 > ;; initial deal show up only after the garbage collector returned. For
 > ;; this the user might stare at a gray empty window for a short period
 > ;; of time.
 > ;;
 > ;; Usually after each move-done there should be enough time to run the
 > ;; garbage collector because the user thinks about his next move or is
 > ;; on the way of reacting to the visual feedback (if we were talking
 > ;; about milliseconds) BUT: user interface changes are only shown
 > ;; after the event handler returned (to the internal event handling
 > ;; loop) AND the garbage collector seems to be really slow. Starting
 > ;; Flower Garden from the command line instead of running it in the
 > ;; IDE reduces the time the garbage collector takes noticeably but
 > ;; it's still too slow on a 2.4 GHz Dual Core. Racket and the used
 > ;; libraries/modules/packages do need a lot of RAM - about 200 MB but
 > ;; running the garbage collector all the time (at each move-done) does
 > ;; not reduce the time it needs. (BTW It's still 2015 by the time of
 > ;; this writing or should I say: already 2015)?
 > ;;
 > ;; Fast memory allocation might be a performance issue for one-way win
 > ;; the race scientific applications but for end user applications like
 > ;; this it would be better to have fast garbage collection which
 > ;; doesn't need ages - especially when there is nothing to be done and
 > ;; next to no changes in the data structures since the last run.
 > 
 > ;;
 > ;; Program Action Hub
 > {define garden%
 >   (class
 >       object%
 >     (super-new)
 >     
 >     (define number-of-foundations 4)
 >     (define number-of-flower-beds 6)
 >     
 >     (define flower-selection #f)
 >     
 >     (define flowers (make-flowers (make-deck)))
 >     (define layout (new layout% (unit-card (wheels flowers))))
 >     
 >     ;; ;; ;; ;; ;; ;; ;; ;;
 >     ;; This should be a subclass of table% named
 >     ;; flower-garden-table%
 >     ;; But make-table won't let us do this conveniently ???
 >     (define garden (make-table
 >                     "Flower Venus Garden" ; title
 >                     (send layout get-table-width this)
 >                     (send layout get-table-height this) ))
 >     
 >     ;; Redefine mouse interaction. See documentation.
 >     (send* garden
 >       (set-button-action 'left 'drag-raise/one)
 >       (set-button-action 'middle 'drag-raise/one)
 >       (set-button-action 'right 'drag-raise/one))
 >     
 >     (define (dummy-mouse-event-handler card)
 >       #t)
 >     
 >     ;; Event Handling
 >     ;;
 >     ;; There is no documented message passing protocol for the event
 >     ;; stream coming from region and table objects. There is no well
 >     ;; defined order but we can look at the order of events arriving
 >     ;; and think about it. A drag starts out with a single click
 >     ;; event. That single click event might or might not match our
 >     ;; interactor model but we need to make its consequences unhappen
 >     ;; because the user did not click but drag and we got to know about
 >     ;; this only later on. There is a place to do that: see
 >     ;; set-interactive-region-callback! in stack% add-region.
 >     ;;
 >     ;; A double click is a time and coordinate dependent event usually
 >     ;; composed of two single clicks. Depending on the libraries and
 >     ;; low level routines in use we might expect to see the following
 >     ;; sequences in the event stream on the same card in a short time
 >     ;; interval: a period "." denotes a single click event, a colon ":"
 >     ;; denotes a double click event
 >     ;;
 >     ;; ..  two clicks no double click event
 >     ;; :   one double click event - no single click events
 >     ;; .:  one single click event and one double click event
 >     ;; ..: two single click events and one double click event
 >     ;; :.. one double click event and two single click events
 >     ;; .:. one single click event then a double click event then
 >     ;;      a single click event again
 >     ;;
 >     ;; We can adapt our interaction model or Interactor (see Garnet) to
 >     ;; avoid misinterpreting events. A single click sets the selection
 >     ;; and the next click clears the selection. A double click clears
 >     ;; the selection. With this behaviour in mind there remain two
 >     ;; cases of event sequences which are not handled in the right way:
 >     ;; the first one (..) which is degenerate because there is no
 >     ;; double click event at all. We could try to look at the time
 >     ;; codes of the events and determine if it was a double click or
 >     ;; not but we cannot check the pointer coordinates here which is
 >     ;; crucial to recognize double clicks and drags. Then the last
 >     ;; sequence (.:.) is problematic, too. And testing suggests that
 >     ;; this is our favourite one and only sequence of events. On the
 >     ;; developer's machine each double click event is surrouned by
 >     ;; single clicks and we end up with a card that has already been
 >     ;; moved by the double click event which cleared selection and we
 >     ;; now receive a single click event for that card: it ends up
 >     ;; selected (in a foundation). Please bear in mind that a click
 >     ;; event is a synthesized composed event itself: usually a click is
 >     ;; defined as the following sequence of low level events: mouse
 >     ;; button down, mouse button up (within the same spot region in
 >     ;; screen coordinates). The Virtual Card Library does not use that
 >     ;; definition of a click. Another aspect of our event handling here
 >     ;; to keep in mind is the fact that we do not recieve a stream of
 >     ;; events as a stream of events but the user defined thunks are
 >     ;; invoked as event handlers at certain not well defined moments
 >     ;; not in time but in the execution order of the Virtual Card
 >     ;; Library routines intertwined with garbage collection and
 >     ;; operating system interaction.
 >     ;;
 >     ;; Interaction Models have to be learned by the user. Some are
 >     ;; nowadays common accepted standard (even if not well documented)
 >     ;; but everything changes: where you're favourite lisp based action
 >     ;; game developing environment from back then allowed you to choose
 >     ;; one of a set of actions and then apply it on some object today
 >     ;; we expect to select the object.e.g. file and then choose one of
 >     ;; its associated actions, e.g. delete. This is true on most modern
 >     ;; graphical user interaction shells. But when you do graphic
 >     ;; design and photo retouch we first choose the action or tool and
 >     ;; then apply it to some part of the object to design. Vice verse
 >     ;; these behaviours and people will tell you that it's completely
 >     ;; broken even if they're already used to both interaction models.
 >     ;; I don't touch I click - but that's another chapter and out of
 >     ;; the scope of this little card game.
 >     ;;
 >     ;; Some interaction models to not work out anyway: the select card
 >     ;; then destination approach falls for Moon Flower Garden because
 >     ;; the bucket is full of cards. Do you want to move the flower to
 >     ;; the bucket or do you want to select a card in the bucket?
 >     
 >     (send* garden
 >       (set-double-click-action ;dummy-mouse-event-handler)
 >        {lambda (flower)
 >          ;(debug "flower-garden-table%: double-click-action")
 >          (send this rescue-request flower)})
 >       (set-single-click-action dummy-mouse-event-handler) )
 >     ;; 	   {lambda (flower)
 >     ;;              (debug "flower-garden-table%: single-click-action")
 >     ;; 	     (send this selection-request flower)}))
 > 
 >     (send garden add-region
 > 	  (make-background-region
 > 	   (send layout get-background-x-coordinate garden)
 > 	   (send layout get-background-y-coordinate garden)
 > 	   (send layout get-background-width garden)
 > 	   (send layout get-background-height garden)
 > 	   (send layout get-background-paint-callback garden)))
 >  
 >     ;;
 >     ;; Animations
 >     ;;
 >     ;; It seems the animation of the Virtual Card Library are
 >     ;; primarily intended to visualize algorithms or better: their
 >     ;; time ordered consequences. There is a problem where the
 >     ;; animation of a dragged card doesn't start at the final position
 >     ;; of the drag when/where the handler is called but it starts at
 >     ;; the original location of the card which might be percieved as
 >     ;; an unpleasant flickering. That behaviour of the animation
 >     ;; engine depends on a set home-region but not only. Not setting
 >     ;; the home-region at all in the class definition of stack% gives
 >     ;; us the correct starting positions for the animations after a
 >     ;; drag from the Bouquet to a Flower Bed. All drags originating
 >     ;; from Flower Beds do still animate with the described wrong
 >     ;; starting position. This might have to do with one of the
 >     ;; messages in reconfigure-cards but after all: the animation
 >     ;; engine does not feature any fine grained control and is abusing
 >     ;; the cards<%> configuration in an undocumented way. Nevertheless
 >     ;; the wrong starting position seems to be a real bug of the
 >     ;; animation engine. BTW It doesn't animate snap backs either ...
 >     ;; Perhaps they want to fix it.
 > 
 >     ;(send garden animated #f)  ; turn animation off altogether
 >     
 >     ;; End of pseudo subclass flower-garden-table%
 >     ;; ;; ;; ;; ;; ;; ;; ;;
 > 
 >     (define my-bouquet (new flower-dialog% (garden this)))
 >     
 >     ;;
 >     ;; Create the Foundations
 >     ;; We could loop here or abbreviate with some lambda form
 >     ;; but I like to hardcode these things. A different number
 >     ;; of foundations makes a different game.
 >     (define foundations
 >       (list (new foundation% (garden this) (foundation-index 1))
 >             (new foundation% (garden this) (foundation-index 2))
 >             (new foundation% (garden this) (foundation-index 3))
 >             (new foundation% (garden this) (foundation-index 4))))
 >     
 >     ;;
 >     ;; Create the Flower Beds
 >     (define flower-beds
 >       (map {lambda (flower-bed-index)
 >              (new flower-bed%
 >                   (garden this)
 >                   (flower-bed-index flower-bed-index))}
 >            (list 1 2 3 4 5 6)))
 >     
 >     ;;
 >     ;; Create the bouquet.
 >     (define bouquet (new bucket% [garden this]))
 >     
 >     
 >     ;; ;; ;; ;; ;; ;; ;; ;;
 >     ;; This sort of extra stack handling is needed because of our
 >     ;; inability to subclass card% conveniently. See Flowers (flower%).
 >     (define stack-register (append (list bouquet) flower-beds foundations))
 >     (define/public (syncronize-stacks card)
 >       (broadcast stack-register remove-card! card))
 >     ;; ;; ;; ;; ;; ;; ;; ;;
 >     
 >     
 >     ;;
 >     ;; Internal Interface
 >     
 >     (define/public (get-layout) layout)
 >     (define/public (get-table) garden)
 >     (define/public (card-face-up card)	;; XXX
 >       (send garden card-face-up card))
 >     (define/public (flower-picked flower)
 >       (send layout flower-present flower))
 > 
 >     
 >     
 >     ;;
 >     ;; Rule Implementation Interface
 >     ;;
 >     ;; Where one part of a card game's rules usually becomes the game
 >     ;; mechanic, i.e. layout and user interaction, another part becomes
 >     ;; the game's logic. For convenience this is implemented here as
 >     ;; something that resembles a controller.
 >     ;;
 >     ;; To allow different difficulty levels we might want to introduce
 >     ;; flower-garden-ruleset<%> objects and delegate these calls to the
 >     ;; one representing the current ruleset.
 >     
 >     (define empty? null?)
 >     
 >     (define (initial-deal)
 >       ;; Prepare our card game.
 >       (set! flowers (shuffle-list flowers 6))
 >       
 >       ;; Throw the seeds. It's reversed to make them fly over not
 >       ;; under. This deals the cards visually from the bottom of the
 >       ;; deck. But when dealing from its top we would have to
 >       ;; re-stack-cards, i.e. changing the z-axis ordering, for the
 >       ;; whole table all the time.
 >       (send garden add-cards (reverse flowers) 0 0)
 >       
 >       (let ((flowers flowers))
 >         ;; Deal 6 cards on each flower bed.
 >         (repeat 6 {lambda ()
 >                     (for-each {lambda (flower-bed)
 >                                 (send flower-bed add-card
 >                                       (wheels flowers))
 >                                 (set! flowers (cast flowers))}
 >                               flower-beds)} )
 >         ;; Cut the flowers' wheels.
 >         (broadcast (map wheels (broadcast flower-beds get-cards))
 >                    face-up)
 >         ;; Deal the remaining cards into the bucket.
 >         (for-each {lambda (flower)
 >                     (send bouquet add-card flower)}
 >                   flowers))
 >       ;(clear-selection)
 >       (broadcast stack-register move-done)
 >       ;(collect-garbage)
 >       ) ; end of initial deal
 >     
 >     (define/public (place-on-flower-bed-request flower flower-bed)
 >       (let ((stacked (send flower-bed get-cards)))
 >         (when (or (empty? stacked)
 >                   (and (card-one-rank-below? flower (wheels stacked)) 
 >                        (card-same-suit? flower (wheels stacked))))
 >           (send flower-bed add-card flower)
 >           (broadcast stack-register move-done) )))
 >     
 >     (define (game-is-won?)
 >       (define (foundation-full? foundation)
 >         (let ((stacked (send foundation get-cards)))
 >           (and (not (null? stacked))
 >                (card-is-king? (wheels stacked))) ))
 >       (define (game-is-won? foundations)
 >         (if (null? foundations)
 >             #t
 >             (and (foundation-full? (wheels foundations))
 >                  (game-is-won? (cast foundations))) )) ; not tail recursive
 >       (game-is-won? foundations))
 >     
 >     (define/public (place-on-foundation-request flower foundation)
 >       (let ((stacked (send foundation get-cards)))
 >         (when [or (and (empty? stacked)
 >                        (card-is-ace? flower))
 >                   (and (not (empty? stacked))
 >                        (card-same-suit? flower (wheels stacked))
 >                        (card-one-rank-above? flower (wheels stacked)))]
 >           (send foundation add-card flower)
 >           ;(clear-selection)
 >           (broadcast stack-register move-done)
 > 	  (when (game-is-won?) 
 > 		(send my-bouquet flower-present)
 > 		(reset-game) )) ))
 >     
 >     (define (is-playable? flower)
 >       (and (send flower user-can-move)
 >            (not (send flower face-down?))))
 >     
 >     (define/public (rescue-request flower)
 >       (when (is-playable? flower)
 >         ;; It's a bit like brute force but it's terse and readable.
 >         ;; (and with animation it looks really funny which makes
 >         ;; you lough and that is a good thing [for a card game]!)
 >         (for-each {lambda (foundation)
 >                     (place-on-foundation-request flower foundation)}
 >                   foundations)))
 >     
 >     
 >     (define/public (place-on-bucket-request flower bucket)
 >       (when [< (send bucket number-of-cards) 16]
 >         (send bucket add-card flower)
 >         ;(clear-selection)
 >         (broadcast stack-register move-done) ))
 >     
 >     ;;
 >     ;; DEFUNCT Selection Handling Interface
 >     
 >     ;;    (define/public (clear-selection)
 >     ;;      ;(debug "garden%: clear-selection called; flower-selection: " 
 > flower-selection)
 >     ;;      ;(broadcast flowers dim #f)
 >     ;;      (when flower-selection
 >     ;; 	   (debug "garden%: clear-selection: clearing selection")
 >     ;; 	   ;(send flower-selection dim #f)
 >     ;;            ;(broadcast flowers dim #f)
 >     ;; 	   (set! flower-selection #f)))
 >     
 >     ;;    (define/public (selection-request flower)
 >     ;;      (debug "garden%: selection-request called")
 >     ;;      (if [and (eq? flower-selection flower)
 >     ;; 	      (send flower-selection dim)]
 >     ;; 	 (clear-selection)
 >     ;; 	 (when [is-playable? flower]
 >     ;; 	       (clear-selection)
 >     ;; 	       (set! flower-selection flower)
 >     ;; 	       (send flower dim #t)) ))
 >     
 >     
 >     ;;;
 >     ;;; Application Interface
 >     
 >     (define/public (grow)
 >       (send garden show #t)
 >       (w/o-cart-animation garden initial-deal))
 >     ;(initial-deal))
 >     
 >     (define/public (reset-game)
 >       [w/o-cart-animation* garden
 >                            ;; remove cards from the stacks (from the model)
 >                            (for-each {lambda (card)
 >                                        ;; ??? perhaps it's better to implement 
 > reset in
 >                                        ;; stack%
 >                                        (broadcast stack-register remove-card! 
 > card)}
 >                                      flowers)
 >                            ;; remove cards from the table (from the view)
 >                            (send garden remove-cards flowers)
 >                            
 >                            (reset-flowers flowers)
 >                            (initial-deal)])
 > 
 >     )}
 > 
 > 
 > ;;
 > ;; Application Class / Menu and System Interface
 > ;;
 > 
 > (define flower-garden%
 >   {class
 >       object%
 >     (super-new)
 >     
 >     (define garden (new garden%))
 >     (define main-frame (send garden get-table))
 >     (define my-menu-bar (make-object menu-bar% main-frame))
 >     (define my-game-menu (make-object menu% "Game" my-menu-bar))
 >     (new menu-item%
 >          [label "Reset Game..."]
 >          [parent my-game-menu]
 >          [callback
 >           {lambda (i e)
 >             (when (eq? 'yes (message-box "Reset Game"
 >                                          "Are you sure you want to reset the 
 > game?"
 >                                          main-frame
 >                                          '(yes-no)))
 >               (send garden reset-game))}])
 >     (new separator-menu-item% [parent my-game-menu])
 >     (new menu-item%
 >          [label "Quit"]
 >          [parent my-game-menu]
 >          [callback {lambda (i e)
 >                      (send main-frame show #f)
 >                      (exit)}])
 >     
 >     
 >     (send garden grow)
 >     })
 > 
 > (define sort-by-suit (new flower-garden%))
 > 
 > *** Environment:
 > macosx "Darwin nPing.local 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7 
 > 16:33:36 PDT 2011; root:xnu-1504.15.3~1/RELEASE_I386 i386" (x86_64-macosx/3m) 
 > (get-display-depth) = 32
 > Human Language: english
 > (current-memory-use) 440017348
 > raco pkg (show):
 > Installation-wide:
 >  Package              Checksum                                    Source
 >  main-distribution    f07e2d4bf2708c1085be38eca18aa9eb6755e547    (catalog 
 > main-distribution)
 >  racket-lib           41c7b3221006758c5a840a18dcc0d265632f14c2    (catalog 
 > racket-lib)
 >  [178 auto-installed packages not shown]
 > User-specific for installation "6.1":
 >  [none]
 > 
 > 
 > 
 > Collections:
 > ("/Users/mt/Library/Racket/6.1/collects"
 >  (non-existent-path))
 > ("/Applications/Racket v6.1/collects"
 >  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" 
 > "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" 
 > "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))
 > 
 > Recent Internal Errors: 
 > Computer Language: (("Determine language from source") (#(#t print 
 > mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t #t ((test) 
 > (main)) #t))
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: michael.tiedtke@o2online.de, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/15059: Color Database (color-database<%>) Name
 Mix up
Date: Mon, 11 May 2015 13:05:40 -0500

 I think changing the Green at this point is unwise. But maybe adding
 the missing one would be good. And DarkSeaGreen seems like a good
 change.
 
 So many methods take strings and are documented to use this table so
 it is hard for me to think of a good way to make a reasonable
 backwards compatible change. But we could offer a second color
 database and encourage new code to use that, maybe?
 
 Robby
 
 On Mon, May 11, 2015 at 10:57 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > Thanks for the report!
 >
 > "Cornflower Blue" is definitely a problem, and "Cadet Blue" is also
 > slightly off from "CadetBlue". I think "Lavender" and "Azure" are
 > mapped in the same way as standards, though.
 >
 > Colors mappings that don't match HTML 4.01:
 >
 >            HTML            racket/draw
 >  Green     (0 128 0)       (0 255 0)
 >  Gray      (128 128 128)   (190 190 190)
 >  Maroon    (128 0 0)       (176 48 96)
 >  Purple    (128 0 128)     (160 32 240)
 >  Navy      (0 0 128)       (36 36 140)
 >
 > Other colors that are not part of the HTML standard, but are part of
 > the SVG standard and supported by most browsers for HTML:
 >
 >                 SVG            racket/draw
 >  Brown          (165 42 42)    (132 60 36)
 >  RebeccaPurple  (102 51 153)   [missing]
 >  Aquamarine     (127 255 212)  (112 216 144)
 >  DarkSeaGreen   (143 188 143)  (143 188 139)
 >
 > I'm not yet sure what to do. The mismatch seems bad, but changing the
 > meaning of color names (which could break existing programs, especially
 > for "Green") also seems bad.
 >
 >
 > At Mon, 11 May 2015 01:16:02 -0400, michael.tiedtke@o2online.de wrote:
 >> A new problem report is waiting at
 >>   http://bugs.racket-lang.org/query/?cmd=view&pr=15059
 >>
 >> Reported by Michael Tit-ke for release: 6.1
 >>
 >> *** Description:
 >> Oops, Racket's color database seems to have been hacked: a
 >> little name mix up: Cornflower Blue is Lavender where Lavender
 >> probably is azzurro (in italian) where the database has a french
 >> sounding entry named azure. The other CornflowerBlue is alright
 >> but the way things are you're now allowed to pick any colors not
 >> only the ones named after flowers.
 >> Just changing the names again would probably not be the right solution. Steps
 >> to reproduce might contain other issues (Redrw
 >>
 >> *** How to repeat:
 >> #lang racket
 >>
 >> ;; This is the message passing approach to the patience solitaire game
 >> ;; Flower Garden.
 >> ;;
 >> ;; This is the variant Flower Venus Garden with a relaxed ruleset.  You
 >> ;; can move only one card at time but from anywhere to anywhere.
 >> ;; Sequences in the flower beds have to be build by suit.  The
 >> ;; foundations are built from ace to king but cards can be moved back
 >> ;; into the game. You can double click a card and if possible it will
 >> ;; find its place in the foundations. You can place up to sixteen
 >> ;; cards in the bouquet. There is a good chance of winning the game.
 >> ;;
 >> ;; (The layout of the bouquet, i.e. the reserve of cards at the bottom
 >> ;; of the table is done automatically but only after a card has been
 >> ;; moved successfully. Rethinking and correcting this is left as
 >> ;; exercise for the interested player.)
 >> ;;
 >> ;; Description & Rules
 >> ;;
 >> ;; One deck of 52 cards.
 >> ;;
 >> ;; < from wikipedia
 >> ;; Thirty-six cards are dealt in to six columns, each containing six
 >> ;; cards. The columns are called the "flower beds" and the entire
 >> ;; tableau is sometimes called "the garden." The sixteen leftover
 >> ;; cards become the reserve, or "the bouquet."
 >> ;;
 >> ;; The top cards of each flower-bed and all of the cards in the
 >> ;; bouquet are available for play. Cards can only be moved one at a
 >> ;; time and can be built either on the foundations or on the other
 >> ;; flower beds. The foundations are built up by suit, from Ace to King
 >> ;; (a general idea of the game is to release the aces first). The
 >> ;; cards in the garden, on the other hand, can be built down
 >> ;; regardless of suit and any empty flower bed can be filled with any
 >> ;; card. The cards in the bouquet can be used to aid in building, be
 >> ;; put into the foundations, or fill an empty flower bed.
 >> ;;
 >> ;; The game is won when all cards end up in the foundations.
 >> ;; > end from wikipedia
 >> ;;
 >>
 >> ;;
 >> ;; Technical Note: While it is written in a rather traditional way
 >> ;; without mixins, traits or an emphasis on surrogates it might
 >> ;; contain ideas, concepts and terms that go beyond today's message
 >> ;; passing "customs". A new message passing primitive "broadcast" and
 >> ;; the term hub for certain classes are consequences of thinking about
 >> ;; the future of message passing, parallel objects and one new program
 >> ;; code abstraction system "to rule them all" especially when it comes
 >> ;; to open source and the user's ability to adapt and program the
 >> ;; shiny some thousand money units worth machine in front of him. From
 >> ;; LISP machines to BSD to Mach message passing microkernel to
 >> ;; NextStep to ... but that is far away: for me it was from QBASIC to
 >> ;; RISC assembler to NetBeans to Dr. Racket to whatever comes in
 >> ;; handy.
 >> ;;
 >>
 >> ;;
 >> ;; Description of the User Interaction
 >> ;;
 >> ;; Most of the event handling is done by the views card<%>, table<%>
 >> ;; and region. (See Event Handling)
 >> ;;
 >> ;; According to the rules only one card may be moved at any time.
 >> ;;
 >>
 >> ;;
 >> ;; Bugs and Maintenance
 >> ;;
 >> ;; Bug (unreproducible): in a new game after program start the second
 >> ;; card in a flower bed which was face down could be moved. As
 >> ;; reconfigure-cards in the flower-bed class is rather clear about
 >> ;; this issue and because it happened during the animation of an
 >> ;; unrelated move and is part of the Virtual Card Library's special
 >> ;; behaviours.
 >>
 >> ;;;
 >> ;;; Modules and Dependencies
 >> ;;;
 >>
 >> (require games/cards racket/gui racket/class racket/unit)
 >>
 >> ;(load "card-logic.rkt")
 >> ;(include (file "card-logic.rkt"))
 >>
 >>
 >> ;;;
 >> ;;; Extension of the Algorithmic Language Scheme
 >> ;;;
 >>
 >> ;; (define (broadcast object-list method . arguments)
 >> ;;   {define (apply-messages object)
 >> ;;     (send/apply object method arguments)}
 >> ;;   (map apply-messages object-list))
 >>
 >> (define-syntax cast (syntax-rules () ((_ type) (cdr type))))
 >> (define-syntax broadcast
 >>   (syntax-rules ()
 >>     ((_ object-list method ...)
 >>      (map {lambda (object) (send object method ...)}
 >>           object-list))))
 >> (define-syntax broadcast*
 >>   (syntax-rules ()
 >>     ((_ object-list method ...)
 >>      (map {lambda (object) (send* object method ...)}
 >>           object-list))))
 >>
 >> (define (repeat n closure)
 >>   "Execute closure n times."
 >>   (if (not (and (exact? n) (integer? n)  ; 'integer?' does not check for
 >> exactness ...
 >>                 (>= n 0)))
 >>       (error "repeat: the parameter n must be an exact natural number or zero.")
 >>       {let loop ((i 0))
 >>         (when (< i n)
 >>           (closure)
 >>           (loop (add1 i)))} ))
 >>
 >> (define (half numerical) (/ numerical 2))
 >>
 >> (define wheels
 >>   ;; Every car has four wheels.
 >>   car)
 >>
 >> ;;
 >> ;; The Virtual Card Library wants us to program in assembler
 >> ;; style. This is how we escape it.
 >> (define (w/o-cart-animation table closure)
 >>   "Don't let the car's movement be shown."
 >>   (let ((returned-value void))
 >>     (send table begin-card-sequence)  ; determine the winning card sequence
 >>     (set! returned-value (closure))
 >>     (send table end-card-sequence)
 >>     returned-value))
 >>
 >> (define-syntax w/o-cart-animation*
 >>   (syntax-rules ()
 >>     ((_ table first-expression ...)
 >>      ;; 'returned-value' was accessible by the expressions in the expansion;
 >>      ;; that was a shortcoming.
 >>      ;; It might even have shadowed a definition for that symbol at the
 >>      ;; position of the expansion. That would have beeen a pity.
 >>      ;;
 >>      ;; We're now creating a closure for the expressions.
 >>      ;; This should be safe, hygienic or however you want to call it.
 >>      (let* ([closure {lambda ()
 >>                        first-expression
 >>                        ...}]
 >>             [returned-value void])
 >>        (send table begin-card-sequence)
 >>        (set! returned-value (closure))
 >>        (send table end-card-sequence)
 >>        returned-value) )))
 >>
 >> (define create-cell-and-attach cons)
 >>
 >> ;; That is "sea cat" but where is "bee cat"?
 >> ;; (You might even find "a cat").
 >> (define sea-cat create-cell-and-attach)
 >>
 >>
 >> ;;;
 >> ;;; Card Logic
 >> ;;;
 >>
 >> ;;
 >> ;; Card Suits and Colors: Predicates and Utility Procedures
 >>
 >> (define (suit-color suit-symbol)
 >>   "Return 'red for 'heart and 'club. Return 'black for 'diamond or 'spade. Else
 >> false."
 >>   (case suit-symbol
 >>     [(hearts diamonds) 'red]
 >>     [(clubs spades) 'black]
 >>     [(unknown) (debug "card logic: suit-color: unknown suit") #f] ; this entry
 >> exists for completeness as card<%> get-suit might return 'unknown
 >>     [else (warning "card logic: suit-color: suit not found: " suit-symbol) #f]))
 >>
 >> (define (card-color card)
 >>   "Return the color of the card's suit like suit-color."
 >>   (suit-color (send card get-suit)))
 >>
 >> (define (card-is-red? card)
 >>   "Return true if the color of the card's suit is red."
 >>   (eq? (card-color card) 'red))
 >>
 >> (define (card-is-black? card)
 >>   "Return true if the color of the card's suit is black."
 >>   (eq? (card-color card) 'black))
 >>
 >>
 >> ;;
 >> ;; Card Rank Predicates
 >>
 >> (define (card-is-ace? card)
 >>   "Return true if the card is an ace."
 >>   (= (send card get-value) 1))
 >>
 >> (define (card-is-king? card)
 >>   "Return true if the card is a king."
 >>   (= (send card get-value) 13))
 >>
 >> (define (card-is-queen? card)
 >>   "Return true if the card is a queen."
 >>   (= (send card get-value) 12))
 >>
 >> (define (card-is-joker? card)
 >>   "Reutrn true if the card is a joker."
 >>   (= (send card get-value) 11))
 >>
 >> (define (card-is-ten? card) "Return true if the card is a ten."
 >>   (= (send card get-value) 10))
 >>
 >> (define (card-is-nine? card) "Return true if the card is a nine."
 >>   (= (send card get-value) 9))
 >>
 >> (define (card-is-eight? card) "Return true if the card is an eight."
 >>   (= (send card get-value) 8))
 >>
 >> (define (card-is-seven? card) "Return true if the card is a seven."
 >>   (= (send card get-value) 7))
 >>
 >> (define (card-is-six? card) "Return true if the card is a six."
 >>   (= (send card get-value) 6))
 >>
 >> (define (card-is-five? card) "Return true if the card is a five."
 >>   (= (send card get-value) 5))
 >>
 >> (define (card-is-four? card) "Return true if the card is a four."
 >>   (= (send card get-value) 4))
 >>
 >> (define (card-is-three? card) "Return true if the card is a three."
 >>   (= (send card get-value) 3))
 >>
 >> (define (card-is-two? card) "Return true if the card is a two."
 >>   (= (send card get-value 2)))
 >>
 >>
 >> ;;;
 >> ;;; Card Binary Predicates
 >>
 >> ;; Card Rank Binary Predicates
 >>
 >> (define (card-one-rank-below? first-card second-card)
 >>   "Return true if the first-card is one rank below the second-card."
 >>   (let ((first-value (send first-card get-value))
 >>         (second-value (send second-card get-value)))
 >>     (= 1 (- second-value first-value))))
 >>
 >> (define (card-one-rank-above? first-card second-card)
 >>   "Return true if the first-card is one rank above the second-card."
 >>   (card-one-rank-below? second-card first-card))
 >>
 >> (define (card-next-rank? first-card second-card)
 >>   "Return true if the first card is one rank above or below the second-card."
 >>   (or (card-one-rank-below? first-card second-card)
 >>       (card-one-rank-above? first-card second-card)))
 >>
 >> (define (card-circular-one-rank-below? first-card second-card)
 >>   "Return true if card-one-rank-below? is true or if the first-card is a king
 >> and second-card is an ace."
 >>   (or (card-one-rank-below? first-card second-card)
 >>       (and (card-is-king? first-card)
 >>            (card-is-ace? second-card))))
 >>
 >> (define (card-circular-one-rank-above? first-card second-card)
 >>   "Return true if card-one-rank-above? is true or if the first-card is an ace
 >> and the second-card is a king."
 >>   (or (card-one-rank-above? first-card second-card)
 >>       (and (card-is-ace? first-card)
 >>            (card-is-king? second-card))))
 >>
 >> (define (card-circular-next-rank? first-card second-card)
 >>   "Return true if card-next-rank? is true or if the two cards are a king and an
 >> ace."
 >>   (or (card-next-rank? first-card second-card)
 >>       (or (and (card-is-king? first-card) (card-is-ace? second-card))
 >>           (and (card-is-ace? first-card) (card-is-king? second-card)))))
 >>
 >>
 >> ;; Card Color and Suit Binary Predicates
 >>
 >> (define (card-same-color? first-card second-card)
 >>   "Return true if the color of the first-card's suit is the same as the one of
 >> the second-card."
 >>   (eq? (card-color first-card)
 >>        (card-color second-card)))
 >>
 >> (define (card-same-suit? first-card second-card)
 >>   "Return true if the suit of the first-card is the same as the one of the
 >> second-card."
 >>   (eq? (send first-card get-suit)
 >>        (send second-card get-suit)))
 >>
 >>
 >> ;;;
 >> ;;; Debugging and other Developer Utilities
 >> ;;;
 >>
 >> (define (debug . args)
 >>   (display "Flower Garden: ")
 >>   (for-each {lambda (arg) (display arg)}
 >>             args)
 >>   (newline))
 >>
 >> (define (warning . args)
 >>   (apply debug "WARNING: " args))
 >>
 >> ;;; End of Pretext
 >>
 >> ;;
 >> ;; Layout
 >> ;;
 >> ;; This abstract layout hub class keeps the layout in one spot.
 >> ;; This approach rips open the encapsulation of the other classes
 >> ;; but in this case it's more important to seperate layout from logic.
 >> ;;
 >> ;; As a general layout message passing protocol objects requesting
 >> ;; layout information send themselves as arguments even if this is
 >> ;; right now unecessary in some cases. In most cases though this
 >> ;; layout hub needs more information from the object, e.g. the index
 >> ;; of a stack to provide the correct layout information.
 >> ;;
 >> ;; About this layout for Flower Garden:
 >> ;;
 >> ;; The layout is hardcoded: it will not adapt to a change in the
 >> ;; number of stacks. A different number of stacks would be a different
 >> ;; game anyway. It should be rather easy to exchange the meaning of
 >> ;; row and column in this layout though. But it might even be
 >> ;; intertwined: not always following its inner logic.
 >> ;;
 >> ;; The layout is completely based on the playing card dimensions:
 >> ;;  for this it needs one unit card to retrieve the dimensions.
 >> ;;
 >> ;; There is an upper border and a left border.
 >> ;; There are six columns with intercolumn spacing.
 >> ;; There are three rows with interrow spacing.
 >> ;;  The first row contains the centered four foundations.
 >> ;;  The second row contains the six flower beds.
 >> ;;  The third row contains the bouquet.
 >>
 >> {define layout%
 >>   (class
 >>       object%
 >>     (init unit-card)
 >>     (super-new)
 >>     (define card-width (send unit-card card-width))
 >>     (define card-height (send unit-card card-height))
 >>     ;; ??? perhaps we should release unit-card here
 >>
 >>     (define default-spacing-unit (/ card-width 7)) ; confront with table width
 >>
 >>     (define upper-border default-spacing-unit)
 >>     (define left-border default-spacing-unit)
 >>     (define intercolumn-space default-spacing-unit)
 >>     (define interrow-space (* 2 default-spacing-unit))
 >>
 >>     (define (column-n-x n)
 >>       "Return the x coordinate of the left border of the n'th column."
 >>       (+ left-border (* (+ card-width intercolumn-space)
 >>                         (sub1 n))) )
 >>
 >>     ;;
 >>     ;; Layout of the Table
 >>
 >>     ;; One card width for each column plus one for spacing.
 >>     (define/public (get-table-width garden) 7)
 >>
 >>     ;; One card height for the foundations, one for the bouquet, one
 >>     ;; for spacing and four card heights for the flower bed.
 >>     (define/public (get-table-height garden) 7)
 >>
 >>     ;; Table Background
 >>     (define fixed-window-border 0)
 >>     (define flower "Lavender")
 >>     (define/public (get-background-x-coordinate garden)
 >>       fixed-window-border)
 >>     (define/public (get-background-y-coordinate garden)
 >>       fixed-window-border)
 >>     (define/public (get-background-width garden)
 >>       (- (* card-width (get-table-width garden))
 >>          (* 2 fixed-window-border)))
 >>     (define/public (get-background-height garden)
 >>       (- (* card-height (get-table-height garden))
 >>          (* 2 fixed-window-border)))
 >>     (define/public (get-background-paint-callback garden)
 >>       ;; This is design and not only layout.
 >>       ;; See the documentation of color-database<%> for color names.
 >>       ;; (But you're only allowed to use colors named after flowers. ;-)
 >>       {lambda (drawing-context x y width height)
 >>       ;; XXX there is some redrawing shortcoming at the right border
 >>       ;; and at the lower border
 >>       (send drawing-context set-background flower)
 >>         (send drawing-context clear)
 >>       })
 >>     (define/public (flower-present selected-flower)
 >>       (set! flower selected-flower))
 >>
 >>     ;;
 >>     ;; Layout of the Foundations
 >>     (define foundation-top-line
 >>       upper-border)
 >>     (define/public (get-foundation-x-coordinate foundation)
 >>       (let ((foundation-index (send foundation get-foundation-index)))
 >>         (column-n-x (+ foundation-index 1))))
 >>     (define/public (get-foundation-y-coordinate foundation)
 >>       foundation-top-line)
 >>     (define/public (get-foundation-width foundation)
 >>       card-width)
 >>     (define foundation-height card-height)
 >>     (define/public (get-foundation-height foundation)
 >>       foundation-height)
 >>
 >>     ;;
 >>     ;; Layout of the Flower Beds
 >>     (define flower-bed-top-line
 >>       (+ foundation-top-line
 >>          foundation-height
 >>          interrow-space))
 >>     (define/public (get-flower-bed-x-coordinate flower-bed)
 >>       (let ((flower-bed-index (send flower-bed get-flower-bed-index)))
 >>         (column-n-x flower-bed-index)))
 >>     (define/public (get-flower-bed-y-coordinate flower-bed)
 >>       flower-bed-top-line)
 >>     (define flower-bed-width card-width)
 >>     (define/public (get-flower-bed-width flower-bed)
 >>       flower-bed-width)
 >>     ;; Each flower bed needs to accomodate up to 18 cards.
 >>     (define flower-bed-card-y-offset (/ card-height 3))
 >>     (define flower-bed-height (+ (* 1  card-height)
 >>                                  (* 8 flower-bed-card-y-offset)))
 >>     (define/public (get-flower-bed-height flower-bed)
 >>       flower-bed-height)
 >>
 >>     ;;
 >>     ;; Layout of the Bouquet
 >>     (define bucket-top-line
 >>       (+ flower-bed-top-line
 >>          flower-bed-height
 >>          (* 3/2 interrow-space)))     ; this extra space makes it look better
 >>     (define/public (get-bucket-x-coordinate bucket)
 >>       (column-n-x 1)) ; bucket's left border is aligned to the first column
 >>     (define/public (get-bucket-y-coordinate bucket)
 >>       bucket-top-line)
 >>     (define/public (get-bucket-width bucket)
 >>       (- (+ (column-n-x 6) flower-bed-width)
 >>          left-border)) ; bucket's right border is aligned to the last column
 >>     (define/public (get-bucket-height bucket)
 >>       [+ (* 3/4 default-spacing-unit) ; there is no sense if not asthetic sense
 >>          (* 3/2 card-height)]) ; give the user some space and fill the table
 >>
 >>     ;;
 >>     ;; Card Layout
 >>     (define (stack-layout-cards! foundation)
 >>       (let ((cards (reverse (send foundation get-cards)))
 >>             (region (send foundation get-region)))
 >>         (send* (send (send foundation get-garden)
 >>                      get-table)
 >>           (stack-cards (reverse cards)) ; z-axis-stacking
 >>           (move-cards cards
 >>                       (region-x region)
 >>                       (region-y region)))))
 >>     (define foundation-layout-cards! stack-layout-cards!)
 >>
 >>     (define (flower-bed-layout-cards! flower-bed)
 >>       (let* ((cards (reverse (send flower-bed get-cards)))
 >>              (region (send flower-bed get-region))
 >>              (number-of-cards (length cards))
 >>              ;(card-height (send (wheels cards) card-height))
 >>              (offset flower-bed-card-y-offset)
 >>              (height (region-h region)))
 >>         (when (> (+ card-height (* number-of-cards offset))
 >>                  height)
 >>           ;                                   ; y = ch + (nc-1)*of
 >>           ;                                   ; y-ch / (nc-1) = of
 >>           (set! offset (/ (- height card-height)
 >>                           (sub1 number-of-cards))))
 >>         (send* (send (send flower-bed get-garden) get-table)
 >>           (stack-cards (reverse cards)) ; z-axis-stacking
 >>           (move-cards cards
 >>                       (region-x region)
 >>                       (region-y region)
 >>                       {lambda (n)
 >>                         (values 0 (* offset n)) } ))))
 >>
 >>
 >>     ;; Preserve x-axis order and DO NOT preserve the y-coordinates
 >>     ;(define (x-selector x y) x)
 >>     ;   (define (get-card-x-coordinate card table)
 >>     ;     (call-with-values (lambda ()
 >>     ;                         (send table card-location card))
 >>     ;                       (lambda (x y) x)))
 >>     (define bucket-card-top-line (+ bucket-top-line
 >>                                     (* 2 default-spacing-unit)))
 >>     (define (bucket-layout-cards! bucket)
 >>       (let* ((table (send (send bucket get-garden) get-table))
 >>              (cards (sort (send bucket get-cards)
 >>                           [lambda (first-card second-card)
 >>                             (let-values (([x1 y1] (send table card-location
 >> first-card))
 >>                                          ([x2 y2] (send table card-location
 >> second-card)))
 >>                               (< x1 x2))]))
 >> ;             (y-coordinates (list->vector
 >> ;                             (map {lambda (card) ; retrieve sorted
 >> y-coordinates
 >> ;                                    (let-values
 >> ;                                        ([(x y)
 >> ;                                          (send table card-location card)])
 >> ;                                      (if (< y bucket-card-top-line)
 >> ;                                          (* 2 default-spacing-unit)
 >> ;                                          (- y bucket-top-line)))}
 >> ;                                  cards)))
 >>              (number-of-cards (send bucket number-of-cards))
 >>              (region (send bucket get-region))
 >>              ;(card-height (send (wheels cards) card-height))
 >>              (width (region-w region))
 >>              ;; Racket doesn't know how to divide by zero so we have to
 >>              ;; check and in the case of a too small number of cards we
 >>              ;; use infinity as the offset for the other cards
 >>              ;; that do not even exist. But infinity is bigger than the
 >>              ;; the maximum offset and that is what we want. Thus dividing
 >>              ;; by zero should (at least as an option) yield infinity because
 >>              ;; well behaved algorithms can continue correctly and might
 >>              ;; even depend on the mathematical consequences of using the
 >>              ;; "symbol" or concept of infinity.
 >>              [offset (if (> number-of-cards 1)
 >>                          (begin (/ (- width (* 1 card-width))
 >>                                    (sub1 number-of-cards)))
 >>                          ; This is correct when number-of-cards is one.
 >>                          ; This is wrong for number-of-cards less than
 >>                          ; or equal to 0 which should not happen.
 >>                          +inf.0)]
 >>              [maximum-offset (* 3/2 card-width)]
 >>              [centered-x-offset 0])
 >>         (cond
 >> ;              [[> offset maximum-offset]
 >> ;               ;; This is difficult to test as the situation arises only
 >> ;               ;; later on in the game.
 >> ;               (set! offset maximum-offset)
 >> ;               (set! centered-x-offset
 >> ;                     {half [- (region-w region)
 >> ;                              {+ card-width [* offset (- number-of-cards
 >> 1)]}]} )]
 >>               ;; When the offset is too close to card-width it looks better
 >>               ;; not to put one card next to the other but to fan them.
 >>               ([> offset (* 2/3 card-width)]
 >>                (set! offset (* 2/3 card-width))
 >>                (set! centered-x-offset
 >>                      {half [- (region-w region)
 >>                               {+ card-width [* offset (- number-of-cards 1)]}]}
 >> )))
 >>         (send* (send (send bucket get-garden) get-table)
 >>           (stack-cards (reverse cards)) ; z-axis-stacking
 >>           (move-cards cards
 >>                       (+ (region-x region) centered-x-offset)
 >>                       (region-y region)
 >>                       {lambda (n)
 >>                         (values (* offset n)
 >>                                 (* 2 default-spacing-unit))
 >>                                 ;(vector-ref y-coordinates n))
 >>                                 } ))))
 >>
 >>     (define/public (layout-cards! stack)
 >>       (cond ([is-a? stack foundation%] (foundation-layout-cards! stack))
 >>             ([is-a? stack flower-bed%] (flower-bed-layout-cards! stack))
 >>             ([is-a? stack bucket%] (bucket-layout-cards! stack))
 >>             (else
 >>              (warning "layout%: layout-cards!:"
 >>                       " no registered card layout found for type: "
 >>                       (object-interface stack)
 >>                       ": using fallback: stack-layout-cards!")
 >>              (stack-layout-cards! stack))))
 >>     )}
 >>
 >> ;;
 >> ;; Flowers
 >> ;;
 >> ;; Now this is the stupid approach to class redefinition (see
 >> ;; Guile/GOOPS). We need each card object to have a back link to its
 >> ;; stack. While card% does feature a home-region where region is the
 >> ;; "view" of the stack the region structure does not provide a list of
 >> ;; cards and thus it does not keep track of the sequence of cards. We
 >> ;; do this in the model with a list (see stack%). Then the message
 >> ;; passing protocol for the region callbacks gives us a list of cards
 >> ;; dragged to a region and we can add these cards to the stack of the
 >> ;; target. But how do we remove these cards from the stack where the
 >> ;; cards came from? BTW The implementation of Spider loops through all
 >> ;; stacks. We do that with broadcast.
 >>
 >> (define (reset-flowers flowers)
 >>   (broadcast* flowers
 >>               (face-down)
 >>               (user-can-flip #f)
 >>               (snap-back-after-move #t)
 >>               (user-can-move #f))
 >>   flowers)
 >>
 >> (define (make-flowers flowers)
 >>   (reset-flowers flowers))
 >>
 >> (define flower-dialog%
 >>   {class
 >>    dialog%
 >>    (init garden)
 >>    (define my-garden garden)
 >>    (super-new [label "Flowers"]
 >>             [parent (send my-garden get-table)]
 >>             [stretchable-width #f]
 >>             [stretchable-height #f])
 >>    ;; See the documentation of color-database<%> for color names.
 >>    ;; (But you're only allowed to use colors named after flowers. ;-)
 >>    ;; Oops, Racket's color database seems to have been hacked: a
 >>    ;; little name mix up: Cornflower Blue is Lavender where Lavender
 >>    ;; probably is azzurro (in italian) where the database has a french
 >>    ;; sounding entry named azure. The other CornflowerBlue is alright
 >>    ;; but the way things are you're now allowed to pick any colors not
 >>    ;; only the ones named after flowers.
 >>    (define flowers
 >>      (list
 >>       ;"Pale Green" ; you might take this for the infamous Mint Green
 >>       "Lavender"
 >>       "FloralWhite"
 >>       "MistyRose"
 >>       "Cornflower Blue"
 >>       "Orchid"
 >>       "Violet Red"
 >>       ))
 >>    (define flower-chooser
 >>     (new radio-box%
 >>        [label #f]
 >>        [parent (new group-box-panel%
 >>                     [parent this]
 >>                     [label "You can pick a flower!"]
 >>                     [stretchable-width #f]
 >>                     [stretchable-height #f])]
 >>        [choices flowers]))
 >>    (define bottom-panel
 >>      (new horizontal-panel%
 >>         [parent this]
 >>         [alignment '(center center)]
 >>         [stretchable-height #f]))
 >>    (new button%
 >>        [parent bottom-panel]
 >>        [label "&Ok"]
 >>        [style '(border)]
 >>        [callback {lambda (b e)
 >>                  (send my-garden flower-picked
 >>                        (vector-ref (list->vector flowers)
 >>                                    (send flower-chooser get-selection)))
 >>                  (send this show #f)} ])
 >>
 >>    (define/public (flower-present)
 >>      ;(set! flowers (shuffle-list *flower-list* 12))
 >>      (send this center)
 >>      (send this show #t))
 >> })
 >>
 >> ;;
 >> ;; Stacks
 >> ;;
 >> ;; There are three kinds of stacks: foundations, flower beds and
 >> ;; bouquet. Layouting is done with the help of the layout hub object
 >> ;; as retrieved from the hosting garden object.
 >> ;;
 >> ;; While each card<%> object knows about its home-region, the regions
 >> ;; are not aware of these cards. To get all the cards in one region on
 >> ;; the table we could ask each card individually or keep track of all
 >> ;; the moves and maintain the missing list of cards for each stack.
 >> ;;
 >> ;; NB Asking all card objects on the table about their home-region is
 >> ;; not too time consuming, i.e. O(n), where each deck brings only 52
 >> ;; objects into the game.
 >>
 >> (define stack%
 >>   {class
 >>       object%
 >>     (init garden)
 >>     (super-new)
 >>
 >>     ;;
 >>     ;; Fields
 >>     (define cards null)
 >>     (define my-region null)
 >>     (define my-garden garden)
 >>
 >>     ;; Accessors
 >>     (define/public (get-garden) my-garden)
 >>     (define/public (get-layout)
 >>       (send my-garden get-layout))
 >>
 >>     (define/public (add-card card-to-add)
 >>       (send (send this get-garden) syncronize-stacks card-to-add)
 >>       (set! cards (sea-cat card-to-add cards))
 >>       (send* card-to-add
 >>         (home-region my-region)
 >>         ;(stay-in-region my-region)
 >>         )
 >>       (send (get-layout) layout-cards! this)
 >>       )
 >>
 >>     (define/public (remove-card! card-to-remove)
 >>       (set! cards (filter {lambda (card) (not (eq? card card-to-remove))}
 >> cards)))
 >>
 >>     (define/public (move-done)
 >>       ;(send (get-layout) layout-cards! this)
 >>       #t)
 >>
 >>     (define/public (number-of-cards) (length cards))
 >>     (define/public (empty?) (null? cards))
 >>     (define/public (get-cards) cards)
 >>
 >>     ;;    (define/public (syncronize-cards-on-region)
 >>     ;;      (set! cards (filter (lambda (card)
 >>     ;;                            (equal? (send card home-region)
 >>     ;;                                    my-region))
 >>     ;;                          cards)))
 >>
 >>     ;;   (define/public (after-or-before-drag finished-on-region? cards)
 >>     ;;     #t)
 >>     (define/public (get-region) my-region)
 >>     (define/public (set-region new-region)
 >>       (set! my-region new-region)
 >>       ;     (set-region-interactive-callback!
 >>       ;      my-region
 >>       ;      {lambda (finished-on-region? cards)
 >>       ;       (send this after-or-before-drag finished-on-region? cards)})
 >>       )
 >>     })
 >>
 >> (define foundation%
 >>   {class
 >>       stack%
 >>     (init foundation-index)
 >>     (super-new)
 >>
 >>     (define my-index foundation-index)
 >>
 >>     (define (foundation-region-callback cards)
 >>       (send (send this get-garden) place-on-foundation-request (wheels cards)
 >> this))
 >>
 >>     (let ((layout (send this get-layout)))
 >>       (send this set-region
 >>             (make-region
 >>              (send layout get-foundation-x-coordinate this)
 >>              (send layout get-foundation-y-coordinate this)
 >>              (send layout get-foundation-width this)
 >>              (send layout get-foundation-height this)
 >>              "Foundation"
 >>              foundation-region-callback)))
 >>     (send (send (send this get-garden) get-table)
 >>           add-region (send this get-region))
 >>
 >>     (define/public (get-foundation-index) my-index)
 >>     })
 >>
 >> (define flower-bed%
 >>   {class
 >>       stack%
 >>     (init flower-bed-index)
 >>     (super-new)
 >>
 >>     (define my-index flower-bed-index)
 >>
 >>     (define (flower-bed-region-callback cards)
 >>       (send (send this get-garden) place-on-flower-bed-request (wheels cards)
 >> this))
 >>
 >>     (let ((layout (send this get-layout)))
 >>       (send this set-region
 >>             (make-region
 >>              (send layout get-flower-bed-x-coordinate this)
 >>              (send layout get-flower-bed-y-coordinate this)
 >>              (send layout get-flower-bed-width this)
 >>              (send layout get-flower-bed-height this)
 >>              #f ;"Flower Bed"
 >>              flower-bed-region-callback)))
 >>     (send (send (send this get-garden) get-table)
 >>           add-region (send this get-region))
 >>
 >>     (define/public (get-flower-bed-index) my-index)
 >>
 >>     (define (reconfigure-cards)
 >>       (let ((my-cards (send this get-cards)))
 >>         (broadcast* my-cards
 >>                     (user-can-move #f)
 >>                     (snap-back-after-move #t))
 >>         (when (not (null? my-cards))
 >>           (let ((top-card (wheels my-cards)))
 >>             (when (send top-card face-down?) (send top-card face-up))
 >>             (send top-card user-can-move #t)) )))
 >>
 >>     (define/override (move-done)
 >>       (reconfigure-cards))
 >>     ;(send (send this get-layout) layout-cards! this))
 >>     })
 >>
 >> ;; According to the game play bucket% might not even be a
 >> ;; stack%. Technically speaking it does not impose any useful order
 >> ;; onto the cards but is the reserve and its layout could be done by
 >> ;; the user. Quality assurance (me when I just want to play) assured
 >> ;; us though that doing the layout by hand isn't much fun and they
 >> ;; would prefer us to do the layout for the user.
 >> (define bucket%
 >>   {class
 >>       stack%
 >>     (super-new)
 >>
 >>     (define (bucket-region-callback cards)
 >>       (send (send this get-garden) place-on-bucket-request (wheels cards) this))
 >>
 >>     (let ((layout (send this get-layout)))
 >>       (send this set-region
 >>             (make-region
 >>              (send layout get-bucket-x-coordinate this)
 >>              (send layout get-bucket-y-coordinate this)
 >>              (send layout get-bucket-width this)
 >>              (send layout get-bucket-height this)
 >>              #f ;"Bouquet"
 >>              bucket-region-callback)))
 >>     (send (send (send this get-garden) get-table)
 >>           add-region (send this get-region))
 >>
 >>     (define (prepare-card-for-bucket card)
 >>       (when (send card face-down?) (send card face-up))
 >>       (send* card
 >>         ;(face-up)
 >>         (snap-back-after-move #f)
 >>         (user-can-move #t)
 >>         ))
 >>
 >>     (define/override (add-card card)
 >>       (prepare-card-for-bucket card)
 >>       (super add-card card))
 >>
 >>     (define/override (move-done)
 >>       (send (send this get-layout) layout-cards! this))
 >>
 >>     ;;    (define/override (after-drag finished-on-region? cards)
 >>     ;;      (send (send this get-layout) layout-cards! this))
 >>     })
 >>
 >> ;;
 >> ;; Garbage Collection
 >> ;;
 >> ;; Sometimes the garbage collector (3m) starts running in the midst of
 >> ;; an animation or worse in the middle of a user interaction like a
 >> ;; drag. To avoid that this happens we call the garbage collector in
 >> ;; right after the initial deal. The user interface effects of the
 >> ;; initial deal show up only after the garbage collector returned. For
 >> ;; this the user might stare at a gray empty window for a short period
 >> ;; of time.
 >> ;;
 >> ;; Usually after each move-done there should be enough time to run the
 >> ;; garbage collector because the user thinks about his next move or is
 >> ;; on the way of reacting to the visual feedback (if we were talking
 >> ;; about milliseconds) BUT: user interface changes are only shown
 >> ;; after the event handler returned (to the internal event handling
 >> ;; loop) AND the garbage collector seems to be really slow. Starting
 >> ;; Flower Garden from the command line instead of running it in the
 >> ;; IDE reduces the time the garbage collector takes noticeably but
 >> ;; it's still too slow on a 2.4 GHz Dual Core. Racket and the used
 >> ;; libraries/modules/packages do need a lot of RAM - about 200 MB but
 >> ;; running the garbage collector all the time (at each move-done) does
 >> ;; not reduce the time it needs. (BTW It's still 2015 by the time of
 >> ;; this writing or should I say: already 2015)?
 >> ;;
 >> ;; Fast memory allocation might be a performance issue for one-way win
 >> ;; the race scientific applications but for end user applications like
 >> ;; this it would be better to have fast garbage collection which
 >> ;; doesn't need ages - especially when there is nothing to be done and
 >> ;; next to no changes in the data structures since the last run.
 >>
 >> ;;
 >> ;; Program Action Hub
 >> {define garden%
 >>   (class
 >>       object%
 >>     (super-new)
 >>
 >>     (define number-of-foundations 4)
 >>     (define number-of-flower-beds 6)
 >>
 >>     (define flower-selection #f)
 >>
 >>     (define flowers (make-flowers (make-deck)))
 >>     (define layout (new layout% (unit-card (wheels flowers))))
 >>
 >>     ;; ;; ;; ;; ;; ;; ;; ;;
 >>     ;; This should be a subclass of table% named
 >>     ;; flower-garden-table%
 >>     ;; But make-table won't let us do this conveniently ???
 >>     (define garden (make-table
 >>                     "Flower Venus Garden" ; title
 >>                     (send layout get-table-width this)
 >>                     (send layout get-table-height this) ))
 >>
 >>     ;; Redefine mouse interaction. See documentation.
 >>     (send* garden
 >>       (set-button-action 'left 'drag-raise/one)
 >>       (set-button-action 'middle 'drag-raise/one)
 >>       (set-button-action 'right 'drag-raise/one))
 >>
 >>     (define (dummy-mouse-event-handler card)
 >>       #t)
 >>
 >>     ;; Event Handling
 >>     ;;
 >>     ;; There is no documented message passing protocol for the event
 >>     ;; stream coming from region and table objects. There is no well
 >>     ;; defined order but we can look at the order of events arriving
 >>     ;; and think about it. A drag starts out with a single click
 >>     ;; event. That single click event might or might not match our
 >>     ;; interactor model but we need to make its consequences unhappen
 >>     ;; because the user did not click but drag and we got to know about
 >>     ;; this only later on. There is a place to do that: see
 >>     ;; set-interactive-region-callback! in stack% add-region.
 >>     ;;
 >>     ;; A double click is a time and coordinate dependent event usually
 >>     ;; composed of two single clicks. Depending on the libraries and
 >>     ;; low level routines in use we might expect to see the following
 >>     ;; sequences in the event stream on the same card in a short time
 >>     ;; interval: a period "." denotes a single click event, a colon ":"
 >>     ;; denotes a double click event
 >>     ;;
 >>     ;; ..  two clicks no double click event
 >>     ;; :   one double click event - no single click events
 >>     ;; .:  one single click event and one double click event
 >>     ;; ..: two single click events and one double click event
 >>     ;; :.. one double click event and two single click events
 >>     ;; .:. one single click event then a double click event then
 >>     ;;      a single click event again
 >>     ;;
 >>     ;; We can adapt our interaction model or Interactor (see Garnet) to
 >>     ;; avoid misinterpreting events. A single click sets the selection
 >>     ;; and the next click clears the selection. A double click clears
 >>     ;; the selection. With this behaviour in mind there remain two
 >>     ;; cases of event sequences which are not handled in the right way:
 >>     ;; the first one (..) which is degenerate because there is no
 >>     ;; double click event at all. We could try to look at the time
 >>     ;; codes of the events and determine if it was a double click or
 >>     ;; not but we cannot check the pointer coordinates here which is
 >>     ;; crucial to recognize double clicks and drags. Then the last
 >>     ;; sequence (.:.) is problematic, too. And testing suggests that
 >>     ;; this is our favourite one and only sequence of events. On the
 >>     ;; developer's machine each double click event is surrouned by
 >>     ;; single clicks and we end up with a card that has already been
 >>     ;; moved by the double click event which cleared selection and we
 >>     ;; now receive a single click event for that card: it ends up
 >>     ;; selected (in a foundation). Please bear in mind that a click
 >>     ;; event is a synthesized composed event itself: usually a click is
 >>     ;; defined as the following sequence of low level events: mouse
 >>     ;; button down, mouse button up (within the same spot region in
 >>     ;; screen coordinates). The Virtual Card Library does not use that
 >>     ;; definition of a click. Another aspect of our event handling here
 >>     ;; to keep in mind is the fact that we do not recieve a stream of
 >>     ;; events as a stream of events but the user defined thunks are
 >>     ;; invoked as event handlers at certain not well defined moments
 >>     ;; not in time but in the execution order of the Virtual Card
 >>     ;; Library routines intertwined with garbage collection and
 >>     ;; operating system interaction.
 >>     ;;
 >>     ;; Interaction Models have to be learned by the user. Some are
 >>     ;; nowadays common accepted standard (even if not well documented)
 >>     ;; but everything changes: where you're favourite lisp based action
 >>     ;; game developing environment from back then allowed you to choose
 >>     ;; one of a set of actions and then apply it on some object today
 >>     ;; we expect to select the object.e.g. file and then choose one of
 >>     ;; its associated actions, e.g. delete. This is true on most modern
 >>     ;; graphical user interaction shells. But when you do graphic
 >>     ;; design and photo retouch we first choose the action or tool and
 >>     ;; then apply it to some part of the object to design. Vice verse
 >>     ;; these behaviours and people will tell you that it's completely
 >>     ;; broken even if they're already used to both interaction models.
 >>     ;; I don't touch I click - but that's another chapter and out of
 >>     ;; the scope of this little card game.
 >>     ;;
 >>     ;; Some interaction models to not work out anyway: the select card
 >>     ;; then destination approach falls for Moon Flower Garden because
 >>     ;; the bucket is full of cards. Do you want to move the flower to
 >>     ;; the bucket or do you want to select a card in the bucket?
 >>
 >>     (send* garden
 >>       (set-double-click-action ;dummy-mouse-event-handler)
 >>        {lambda (flower)
 >>          ;(debug "flower-garden-table%: double-click-action")
 >>          (send this rescue-request flower)})
 >>       (set-single-click-action dummy-mouse-event-handler) )
 >>     ;;           {lambda (flower)
 >>     ;;              (debug "flower-garden-table%: single-click-action")
 >>     ;;             (send this selection-request flower)}))
 >>
 >>     (send garden add-region
 >>         (make-background-region
 >>          (send layout get-background-x-coordinate garden)
 >>          (send layout get-background-y-coordinate garden)
 >>          (send layout get-background-width garden)
 >>          (send layout get-background-height garden)
 >>          (send layout get-background-paint-callback garden)))
 >>
 >>     ;;
 >>     ;; Animations
 >>     ;;
 >>     ;; It seems the animation of the Virtual Card Library are
 >>     ;; primarily intended to visualize algorithms or better: their
 >>     ;; time ordered consequences. There is a problem where the
 >>     ;; animation of a dragged card doesn't start at the final position
 >>     ;; of the drag when/where the handler is called but it starts at
 >>     ;; the original location of the card which might be percieved as
 >>     ;; an unpleasant flickering. That behaviour of the animation
 >>     ;; engine depends on a set home-region but not only. Not setting
 >>     ;; the home-region at all in the class definition of stack% gives
 >>     ;; us the correct starting positions for the animations after a
 >>     ;; drag from the Bouquet to a Flower Bed. All drags originating
 >>     ;; from Flower Beds do still animate with the described wrong
 >>     ;; starting position. This might have to do with one of the
 >>     ;; messages in reconfigure-cards but after all: the animation
 >>     ;; engine does not feature any fine grained control and is abusing
 >>     ;; the cards<%> configuration in an undocumented way. Nevertheless
 >>     ;; the wrong starting position seems to be a real bug of the
 >>     ;; animation engine. BTW It doesn't animate snap backs either ...
 >>     ;; Perhaps they want to fix it.
 >>
 >>     ;(send garden animated #f)  ; turn animation off altogether
 >>
 >>     ;; End of pseudo subclass flower-garden-table%
 >>     ;; ;; ;; ;; ;; ;; ;; ;;
 >>
 >>     (define my-bouquet (new flower-dialog% (garden this)))
 >>
 >>     ;;
 >>     ;; Create the Foundations
 >>     ;; We could loop here or abbreviate with some lambda form
 >>     ;; but I like to hardcode these things. A different number
 >>     ;; of foundations makes a different game.
 >>     (define foundations
 >>       (list (new foundation% (garden this) (foundation-index 1))
 >>             (new foundation% (garden this) (foundation-index 2))
 >>             (new foundation% (garden this) (foundation-index 3))
 >>             (new foundation% (garden this) (foundation-index 4))))
 >>
 >>     ;;
 >>     ;; Create the Flower Beds
 >>     (define flower-beds
 >>       (map {lambda (flower-bed-index)
 >>              (new flower-bed%
 >>                   (garden this)
 >>                   (flower-bed-index flower-bed-index))}
 >>            (list 1 2 3 4 5 6)))
 >>
 >>     ;;
 >>     ;; Create the bouquet.
 >>     (define bouquet (new bucket% [garden this]))
 >>
 >>
 >>     ;; ;; ;; ;; ;; ;; ;; ;;
 >>     ;; This sort of extra stack handling is needed because of our
 >>     ;; inability to subclass card% conveniently. See Flowers (flower%).
 >>     (define stack-register (append (list bouquet) flower-beds foundations))
 >>     (define/public (syncronize-stacks card)
 >>       (broadcast stack-register remove-card! card))
 >>     ;; ;; ;; ;; ;; ;; ;; ;;
 >>
 >>
 >>     ;;
 >>     ;; Internal Interface
 >>
 >>     (define/public (get-layout) layout)
 >>     (define/public (get-table) garden)
 >>     (define/public (card-face-up card)        ;; XXX
 >>       (send garden card-face-up card))
 >>     (define/public (flower-picked flower)
 >>       (send layout flower-present flower))
 >>
 >>
 >>
 >>     ;;
 >>     ;; Rule Implementation Interface
 >>     ;;
 >>     ;; Where one part of a card game's rules usually becomes the game
 >>     ;; mechanic, i.e. layout and user interaction, another part becomes
 >>     ;; the game's logic. For convenience this is implemented here as
 >>     ;; something that resembles a controller.
 >>     ;;
 >>     ;; To allow different difficulty levels we might want to introduce
 >>     ;; flower-garden-ruleset<%> objects and delegate these calls to the
 >>     ;; one representing the current ruleset.
 >>
 >>     (define empty? null?)
 >>
 >>     (define (initial-deal)
 >>       ;; Prepare our card game.
 >>       (set! flowers (shuffle-list flowers 6))
 >>
 >>       ;; Throw the seeds. It's reversed to make them fly over not
 >>       ;; under. This deals the cards visually from the bottom of the
 >>       ;; deck. But when dealing from its top we would have to
 >>       ;; re-stack-cards, i.e. changing the z-axis ordering, for the
 >>       ;; whole table all the time.
 >>       (send garden add-cards (reverse flowers) 0 0)
 >>
 >>       (let ((flowers flowers))
 >>         ;; Deal 6 cards on each flower bed.
 >>         (repeat 6 {lambda ()
 >>                     (for-each {lambda (flower-bed)
 >>                                 (send flower-bed add-card
 >>                                       (wheels flowers))
 >>                                 (set! flowers (cast flowers))}
 >>                               flower-beds)} )
 >>         ;; Cut the flowers' wheels.
 >>         (broadcast (map wheels (broadcast flower-beds get-cards))
 >>                    face-up)
 >>         ;; Deal the remaining cards into the bucket.
 >>         (for-each {lambda (flower)
 >>                     (send bouquet add-card flower)}
 >>                   flowers))
 >>       ;(clear-selection)
 >>       (broadcast stack-register move-done)
 >>       ;(collect-garbage)
 >>       ) ; end of initial deal
 >>
 >>     (define/public (place-on-flower-bed-request flower flower-bed)
 >>       (let ((stacked (send flower-bed get-cards)))
 >>         (when (or (empty? stacked)
 >>                   (and (card-one-rank-below? flower (wheels stacked))
 >>                        (card-same-suit? flower (wheels stacked))))
 >>           (send flower-bed add-card flower)
 >>           (broadcast stack-register move-done) )))
 >>
 >>     (define (game-is-won?)
 >>       (define (foundation-full? foundation)
 >>         (let ((stacked (send foundation get-cards)))
 >>           (and (not (null? stacked))
 >>                (card-is-king? (wheels stacked))) ))
 >>       (define (game-is-won? foundations)
 >>         (if (null? foundations)
 >>             #t
 >>             (and (foundation-full? (wheels foundations))
 >>                  (game-is-won? (cast foundations))) )) ; not tail recursive
 >>       (game-is-won? foundations))
 >>
 >>     (define/public (place-on-foundation-request flower foundation)
 >>       (let ((stacked (send foundation get-cards)))
 >>         (when [or (and (empty? stacked)
 >>                        (card-is-ace? flower))
 >>                   (and (not (empty? stacked))
 >>                        (card-same-suit? flower (wheels stacked))
 >>                        (card-one-rank-above? flower (wheels stacked)))]
 >>           (send foundation add-card flower)
 >>           ;(clear-selection)
 >>           (broadcast stack-register move-done)
 >>         (when (game-is-won?)
 >>               (send my-bouquet flower-present)
 >>               (reset-game) )) ))
 >>
 >>     (define (is-playable? flower)
 >>       (and (send flower user-can-move)
 >>            (not (send flower face-down?))))
 >>
 >>     (define/public (rescue-request flower)
 >>       (when (is-playable? flower)
 >>         ;; It's a bit like brute force but it's terse and readable.
 >>         ;; (and with animation it looks really funny which makes
 >>         ;; you lough and that is a good thing [for a card game]!)
 >>         (for-each {lambda (foundation)
 >>                     (place-on-foundation-request flower foundation)}
 >>                   foundations)))
 >>
 >>
 >>     (define/public (place-on-bucket-request flower bucket)
 >>       (when [< (send bucket number-of-cards) 16]
 >>         (send bucket add-card flower)
 >>         ;(clear-selection)
 >>         (broadcast stack-register move-done) ))
 >>
 >>     ;;
 >>     ;; DEFUNCT Selection Handling Interface
 >>
 >>     ;;    (define/public (clear-selection)
 >>     ;;      ;(debug "garden%: clear-selection called; flower-selection: "
 >> flower-selection)
 >>     ;;      ;(broadcast flowers dim #f)
 >>     ;;      (when flower-selection
 >>     ;;           (debug "garden%: clear-selection: clearing selection")
 >>     ;;           ;(send flower-selection dim #f)
 >>     ;;            ;(broadcast flowers dim #f)
 >>     ;;           (set! flower-selection #f)))
 >>
 >>     ;;    (define/public (selection-request flower)
 >>     ;;      (debug "garden%: selection-request called")
 >>     ;;      (if [and (eq? flower-selection flower)
 >>     ;;              (send flower-selection dim)]
 >>     ;;         (clear-selection)
 >>     ;;         (when [is-playable? flower]
 >>     ;;               (clear-selection)
 >>     ;;               (set! flower-selection flower)
 >>     ;;               (send flower dim #t)) ))
 >>
 >>
 >>     ;;;
 >>     ;;; Application Interface
 >>
 >>     (define/public (grow)
 >>       (send garden show #t)
 >>       (w/o-cart-animation garden initial-deal))
 >>     ;(initial-deal))
 >>
 >>     (define/public (reset-game)
 >>       [w/o-cart-animation* garden
 >>                            ;; remove cards from the stacks (from the model)
 >>                            (for-each {lambda (card)
 >>                                        ;; ??? perhaps it's better to implement
 >> reset in
 >>                                        ;; stack%
 >>                                        (broadcast stack-register remove-card!
 >> card)}
 >>                                      flowers)
 >>                            ;; remove cards from the table (from the view)
 >>                            (send garden remove-cards flowers)
 >>
 >>                            (reset-flowers flowers)
 >>                            (initial-deal)])
 >>
 >>     )}
 >>
 >>
 >> ;;
 >> ;; Application Class / Menu and System Interface
 >> ;;
 >>
 >> (define flower-garden%
 >>   {class
 >>       object%
 >>     (super-new)
 >>
 >>     (define garden (new garden%))
 >>     (define main-frame (send garden get-table))
 >>     (define my-menu-bar (make-object menu-bar% main-frame))
 >>     (define my-game-menu (make-object menu% "Game" my-menu-bar))
 >>     (new menu-item%
 >>          [label "Reset Game..."]
 >>          [parent my-game-menu]
 >>          [callback
 >>           {lambda (i e)
 >>             (when (eq? 'yes (message-box "Reset Game"
 >>                                          "Are you sure you want to reset the
 >> game?"
 >>                                          main-frame
 >>                                          '(yes-no)))
 >>               (send garden reset-game))}])
 >>     (new separator-menu-item% [parent my-game-menu])
 >>     (new menu-item%
 >>          [label "Quit"]
 >>          [parent my-game-menu]
 >>          [callback {lambda (i e)
 >>                      (send main-frame show #f)
 >>                      (exit)}])
 >>
 >>
 >>     (send garden grow)
 >>     })
 >>
 >> (define sort-by-suit (new flower-garden%))
 >>
 >> *** Environment:
 >> macosx "Darwin nPing.local 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7
 >> 16:33:36 PDT 2011; root:xnu-1504.15.3~1/RELEASE_I386 i386" (x86_64-macosx/3m)
 >> (get-display-depth) = 32
 >> Human Language: english
 >> (current-memory-use) 440017348
 >> raco pkg (show):
 >> Installation-wide:
 >>  Package              Checksum                                    Source
 >>  main-distribution    f07e2d4bf2708c1085be38eca18aa9eb6755e547    (catalog
 >> main-distribution)
 >>  racket-lib           41c7b3221006758c5a840a18dcc0d265632f14c2    (catalog
 >> racket-lib)
 >>  [178 auto-installed packages not shown]
 >> User-specific for installation "6.1":
 >>  [none]
 >>
 >>
 >>
 >> Collections:
 >> ("/Users/mt/Library/Racket/6.1/collects"
 >>  (non-existent-path))
 >> ("/Applications/Racket v6.1/collects"
 >>  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info"
 >> "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco"
 >> "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))
 >>
 >> Recent Internal Errors:
 >> Computer Language: (("Determine language from source") (#(#t print
 >> mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t #t ((test)
 >> (main)) #t))
From: =?UTF-8?Q?Jens_Axel_S=C3=B8gaard?= <jensaxel@soegaard.net>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, michael.tiedtke@o2online.de,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/15059: Color Database (color-database<%>) Name
 Mix up
Date: Mon, 11 May 2015 20:14:50 +0200

 --001a113deff29ac0d10515d25a9c
 Content-Type: text/plain; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 We could have more than one color database.
 Whether the fixed or the current should be the default matters not too much=
 .
 
 (Note: On OS X we don't respect RGB values, so we (I am almost sure)
            have different colors on OS X and Windows.
            Example: Create a color using rgb and draw in the screen with
 Racket.
                            Use a color picker program and examine the RGB
 values.
                            They are different.
            The bug isn't in Racket, but in Cairo. It has something to do
 with
            Cairo not using the monitor information form the OS.)
 
 
 
 
 
 2015-05-11 20:05 GMT+02:00 Robby Findler <robby@eecs.northwestern.edu>:
 
 > I think changing the Green at this point is unwise. But maybe adding
 > the missing one would be good. And DarkSeaGreen seems like a good
 > change.
 >
 > So many methods take strings and are documented to use this table so
 > it is hard for me to think of a good way to make a reasonable
 > backwards compatible change. But we could offer a second color
 > database and encourage new code to use that, maybe?
 >
 > Robby
 >
 > On Mon, May 11, 2015 at 10:57 AM, Matthew Flatt <mflatt@cs.utah.edu>
 > wrote:
 > > Thanks for the report!
 > >
 > > "Cornflower Blue" is definitely a problem, and "Cadet Blue" is also
 > > slightly off from "CadetBlue". I think "Lavender" and "Azure" are
 > > mapped in the same way as standards, though.
 > >
 > > Colors mappings that don't match HTML 4.01:
 > >
 > >            HTML            racket/draw
 > >  Green     (0 128 0)       (0 255 0)
 > >  Gray      (128 128 128)   (190 190 190)
 > >  Maroon    (128 0 0)       (176 48 96)
 > >  Purple    (128 0 128)     (160 32 240)
 > >  Navy      (0 0 128)       (36 36 140)
 > >
 > > Other colors that are not part of the HTML standard, but are part of
 > > the SVG standard and supported by most browsers for HTML:
 > >
 > >                 SVG            racket/draw
 > >  Brown          (165 42 42)    (132 60 36)
 > >  RebeccaPurple  (102 51 153)   [missing]
 > >  Aquamarine     (127 255 212)  (112 216 144)
 > >  DarkSeaGreen   (143 188 143)  (143 188 139)
 > >
 > > I'm not yet sure what to do. The mismatch seems bad, but changing the
 > > meaning of color names (which could break existing programs, especially
 > > for "Green") also seems bad.
 > >
 > >
 > > At Mon, 11 May 2015 01:16:02 -0400, michael.tiedtke@o2online.de wrote:
 > >> A new problem report is waiting at
 > >>   http://bugs.racket-lang.org/query/?cmd=3Dview&pr=3D15059
 > >>
 > >> Reported by Michael Tit-ke for release: 6.1
 > >>
 > >> *** Description:
 > >> Oops, Racket's color database seems to have been hacked: a
 > >> little name mix up: Cornflower Blue is Lavender where Lavender
 > >> probably is azzurro (in italian) where the database has a french
 > >> sounding entry named azure. The other CornflowerBlue is alright
 > >> but the way things are you're now allowed to pick any colors not
 > >> only the ones named after flowers.
 > >> Just changing the names again would probably not be the right solution=
 .
 > Steps
 > >> to reproduce might contain other issues (Redrw
 > >>
 > >> *** How to repeat:
 > >> #lang racket
 > >>
 > >> ;; This is the message passing approach to the patience solitaire game
 > >> ;; Flower Garden.
 > >> ;;
 > >> ;; This is the variant Flower Venus Garden with a relaxed ruleset.  Yo=
 u
 > >> ;; can move only one card at time but from anywhere to anywhere.
 > >> ;; Sequences in the flower beds have to be build by suit.  The
 > >> ;; foundations are built from ace to king but cards can be moved back
 > >> ;; into the game. You can double click a card and if possible it will
 > >> ;; find its place in the foundations. You can place up to sixteen
 > >> ;; cards in the bouquet. There is a good chance of winning the game.
 > >> ;;
 > >> ;; (The layout of the bouquet, i.e. the reserve of cards at the bottom
 > >> ;; of the table is done automatically but only after a card has been
 > >> ;; moved successfully. Rethinking and correcting this is left as
 > >> ;; exercise for the interested player.)
 > >> ;;
 > >> ;; Description & Rules
 > >> ;;
 > >> ;; One deck of 52 cards.
 > >> ;;
 > >> ;; < from wikipedia
 > >> ;; Thirty-six cards are dealt in to six columns, each containing six
 > >> ;; cards. The columns are called the "flower beds" and the entire
 > >> ;; tableau is sometimes called "the garden." The sixteen leftover
 > >> ;; cards become the reserve, or "the bouquet."
 > >> ;;
 > >> ;; The top cards of each flower-bed and all of the cards in the
 > >> ;; bouquet are available for play. Cards can only be moved one at a
 > >> ;; time and can be built either on the foundations or on the other
 > >> ;; flower beds. The foundations are built up by suit, from Ace to King
 > >> ;; (a general idea of the game is to release the aces first). The
 > >> ;; cards in the garden, on the other hand, can be built down
 > >> ;; regardless of suit and any empty flower bed can be filled with any
 > >> ;; card. The cards in the bouquet can be used to aid in building, be
 > >> ;; put into the foundations, or fill an empty flower bed.
 > >> ;;
 > >> ;; The game is won when all cards end up in the foundations.
 > >> ;; > end from wikipedia
 > >> ;;
 > >>
 > >> ;;
 > >> ;; Technical Note: While it is written in a rather traditional way
 > >> ;; without mixins, traits or an emphasis on surrogates it might
 > >> ;; contain ideas, concepts and terms that go beyond today's message
 > >> ;; passing "customs". A new message passing primitive "broadcast" and
 > >> ;; the term hub for certain classes are consequences of thinking about
 > >> ;; the future of message passing, parallel objects and one new program
 > >> ;; code abstraction system "to rule them all" especially when it comes
 > >> ;; to open source and the user's ability to adapt and program the
 > >> ;; shiny some thousand money units worth machine in front of him. From
 > >> ;; LISP machines to BSD to Mach message passing microkernel to
 > >> ;; NextStep to ... but that is far away: for me it was from QBASIC to
 > >> ;; RISC assembler to NetBeans to Dr. Racket to whatever comes in
 > >> ;; handy.
 > >> ;;
 > >>
 > >> ;;
 > >> ;; Description of the User Interaction
 > >> ;;
 > >> ;; Most of the event handling is done by the views card<%>, table<%>
 > >> ;; and region. (See Event Handling)
 > >> ;;
 > >> ;; According to the rules only one card may be moved at any time.
 > >> ;;
 > >>
 > >> ;;
 > >> ;; Bugs and Maintenance
 > >> ;;
 > >> ;; Bug (unreproducible): in a new game after program start the second
 > >> ;; card in a flower bed which was face down could be moved. As
 > >> ;; reconfigure-cards in the flower-bed class is rather clear about
 > >> ;; this issue and because it happened during the animation of an
 > >> ;; unrelated move and is part of the Virtual Card Library's special
 > >> ;; behaviours.
 > >>
 > >> ;;;
 > >> ;;; Modules and Dependencies
 > >> ;;;
 > >>
 > >> (require games/cards racket/gui racket/class racket/unit)
 > >>
 > >> ;(load "card-logic.rkt")
 > >> ;(include (file "card-logic.rkt"))
 > >>
 > >>
 > >> ;;;
 > >> ;;; Extension of the Algorithmic Language Scheme
 > >> ;;;
 > >>
 > >> ;; (define (broadcast object-list method . arguments)
 > >> ;;   {define (apply-messages object)
 > >> ;;     (send/apply object method arguments)}
 > >> ;;   (map apply-messages object-list))
 > >>
 > >> (define-syntax cast (syntax-rules () ((_ type) (cdr type))))
 > >> (define-syntax broadcast
 > >>   (syntax-rules ()
 > >>     ((_ object-list method ...)
 > >>      (map {lambda (object) (send object method ...)}
 > >>           object-list))))
 > >> (define-syntax broadcast*
 > >>   (syntax-rules ()
 > >>     ((_ object-list method ...)
 > >>      (map {lambda (object) (send* object method ...)}
 > >>           object-list))))
 > >>
 > >> (define (repeat n closure)
 > >>   "Execute closure n times."
 > >>   (if (not (and (exact? n) (integer? n)  ; 'integer?' does not check f=
 or
 > >> exactness ...
 > >>                 (>=3D n 0)))
 > >>       (error "repeat: the parameter n must be an exact natural number
 > or zero.")
 > >>       {let loop ((i 0))
 > >>         (when (< i n)
 > >>           (closure)
 > >>           (loop (add1 i)))} ))
 > >>
 > >> (define (half numerical) (/ numerical 2))
 > >>
 > >> (define wheels
 > >>   ;; Every car has four wheels.
 > >>   car)
 > >>
 > >> ;;
 > >> ;; The Virtual Card Library wants us to program in assembler
 > >> ;; style. This is how we escape it.
 > >> (define (w/o-cart-animation table closure)
 > >>   "Don't let the car's movement be shown."
 > >>   (let ((returned-value void))
 > >>     (send table begin-card-sequence)  ; determine the winning card
 > sequence
 > >>     (set! returned-value (closure))
 > >>     (send table end-card-sequence)
 > >>     returned-value))
 > >>
 > >> (define-syntax w/o-cart-animation*
 > >>   (syntax-rules ()
 > >>     ((_ table first-expression ...)
 > >>      ;; 'returned-value' was accessible by the expressions in the
 > expansion;
 > >>      ;; that was a shortcoming.
 > >>      ;; It might even have shadowed a definition for that symbol at th=
 e
 > >>      ;; position of the expansion. That would have beeen a pity.
 > >>      ;;
 > >>      ;; We're now creating a closure for the expressions.
 > >>      ;; This should be safe, hygienic or however you want to call it.
 > >>      (let* ([closure {lambda ()
 > >>                        first-expression
 > >>                        ...}]
 > >>             [returned-value void])
 > >>        (send table begin-card-sequence)
 > >>        (set! returned-value (closure))
 > >>        (send table end-card-sequence)
 > >>        returned-value) )))
 > >>
 > >> (define create-cell-and-attach cons)
 > >>
 > >> ;; That is "sea cat" but where is "bee cat"?
 > >> ;; (You might even find "a cat").
 > >> (define sea-cat create-cell-and-attach)
 > >>
 > >>
 > >> ;;;
 > >> ;;; Card Logic
 > >> ;;;
 > >>
 > >> ;;
 > >> ;; Card Suits and Colors: Predicates and Utility Procedures
 > >>
 > >> (define (suit-color suit-symbol)
 > >>   "Return 'red for 'heart and 'club. Return 'black for 'diamond or
 > 'spade. Else
 > >> false."
 > >>   (case suit-symbol
 > >>     [(hearts diamonds) 'red]
 > >>     [(clubs spades) 'black]
 > >>     [(unknown) (debug "card logic: suit-color: unknown suit") #f] ;
 > this entry
 > >> exists for completeness as card<%> get-suit might return 'unknown
 > >>     [else (warning "card logic: suit-color: suit not found: "
 > suit-symbol) #f]))
 > >>
 > >> (define (card-color card)
 > >>   "Return the color of the card's suit like suit-color."
 > >>   (suit-color (send card get-suit)))
 > >>
 > >> (define (card-is-red? card)
 > >>   "Return true if the color of the card's suit is red."
 > >>   (eq? (card-color card) 'red))
 > >>
 > >> (define (card-is-black? card)
 > >>   "Return true if the color of the card's suit is black."
 > >>   (eq? (card-color card) 'black))
 > >>
 > >>
 > >> ;;
 > >> ;; Card Rank Predicates
 > >>
 > >> (define (card-is-ace? card)
 > >>   "Return true if the card is an ace."
 > >>   (=3D (send card get-value) 1))
 > >>
 > >> (define (card-is-king? card)
 > >>   "Return true if the card is a king."
 > >>   (=3D (send card get-value) 13))
 > >>
 > >> (define (card-is-queen? card)
 > >>   "Return true if the card is a queen."
 > >>   (=3D (send card get-value) 12))
 > >>
 > >> (define (card-is-joker? card)
 > >>   "Reutrn true if the card is a joker."
 > >>   (=3D (send card get-value) 11))
 > >>
 > >> (define (card-is-ten? card) "Return true if the card is a ten."
 > >>   (=3D (send card get-value) 10))
 > >>
 > >> (define (card-is-nine? card) "Return true if the card is a nine."
 > >>   (=3D (send card get-value) 9))
 > >>
 > >> (define (card-is-eight? card) "Return true if the card is an eight."
 > >>   (=3D (send card get-value) 8))
 > >>
 > >> (define (card-is-seven? card) "Return true if the card is a seven."
 > >>   (=3D (send card get-value) 7))
 > >>
 > >> (define (card-is-six? card) "Return true if the card is a six."
 > >>   (=3D (send card get-value) 6))
 > >>
 > >> (define (card-is-five? card) "Return true if the card is a five."
 > >>   (=3D (send card get-value) 5))
 > >>
 > >> (define (card-is-four? card) "Return true if the card is a four."
 > >>   (=3D (send card get-value) 4))
 > >>
 > >> (define (card-is-three? card) "Return true if the card is a three."
 > >>   (=3D (send card get-value) 3))
 > >>
 > >> (define (card-is-two? card) "Return true if the card is a two."
 > >>   (=3D (send card get-value 2)))
 > >>
 > >>
 > >> ;;;
 > >> ;;; Card Binary Predicates
 > >>
 > >> ;; Card Rank Binary Predicates
 > >>
 > >> (define (card-one-rank-below? first-card second-card)
 > >>   "Return true if the first-card is one rank below the second-card."
 > >>   (let ((first-value (send first-card get-value))
 > >>         (second-value (send second-card get-value)))
 > >>     (=3D 1 (- second-value first-value))))
 > >>
 > >> (define (card-one-rank-above? first-card second-card)
 > >>   "Return true if the first-card is one rank above the second-card."
 > >>   (card-one-rank-below? second-card first-card))
 > >>
 > >> (define (card-next-rank? first-card second-card)
 > >>   "Return true if the first card is one rank above or below the
 > second-card."
 > >>   (or (card-one-rank-below? first-card second-card)
 > >>       (card-one-rank-above? first-card second-card)))
 > >>
 > >> (define (card-circular-one-rank-below? first-card second-card)
 > >>   "Return true if card-one-rank-below? is true or if the first-card is
 > a king
 > >> and second-card is an ace."
 > >>   (or (card-one-rank-below? first-card second-card)
 > >>       (and (card-is-king? first-card)
 > >>            (card-is-ace? second-card))))
 > >>
 > >> (define (card-circular-one-rank-above? first-card second-card)
 > >>   "Return true if card-one-rank-above? is true or if the first-card is
 > an ace
 > >> and the second-card is a king."
 > >>   (or (card-one-rank-above? first-card second-card)
 > >>       (and (card-is-ace? first-card)
 > >>            (card-is-king? second-card))))
 > >>
 > >> (define (card-circular-next-rank? first-card second-card)
 > >>   "Return true if card-next-rank? is true or if the two cards are a
 > king and an
 > >> ace."
 > >>   (or (card-next-rank? first-card second-card)
 > >>       (or (and (card-is-king? first-card) (card-is-ace? second-card))
 > >>           (and (card-is-ace? first-card) (card-is-king? second-card)))=
 ))
 > >>
 > >>
 > >> ;; Card Color and Suit Binary Predicates
 > >>
 > >> (define (card-same-color? first-card second-card)
 > >>   "Return true if the color of the first-card's suit is the same as th=
 e
 > one of
 > >> the second-card."
 > >>   (eq? (card-color first-card)
 > >>        (card-color second-card)))
 > >>
 > >> (define (card-same-suit? first-card second-card)
 > >>   "Return true if the suit of the first-card is the same as the one of
 > the
 > >> second-card."
 > >>   (eq? (send first-card get-suit)
 > >>        (send second-card get-suit)))
 > >>
 > >>
 > >> ;;;
 > >> ;;; Debugging and other Developer Utilities
 > >> ;;;
 > >>
 > >> (define (debug . args)
 > >>   (display "Flower Garden: ")
 > >>   (for-each {lambda (arg) (display arg)}
 > >>             args)
 > >>   (newline))
 > >>
 > >> (define (warning . args)
 > >>   (apply debug "WARNING: " args))
 > >>
 > >> ;;; End of Pretext
 > >>
 > >> ;;
 > >> ;; Layout
 > >> ;;
 > >> ;; This abstract layout hub class keeps the layout in one spot.
 > >> ;; This approach rips open the encapsulation of the other classes
 > >> ;; but in this case it's more important to seperate layout from logic.
 > >> ;;
 > >> ;; As a general layout message passing protocol objects requesting
 > >> ;; layout information send themselves as arguments even if this is
 > >> ;; right now unecessary in some cases. In most cases though this
 > >> ;; layout hub needs more information from the object, e.g. the index
 > >> ;; of a stack to provide the correct layout information.
 > >> ;;
 > >> ;; About this layout for Flower Garden:
 > >> ;;
 > >> ;; The layout is hardcoded: it will not adapt to a change in the
 > >> ;; number of stacks. A different number of stacks would be a different
 > >> ;; game anyway. It should be rather easy to exchange the meaning of
 > >> ;; row and column in this layout though. But it might even be
 > >> ;; intertwined: not always following its inner logic.
 > >> ;;
 > >> ;; The layout is completely based on the playing card dimensions:
 > >> ;;  for this it needs one unit card to retrieve the dimensions.
 > >> ;;
 > >> ;; There is an upper border and a left border.
 > >> ;; There are six columns with intercolumn spacing.
 > >> ;; There are three rows with interrow spacing.
 > >> ;;  The first row contains the centered four foundations.
 > >> ;;  The second row contains the six flower beds.
 > >> ;;  The third row contains the bouquet.
 > >>
 > >> {define layout%
 > >>   (class
 > >>       object%
 > >>     (init unit-card)
 > >>     (super-new)
 > >>     (define card-width (send unit-card card-width))
 > >>     (define card-height (send unit-card card-height))
 > >>     ;; ??? perhaps we should release unit-card here
 > >>
 > >>     (define default-spacing-unit (/ card-width 7)) ; confront with
 > table width
 > >>
 > >>     (define upper-border default-spacing-unit)
 > >>     (define left-border default-spacing-unit)
 > >>     (define intercolumn-space default-spacing-unit)
 > >>     (define interrow-space (* 2 default-spacing-unit))
 > >>
 > >>     (define (column-n-x n)
 > >>       "Return the x coordinate of the left border of the n'th column."
 > >>       (+ left-border (* (+ card-width intercolumn-space)
 > >>                         (sub1 n))) )
 > >>
 > >>     ;;
 > >>     ;; Layout of the Table
 > >>
 > >>     ;; One card width for each column plus one for spacing.
 > >>     (define/public (get-table-width garden) 7)
 > >>
 > >>     ;; One card height for the foundations, one for the bouquet, one
 > >>     ;; for spacing and four card heights for the flower bed.
 > >>     (define/public (get-table-height garden) 7)
 > >>
 > >>     ;; Table Background
 > >>     (define fixed-window-border 0)
 > >>     (define flower "Lavender")
 > >>     (define/public (get-background-x-coordinate garden)
 > >>       fixed-window-border)
 > >>     (define/public (get-background-y-coordinate garden)
 > >>       fixed-window-border)
 > >>     (define/public (get-background-width garden)
 > >>       (- (* card-width (get-table-width garden))
 > >>          (* 2 fixed-window-border)))
 > >>     (define/public (get-background-height garden)
 > >>       (- (* card-height (get-table-height garden))
 > >>          (* 2 fixed-window-border)))
 > >>     (define/public (get-background-paint-callback garden)
 > >>       ;; This is design and not only layout.
 > >>       ;; See the documentation of color-database<%> for color names.
 > >>       ;; (But you're only allowed to use colors named after flowers. ;=
 -)
 > >>       {lambda (drawing-context x y width height)
 > >>       ;; XXX there is some redrawing shortcoming at the right border
 > >>       ;; and at the lower border
 > >>       (send drawing-context set-background flower)
 > >>         (send drawing-context clear)
 > >>       })
 > >>     (define/public (flower-present selected-flower)
 > >>       (set! flower selected-flower))
 > >>
 > >>     ;;
 > >>     ;; Layout of the Foundations
 > >>     (define foundation-top-line
 > >>       upper-border)
 > >>     (define/public (get-foundation-x-coordinate foundation)
 > >>       (let ((foundation-index (send foundation get-foundation-index)))
 > >>         (column-n-x (+ foundation-index 1))))
 > >>     (define/public (get-foundation-y-coordinate foundation)
 > >>       foundation-top-line)
 > >>     (define/public (get-foundation-width foundation)
 > >>       card-width)
 > >>     (define foundation-height card-height)
 > >>     (define/public (get-foundation-height foundation)
 > >>       foundation-height)
 > >>
 > >>     ;;
 > >>     ;; Layout of the Flower Beds
 > >>     (define flower-bed-top-line
 > >>       (+ foundation-top-line
 > >>          foundation-height
 > >>          interrow-space))
 > >>     (define/public (get-flower-bed-x-coordinate flower-bed)
 > >>       (let ((flower-bed-index (send flower-bed get-flower-bed-index)))
 > >>         (column-n-x flower-bed-index)))
 > >>     (define/public (get-flower-bed-y-coordinate flower-bed)
 > >>       flower-bed-top-line)
 > >>     (define flower-bed-width card-width)
 > >>     (define/public (get-flower-bed-width flower-bed)
 > >>       flower-bed-width)
 > >>     ;; Each flower bed needs to accomodate up to 18 cards.
 > >>     (define flower-bed-card-y-offset (/ card-height 3))
 > >>     (define flower-bed-height (+ (* 1  card-height)
 > >>                                  (* 8 flower-bed-card-y-offset)))
 > >>     (define/public (get-flower-bed-height flower-bed)
 > >>       flower-bed-height)
 > >>
 > >>     ;;
 > >>     ;; Layout of the Bouquet
 > >>     (define bucket-top-line
 > >>       (+ flower-bed-top-line
 > >>          flower-bed-height
 > >>          (* 3/2 interrow-space)))     ; this extra space makes it look
 > better
 > >>     (define/public (get-bucket-x-coordinate bucket)
 > >>       (column-n-x 1)) ; bucket's left border is aligned to the first
 > column
 > >>     (define/public (get-bucket-y-coordinate bucket)
 > >>       bucket-top-line)
 > >>     (define/public (get-bucket-width bucket)
 > >>       (- (+ (column-n-x 6) flower-bed-width)
 > >>          left-border)) ; bucket's right border is aligned to the last
 > column
 > >>     (define/public (get-bucket-height bucket)
 > >>       [+ (* 3/4 default-spacing-unit) ; there is no sense if not
 > asthetic sense
 > >>          (* 3/2 card-height)]) ; give the user some space and fill the
 > table
 > >>
 > >>     ;;
 > >>     ;; Card Layout
 > >>     (define (stack-layout-cards! foundation)
 > >>       (let ((cards (reverse (send foundation get-cards)))
 > >>             (region (send foundation get-region)))
 > >>         (send* (send (send foundation get-garden)
 > >>                      get-table)
 > >>           (stack-cards (reverse cards)) ; z-axis-stacking
 > >>           (move-cards cards
 > >>                       (region-x region)
 > >>                       (region-y region)))))
 > >>     (define foundation-layout-cards! stack-layout-cards!)
 > >>
 > >>     (define (flower-bed-layout-cards! flower-bed)
 > >>       (let* ((cards (reverse (send flower-bed get-cards)))
 > >>              (region (send flower-bed get-region))
 > >>              (number-of-cards (length cards))
 > >>              ;(card-height (send (wheels cards) card-height))
 > >>              (offset flower-bed-card-y-offset)
 > >>              (height (region-h region)))
 > >>         (when (> (+ card-height (* number-of-cards offset))
 > >>                  height)
 > >>           ;                                   ; y =3D ch + (nc-1)*of
 > >>           ;                                   ; y-ch / (nc-1) =3D of
 > >>           (set! offset (/ (- height card-height)
 > >>                           (sub1 number-of-cards))))
 > >>         (send* (send (send flower-bed get-garden) get-table)
 > >>           (stack-cards (reverse cards)) ; z-axis-stacking
 > >>           (move-cards cards
 > >>                       (region-x region)
 > >>                       (region-y region)
 > >>                       {lambda (n)
 > >>                         (values 0 (* offset n)) } ))))
 > >>
 > >>
 > >>     ;; Preserve x-axis order and DO NOT preserve the y-coordinates
 > >>     ;(define (x-selector x y) x)
 > >>     ;   (define (get-card-x-coordinate card table)
 > >>     ;     (call-with-values (lambda ()
 > >>     ;                         (send table card-location card))
 > >>     ;                       (lambda (x y) x)))
 > >>     (define bucket-card-top-line (+ bucket-top-line
 > >>                                     (* 2 default-spacing-unit)))
 > >>     (define (bucket-layout-cards! bucket)
 > >>       (let* ((table (send (send bucket get-garden) get-table))
 > >>              (cards (sort (send bucket get-cards)
 > >>                           [lambda (first-card second-card)
 > >>                             (let-values (([x1 y1] (send table
 > card-location
 > >> first-card))
 > >>                                          ([x2 y2] (send table
 > card-location
 > >> second-card)))
 > >>                               (< x1 x2))]))
 > >> ;             (y-coordinates (list->vector
 > >> ;                             (map {lambda (card) ; retrieve sorted
 > >> y-coordinates
 > >> ;                                    (let-values
 > >> ;                                        ([(x y)
 > >> ;                                          (send table card-location
 > card)])
 > >> ;                                      (if (< y bucket-card-top-line)
 > >> ;                                          (* 2 default-spacing-unit)
 > >> ;                                          (- y bucket-top-line)))}
 > >> ;                                  cards)))
 > >>              (number-of-cards (send bucket number-of-cards))
 > >>              (region (send bucket get-region))
 > >>              ;(card-height (send (wheels cards) card-height))
 > >>              (width (region-w region))
 > >>              ;; Racket doesn't know how to divide by zero so we have t=
 o
 > >>              ;; check and in the case of a too small number of cards w=
 e
 > >>              ;; use infinity as the offset for the other cards
 > >>              ;; that do not even exist. But infinity is bigger than th=
 e
 > >>              ;; the maximum offset and that is what we want. Thus
 > dividing
 > >>              ;; by zero should (at least as an option) yield infinity
 > because
 > >>              ;; well behaved algorithms can continue correctly and mig=
 ht
 > >>              ;; even depend on the mathematical consequences of using
 > the
 > >>              ;; "symbol" or concept of infinity.
 > >>              [offset (if (> number-of-cards 1)
 > >>                          (begin (/ (- width (* 1 card-width))
 > >>                                    (sub1 number-of-cards)))
 > >>                          ; This is correct when number-of-cards is one=
 .
 > >>                          ; This is wrong for number-of-cards less than
 > >>                          ; or equal to 0 which should not happen.
 > >>                          +inf.0)]
 > >>              [maximum-offset (* 3/2 card-width)]
 > >>              [centered-x-offset 0])
 > >>         (cond
 > >> ;              [[> offset maximum-offset]
 > >> ;               ;; This is difficult to test as the situation arises
 > only
 > >> ;               ;; later on in the game.
 > >> ;               (set! offset maximum-offset)
 > >> ;               (set! centered-x-offset
 > >> ;                     {half [- (region-w region)
 > >> ;                              {+ card-width [* offset (-
 > number-of-cards
 > >> 1)]}]} )]
 > >>               ;; When the offset is too close to card-width it looks
 > better
 > >>               ;; not to put one card next to the other but to fan them=
 .
 > >>               ([> offset (* 2/3 card-width)]
 > >>                (set! offset (* 2/3 card-width))
 > >>                (set! centered-x-offset
 > >>                      {half [- (region-w region)
 > >>                               {+ card-width [* offset (-
 > number-of-cards 1)]}]}
 > >> )))
 > >>         (send* (send (send bucket get-garden) get-table)
 > >>           (stack-cards (reverse cards)) ; z-axis-stacking
 > >>           (move-cards cards
 > >>                       (+ (region-x region) centered-x-offset)
 > >>                       (region-y region)
 > >>                       {lambda (n)
 > >>                         (values (* offset n)
 > >>                                 (* 2 default-spacing-unit))
 > >>                                 ;(vector-ref y-coordinates n))
 > >>                                 } ))))
 > >>
 > >>     (define/public (layout-cards! stack)
 > >>       (cond ([is-a? stack foundation%] (foundation-layout-cards! stack=
 ))
 > >>             ([is-a? stack flower-bed%] (flower-bed-layout-cards! stack=
 ))
 > >>             ([is-a? stack bucket%] (bucket-layout-cards! stack))
 > >>             (else
 > >>              (warning "layout%: layout-cards!:"
 > >>                       " no registered card layout found for type: "
 > >>                       (object-interface stack)
 > >>                       ": using fallback: stack-layout-cards!")
 > >>              (stack-layout-cards! stack))))
 > >>     )}
 > >>
 > >> ;;
 > >> ;; Flowers
 > >> ;;
 > >> ;; Now this is the stupid approach to class redefinition (see
 > >> ;; Guile/GOOPS). We need each card object to have a back link to its
 > >> ;; stack. While card% does feature a home-region where region is the
 > >> ;; "view" of the stack the region structure does not provide a list of
 > >> ;; cards and thus it does not keep track of the sequence of cards. We
 > >> ;; do this in the model with a list (see stack%). Then the message
 > >> ;; passing protocol for the region callbacks gives us a list of cards
 > >> ;; dragged to a region and we can add these cards to the stack of the
 > >> ;; target. But how do we remove these cards from the stack where the
 > >> ;; cards came from? BTW The implementation of Spider loops through all
 > >> ;; stacks. We do that with broadcast.
 > >>
 > >> (define (reset-flowers flowers)
 > >>   (broadcast* flowers
 > >>               (face-down)
 > >>               (user-can-flip #f)
 > >>               (snap-back-after-move #t)
 > >>               (user-can-move #f))
 > >>   flowers)
 > >>
 > >> (define (make-flowers flowers)
 > >>   (reset-flowers flowers))
 > >>
 > >> (define flower-dialog%
 > >>   {class
 > >>    dialog%
 > >>    (init garden)
 > >>    (define my-garden garden)
 > >>    (super-new [label "Flowers"]
 > >>             [parent (send my-garden get-table)]
 > >>             [stretchable-width #f]
 > >>             [stretchable-height #f])
 > >>    ;; See the documentation of color-database<%> for color names.
 > >>    ;; (But you're only allowed to use colors named after flowers. ;-)
 > >>    ;; Oops, Racket's color database seems to have been hacked: a
 > >>    ;; little name mix up: Cornflower Blue is Lavender where Lavender
 > >>    ;; probably is azzurro (in italian) where the database has a french
 > >>    ;; sounding entry named azure. The other CornflowerBlue is alright
 > >>    ;; but the way things are you're now allowed to pick any colors not
 > >>    ;; only the ones named after flowers.
 > >>    (define flowers
 > >>      (list
 > >>       ;"Pale Green" ; you might take this for the infamous Mint Green
 > >>       "Lavender"
 > >>       "FloralWhite"
 > >>       "MistyRose"
 > >>       "Cornflower Blue"
 > >>       "Orchid"
 > >>       "Violet Red"
 > >>       ))
 > >>    (define flower-chooser
 > >>     (new radio-box%
 > >>        [label #f]
 > >>        [parent (new group-box-panel%
 > >>                     [parent this]
 > >>                     [label "You can pick a flower!"]
 > >>                     [stretchable-width #f]
 > >>                     [stretchable-height #f])]
 > >>        [choices flowers]))
 > >>    (define bottom-panel
 > >>      (new horizontal-panel%
 > >>         [parent this]
 > >>         [alignment '(center center)]
 > >>         [stretchable-height #f]))
 > >>    (new button%
 > >>        [parent bottom-panel]
 > >>        [label "&Ok"]
 > >>        [style '(border)]
 > >>        [callback {lambda (b e)
 > >>                  (send my-garden flower-picked
 > >>                        (vector-ref (list->vector flowers)
 > >>                                    (send flower-chooser get-selection)=
 ))
 > >>                  (send this show #f)} ])
 > >>
 > >>    (define/public (flower-present)
 > >>      ;(set! flowers (shuffle-list *flower-list* 12))
 > >>      (send this center)
 > >>      (send this show #t))
 > >> })
 > >>
 > >> ;;
 > >> ;; Stacks
 > >> ;;
 > >> ;; There are three kinds of stacks: foundations, flower beds and
 > >> ;; bouquet. Layouting is done with the help of the layout hub object
 > >> ;; as retrieved from the hosting garden object.
 > >> ;;
 > >> ;; While each card<%> object knows about its home-region, the regions
 > >> ;; are not aware of these cards. To get all the cards in one region on
 > >> ;; the table we could ask each card individually or keep track of all
 > >> ;; the moves and maintain the missing list of cards for each stack.
 > >> ;;
 > >> ;; NB Asking all card objects on the table about their home-region is
 > >> ;; not too time consuming, i.e. O(n), where each deck brings only 52
 > >> ;; objects into the game.
 > >>
 > >> (define stack%
 > >>   {class
 > >>       object%
 > >>     (init garden)
 > >>     (super-new)
 > >>
 > >>     ;;
 > >>     ;; Fields
 > >>     (define cards null)
 > >>     (define my-region null)
 > >>     (define my-garden garden)
 > >>
 > >>     ;; Accessors
 > >>     (define/public (get-garden) my-garden)
 > >>     (define/public (get-layout)
 > >>       (send my-garden get-layout))
 > >>
 > >>     (define/public (add-card card-to-add)
 > >>       (send (send this get-garden) syncronize-stacks card-to-add)
 > >>       (set! cards (sea-cat card-to-add cards))
 > >>       (send* card-to-add
 > >>         (home-region my-region)
 > >>         ;(stay-in-region my-region)
 > >>         )
 > >>       (send (get-layout) layout-cards! this)
 > >>       )
 > >>
 > >>     (define/public (remove-card! card-to-remove)
 > >>       (set! cards (filter {lambda (card) (not (eq? card
 > card-to-remove))}
 > >> cards)))
 > >>
 > >>     (define/public (move-done)
 > >>       ;(send (get-layout) layout-cards! this)
 > >>       #t)
 > >>
 > >>     (define/public (number-of-cards) (length cards))
 > >>     (define/public (empty?) (null? cards))
 > >>     (define/public (get-cards) cards)
 > >>
 > >>     ;;    (define/public (syncronize-cards-on-region)
 > >>     ;;      (set! cards (filter (lambda (card)
 > >>     ;;                            (equal? (send card home-region)
 > >>     ;;                                    my-region))
 > >>     ;;                          cards)))
 > >>
 > >>     ;;   (define/public (after-or-before-drag finished-on-region? card=
 s)
 > >>     ;;     #t)
 > >>     (define/public (get-region) my-region)
 > >>     (define/public (set-region new-region)
 > >>       (set! my-region new-region)
 > >>       ;     (set-region-interactive-callback!
 > >>       ;      my-region
 > >>       ;      {lambda (finished-on-region? cards)
 > >>       ;       (send this after-or-before-drag finished-on-region?
 > cards)})
 > >>       )
 > >>     })
 > >>
 > >> (define foundation%
 > >>   {class
 > >>       stack%
 > >>     (init foundation-index)
 > >>     (super-new)
 > >>
 > >>     (define my-index foundation-index)
 > >>
 > >>     (define (foundation-region-callback cards)
 > >>       (send (send this get-garden) place-on-foundation-request (wheels
 > cards)
 > >> this))
 > >>
 > >>     (let ((layout (send this get-layout)))
 > >>       (send this set-region
 > >>             (make-region
 > >>              (send layout get-foundation-x-coordinate this)
 > >>              (send layout get-foundation-y-coordinate this)
 > >>              (send layout get-foundation-width this)
 > >>              (send layout get-foundation-height this)
 > >>              "Foundation"
 > >>              foundation-region-callback)))
 > >>     (send (send (send this get-garden) get-table)
 > >>           add-region (send this get-region))
 > >>
 > >>     (define/public (get-foundation-index) my-index)
 > >>     })
 > >>
 > >> (define flower-bed%
 > >>   {class
 > >>       stack%
 > >>     (init flower-bed-index)
 > >>     (super-new)
 > >>
 > >>     (define my-index flower-bed-index)
 > >>
 > >>     (define (flower-bed-region-callback cards)
 > >>       (send (send this get-garden) place-on-flower-bed-request (wheels
 > cards)
 > >> this))
 > >>
 > >>     (let ((layout (send this get-layout)))
 > >>       (send this set-region
 > >>             (make-region
 > >>              (send layout get-flower-bed-x-coordinate this)
 > >>              (send layout get-flower-bed-y-coordinate this)
 > >>              (send layout get-flower-bed-width this)
 > >>              (send layout get-flower-bed-height this)
 > >>              #f ;"Flower Bed"
 > >>              flower-bed-region-callback)))
 > >>     (send (send (send this get-garden) get-table)
 > >>           add-region (send this get-region))
 > >>
 > >>     (define/public (get-flower-bed-index) my-index)
 > >>
 > >>     (define (reconfigure-cards)
 > >>       (let ((my-cards (send this get-cards)))
 > >>         (broadcast* my-cards
 > >>                     (user-can-move #f)
 > >>                     (snap-back-after-move #t))
 > >>         (when (not (null? my-cards))
 > >>           (let ((top-card (wheels my-cards)))
 > >>             (when (send top-card face-down?) (send top-card face-up))
 > >>             (send top-card user-can-move #t)) )))
 > >>
 > >>     (define/override (move-done)
 > >>       (reconfigure-cards))
 > >>     ;(send (send this get-layout) layout-cards! this))
 > >>     })
 > >>
 > >> ;; According to the game play bucket% might not even be a
 > >> ;; stack%. Technically speaking it does not impose any useful order
 > >> ;; onto the cards but is the reserve and its layout could be done by
 > >> ;; the user. Quality assurance (me when I just want to play) assured
 > >> ;; us though that doing the layout by hand isn't much fun and they
 > >> ;; would prefer us to do the layout for the user.
 > >> (define bucket%
 > >>   {class
 > >>       stack%
 > >>     (super-new)
 > >>
 > >>     (define (bucket-region-callback cards)
 > >>       (send (send this get-garden) place-on-bucket-request (wheels
 > cards) this))
 > >>
 > >>     (let ((layout (send this get-layout)))
 > >>       (send this set-region
 > >>             (make-region
 > >>              (send layout get-bucket-x-coordinate this)
 > >>              (send layout get-bucket-y-coordinate this)
 > >>              (send layout get-bucket-width this)
 > >>              (send layout get-bucket-height this)
 > >>              #f ;"Bouquet"
 > >>              bucket-region-callback)))
 > >>     (send (send (send this get-garden) get-table)
 > >>           add-region (send this get-region))
 > >>
 > >>     (define (prepare-card-for-bucket card)
 > >>       (when (send card face-down?) (send card face-up))
 > >>       (send* card
 > >>         ;(face-up)
 > >>         (snap-back-after-move #f)
 > >>         (user-can-move #t)
 > >>         ))
 > >>
 > >>     (define/override (add-card card)
 > >>       (prepare-card-for-bucket card)
 > >>       (super add-card card))
 > >>
 > >>     (define/override (move-done)
 > >>       (send (send this get-layout) layout-cards! this))
 > >>
 > >>     ;;    (define/override (after-drag finished-on-region? cards)
 > >>     ;;      (send (send this get-layout) layout-cards! this))
 > >>     })
 > >>
 > >> ;;
 > >> ;; Garbage Collection
 > >> ;;
 > >> ;; Sometimes the garbage collector (3m) starts running in the midst of
 > >> ;; an animation or worse in the middle of a user interaction like a
 > >> ;; drag. To avoid that this happens we call the garbage collector in
 > >> ;; right after the initial deal. The user interface effects of the
 > >> ;; initial deal show up only after the garbage collector returned. For
 > >> ;; this the user might stare at a gray empty window for a short period
 > >> ;; of time.
 > >> ;;
 > >> ;; Usually after each move-done there should be enough time to run the
 > >> ;; garbage collector because the user thinks about his next move or is
 > >> ;; on the way of reacting to the visual feedback (if we were talking
 > >> ;; about milliseconds) BUT: user interface changes are only shown
 > >> ;; after the event handler returned (to the internal event handling
 > >> ;; loop) AND the garbage collector seems to be really slow. Starting
 > >> ;; Flower Garden from the command line instead of running it in the
 > >> ;; IDE reduces the time the garbage collector takes noticeably but
 > >> ;; it's still too slow on a 2.4 GHz Dual Core. Racket and the used
 > >> ;; libraries/modules/packages do need a lot of RAM - about 200 MB but
 > >> ;; running the garbage collector all the time (at each move-done) does
 > >> ;; not reduce the time it needs. (BTW It's still 2015 by the time of
 > >> ;; this writing or should I say: already 2015)?
 > >> ;;
 > >> ;; Fast memory allocation might be a performance issue for one-way win
 > >> ;; the race scientific applications but for end user applications like
 > >> ;; this it would be better to have fast garbage collection which
 > >> ;; doesn't need ages - especially when there is nothing to be done and
 > >> ;; next to no changes in the data structures since the last run.
 > >>
 > >> ;;
 > >> ;; Program Action Hub
 > >> {define garden%
 > >>   (class
 > >>       object%
 > >>     (super-new)
 > >>
 > >>     (define number-of-foundations 4)
 > >>     (define number-of-flower-beds 6)
 > >>
 > >>     (define flower-selection #f)
 > >>
 > >>     (define flowers (make-flowers (make-deck)))
 > >>     (define layout (new layout% (unit-card (wheels flowers))))
 > >>
 > >>     ;; ;; ;; ;; ;; ;; ;; ;;
 > >>     ;; This should be a subclass of table% named
 > >>     ;; flower-garden-table%
 > >>     ;; But make-table won't let us do this conveniently ???
 > >>     (define garden (make-table
 > >>                     "Flower Venus Garden" ; title
 > >>                     (send layout get-table-width this)
 > >>                     (send layout get-table-height this) ))
 > >>
 > >>     ;; Redefine mouse interaction. See documentation.
 > >>     (send* garden
 > >>       (set-button-action 'left 'drag-raise/one)
 > >>       (set-button-action 'middle 'drag-raise/one)
 > >>       (set-button-action 'right 'drag-raise/one))
 > >>
 > >>     (define (dummy-mouse-event-handler card)
 > >>       #t)
 > >>
 > >>     ;; Event Handling
 > >>     ;;
 > >>     ;; There is no documented message passing protocol for the event
 > >>     ;; stream coming from region and table objects. There is no well
 > >>     ;; defined order but we can look at the order of events arriving
 > >>     ;; and think about it. A drag starts out with a single click
 > >>     ;; event. That single click event might or might not match our
 > >>     ;; interactor model but we need to make its consequences unhappen
 > >>     ;; because the user did not click but drag and we got to know abou=
 t
 > >>     ;; this only later on. There is a place to do that: see
 > >>     ;; set-interactive-region-callback! in stack% add-region.
 > >>     ;;
 > >>     ;; A double click is a time and coordinate dependent event usually
 > >>     ;; composed of two single clicks. Depending on the libraries and
 > >>     ;; low level routines in use we might expect to see the following
 > >>     ;; sequences in the event stream on the same card in a short time
 > >>     ;; interval: a period "." denotes a single click event, a colon ":=
 "
 > >>     ;; denotes a double click event
 > >>     ;;
 > >>     ;; ..  two clicks no double click event
 > >>     ;; :   one double click event - no single click events
 > >>     ;; .:  one single click event and one double click event
 > >>     ;; ..: two single click events and one double click event
 > >>     ;; :.. one double click event and two single click events
 > >>     ;; .:. one single click event then a double click event then
 > >>     ;;      a single click event again
 > >>     ;;
 > >>     ;; We can adapt our interaction model or Interactor (see Garnet) t=
 o
 > >>     ;; avoid misinterpreting events. A single click sets the selection
 > >>     ;; and the next click clears the selection. A double click clears
 > >>     ;; the selection. With this behaviour in mind there remain two
 > >>     ;; cases of event sequences which are not handled in the right way=
 :
 > >>     ;; the first one (..) which is degenerate because there is no
 > >>     ;; double click event at all. We could try to look at the time
 > >>     ;; codes of the events and determine if it was a double click or
 > >>     ;; not but we cannot check the pointer coordinates here which is
 > >>     ;; crucial to recognize double clicks and drags. Then the last
 > >>     ;; sequence (.:.) is problematic, too. And testing suggests that
 > >>     ;; this is our favourite one and only sequence of events. On the
 > >>     ;; developer's machine each double click event is surrouned by
 > >>     ;; single clicks and we end up with a card that has already been
 > >>     ;; moved by the double click event which cleared selection and we
 > >>     ;; now receive a single click event for that card: it ends up
 > >>     ;; selected (in a foundation). Please bear in mind that a click
 > >>     ;; event is a synthesized composed event itself: usually a click i=
 s
 > >>     ;; defined as the following sequence of low level events: mouse
 > >>     ;; button down, mouse button up (within the same spot region in
 > >>     ;; screen coordinates). The Virtual Card Library does not use that
 > >>     ;; definition of a click. Another aspect of our event handling her=
 e
 > >>     ;; to keep in mind is the fact that we do not recieve a stream of
 > >>     ;; events as a stream of events but the user defined thunks are
 > >>     ;; invoked as event handlers at certain not well defined moments
 > >>     ;; not in time but in the execution order of the Virtual Card
 > >>     ;; Library routines intertwined with garbage collection and
 > >>     ;; operating system interaction.
 > >>     ;;
 > >>     ;; Interaction Models have to be learned by the user. Some are
 > >>     ;; nowadays common accepted standard (even if not well documented)
 > >>     ;; but everything changes: where you're favourite lisp based actio=
 n
 > >>     ;; game developing environment from back then allowed you to choos=
 e
 > >>     ;; one of a set of actions and then apply it on some object today
 > >>     ;; we expect to select the object.e.g. file and then choose one of
 > >>     ;; its associated actions, e.g. delete. This is true on most moder=
 n
 > >>     ;; graphical user interaction shells. But when you do graphic
 > >>     ;; design and photo retouch we first choose the action or tool and
 > >>     ;; then apply it to some part of the object to design. Vice verse
 > >>     ;; these behaviours and people will tell you that it's completely
 > >>     ;; broken even if they're already used to both interaction models.
 > >>     ;; I don't touch I click - but that's another chapter and out of
 > >>     ;; the scope of this little card game.
 > >>     ;;
 > >>     ;; Some interaction models to not work out anyway: the select card
 > >>     ;; then destination approach falls for Moon Flower Garden because
 > >>     ;; the bucket is full of cards. Do you want to move the flower to
 > >>     ;; the bucket or do you want to select a card in the bucket?
 > >>
 > >>     (send* garden
 > >>       (set-double-click-action ;dummy-mouse-event-handler)
 > >>        {lambda (flower)
 > >>          ;(debug "flower-garden-table%: double-click-action")
 > >>          (send this rescue-request flower)})
 > >>       (set-single-click-action dummy-mouse-event-handler) )
 > >>     ;;           {lambda (flower)
 > >>     ;;              (debug "flower-garden-table%: single-click-action"=
 )
 > >>     ;;             (send this selection-request flower)}))
 > >>
 > >>     (send garden add-region
 > >>         (make-background-region
 > >>          (send layout get-background-x-coordinate garden)
 > >>          (send layout get-background-y-coordinate garden)
 > >>          (send layout get-background-width garden)
 > >>          (send layout get-background-height garden)
 > >>          (send layout get-background-paint-callback garden)))
 > >>
 > >>     ;;
 > >>     ;; Animations
 > >>     ;;
 > >>     ;; It seems the animation of the Virtual Card Library are
 > >>     ;; primarily intended to visualize algorithms or better: their
 > >>     ;; time ordered consequences. There is a problem where the
 > >>     ;; animation of a dragged card doesn't start at the final position
 > >>     ;; of the drag when/where the handler is called but it starts at
 > >>     ;; the original location of the card which might be percieved as
 > >>     ;; an unpleasant flickering. That behaviour of the animation
 > >>     ;; engine depends on a set home-region but not only. Not setting
 > >>     ;; the home-region at all in the class definition of stack% gives
 > >>     ;; us the correct starting positions for the animations after a
 > >>     ;; drag from the Bouquet to a Flower Bed. All drags originating
 > >>     ;; from Flower Beds do still animate with the described wrong
 > >>     ;; starting position. This might have to do with one of the
 > >>     ;; messages in reconfigure-cards but after all: the animation
 > >>     ;; engine does not feature any fine grained control and is abusing
 > >>     ;; the cards<%> configuration in an undocumented way. Nevertheless
 > >>     ;; the wrong starting position seems to be a real bug of the
 > >>     ;; animation engine. BTW It doesn't animate snap backs either ...
 > >>     ;; Perhaps they want to fix it.
 > >>
 > >>     ;(send garden animated #f)  ; turn animation off altogether
 > >>
 > >>     ;; End of pseudo subclass flower-garden-table%
 > >>     ;; ;; ;; ;; ;; ;; ;; ;;
 > >>
 > >>     (define my-bouquet (new flower-dialog% (garden this)))
 > >>
 > >>     ;;
 > >>     ;; Create the Foundations
 > >>     ;; We could loop here or abbreviate with some lambda form
 > >>     ;; but I like to hardcode these things. A different number
 > >>     ;; of foundations makes a different game.
 > >>     (define foundations
 > >>       (list (new foundation% (garden this) (foundation-index 1))
 > >>             (new foundation% (garden this) (foundation-index 2))
 > >>             (new foundation% (garden this) (foundation-index 3))
 > >>             (new foundation% (garden this) (foundation-index 4))))
 > >>
 > >>     ;;
 > >>     ;; Create the Flower Beds
 > >>     (define flower-beds
 > >>       (map {lambda (flower-bed-index)
 > >>              (new flower-bed%
 > >>                   (garden this)
 > >>                   (flower-bed-index flower-bed-index))}
 > >>            (list 1 2 3 4 5 6)))
 > >>
 > >>     ;;
 > >>     ;; Create the bouquet.
 > >>     (define bouquet (new bucket% [garden this]))
 > >>
 > >>
 > >>     ;; ;; ;; ;; ;; ;; ;; ;;
 > >>     ;; This sort of extra stack handling is needed because of our
 > >>     ;; inability to subclass card% conveniently. See Flowers (flower%)=
 .
 > >>     (define stack-register (append (list bouquet) flower-beds
 > foundations))
 > >>     (define/public (syncronize-stacks card)
 > >>       (broadcast stack-register remove-card! card))
 > >>     ;; ;; ;; ;; ;; ;; ;; ;;
 > >>
 > >>
 > >>     ;;
 > >>     ;; Internal Interface
 > >>
 > >>     (define/public (get-layout) layout)
 > >>     (define/public (get-table) garden)
 > >>     (define/public (card-face-up card)        ;; XXX
 > >>       (send garden card-face-up card))
 > >>     (define/public (flower-picked flower)
 > >>       (send layout flower-present flower))
 > >>
 > >>
 > >>
 > >>     ;;
 > >>     ;; Rule Implementation Interface
 > >>     ;;
 > >>     ;; Where one part of a card game's rules usually becomes the game
 > >>     ;; mechanic, i.e. layout and user interaction, another part become=
 s
 > >>     ;; the game's logic. For convenience this is implemented here as
 > >>     ;; something that resembles a controller.
 > >>     ;;
 > >>     ;; To allow different difficulty levels we might want to introduce
 > >>     ;; flower-garden-ruleset<%> objects and delegate these calls to th=
 e
 > >>     ;; one representing the current ruleset.
 > >>
 > >>     (define empty? null?)
 > >>
 > >>     (define (initial-deal)
 > >>       ;; Prepare our card game.
 > >>       (set! flowers (shuffle-list flowers 6))
 > >>
 > >>       ;; Throw the seeds. It's reversed to make them fly over not
 > >>       ;; under. This deals the cards visually from the bottom of the
 > >>       ;; deck. But when dealing from its top we would have to
 > >>       ;; re-stack-cards, i.e. changing the z-axis ordering, for the
 > >>       ;; whole table all the time.
 > >>       (send garden add-cards (reverse flowers) 0 0)
 > >>
 > >>       (let ((flowers flowers))
 > >>         ;; Deal 6 cards on each flower bed.
 > >>         (repeat 6 {lambda ()
 > >>                     (for-each {lambda (flower-bed)
 > >>                                 (send flower-bed add-card
 > >>                                       (wheels flowers))
 > >>                                 (set! flowers (cast flowers))}
 > >>                               flower-beds)} )
 > >>         ;; Cut the flowers' wheels.
 > >>         (broadcast (map wheels (broadcast flower-beds get-cards))
 > >>                    face-up)
 > >>         ;; Deal the remaining cards into the bucket.
 > >>         (for-each {lambda (flower)
 > >>                     (send bouquet add-card flower)}
 > >>                   flowers))
 > >>       ;(clear-selection)
 > >>       (broadcast stack-register move-done)
 > >>       ;(collect-garbage)
 > >>       ) ; end of initial deal
 > >>
 > >>     (define/public (place-on-flower-bed-request flower flower-bed)
 > >>       (let ((stacked (send flower-bed get-cards)))
 > >>         (when (or (empty? stacked)
 > >>                   (and (card-one-rank-below? flower (wheels stacked))
 > >>                        (card-same-suit? flower (wheels stacked))))
 > >>           (send flower-bed add-card flower)
 > >>           (broadcast stack-register move-done) )))
 > >>
 > >>     (define (game-is-won?)
 > >>       (define (foundation-full? foundation)
 > >>         (let ((stacked (send foundation get-cards)))
 > >>           (and (not (null? stacked))
 > >>                (card-is-king? (wheels stacked))) ))
 > >>       (define (game-is-won? foundations)
 > >>         (if (null? foundations)
 > >>             #t
 > >>             (and (foundation-full? (wheels foundations))
 > >>                  (game-is-won? (cast foundations))) )) ; not tail
 > recursive
 > >>       (game-is-won? foundations))
 > >>
 > >>     (define/public (place-on-foundation-request flower foundation)
 > >>       (let ((stacked (send foundation get-cards)))
 > >>         (when [or (and (empty? stacked)
 > >>                        (card-is-ace? flower))
 > >>                   (and (not (empty? stacked))
 > >>                        (card-same-suit? flower (wheels stacked))
 > >>                        (card-one-rank-above? flower (wheels stacked)))=
 ]
 > >>           (send foundation add-card flower)
 > >>           ;(clear-selection)
 > >>           (broadcast stack-register move-done)
 > >>         (when (game-is-won?)
 > >>               (send my-bouquet flower-present)
 > >>               (reset-game) )) ))
 > >>
 > >>     (define (is-playable? flower)
 > >>       (and (send flower user-can-move)
 > >>            (not (send flower face-down?))))
 > >>
 > >>     (define/public (rescue-request flower)
 > >>       (when (is-playable? flower)
 > >>         ;; It's a bit like brute force but it's terse and readable.
 > >>         ;; (and with animation it looks really funny which makes
 > >>         ;; you lough and that is a good thing [for a card game]!)
 > >>         (for-each {lambda (foundation)
 > >>                     (place-on-foundation-request flower foundation)}
 > >>                   foundations)))
 > >>
 > >>
 > >>     (define/public (place-on-bucket-request flower bucket)
 > >>       (when [< (send bucket number-of-cards) 16]
 > >>         (send bucket add-card flower)
 > >>         ;(clear-selection)
 > >>         (broadcast stack-register move-done) ))
 > >>
 > >>     ;;
 > >>     ;; DEFUNCT Selection Handling Interface
 > >>
 > >>     ;;    (define/public (clear-selection)
 > >>     ;;      ;(debug "garden%: clear-selection called; flower-selection=
 :
 > "
 > >> flower-selection)
 > >>     ;;      ;(broadcast flowers dim #f)
 > >>     ;;      (when flower-selection
 > >>     ;;           (debug "garden%: clear-selection: clearing selection"=
 )
 > >>     ;;           ;(send flower-selection dim #f)
 > >>     ;;            ;(broadcast flowers dim #f)
 > >>     ;;           (set! flower-selection #f)))
 > >>
 > >>     ;;    (define/public (selection-request flower)
 > >>     ;;      (debug "garden%: selection-request called")
 > >>     ;;      (if [and (eq? flower-selection flower)
 > >>     ;;              (send flower-selection dim)]
 > >>     ;;         (clear-selection)
 > >>     ;;         (when [is-playable? flower]
 > >>     ;;               (clear-selection)
 > >>     ;;               (set! flower-selection flower)
 > >>     ;;               (send flower dim #t)) ))
 > >>
 > >>
 > >>     ;;;
 > >>     ;;; Application Interface
 > >>
 > >>     (define/public (grow)
 > >>       (send garden show #t)
 > >>       (w/o-cart-animation garden initial-deal))
 > >>     ;(initial-deal))
 > >>
 > >>     (define/public (reset-game)
 > >>       [w/o-cart-animation* garden
 > >>                            ;; remove cards from the stacks (from the
 > model)
 > >>                            (for-each {lambda (card)
 > >>                                        ;; ??? perhaps it's better to
 > implement
 > >> reset in
 > >>                                        ;; stack%
 > >>                                        (broadcast stack-register
 > remove-card!
 > >> card)}
 > >>                                      flowers)
 > >>                            ;; remove cards from the table (from the
 > view)
 > >>                            (send garden remove-cards flowers)
 > >>
 > >>                            (reset-flowers flowers)
 > >>                            (initial-deal)])
 > >>
 > >>     )}
 > >>
 > >>
 > >> ;;
 > >> ;; Application Class / Menu and System Interface
 > >> ;;
 > >>
 > >> (define flower-garden%
 > >>   {class
 > >>       object%
 > >>     (super-new)
 > >>
 > >>     (define garden (new garden%))
 > >>     (define main-frame (send garden get-table))
 > >>     (define my-menu-bar (make-object menu-bar% main-frame))
 > >>     (define my-game-menu (make-object menu% "Game" my-menu-bar))
 > >>     (new menu-item%
 > >>          [label "Reset Game..."]
 > >>          [parent my-game-menu]
 > >>          [callback
 > >>           {lambda (i e)
 > >>             (when (eq? 'yes (message-box "Reset Game"
 > >>                                          "Are you sure you want to
 > reset the
 > >> game?"
 > >>                                          main-frame
 > >>                                          '(yes-no)))
 > >>               (send garden reset-game))}])
 > >>     (new separator-menu-item% [parent my-game-menu])
 > >>     (new menu-item%
 > >>          [label "Quit"]
 > >>          [parent my-game-menu]
 > >>          [callback {lambda (i e)
 > >>                      (send main-frame show #f)
 > >>                      (exit)}])
 > >>
 > >>
 > >>     (send garden grow)
 > >>     })
 > >>
 > >> (define sort-by-suit (new flower-garden%))
 > >>
 > >> *** Environment:
 > >> macosx "Darwin nPing.local 10.8.0 Darwin Kernel Version 10.8.0: Tue
 > Jun  7
 > >> 16:33:36 PDT 2011; root:xnu-1504.15.3~1/RELEASE_I386 i386"
 > (x86_64-macosx/3m)
 > >> (get-display-depth) =3D 32
 > >> Human Language: english
 > >> (current-memory-use) 440017348
 > >> raco pkg (show):
 > >> Installation-wide:
 > >>  Package              Checksum                                    Sour=
 ce
 > >>  main-distribution    f07e2d4bf2708c1085be38eca18aa9eb6755e547
 > (catalog
 > >> main-distribution)
 > >>  racket-lib           41c7b3221006758c5a840a18dcc0d265632f14c2
 > (catalog
 > >> racket-lib)
 > >>  [178 auto-installed packages not shown]
 > >> User-specific for installation "6.1":
 > >>  [none]
 > >>
 > >>
 > >>
 > >> Collections:
 > >> ("/Users/mt/Library/Racket/6.1/collects"
 > >>  (non-existent-path))
 > >> ("/Applications/Racket v6.1/collects"
 > >>  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file"
 > "info"
 > >> "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket=
 "
 > "raco"
 > >> "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))
 > >>
 > >> Recent Internal Errors:
 > >> Computer Language: (("Determine language from source") (#(#t print
 > >> mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t #t
 > ((test)
 > >> (main)) #t))
 >
 
 
 
 --=20
 --=20
 Jens Axel S=C3=B8gaard
 
 --001a113deff29ac0d10515d25a9c
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 <div dir=3D"ltr"><div>We could have more than one color database.<br></div>=
 <div>Whether the fixed or the current should be the default matters not too=
  much.</div><div><br></div><div>(Note: On OS X we don&#39;t respect RGB val=
 ues, so we (I am almost sure)</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0have different colors on OS X and Windows.</div><div>=C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0Example: Create a color using rgb and draw in th=
 e screen with Racket.</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0Use a color picker p=
 rogram and examine the RGB values.</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0They a=
 re different.</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0The bug is=
 n&#39;t in Racket, but in Cairo. It has something to do with</div><div>=C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0Cairo not using the monitor informati=
 on form the OS.)</div><div><br></div><div><br></div><div><br></div><div><br=
 ></div></div><div class=3D"gmail_extra"><br><div class=3D"gmail_quote">2015=
 -05-11 20:05 GMT+02:00 Robby Findler <span dir=3D"ltr">&lt;<a href=3D"mailt=
 o:robby@eecs.northwestern.edu" target=3D"_blank">robby@eecs.northwestern.ed=
 u</a>&gt;</span>:<br><blockquote class=3D"gmail_quote" style=3D"margin:0 0 =
 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">I think changing the Gr=
 een at this point is unwise. But maybe adding<br>
 the missing one would be good. And DarkSeaGreen seems like a good<br>
 change.<br>
 <br>
 So many methods take strings and are documented to use this table so<br>
 it is hard for me to think of a good way to make a reasonable<br>
 backwards compatible change. But we could offer a second color<br>
 database and encourage new code to use that, maybe?<br>
 <span class=3D"HOEnZb"><font color=3D"#888888"><br>
 Robby<br>
 </font></span><div class=3D"HOEnZb"><div class=3D"h5"><br>
 On Mon, May 11, 2015 at 10:57 AM, Matthew Flatt &lt;<a href=3D"mailto:mflat=
 t@cs.utah.edu">mflatt@cs.utah.edu</a>&gt; wrote:<br>
 &gt; Thanks for the report!<br>
 &gt;<br>
 &gt; &quot;Cornflower Blue&quot; is definitely a problem, and &quot;Cadet B=
 lue&quot; is also<br>
 &gt; slightly off from &quot;CadetBlue&quot;. I think &quot;Lavender&quot; =
 and &quot;Azure&quot; are<br>
 &gt; mapped in the same way as standards, though.<br>
 &gt;<br>
 &gt; Colors mappings that don&#39;t match HTML 4.01:<br>
 &gt;<br>
 &gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 HTML=C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 racket/draw<br>
 &gt;=C2=A0 Green=C2=A0 =C2=A0 =C2=A0(0 128 0)=C2=A0 =C2=A0 =C2=A0 =C2=A0(0 =
 255 0)<br>
 &gt;=C2=A0 Gray=C2=A0 =C2=A0 =C2=A0 (128 128 128)=C2=A0 =C2=A0(190 190 190)=
 <br>
 &gt;=C2=A0 Maroon=C2=A0 =C2=A0 (128 0 0)=C2=A0 =C2=A0 =C2=A0 =C2=A0(176 48 =
 96)<br>
 &gt;=C2=A0 Purple=C2=A0 =C2=A0 (128 0 128)=C2=A0 =C2=A0 =C2=A0(160 32 240)<=
 br>
 &gt;=C2=A0 Navy=C2=A0 =C2=A0 =C2=A0 (0 0 128)=C2=A0 =C2=A0 =C2=A0 =C2=A0(36=
  36 140)<br>
 &gt;<br>
 &gt; Other colors that are not part of the HTML standard, but are part of<b=
 r>
 &gt; the SVG standard and supported by most browsers for HTML:<br>
 &gt;<br>
 &gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0SVG=C2=A0=
  =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 racket/draw<br>
 &gt;=C2=A0 Brown=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (165 42 42)=C2=A0 =C2=A0=
  (132 60 36)<br>
 &gt;=C2=A0 RebeccaPurple=C2=A0 (102 51 153)=C2=A0 =C2=A0[missing]<br>
 &gt;=C2=A0 Aquamarine=C2=A0 =C2=A0 =C2=A0(127 255 212)=C2=A0 (112 216 144)<=
 br>
 &gt;=C2=A0 DarkSeaGreen=C2=A0 =C2=A0(143 188 143)=C2=A0 (143 188 139)<br>
 &gt;<br>
 &gt; I&#39;m not yet sure what to do. The mismatch seems bad, but changing =
 the<br>
 &gt; meaning of color names (which could break existing programs, especiall=
 y<br>
 &gt; for &quot;Green&quot;) also seems bad.<br>
 &gt;<br>
 &gt;<br>
 &gt; At Mon, 11 May 2015 01:16:02 -0400, <a href=3D"mailto:michael.tiedtke@=
 o2online.de">michael.tiedtke@o2online.de</a> wrote:<br>
 &gt;&gt; A new problem report is waiting at<br>
 &gt;&gt;=C2=A0 =C2=A0<a href=3D"http://bugs.racket-lang.org/query/?cmd=3Dvi=
 ew&amp;pr=3D15059" target=3D"_blank">http://bugs.racket-lang.org/query/?cmd=
 =3Dview&amp;pr=3D15059</a><br>
 &gt;&gt;<br>
 &gt;&gt; Reported by Michael Tit-ke for release: 6.1<br>
 &gt;&gt;<br>
 &gt;&gt; *** Description:<br>
 &gt;&gt; Oops, Racket&#39;s color database seems to have been hacked: a<br>
 &gt;&gt; little name mix up: Cornflower Blue is Lavender where Lavender<br>
 &gt;&gt; probably is azzurro (in italian) where the database has a french<b=
 r>
 &gt;&gt; sounding entry named azure. The other CornflowerBlue is alright<br=
 >
 &gt;&gt; but the way things are you&#39;re now allowed to pick any colors n=
 ot<br>
 &gt;&gt; only the ones named after flowers.<br>
 &gt;&gt; Just changing the names again would probably not be the right solu=
 tion. Steps<br>
 &gt;&gt; to reproduce might contain other issues (Redrw<br>
 &gt;&gt;<br>
 &gt;&gt; *** How to repeat:<br>
 &gt;&gt; #lang racket<br>
 &gt;&gt;<br>
 &gt;&gt; ;; This is the message passing approach to the patience solitaire =
 game<br>
 &gt;&gt; ;; Flower Garden.<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; This is the variant Flower Venus Garden with a relaxed ruleset.=
 =C2=A0 You<br>
 &gt;&gt; ;; can move only one card at time but from anywhere to anywhere.<b=
 r>
 &gt;&gt; ;; Sequences in the flower beds have to be build by suit.=C2=A0 Th=
 e<br>
 &gt;&gt; ;; foundations are built from ace to king but cards can be moved b=
 ack<br>
 &gt;&gt; ;; into the game. You can double click a card and if possible it w=
 ill<br>
 &gt;&gt; ;; find its place in the foundations. You can place up to sixteen<=
 br>
 &gt;&gt; ;; cards in the bouquet. There is a good chance of winning the gam=
 e.<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; (The layout of the bouquet, i.e. the reserve of cards at the bo=
 ttom<br>
 &gt;&gt; ;; of the table is done automatically but only after a card has be=
 en<br>
 &gt;&gt; ;; moved successfully. Rethinking and correcting this is left as<b=
 r>
 &gt;&gt; ;; exercise for the interested player.)<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Description &amp; Rules<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; One deck of 52 cards.<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; &lt; from wikipedia<br>
 &gt;&gt; ;; Thirty-six cards are dealt in to six columns, each containing s=
 ix<br>
 &gt;&gt; ;; cards. The columns are called the &quot;flower beds&quot; and t=
 he entire<br>
 &gt;&gt; ;; tableau is sometimes called &quot;the garden.&quot; The sixteen=
  leftover<br>
 &gt;&gt; ;; cards become the reserve, or &quot;the bouquet.&quot;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; The top cards of each flower-bed and all of the cards in the<br=
 >
 &gt;&gt; ;; bouquet are available for play. Cards can only be moved one at =
 a<br>
 &gt;&gt; ;; time and can be built either on the foundations or on the other=
 <br>
 &gt;&gt; ;; flower beds. The foundations are built up by suit, from Ace to =
 King<br>
 &gt;&gt; ;; (a general idea of the game is to release the aces first). The<=
 br>
 &gt;&gt; ;; cards in the garden, on the other hand, can be built down<br>
 &gt;&gt; ;; regardless of suit and any empty flower bed can be filled with =
 any<br>
 &gt;&gt; ;; card. The cards in the bouquet can be used to aid in building, =
 be<br>
 &gt;&gt; ;; put into the foundations, or fill an empty flower bed.<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; The game is won when all cards end up in the foundations.<br>
 &gt;&gt; ;; &gt; end from wikipedia<br>
 &gt;&gt; ;;<br>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Technical Note: While it is written in a rather traditional way=
 <br>
 &gt;&gt; ;; without mixins, traits or an emphasis on surrogates it might<br=
 >
 &gt;&gt; ;; contain ideas, concepts and terms that go beyond today&#39;s me=
 ssage<br>
 &gt;&gt; ;; passing &quot;customs&quot;. A new message passing primitive &q=
 uot;broadcast&quot; and<br>
 &gt;&gt; ;; the term hub for certain classes are consequences of thinking a=
 bout<br>
 &gt;&gt; ;; the future of message passing, parallel objects and one new pro=
 gram<br>
 &gt;&gt; ;; code abstraction system &quot;to rule them all&quot; especially=
  when it comes<br>
 &gt;&gt; ;; to open source and the user&#39;s ability to adapt and program =
 the<br>
 &gt;&gt; ;; shiny some thousand money units worth machine in front of him. =
 From<br>
 &gt;&gt; ;; LISP machines to BSD to Mach message passing microkernel to<br>
 &gt;&gt; ;; NextStep to ... but that is far away: for me it was from QBASIC=
  to<br>
 &gt;&gt; ;; RISC assembler to NetBeans to Dr. Racket to whatever comes in<b=
 r>
 &gt;&gt; ;; handy.<br>
 &gt;&gt; ;;<br>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Description of the User Interaction<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Most of the event handling is done by the views card&lt;%&gt;, =
 table&lt;%&gt;<br>
 &gt;&gt; ;; and region. (See Event Handling)<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; According to the rules only one card may be moved at any time.<=
 br>
 &gt;&gt; ;;<br>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Bugs and Maintenance<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Bug (unreproducible): in a new game after program start the sec=
 ond<br>
 &gt;&gt; ;; card in a flower bed which was face down could be moved. As<br>
 &gt;&gt; ;; reconfigure-cards in the flower-bed class is rather clear about=
 <br>
 &gt;&gt; ;; this issue and because it happened during the animation of an<b=
 r>
 &gt;&gt; ;; unrelated move and is part of the Virtual Card Library&#39;s sp=
 ecial<br>
 &gt;&gt; ;; behaviours.<br>
 &gt;&gt;<br>
 &gt;&gt; ;;;<br>
 &gt;&gt; ;;; Modules and Dependencies<br>
 &gt;&gt; ;;;<br>
 &gt;&gt;<br>
 &gt;&gt; (require games/cards racket/gui racket/class racket/unit)<br>
 &gt;&gt;<br>
 &gt;&gt; ;(load &quot;card-logic.rkt&quot;)<br>
 &gt;&gt; ;(include (file &quot;card-logic.rkt&quot;))<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt; ;;;<br>
 &gt;&gt; ;;; Extension of the Algorithmic Language Scheme<br>
 &gt;&gt; ;;;<br>
 &gt;&gt;<br>
 &gt;&gt; ;; (define (broadcast object-list method . arguments)<br>
 &gt;&gt; ;;=C2=A0 =C2=A0{define (apply-messages object)<br>
 &gt;&gt; ;;=C2=A0 =C2=A0 =C2=A0(send/apply object method arguments)}<br>
 &gt;&gt; ;;=C2=A0 =C2=A0(map apply-messages object-list))<br>
 &gt;&gt;<br>
 &gt;&gt; (define-syntax cast (syntax-rules () ((_ type) (cdr type))))<br>
 &gt;&gt; (define-syntax broadcast<br>
 &gt;&gt;=C2=A0 =C2=A0(syntax-rules ()<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0((_ object-list method ...)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 (map {lambda (object) (send object method ...)=
 }<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0object-list))))<br>
 &gt;&gt; (define-syntax broadcast*<br>
 &gt;&gt;=C2=A0 =C2=A0(syntax-rules ()<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0((_ object-list method ...)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 (map {lambda (object) (send* object method ...=
 )}<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0object-list))))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (repeat n closure)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Execute closure n times.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(if (not (and (exact? n) (integer? n)=C2=A0 ; &#39;int=
 eger?&#39; does not check for<br>
 &gt;&gt; exactness ...<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(&gt;=
 =3D n 0)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(error &quot;repeat: the parameter n mus=
 t be an exact natural number or zero.&quot;)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0{let loop ((i 0))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(when (&lt; i n)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(closure)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(loop (add1 i)))} ))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (half numerical) (/ numerical 2))<br>
 &gt;&gt;<br>
 &gt;&gt; (define wheels<br>
 &gt;&gt;=C2=A0 =C2=A0;; Every car has four wheels.<br>
 &gt;&gt;=C2=A0 =C2=A0car)<br>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; The Virtual Card Library wants us to program in assembler<br>
 &gt;&gt; ;; style. This is how we escape it.<br>
 &gt;&gt; (define (w/o-cart-animation table closure)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Don&#39;t let the car&#39;s movement be shown.&q=
 uot;<br>
 &gt;&gt;=C2=A0 =C2=A0(let ((returned-value void))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(send table begin-card-sequence)=C2=A0 ; determ=
 ine the winning card sequence<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(set! returned-value (closure))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(send table end-card-sequence)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0returned-value))<br>
 &gt;&gt;<br>
 &gt;&gt; (define-syntax w/o-cart-animation*<br>
 &gt;&gt;=C2=A0 =C2=A0(syntax-rules ()<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0((_ table first-expression ...)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 ;; &#39;returned-value&#39; was accessible by =
 the expressions in the expansion;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 ;; that was a shortcoming.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 ;; It might even have shadowed a definition fo=
 r that symbol at the<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 ;; position of the expansion. That would have =
 beeen a pity.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 ;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 ;; We&#39;re now creating a closure for the ex=
 pressions.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 ;; This should be safe, hygienic or however yo=
 u want to call it.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 (let* ([closure {lambda ()<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 first-expression<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 ...}]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0[returned-value voi=
 d])<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 (send table begin-card-sequence)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 (set! returned-value (closure))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 (send table end-card-sequence)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 returned-value) )))<br>
 &gt;&gt;<br>
 &gt;&gt; (define create-cell-and-attach cons)<br>
 &gt;&gt;<br>
 &gt;&gt; ;; That is &quot;sea cat&quot; but where is &quot;bee cat&quot;?<b=
 r>
 &gt;&gt; ;; (You might even find &quot;a cat&quot;).<br>
 &gt;&gt; (define sea-cat create-cell-and-attach)<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt; ;;;<br>
 &gt;&gt; ;;; Card Logic<br>
 &gt;&gt; ;;;<br>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Card Suits and Colors: Predicates and Utility Procedures<br>
 &gt;&gt;<br>
 &gt;&gt; (define (suit-color suit-symbol)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return &#39;red for &#39;heart and &#39;club. Re=
 turn &#39;black for &#39;diamond or &#39;spade. Else<br>
 &gt;&gt; false.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(case suit-symbol<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0[(hearts diamonds) &#39;red]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0[(clubs spades) &#39;black]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0[(unknown) (debug &quot;card logic: suit-color:=
  unknown suit&quot;) #f] ; this entry<br>
 &gt;&gt; exists for completeness as card&lt;%&gt; get-suit might return &#3=
 9;unknown<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0[else (warning &quot;card logic: suit-color: su=
 it not found: &quot; suit-symbol) #f]))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-color card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return the color of the card&#39;s suit like sui=
 t-color.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(suit-color (send card get-suit)))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-red? card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if the color of the card&#39;s suit =
 is red.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(eq? (card-color card) &#39;red))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-black? card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if the color of the card&#39;s suit =
 is black.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(eq? (card-color card) &#39;black))<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Card Rank Predicates<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-ace? card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if the card is an ace.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 1))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-king? card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if the card is a king.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 13))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-queen? card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if the card is a queen.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 12))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-joker? card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Reutrn true if the card is a joker.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 11))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-ten? card) &quot;Return true if the card is a ten=
 .&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 10))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-nine? card) &quot;Return true if the card is a ni=
 ne.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 9))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-eight? card) &quot;Return true if the card is an =
 eight.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 8))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-seven? card) &quot;Return true if the card is a s=
 even.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 7))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-six? card) &quot;Return true if the card is a six=
 .&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 6))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-five? card) &quot;Return true if the card is a fi=
 ve.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 5))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-four? card) &quot;Return true if the card is a fo=
 ur.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 4))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-three? card) &quot;Return true if the card is a t=
 hree.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value) 3))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-is-two? card) &quot;Return true if the card is a two=
 .&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(=3D (send card get-value 2)))<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt; ;;;<br>
 &gt;&gt; ;;; Card Binary Predicates<br>
 &gt;&gt;<br>
 &gt;&gt; ;; Card Rank Binary Predicates<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-one-rank-below? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if the first-card is one rank below =
 the second-card.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(let ((first-value (send first-card get-value))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(second-value (send second-card g=
 et-value)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(=3D 1 (- second-value first-value))))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-one-rank-above? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if the first-card is one rank above =
 the second-card.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(card-one-rank-below? second-card first-card))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-next-rank? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if the first card is one rank above =
 or below the second-card.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(or (card-one-rank-below? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(card-one-rank-above? first-card second-=
 card)))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-circular-one-rank-below? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if card-one-rank-below? is true or i=
 f the first-card is a king<br>
 &gt;&gt; and second-card is an ace.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(or (card-one-rank-below? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(and (card-is-king? first-card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (card-is-ace? second-card=
 ))))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-circular-one-rank-above? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if card-one-rank-above? is true or i=
 f the first-card is an ace<br>
 &gt;&gt; and the second-card is a king.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(or (card-one-rank-above? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(and (card-is-ace? first-card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (card-is-king? second-car=
 d))))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-circular-next-rank? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if card-next-rank? is true or if the=
  two cards are a king and an<br>
 &gt;&gt; ace.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(or (card-next-rank? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(or (and (card-is-king? first-card) (car=
 d-is-ace? second-card))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(and (card-is-ace? first-c=
 ard) (card-is-king? second-card)))))<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt; ;; Card Color and Suit Binary Predicates<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-same-color? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if the color of the first-card&#39;s=
  suit is the same as the one of<br>
 &gt;&gt; the second-card.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(eq? (card-color first-card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 (card-color second-card)))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (card-same-suit? first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0&quot;Return true if the suit of the first-card is the=
  same as the one of the<br>
 &gt;&gt; second-card.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0(eq? (send first-card get-suit)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 (send second-card get-suit)))<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt; ;;;<br>
 &gt;&gt; ;;; Debugging and other Developer Utilities<br>
 &gt;&gt; ;;;<br>
 &gt;&gt;<br>
 &gt;&gt; (define (debug . args)<br>
 &gt;&gt;=C2=A0 =C2=A0(display &quot;Flower Garden: &quot;)<br>
 &gt;&gt;=C2=A0 =C2=A0(for-each {lambda (arg) (display arg)}<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0args)<br>
 &gt;&gt;=C2=A0 =C2=A0(newline))<br>
 &gt;&gt;<br>
 &gt;&gt; (define (warning . args)<br>
 &gt;&gt;=C2=A0 =C2=A0(apply debug &quot;WARNING: &quot; args))<br>
 &gt;&gt;<br>
 &gt;&gt; ;;; End of Pretext<br>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Layout<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; This abstract layout hub class keeps the layout in one spot.<br=
 >
 &gt;&gt; ;; This approach rips open the encapsulation of the other classes<=
 br>
 &gt;&gt; ;; but in this case it&#39;s more important to seperate layout fro=
 m logic.<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; As a general layout message passing protocol objects requesting=
 <br>
 &gt;&gt; ;; layout information send themselves as arguments even if this is=
 <br>
 &gt;&gt; ;; right now unecessary in some cases. In most cases though this<b=
 r>
 &gt;&gt; ;; layout hub needs more information from the object, e.g. the ind=
 ex<br>
 &gt;&gt; ;; of a stack to provide the correct layout information.<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; About this layout for Flower Garden:<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; The layout is hardcoded: it will not adapt to a change in the<b=
 r>
 &gt;&gt; ;; number of stacks. A different number of stacks would be a diffe=
 rent<br>
 &gt;&gt; ;; game anyway. It should be rather easy to exchange the meaning o=
 f<br>
 &gt;&gt; ;; row and column in this layout though. But it might even be<br>
 &gt;&gt; ;; intertwined: not always following its inner logic.<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; The layout is completely based on the playing card dimensions:<=
 br>
 &gt;&gt; ;;=C2=A0 for this it needs one unit card to retrieve the dimension=
 s.<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; There is an upper border and a left border.<br>
 &gt;&gt; ;; There are six columns with intercolumn spacing.<br>
 &gt;&gt; ;; There are three rows with interrow spacing.<br>
 &gt;&gt; ;;=C2=A0 The first row contains the centered four foundations.<br>
 &gt;&gt; ;;=C2=A0 The second row contains the six flower beds.<br>
 &gt;&gt; ;;=C2=A0 The third row contains the bouquet.<br>
 &gt;&gt;<br>
 &gt;&gt; {define layout%<br>
 &gt;&gt;=C2=A0 =C2=A0(class<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0object%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(init unit-card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(super-new)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define card-width (send unit-card card-width))=
 <br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define card-height (send unit-card card-height=
 ))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; ??? perhaps we should release unit-card here=
 <br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define default-spacing-unit (/ card-width 7)) =
 ; confront with table width<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define upper-border default-spacing-unit)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define left-border default-spacing-unit)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define intercolumn-space default-spacing-unit)=
 <br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define interrow-space (* 2 default-spacing-uni=
 t))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (column-n-x n)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0&quot;Return the x coordinate of the lef=
 t border of the n&#39;th column.&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(+ left-border (* (+ card-width intercol=
 umn-space)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0(sub1 n))) )<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Layout of the Table<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; One card width for each column plus one for =
 spacing.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-table-width garden) 7)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; One card height for the foundations, one for=
  the bouquet, one<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; for spacing and four card heights for the fl=
 ower bed.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-table-height garden) 7)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Table Background<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define fixed-window-border 0)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define flower &quot;Lavender&quot;)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-background-x-coordinate gar=
 den)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0fixed-window-border)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-background-y-coordinate gar=
 den)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0fixed-window-border)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-background-width garden)<br=
 >
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(- (* card-width (get-table-width garden=
 ))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (* 2 fixed-window-border)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-background-height garden)<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(- (* card-height (get-table-height gard=
 en))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (* 2 fixed-window-border)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-background-paint-callback g=
 arden)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;; This is design and not only layout.<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;; See the documentation of color-databa=
 se&lt;%&gt; for color names.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;; (But you&#39;re only allowed to use c=
 olors named after flowers. ;-)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0{lambda (drawing-context x y width heigh=
 t)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;; XXX there is some redrawing shortcomi=
 ng at the right border<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;; and at the lower border<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send drawing-context set-background flo=
 wer)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send drawing-context clear)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0})<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (flower-present selected-flower)=
 <br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(set! flower selected-flower))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Layout of the Foundations<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define foundation-top-line<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0upper-border)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-foundation-x-coordinate fou=
 ndation)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(let ((foundation-index (send foundation=
  get-foundation-index)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(column-n-x (+ foundation-index 1=
 ))))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-foundation-y-coordinate fou=
 ndation)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0foundation-top-line)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-foundation-width foundation=
 )<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0card-width)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define foundation-height card-height)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-foundation-height foundatio=
 n)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0foundation-height)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Layout of the Flower Beds<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define flower-bed-top-line<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(+ foundation-top-line<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 foundation-height<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 interrow-space))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-flower-bed-x-coordinate flo=
 wer-bed)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(let ((flower-bed-index (send flower-bed=
  get-flower-bed-index)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(column-n-x flower-bed-index)))<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-flower-bed-y-coordinate flo=
 wer-bed)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0flower-bed-top-line)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define flower-bed-width card-width)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-flower-bed-width flower-bed=
 )<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0flower-bed-width)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Each flower bed needs to accomodate up to 18=
  cards.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define flower-bed-card-y-offset (/ card-height=
  3))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define flower-bed-height (+ (* 1=C2=A0 card-he=
 ight)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (* 8 flower-bed-card-y=
 -offset)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-flower-bed-height flower-be=
 d)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0flower-bed-height)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Layout of the Bouquet<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define bucket-top-line<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(+ flower-bed-top-line<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 flower-bed-height<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (* 3/2 interrow-space)))=C2=A0 =
 =C2=A0 =C2=A0; this extra space makes it look better<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-bucket-x-coordinate bucket)=
 <br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(column-n-x 1)) ; bucket&#39;s left bord=
 er is aligned to the first column<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-bucket-y-coordinate bucket)=
 <br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0bucket-top-line)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-bucket-width bucket)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(- (+ (column-n-x 6) flower-bed-width)<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 left-border)) ; bucket&#39;s rig=
 ht border is aligned to the last column<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-bucket-height bucket)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0[+ (* 3/4 default-spacing-unit) ; there =
 is no sense if not asthetic sense<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (* 3/2 card-height)]) ; give the=
  user some space and fill the table<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Card Layout<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (stack-layout-cards! foundation)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(let ((cards (reverse (send foundation g=
 et-cards)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(region (send found=
 ation get-region)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send* (send (send foundation get=
 -garden)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 get-table)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(stack-cards (reverse card=
 s)) ; z-axis-stacking<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(move-cards cards<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0(region-x region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0(region-y region)))))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define foundation-layout-cards! stack-layout-c=
 ards!)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (flower-bed-layout-cards! flower-bed)<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(let* ((cards (reverse (send flower-bed =
 get-cards)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (region (send flow=
 er-bed get-region))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (number-of-cards (=
 length cards))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;(card-height (sen=
 d (wheels cards) card-height))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (offset flower-bed=
 -card-y-offset)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (height (region-h =
 region)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(when (&gt; (+ card-height (* num=
 ber-of-cards offset))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 heig=
 ht)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;=C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0; y =3D ch + (nc-1)*of<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;=C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0; y-ch / (nc-1) =3D of<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(set! offset (/ (- height =
 card-height)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(sub1 number-of-cards))))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send* (send (send flower-bed get=
 -garden) get-table)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(stack-cards (reverse card=
 s)) ; z-axis-stacking<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(move-cards cards<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0(region-x region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0(region-y region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0{lambda (n)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0(values 0 (* offset n)) } ))))<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Preserve x-axis order and DO NOT preserve th=
 e y-coordinates<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;(define (x-selector x y) x)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;=C2=A0 =C2=A0(define (get-card-x-coordinate ca=
 rd table)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;=C2=A0 =C2=A0 =C2=A0(call-with-values (lambda =
 ()<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send table card-location card=
 ))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(lambda (x y) x)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define bucket-card-top-line (+ bucket-top-line=
 <br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(* 2 defa=
 ult-spacing-unit)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (bucket-layout-cards! bucket)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(let* ((table (send (send bucket get-gar=
 den) get-table))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (cards (sort (send=
  bucket get-cards)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0[lambda (first-card second-card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(let-values (([x1 y1] (send table car=
 d-location<br>
 &gt;&gt; first-card))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 ([x2 y2] (send table card-location<br>
 &gt;&gt; second-card)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(&lt; x1 x2))]))<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(y-coordinates (l=
 ist-&gt;vector<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(map {lambda (card) ; retrieve sor=
 ted<br>
 &gt;&gt; y-coordinates<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (let-values<=
 br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 ([(x y)<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 (send table card-location card)])<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (if (=
 &lt; y bucket-card-top-line)<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 (* 2 default-spacing-unit)<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 (- y bucket-top-line)))}<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 cards)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (number-of-cards (=
 send bucket number-of-cards))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (region (send buck=
 et get-region))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;(card-height (sen=
 d (wheels cards) card-height))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (width (region-w r=
 egion))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;; Racket doesn&#3=
 9;t know how to divide by zero so we have to<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;; check and in th=
 e case of a too small number of cards we<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;; use infinity as=
  the offset for the other cards<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;; that do not eve=
 n exist. But infinity is bigger than the<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;; the maximum off=
 set and that is what we want. Thus dividing<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;; by zero should =
 (at least as an option) yield infinity because<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;; well behaved al=
 gorithms can continue correctly and might<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;; even depend on =
 the mathematical consequences of using the<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;; &quot;symbol&qu=
 ot; or concept of infinity.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [offset (if (&gt; =
 number-of-cards 1)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 (begin (/ (- width (* 1 card-width))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (sub1 number-of=
 -cards)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 ; This is correct when number-of-cards is one.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 ; This is wrong for number-of-cards less than<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 ; or equal to 0 which should not happen.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 +inf.0)]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [maximum-offset (*=
  3/2 card-width)]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [centered-x-offset=
  0])<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(cond<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [[&gt; offset ma=
 ximum-offset]<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;; This is=
  difficult to test as the situation arises only<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;; later o=
 n in the game.<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(set! offs=
 et maximum-offset)<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(set! cent=
 ered-x-offset<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0{half [- (region-w region)<br>
 &gt;&gt; ;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 {+ card-width [* offset (- number=
 -of-cards<br>
 &gt;&gt; 1)]}]} )]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;; When the =
 offset is too close to card-width it looks better<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;; not to pu=
 t one card next to the other but to fan them.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0([&gt; offse=
 t (* 2/3 card-width)]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (set! offse=
 t (* 2/3 card-width))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (set! cente=
 red-x-offset<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 {half [- (region-w region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0{+ card-width [* offset (- num=
 ber-of-cards 1)]}]}<br>
 &gt;&gt; )))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send* (send (send bucket get-gar=
 den) get-table)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(stack-cards (reverse card=
 s)) ; z-axis-stacking<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(move-cards cards<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0(+ (region-x region) centered-x-offset)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0(region-y region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0{lambda (n)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0(values (* offset n)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(* 2 default-spacing-un=
 it))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;(vector-ref y-coordina=
 tes n))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0} ))))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (layout-cards! stack)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(cond ([is-a? stack foundation%] (founda=
 tion-layout-cards! stack))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0([is-a? stack flowe=
 r-bed%] (flower-bed-layout-cards! stack))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0([is-a? stack bucke=
 t%] (bucket-layout-cards! stack))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(else<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (warning &quot;lay=
 out%: layout-cards!:&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0&quot; no registered card layout found for type: &quot;<br=
 >
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0(object-interface stack)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0&quot;: using fallback: stack-layout-cards!&quot;)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (stack-layout-card=
 s! stack))))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0)}<br>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Flowers<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Now this is the stupid approach to class redefinition (see<br>
 &gt;&gt; ;; Guile/GOOPS). We need each card object to have a back link to i=
 ts<br>
 &gt;&gt; ;; stack. While card% does feature a home-region where region is t=
 he<br>
 &gt;&gt; ;; &quot;view&quot; of the stack the region structure does not pro=
 vide a list of<br>
 &gt;&gt; ;; cards and thus it does not keep track of the sequence of cards.=
  We<br>
 &gt;&gt; ;; do this in the model with a list (see stack%). Then the message=
 <br>
 &gt;&gt; ;; passing protocol for the region callbacks gives us a list of ca=
 rds<br>
 &gt;&gt; ;; dragged to a region and we can add these cards to the stack of =
 the<br>
 &gt;&gt; ;; target. But how do we remove these cards from the stack where t=
 he<br>
 &gt;&gt; ;; cards came from? BTW The implementation of Spider loops through=
  all<br>
 &gt;&gt; ;; stacks. We do that with broadcast.<br>
 &gt;&gt;<br>
 &gt;&gt; (define (reset-flowers flowers)<br>
 &gt;&gt;=C2=A0 =C2=A0(broadcast* flowers<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(face-down)<=
 br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(user-can-fl=
 ip #f)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(snap-back-a=
 fter-move #t)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(user-can-mo=
 ve #f))<br>
 &gt;&gt;=C2=A0 =C2=A0flowers)<br>
 &gt;&gt;<br>
 &gt;&gt; (define (make-flowers flowers)<br>
 &gt;&gt;=C2=A0 =C2=A0(reset-flowers flowers))<br>
 &gt;&gt;<br>
 &gt;&gt; (define flower-dialog%<br>
 &gt;&gt;=C2=A0 =C2=A0{class<br>
 &gt;&gt;=C2=A0 =C2=A0 dialog%<br>
 &gt;&gt;=C2=A0 =C2=A0 (init garden)<br>
 &gt;&gt;=C2=A0 =C2=A0 (define my-garden garden)<br>
 &gt;&gt;=C2=A0 =C2=A0 (super-new [label &quot;Flowers&quot;]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0[parent (send my-ga=
 rden get-table)]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0[stretchable-width =
 #f]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0[stretchable-height=
  #f])<br>
 &gt;&gt;=C2=A0 =C2=A0 ;; See the documentation of color-database&lt;%&gt; f=
 or color names.<br>
 &gt;&gt;=C2=A0 =C2=A0 ;; (But you&#39;re only allowed to use colors named a=
 fter flowers. ;-)<br>
 &gt;&gt;=C2=A0 =C2=A0 ;; Oops, Racket&#39;s color database seems to have be=
 en hacked: a<br>
 &gt;&gt;=C2=A0 =C2=A0 ;; little name mix up: Cornflower Blue is Lavender wh=
 ere Lavender<br>
 &gt;&gt;=C2=A0 =C2=A0 ;; probably is azzurro (in italian) where the databas=
 e has a french<br>
 &gt;&gt;=C2=A0 =C2=A0 ;; sounding entry named azure. The other CornflowerBl=
 ue is alright<br>
 &gt;&gt;=C2=A0 =C2=A0 ;; but the way things are you&#39;re now allowed to p=
 ick any colors not<br>
 &gt;&gt;=C2=A0 =C2=A0 ;; only the ones named after flowers.<br>
 &gt;&gt;=C2=A0 =C2=A0 (define flowers<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 (list<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;&quot;Pale Green&quot; ; you might take=
  this for the infamous Mint Green<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0&quot;Lavender&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0&quot;FloralWhite&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0&quot;MistyRose&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0&quot;Cornflower Blue&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0&quot;Orchid&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0&quot;Violet Red&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0))<br>
 &gt;&gt;=C2=A0 =C2=A0 (define flower-chooser<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(new radio-box%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 [label #f]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 [parent (new group-box-panel%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0[parent this]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0[label &quot;You can pick a flower!&quot;]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0[stretchable-width #f]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0[stretchable-height #f])]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 [choices flowers]))<br>
 &gt;&gt;=C2=A0 =C2=A0 (define bottom-panel<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 (new horizontal-panel%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0[parent this]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0[alignment &#39;(center center)]<=
 br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0[stretchable-height #f]))<br>
 &gt;&gt;=C2=A0 =C2=A0 (new button%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 [parent bottom-panel]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 [label &quot;&amp;Ok&quot;]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 [style &#39;(border)]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 [callback {lambda (b e)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (sen=
 d my-garden flower-picked<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 (vector-ref (list-&gt;vector flowers)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send flower-ch=
 ooser get-selection)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (sen=
 d this show #f)} ])<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 (define/public (flower-present)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 ;(set! flowers (shuffle-list *flower-list* 12)=
 )<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 (send this center)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 (send this show #t))<br>
 &gt;&gt; })<br>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Stacks<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; There are three kinds of stacks: foundations, flower beds and<b=
 r>
 &gt;&gt; ;; bouquet. Layouting is done with the help of the layout hub obje=
 ct<br>
 &gt;&gt; ;; as retrieved from the hosting garden object.<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; While each card&lt;%&gt; object knows about its home-region, th=
 e regions<br>
 &gt;&gt; ;; are not aware of these cards. To get all the cards in one regio=
 n on<br>
 &gt;&gt; ;; the table we could ask each card individually or keep track of =
 all<br>
 &gt;&gt; ;; the moves and maintain the missing list of cards for each stack=
 .<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; NB Asking all card objects on the table about their home-region=
  is<br>
 &gt;&gt; ;; not too time consuming, i.e. O(n), where each deck brings only =
 52<br>
 &gt;&gt; ;; objects into the game.<br>
 &gt;&gt;<br>
 &gt;&gt; (define stack%<br>
 &gt;&gt;=C2=A0 =C2=A0{class<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0object%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(init garden)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(super-new)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Fields<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define cards null)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define my-region null)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define my-garden garden)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Accessors<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-garden) my-garden)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-layout)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send my-garden get-layout))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (add-card card-to-add)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send (send this get-garden) syncronize-=
 stacks card-to-add)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(set! cards (sea-cat card-to-add cards))=
 <br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send* card-to-add<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(home-region my-region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;(stay-in-region my-region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send (get-layout) layout-cards! this)<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (remove-card! card-to-remove)<br=
 >
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(set! cards (filter {lambda (card) (not =
 (eq? card card-to-remove))}<br>
 &gt;&gt; cards)))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (move-done)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;(send (get-layout) layout-cards! this)<=
 br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0#t)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (number-of-cards) (length cards)=
 )<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (empty?) (null? cards))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-cards) cards)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 (define/public (syncronize-card=
 s-on-region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 (set! cards (filter (lam=
 bda (card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (equal? (send card hom=
 e-region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 my-region))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 cards)))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0(define/public (after-or-before-=
 drag finished-on-region? cards)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0#t)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-region) my-region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (set-region new-region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(set! my-region new-region)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;=C2=A0 =C2=A0 =C2=A0(set-region-interac=
 tive-callback!<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;=C2=A0 =C2=A0 =C2=A0 my-region<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;=C2=A0 =C2=A0 =C2=A0 {lambda (finished-=
 on-region? cards)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send this a=
 fter-or-before-drag finished-on-region? cards)})<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0})<br>
 &gt;&gt;<br>
 &gt;&gt; (define foundation%<br>
 &gt;&gt;=C2=A0 =C2=A0{class<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0stack%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(init foundation-index)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(super-new)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define my-index foundation-index)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (foundation-region-callback cards)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send (send this get-garden) place-on-fo=
 undation-request (wheels cards)<br>
 &gt;&gt; this))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(let ((layout (send this get-layout)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send this set-region<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(make-region<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-f=
 oundation-x-coordinate this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-f=
 oundation-y-coordinate this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-f=
 oundation-width this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-f=
 oundation-height this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 &quot;Foundation&q=
 uot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 foundation-region-=
 callback)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(send (send (send this get-garden) get-table)<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0add-region (send this get-=
 region))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-foundation-index) my-index)=
 <br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0})<br>
 &gt;&gt;<br>
 &gt;&gt; (define flower-bed%<br>
 &gt;&gt;=C2=A0 =C2=A0{class<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0stack%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(init flower-bed-index)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(super-new)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define my-index flower-bed-index)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (flower-bed-region-callback cards)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send (send this get-garden) place-on-fl=
 ower-bed-request (wheels cards)<br>
 &gt;&gt; this))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(let ((layout (send this get-layout)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send this set-region<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(make-region<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-f=
 lower-bed-x-coordinate this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-f=
 lower-bed-y-coordinate this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-f=
 lower-bed-width this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-f=
 lower-bed-height this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 #f ;&quot;Flower B=
 ed&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 flower-bed-region-=
 callback)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(send (send (send this get-garden) get-table)<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0add-region (send this get-=
 region))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-flower-bed-index) my-index)=
 <br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (reconfigure-cards)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(let ((my-cards (send this get-cards)))<=
 br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(broadcast* my-cards<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0(user-can-move #f)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0(snap-back-after-move #t))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(when (not (null? my-cards))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(let ((top-card (wheels my=
 -cards)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(when (send top-car=
 d face-down?) (send top-card face-up))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send top-card user=
 -can-move #t)) )))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/override (move-done)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(reconfigure-cards))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;(send (send this get-layout) layout-cards! thi=
 s))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0})<br>
 &gt;&gt;<br>
 &gt;&gt; ;; According to the game play bucket% might not even be a<br>
 &gt;&gt; ;; stack%. Technically speaking it does not impose any useful orde=
 r<br>
 &gt;&gt; ;; onto the cards but is the reserve and its layout could be done =
 by<br>
 &gt;&gt; ;; the user. Quality assurance (me when I just want to play) assur=
 ed<br>
 &gt;&gt; ;; us though that doing the layout by hand isn&#39;t much fun and =
 they<br>
 &gt;&gt; ;; would prefer us to do the layout for the user.<br>
 &gt;&gt; (define bucket%<br>
 &gt;&gt;=C2=A0 =C2=A0{class<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0stack%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(super-new)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (bucket-region-callback cards)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send (send this get-garden) place-on-bu=
 cket-request (wheels cards) this))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(let ((layout (send this get-layout)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send this set-region<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(make-region<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-b=
 ucket-x-coordinate this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-b=
 ucket-y-coordinate this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-b=
 ucket-width this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-b=
 ucket-height this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 #f ;&quot;Bouquet&=
 quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 bucket-region-call=
 back)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(send (send (send this get-garden) get-table)<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0add-region (send this get-=
 region))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (prepare-card-for-bucket card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(when (send card face-down?) (send card =
 face-up))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send* card<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;(face-up)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(snap-back-after-move #f)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(user-can-move #t)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/override (add-card card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(prepare-card-for-bucket card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(super add-card card))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/override (move-done)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send (send this get-layout) layout-card=
 s! this))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 (define/override (after-drag fi=
 nished-on-region? cards)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 (send (send this get-lay=
 out) layout-cards! this))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0})<br>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Garbage Collection<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Sometimes the garbage collector (3m) starts running in the mids=
 t of<br>
 &gt;&gt; ;; an animation or worse in the middle of a user interaction like =
 a<br>
 &gt;&gt; ;; drag. To avoid that this happens we call the garbage collector =
 in<br>
 &gt;&gt; ;; right after the initial deal. The user interface effects of the=
 <br>
 &gt;&gt; ;; initial deal show up only after the garbage collector returned.=
  For<br>
 &gt;&gt; ;; this the user might stare at a gray empty window for a short pe=
 riod<br>
 &gt;&gt; ;; of time.<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Usually after each move-done there should be enough time to run=
  the<br>
 &gt;&gt; ;; garbage collector because the user thinks about his next move o=
 r is<br>
 &gt;&gt; ;; on the way of reacting to the visual feedback (if we were talki=
 ng<br>
 &gt;&gt; ;; about milliseconds) BUT: user interface changes are only shown<=
 br>
 &gt;&gt; ;; after the event handler returned (to the internal event handlin=
 g<br>
 &gt;&gt; ;; loop) AND the garbage collector seems to be really slow. Starti=
 ng<br>
 &gt;&gt; ;; Flower Garden from the command line instead of running it in th=
 e<br>
 &gt;&gt; ;; IDE reduces the time the garbage collector takes noticeably but=
 <br>
 &gt;&gt; ;; it&#39;s still too slow on a 2.4 GHz Dual Core. Racket and the =
 used<br>
 &gt;&gt; ;; libraries/modules/packages do need a lot of RAM - about 200 MB =
 but<br>
 &gt;&gt; ;; running the garbage collector all the time (at each move-done) =
 does<br>
 &gt;&gt; ;; not reduce the time it needs. (BTW It&#39;s still 2015 by the t=
 ime of<br>
 &gt;&gt; ;; this writing or should I say: already 2015)?<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Fast memory allocation might be a performance issue for one-way=
  win<br>
 &gt;&gt; ;; the race scientific applications but for end user applications =
 like<br>
 &gt;&gt; ;; this it would be better to have fast garbage collection which<b=
 r>
 &gt;&gt; ;; doesn&#39;t need ages - especially when there is nothing to be =
 done and<br>
 &gt;&gt; ;; next to no changes in the data structures since the last run.<b=
 r>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Program Action Hub<br>
 &gt;&gt; {define garden%<br>
 &gt;&gt;=C2=A0 =C2=A0(class<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0object%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(super-new)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define number-of-foundations 4)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define number-of-flower-beds 6)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define flower-selection #f)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define flowers (make-flowers (make-deck)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define layout (new layout% (unit-card (wheels =
 flowers))))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; ;; ;; ;; ;; ;; ;; ;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; This should be a subclass of table% named<br=
 >
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; flower-garden-table%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; But make-table won&#39;t let us do this conv=
 eniently ???<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define garden (make-table<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0&quot;Flower Venus Garden&quot; ; title<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0(send layout get-table-width this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0(send layout get-table-height this) ))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Redefine mouse interaction. See documentatio=
 n.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(send* garden<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(set-button-action &#39;left &#39;drag-r=
 aise/one)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(set-button-action &#39;middle &#39;drag=
 -raise/one)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(set-button-action &#39;right &#39;drag-=
 raise/one))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (dummy-mouse-event-handler card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0#t)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Event Handling<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; There is no documented message passing proto=
 col for the event<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; stream coming from region and table objects.=
  There is no well<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; defined order but we can look at the order o=
 f events arriving<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; and think about it. A drag starts out with a=
  single click<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; event. That single click event might or migh=
 t not match our<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; interactor model but we need to make its con=
 sequences unhappen<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; because the user did not click but drag and =
 we got to know about<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; this only later on. There is a place to do t=
 hat: see<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; set-interactive-region-callback! in stack% a=
 dd-region.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; A double click is a time and coordinate depe=
 ndent event usually<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; composed of two single clicks. Depending on =
 the libraries and<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; low level routines in use we might expect to=
  see the following<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; sequences in the event stream on the same ca=
 rd in a short time<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; interval: a period &quot;.&quot; denotes a s=
 ingle click event, a colon &quot;:&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; denotes a double click event<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; ..=C2=A0 two clicks no double click event<br=
 >
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; :=C2=A0 =C2=A0one double click event - no si=
 ngle click events<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; .:=C2=A0 one single click event and one doub=
 le click event<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; ..: two single click events and one double c=
 lick event<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; :.. one double click event and two single cl=
 ick events<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; .:. one single click event then a double cli=
 ck event then<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 a single click event aga=
 in<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; We can adapt our interaction model or Intera=
 ctor (see Garnet) to<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; avoid misinterpreting events. A single click=
  sets the selection<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; and the next click clears the selection. A d=
 ouble click clears<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; the selection. With this behaviour in mind t=
 here remain two<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; cases of event sequences which are not handl=
 ed in the right way:<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; the first one (..) which is degenerate becau=
 se there is no<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; double click event at all. We could try to l=
 ook at the time<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; codes of the events and determine if it was =
 a double click or<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; not but we cannot check the pointer coordina=
 tes here which is<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; crucial to recognize double clicks and drags=
 . Then the last<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; sequence (.:.) is problematic, too. And test=
 ing suggests that<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; this is our favourite one and only sequence =
 of events. On the<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; developer&#39;s machine each double click ev=
 ent is surrouned by<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; single clicks and we end up with a card that=
  has already been<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; moved by the double click event which cleare=
 d selection and we<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; now receive a single click event for that ca=
 rd: it ends up<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; selected (in a foundation). Please bear in m=
 ind that a click<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; event is a synthesized composed event itself=
 : usually a click is<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; defined as the following sequence of low lev=
 el events: mouse<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; button down, mouse button up (within the sam=
 e spot region in<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; screen coordinates). The Virtual Card Librar=
 y does not use that<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; definition of a click. Another aspect of our=
  event handling here<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; to keep in mind is the fact that we do not r=
 ecieve a stream of<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; events as a stream of events but the user de=
 fined thunks are<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; invoked as event handlers at certain not wel=
 l defined moments<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; not in time but in the execution order of th=
 e Virtual Card<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Library routines intertwined with garbage co=
 llection and<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; operating system interaction.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Interaction Models have to be learned by the=
  user. Some are<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; nowadays common accepted standard (even if n=
 ot well documented)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; but everything changes: where you&#39;re fav=
 ourite lisp based action<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; game developing environment from back then a=
 llowed you to choose<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; one of a set of actions and then apply it on=
  some object today<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; we expect to select the object.e.g. file and=
  then choose one of<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; its associated actions, e.g. delete. This is=
  true on most modern<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; graphical user interaction shells. But when =
 you do graphic<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; design and photo retouch we first choose the=
  action or tool and<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; then apply it to some part of the object to =
 design. Vice verse<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; these behaviours and people will tell you th=
 at it&#39;s completely<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; broken even if they&#39;re already used to b=
 oth interaction models.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; I don&#39;t touch I click - but that&#39;s a=
 nother chapter and out of<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; the scope of this little card game.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Some interaction models to not work out anyw=
 ay: the select card<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; then destination approach falls for Moon Flo=
 wer Garden because<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; the bucket is full of cards. Do you want to =
 move the flower to<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; the bucket or do you want to select a card i=
 n the bucket?<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(send* garden<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(set-double-click-action ;dummy-mouse-ev=
 ent-handler)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 {lambda (flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;(debug &quot;flower-garden-tabl=
 e%: double-click-action&quot;)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send this rescue-request flower=
 )})<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(set-single-click-action dummy-mouse-eve=
 nt-handler) )<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0{lam=
 bda (flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 (debug &quot;flower-garden-table%: single-click-action&quot;)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0(send this selection-request flower)}))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(send garden add-region<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(make-background-region<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-background-x-co=
 ordinate garden)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-background-y-co=
 ordinate garden)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-background-widt=
 h garden)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-background-heig=
 ht garden)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send layout get-background-pain=
 t-callback garden)))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Animations<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; It seems the animation of the Virtual Card L=
 ibrary are<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; primarily intended to visualize algorithms o=
 r better: their<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; time ordered consequences. There is a proble=
 m where the<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; animation of a dragged card doesn&#39;t star=
 t at the final position<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; of the drag when/where the handler is called=
  but it starts at<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; the original location of the card which migh=
 t be percieved as<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; an unpleasant flickering. That behaviour of =
 the animation<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; engine depends on a set home-region but not =
 only. Not setting<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; the home-region at all in the class definiti=
 on of stack% gives<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; us the correct starting positions for the an=
 imations after a<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; drag from the Bouquet to a Flower Bed. All d=
 rags originating<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; from Flower Beds do still animate with the d=
 escribed wrong<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; starting position. This might have to do wit=
 h one of the<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; messages in reconfigure-cards but after all:=
  the animation<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; engine does not feature any fine grained con=
 trol and is abusing<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; the cards&lt;%&gt; configuration in an undoc=
 umented way. Nevertheless<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; the wrong starting position seems to be a re=
 al bug of the<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; animation engine. BTW It doesn&#39;t animate=
  snap backs either ...<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Perhaps they want to fix it.<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;(send garden animated #f)=C2=A0 ; turn animati=
 on off altogether<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; End of pseudo subclass flower-garden-table%<=
 br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; ;; ;; ;; ;; ;; ;; ;;<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define my-bouquet (new flower-dialog% (garden =
 this)))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Create the Foundations<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; We could loop here or abbreviate with some l=
 ambda form<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; but I like to hardcode these things. A diffe=
 rent number<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; of foundations makes a different game.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define foundations<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(list (new foundation% (garden this) (fo=
 undation-index 1))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(new foundation% (g=
 arden this) (foundation-index 2))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(new foundation% (g=
 arden this) (foundation-index 3))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(new foundation% (g=
 arden this) (foundation-index 4))))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Create the Flower Beds<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define flower-beds<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(map {lambda (flower-bed-index)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (new flower-bed%<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0(garden this)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0(flower-bed-index flower-bed-index))}<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (list 1 2 3 4 5 6)))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Create the bouquet.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define bouquet (new bucket% [garden this]))<br=
 >
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; ;; ;; ;; ;; ;; ;; ;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; This sort of extra stack handling is needed =
 because of our<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; inability to subclass card% conveniently. Se=
 e Flowers (flower%).<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define stack-register (append (list bouquet) f=
 lower-beds foundations))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (syncronize-stacks card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(broadcast stack-register remove-card! c=
 ard))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; ;; ;; ;; ;; ;; ;; ;;<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Internal Interface<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-layout) layout)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (get-table) garden)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (card-face-up card)=C2=A0 =C2=A0=
  =C2=A0 =C2=A0 ;; XXX<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send garden card-face-up card))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (flower-picked flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send layout flower-present flower))<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Rule Implementation Interface<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; Where one part of a card game&#39;s rules us=
 ually becomes the game<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; mechanic, i.e. layout and user interaction, =
 another part becomes<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; the game&#39;s logic. For convenience this i=
 s implemented here as<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; something that resembles a controller.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; To allow different difficulty levels we migh=
 t want to introduce<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; flower-garden-ruleset&lt;%&gt; objects and d=
 elegate these calls to the<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; one representing the current ruleset.<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define empty? null?)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (initial-deal)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;; Prepare our card game.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(set! flowers (shuffle-list flowers 6))<=
 br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;; Throw the seeds. It&#39;s reversed to=
  make them fly over not<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;; under. This deals the cards visually =
 from the bottom of the<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;; deck. But when dealing from its top w=
 e would have to<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;; re-stack-cards, i.e. changing the z-a=
 xis ordering, for the<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;; whole table all the time.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send garden add-cards (reverse flowers)=
  0 0)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(let ((flowers flowers))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;; Deal 6 cards on each flower be=
 d.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(repeat 6 {lambda ()<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0(for-each {lambda (flower-bed)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send flower-bed add-ca=
 rd<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(w=
 heels flowers))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(set! flowers (cast flo=
 wers))}<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0flower-beds)} )<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;; Cut the flowers&#39; wheels.<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(broadcast (map wheels (broadcast=
  flower-beds get-cards))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 face-up)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;; Deal the remaining cards into =
 the bucket.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(for-each {lambda (flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0(send bouquet add-card flower)}<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0flowers))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;(clear-selection)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(broadcast stack-register move-done)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0;(collect-garbage)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0) ; end of initial deal<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (place-on-flower-bed-request flo=
 wer flower-bed)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(let ((stacked (send flower-bed get-card=
 s)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(when (or (empty? stacked)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0(and (card-one-rank-below? flower (wheels stacked))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 (card-same-suit? flower (wheels stacked))))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send flower-bed add-card =
 flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(broadcast stack-register =
 move-done) )))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (game-is-won?)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(define (foundation-full? foundation)<br=
 >
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(let ((stacked (send foundation g=
 et-cards)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(and (not (null? stacked))=
 <br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (card-is-ki=
 ng? (wheels stacked))) ))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(define (game-is-won? foundations)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(if (null? foundations)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0#t<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(and (foundation-fu=
 ll? (wheels foundations))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (gam=
 e-is-won? (cast foundations))) )) ; not tail recursive<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(game-is-won? foundations))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (place-on-foundation-request flo=
 wer foundation)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(let ((stacked (send foundation get-card=
 s)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(when [or (and (empty? stacked)<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 (card-is-ace? flower))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0(and (not (empty? stacked))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 (card-same-suit? flower (wheels stacked))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 (card-one-rank-above? flower (wheels stacked)))]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send foundation add-card =
 flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;(clear-selection)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(broadcast stack-register =
 move-done)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(when (game-is-won?)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send my-bou=
 quet flower-present)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(reset-game)=
  )) ))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define (is-playable? flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(and (send flower user-can-move)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (not (send flower face-do=
 wn?))))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (rescue-request flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(when (is-playable? flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;; It&#39;s a bit like brute forc=
 e but it&#39;s terse and readable.<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;; (and with animation it looks r=
 eally funny which makes<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;; you lough and that is a good t=
 hing [for a card game]!)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(for-each {lambda (foundation)<br=
 >
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0(place-on-foundation-request flower foundation)}<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0foundations)))<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (place-on-bucket-request flower =
 bucket)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(when [&lt; (send bucket number-of-cards=
 ) 16]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send bucket add-card flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;(clear-selection)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(broadcast stack-register move-do=
 ne) ))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;; DEFUNCT Selection Handling Interface<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 (define/public (clear-selection=
 )<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 ;(debug &quot;garden%: c=
 lear-selection called; flower-selection: &quot;<br>
 &gt;&gt; flower-selection)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 ;(broadcast flowers dim =
 #f)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 (when flower-selection<b=
 r>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(deb=
 ug &quot;garden%: clear-selection: clearing selection&quot;)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0;(se=
 nd flower-selection dim #f)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;(b=
 roadcast flowers dim #f)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(set=
 ! flower-selection #f)))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 (define/public (selection-reque=
 st flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 (debug &quot;garden%: se=
 lection-request called&quot;)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 (if [and (eq? flower-sel=
 ection flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 (send flower-selection dim)]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(clear-sele=
 ction)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(when [is-p=
 layable? flower]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0(clear-selection)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0(set! flower-selection flower)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0(send flower dim #t)) ))<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;;; Application Interface<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (grow)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(send garden show #t)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0(w/o-cart-animation garden initial-deal)=
 )<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0;(initial-deal))<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define/public (reset-game)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0[w/o-cart-animation* garden<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;; remove cards from the stacks (from the m=
 odel)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (for-each {lambda (card)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;=
 ; ??? perhaps it&#39;s better to implement<br>
 &gt;&gt; reset in<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;=
 ; stack%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (=
 broadcast stack-register remove-card!<br>
 &gt;&gt; card)}<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 flowers)=
 <br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ;; remove cards from the table (from the vi=
 ew)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (send garden remove-cards flowers)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (reset-flowers flowers)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (initial-deal)])<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0)}<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt; ;;<br>
 &gt;&gt; ;; Application Class / Menu and System Interface<br>
 &gt;&gt; ;;<br>
 &gt;&gt;<br>
 &gt;&gt; (define flower-garden%<br>
 &gt;&gt;=C2=A0 =C2=A0{class<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0object%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(super-new)<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define garden (new garden%))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define main-frame (send garden get-table))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define my-menu-bar (make-object menu-bar% main=
 -frame))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(define my-game-menu (make-object menu% &quot;G=
 ame&quot; my-menu-bar))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(new menu-item%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [label &quot;Reset Game...&quot;=
 ]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [parent my-game-menu]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [callback<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0{lambda (i e)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(when (eq? &#39;yes=
  (message-box &quot;Reset Game&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 &quot;Are you sure you want to reset the<br>
 &gt;&gt; game?&quot;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 main-frame<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 &#39;(yes-no)))<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(send garden=
  reset-game))}])<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(new separator-menu-item% [parent my-game-menu]=
 )<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(new menu-item%<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [label &quot;Quit&quot;]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [parent my-game-menu]<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 [callback {lambda (i e)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 (send main-frame show #f)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 (exit)}])<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0(send garden grow)<br>
 &gt;&gt;=C2=A0 =C2=A0 =C2=A0})<br>
 &gt;&gt;<br>
 &gt;&gt; (define sort-by-suit (new flower-garden%))<br>
 &gt;&gt;<br>
 &gt;&gt; *** Environment:<br>
 &gt;&gt; macosx &quot;Darwin nPing.local 10.8.0 Darwin Kernel Version 10.8.=
 0: Tue Jun=C2=A0 7<br>
 &gt;&gt; 16:33:36 PDT 2011; root:xnu-1504.15.3~1/RELEASE_I386 i386&quot; (x=
 86_64-macosx/3m)<br>
 &gt;&gt; (get-display-depth) =3D 32<br>
 &gt;&gt; Human Language: english<br>
 &gt;&gt; (current-memory-use) 440017348<br>
 &gt;&gt; raco pkg (show):<br>
 &gt;&gt; Installation-wide:<br>
 &gt;&gt;=C2=A0 Package=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 Chec=
 ksum=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 Source<br>
 &gt;&gt;=C2=A0 main-distribution=C2=A0 =C2=A0 f07e2d4bf2708c1085be38eca18aa=
 9eb6755e547=C2=A0 =C2=A0 (catalog<br>
 &gt;&gt; main-distribution)<br>
 &gt;&gt;=C2=A0 racket-lib=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A041c7b3221=
 006758c5a840a18dcc0d265632f14c2=C2=A0 =C2=A0 (catalog<br>
 &gt;&gt; racket-lib)<br>
 &gt;&gt;=C2=A0 [178 auto-installed packages not shown]<br>
 &gt;&gt; User-specific for installation &quot;6.1&quot;:<br>
 &gt;&gt;=C2=A0 [none]<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt;<br>
 &gt;&gt; Collections:<br>
 &gt;&gt; (&quot;/Users/mt/Library/Racket/6.1/collects&quot;<br>
 &gt;&gt;=C2=A0 (non-existent-path))<br>
 &gt;&gt; (&quot;/Applications/Racket v6.1/collects&quot;<br>
 &gt;&gt;=C2=A0 (&quot;.gitignore&quot; &quot;acks&quot; &quot;compiler&quot=
 ; &quot;data&quot; &quot;db&quot; &quot;dynext&quot; &quot;ffi&quot; &quot;=
 file&quot; &quot;info&quot;<br>
 &gt;&gt; &quot;info-domain&quot; &quot;json&quot; &quot;launcher&quot; &quo=
 t;net&quot; &quot;openssl&quot; &quot;pkg&quot; &quot;planet&quot; &quot;ra=
 cket&quot; &quot;raco&quot;<br>
 &gt;&gt; &quot;reader&quot; &quot;realm&quot; &quot;s-exp&quot; &quot;setup=
 &quot; &quot;syntax&quot; &quot;unstable&quot; &quot;version&quot; &quot;xm=
 l&quot;))<br>
 &gt;&gt;<br>
 &gt;&gt; Recent Internal Errors:<br>
 &gt;&gt; Computer Language: ((&quot;Determine language from source&quot;) (=
 #(#t print<br>
 &gt;&gt; mixed-fraction-e #f #t debug) (default) #() &quot;#lang racket\n&q=
 uot; #t #t ((test)<br>
 &gt;&gt; (main)) #t))<br>
 </div></div></blockquote></div><br><br clear=3D"all"><div><br></div>-- <br>=
 <div class=3D"gmail_signature">-- <br>Jens Axel S=C3=B8gaard<br><br></div>
 </div>
 
 --001a113deff29ac0d10515d25a9c--
