From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Wed Nov 28 23:25:30 2012
Received: from mail-ia0-f172.google.com (mail-ia0-f172.google.com [209.85.210.172])
	by champlain.ccs.neu.edu (8.14.4/8.14.4) with ESMTP id qAT4PRsB007580
	for <bugs@bugs.plt-scheme.org>; Wed, 28 Nov 2012 23:25:27 -0500
Message-Id: <201211290425.qAT4PLUO007568@champlain.ccs.neu.edu>
Date: Wed, 28 Nov 2012 23:25:21 -0500
From: eric.n.dobson@gmail.com
To: bugs@racket-lang.org
Subject: Support for provide/typed

>Number:         13322
>Category:       typed-scheme
>Synopsis:       Support for provide/typed
>Class:          change-request
>Responsible:    samth
>Severity:       serious
>Priority:       medium
>State:          open
>Confidential:   no
>Arrival-Date:   Wed Nov 28 23:28:01 -0500 2012
>Last-Modified:  Tue Mar 26 01:54:03 -0400 2013
>Originator:     Eric Dobson
>Organization:
plt
>Submitter-Id:   unknown
>Release:        5.3
>Environment:
MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/537.2 (KHTML, like Gecko) Chrome/22.0.1215.0 Safari/537.2
>Description:
There should be a form provide/typed that works like the reverse of require/typed. It is used in an untyped module whose exports should be treated as typed for use in other typed modules.
>How-To-Repeat:
>Fix:
>Audit-Trail:
From: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>
Cc: nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Wed, 28 Nov 2012 20:32:36 -0800

 On Wed, Nov 28, 2012 at 8:28 PM,  <eric.n.dobson@gmail.com> wrote:
 >
 > There should be a form provide/typed that works like the reverse of require/typed. It is used in an untyped module whose exports should be treated as typed for use in other typed modules.
 
 So this would basically be `provide/contract` plus a `#%type-decl` module?
 
 --
 sam th
 samth@ccs.neu.edu
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 08:57:59 -0800

 --f46d043c81f876147a04cfa52f40
 Content-Type: text/plain; charset=UTF-8
 
 Yes, and there would need to be support for having the type names bound in
 an untyped program.
 
 
 On Wed, Nov 28, 2012 at 8:32 PM, Sam Tobin-Hochstadt <samth@ccs.neu.edu>wrote:
 
 > On Wed, Nov 28, 2012 at 8:28 PM,  <eric.n.dobson@gmail.com> wrote:
 > >
 > > There should be a form provide/typed that works like the reverse of
 > require/typed. It is used in an untyped module whose exports should be
 > treated as typed for use in other typed modules.
 >
 > So this would basically be `provide/contract` plus a `#%type-decl` module?
 >
 > --
 > sam th
 > samth@ccs.neu.edu
 >
 
 --f46d043c81f876147a04cfa52f40
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 Yes, and there would need to be support for having the type names bound in =
 an untyped program.<div class=3D"gmail_extra"><br><br><div class=3D"gmail_q=
 uote">On Wed, Nov 28, 2012 at 8:32 PM, Sam Tobin-Hochstadt <span dir=3D"ltr=
 ">&lt;<a href=3D"mailto:samth@ccs.neu.edu" target=3D"_blank">samth@ccs.neu.=
 edu</a>&gt;</span> wrote:<br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
 x #ccc solid;padding-left:1ex">On Wed, Nov 28, 2012 at 8:28 PM, =C2=A0&lt;<=
 a href=3D"mailto:eric.n.dobson@gmail.com">eric.n.dobson@gmail.com</a>&gt; w=
 rote:<br>
 
 &gt;<br>
 &gt; There should be a form provide/typed that works like the reverse of re=
 quire/typed. It is used in an untyped module whose exports should be treate=
 d as typed for use in other typed modules.<br>
 <br>
 So this would basically be `provide/contract` plus a `#%type-decl` module?<=
 br>
 <br>
 --<br>
 sam th<br>
 <a href=3D"mailto:samth@ccs.neu.edu">samth@ccs.neu.edu</a><br>
 </blockquote></div><br></div>
 
 --f46d043c81f876147a04cfa52f40--
From: Neil Toronto <neil.toronto@gmail.com>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 10:09:38 -0700

 You can already do that. Choose them from `typed/racket/base' using 
 (require (only-in typed/racket/base T1 T2 ...)). Or you can (require 
 typed/racket/base) if you don't mind it doing... some weird things. I 
 can't recall exactly what the weird things are.
 
 If you mean the act of binding types to module exports, then you can do 
 that using a typed submodule. The `typed/untyped-utils' module 
 (currently undocumented - I'll get to it eventually) exports a macro 
 called `require/untyped-contract' that expands to a typed submodule. 
 It's meant to be used in an untyped parent module. The typed submodule 
 exists just to give new types to existing values, using the same name. 
 It might be close to what you're looking for.
 
 Neil âŠ¥
 
 On 11/29/2012 09:57 AM, Eric Dobson wrote:
 > Yes, and there would need to be support for having the type names bound
 > in an untyped program.
 >
 >
 > On Wed, Nov 28, 2012 at 8:32 PM, Sam Tobin-Hochstadt <samth@ccs.neu.edu
 > <mailto:samth@ccs.neu.edu>> wrote:
 >
 >     On Wed, Nov 28, 2012 at 8:28 PM,  <eric.n.dobson@gmail.com
 >     <mailto:eric.n.dobson@gmail.com>> wrote:
 >      >
 >      > There should be a form provide/typed that works like the reverse
 >     of require/typed. It is used in an untyped module whose exports
 >     should be treated as typed for use in other typed modules.
 >
 >     So this would basically be `provide/contract` plus a `#%type-decl`
 >     module?
 >
 >     --
 >     sam th
 >     samth@ccs.neu.edu <mailto:samth@ccs.neu.edu>
 >
 >
 
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Neil Toronto <neil.toronto@gmail.com>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 09:23:22 -0800

 --0016e6de00e939041704cfa58aff
 Content-Type: text/plain; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 So what I meant was a nice way to import types from the base libraries,
 which it seems is not provided.
 
 The require/untyped-contract seems like it is on the other side of the
 provide/require fence. Also it seem to add a couple more definitions which
 then gets confusing because the expanded id has different bindings
 depending on whether it is used in a typed module or untyped module. My
 request would only require adding annotations about existing bindings.
 
 The original purpose of this FR was that I was thinking of writing a module
 that was complicated and used features not supported by TR (the ffi). But I
 wanted it supported seemlessly in the rest of my TR program. require/typed
 requires work in every importing module, while this would require only work
 in the defining module. It is currently possible to define a sister typed
 module and use require/typed/provide, but this also runs into a binding
 issue and requires a different module for typed versus untyped code.
 
 
 On Thu, Nov 29, 2012 at 9:09 AM, Neil Toronto <neil.toronto@gmail.com>wrote=
 :
 
 > You can already do that. Choose them from `typed/racket/base' using
 > (require (only-in typed/racket/base T1 T2 ...)). Or you can (require
 > typed/racket/base) if you don't mind it doing... some weird things. I can=
 't
 > recall exactly what the weird things are.
 >
 > If you mean the act of binding types to module exports, then you can do
 > that using a typed submodule. The `typed/untyped-utils' module (currently
 > undocumented - I'll get to it eventually) exports a macro called
 > `require/untyped-contract' that expands to a typed submodule. It's meant =
 to
 > be used in an untyped parent module. The typed submodule exists just to
 > give new types to existing values, using the same name. It might be close
 > to what you're looking for.
 >
 > Neil =E2=8A=A5
 >
 >
 > On 11/29/2012 09:57 AM, Eric Dobson wrote:
 >
 >> Yes, and there would need to be support for having the type names bound
 >> in an untyped program.
 >>
 >>
 >> On Wed, Nov 28, 2012 at 8:32 PM, Sam Tobin-Hochstadt <samth@ccs.neu.edu
 >> <mailto:samth@ccs.neu.edu>> wrote:
 >>
 >>     On Wed, Nov 28, 2012 at 8:28 PM,  <eric.n.dobson@gmail.com
 >>     <mailto:eric.n.dobson@gmail.**com <eric.n.dobson@gmail.com>>> wrote:
 >>      >
 >>      > There should be a form provide/typed that works like the reverse
 >>     of require/typed. It is used in an untyped module whose exports
 >>     should be treated as typed for use in other typed modules.
 >>
 >>     So this would basically be `provide/contract` plus a `#%type-decl`
 >>     module?
 >>
 >>     --
 >>     sam th
 >>     samth@ccs.neu.edu <mailto:samth@ccs.neu.edu>
 >>
 >>
 >>
 >
 
 --0016e6de00e939041704cfa58aff
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 So what I meant was a nice way to import types from the base libraries, whi=
 ch it seems is not provided.<div><br></div><div>The require/untyped-contrac=
 t seems like it is on the other side of the provide/require fence. Also it =
 seem to add a couple more definitions which then gets confusing because the=
  expanded id has different bindings depending on whether it is used in a ty=
 ped module or untyped module. My request would only require adding annotati=
 ons about existing bindings.</div>
 <div><br></div><div>The original purpose of this FR was that I was thinking=
  of writing a module that was complicated and used features not supported b=
 y TR (the ffi). But I wanted it supported seemlessly in the rest of my TR p=
 rogram. require/typed requires work in every importing module, while this w=
 ould require only work in the defining module. It is currently possible to =
 define a sister typed module and use require/typed/provide, but this also r=
 uns into a binding issue and requires a different module for typed versus u=
 ntyped code.</div>
 <div class=3D"gmail_extra"><br><br><div class=3D"gmail_quote">On Thu, Nov 2=
 9, 2012 at 9:09 AM, Neil Toronto <span dir=3D"ltr">&lt;<a href=3D"mailto:ne=
 il.toronto@gmail.com" target=3D"_blank">neil.toronto@gmail.com</a>&gt;</spa=
 n> wrote:<br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
 x #ccc solid;padding-left:1ex">You can already do that. Choose them from `t=
 yped/racket/base&#39; using (require (only-in typed/racket/base T1 T2 ...))=
 . Or you can (require typed/racket/base) if you don&#39;t mind it doing... =
 some weird things. I can&#39;t recall exactly what the weird things are.<br=
 >
 
 <br>
 If you mean the act of binding types to module exports, then you can do tha=
 t using a typed submodule. The `typed/untyped-utils&#39; module (currently =
 undocumented - I&#39;ll get to it eventually) exports a macro called `requi=
 re/untyped-contract&#39; that expands to a typed submodule. It&#39;s meant =
 to be used in an untyped parent module. The typed submodule exists just to =
 give new types to existing values, using the same name. It might be close t=
 o what you&#39;re looking for.<br>
 
 <br>
 Neil =E2=8A=A5<div class=3D"im"><br>
 <br>
 On 11/29/2012 09:57 AM, Eric Dobson wrote:<br>
 </div><blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-l=
 eft:1px #ccc solid;padding-left:1ex"><div class=3D"im">
 Yes, and there would need to be support for having the type names bound<br>
 in an untyped program.<br>
 <br>
 <br>
 On Wed, Nov 28, 2012 at 8:32 PM, Sam Tobin-Hochstadt &lt;<a href=3D"mailto:=
 samth@ccs.neu.edu" target=3D"_blank">samth@ccs.neu.edu</a><br></div><div cl=
 ass=3D"im">
 &lt;mailto:<a href=3D"mailto:samth@ccs.neu.edu" target=3D"_blank">samth@ccs=
 .neu.edu</a>&gt;&gt; wrote:<br>
 <br>
 =C2=A0 =C2=A0 On Wed, Nov 28, 2012 at 8:28 PM, =C2=A0&lt;<a href=3D"mailto:=
 eric.n.dobson@gmail.com" target=3D"_blank">eric.n.dobson@gmail.com</a><br><=
 /div><div class=3D"im">
 =C2=A0 =C2=A0 &lt;mailto:<a href=3D"mailto:eric.n.dobson@gmail.com" target=
 =3D"_blank">eric.n.dobson@gmail.<u></u>com</a>&gt;&gt; wrote:<br>
 =C2=A0 =C2=A0 =C2=A0&gt;<br>
 =C2=A0 =C2=A0 =C2=A0&gt; There should be a form provide/typed that works li=
 ke the reverse<br>
 =C2=A0 =C2=A0 of require/typed. It is used in an untyped module whose expor=
 ts<br>
 =C2=A0 =C2=A0 should be treated as typed for use in other typed modules.<br=
 >
 <br>
 =C2=A0 =C2=A0 So this would basically be `provide/contract` plus a `#%type-=
 decl`<br>
 =C2=A0 =C2=A0 module?<br>
 <br>
 =C2=A0 =C2=A0 --<br>
 =C2=A0 =C2=A0 sam th<br></div>
 =C2=A0 =C2=A0 <a href=3D"mailto:samth@ccs.neu.edu" target=3D"_blank">samth@=
 ccs.neu.edu</a> &lt;mailto:<a href=3D"mailto:samth@ccs.neu.edu" target=3D"_=
 blank">samth@ccs.neu.edu</a>&gt;<br>
 <br>
 <br>
 </blockquote>
 <br>
 </blockquote></div><br></div>
 
 --0016e6de00e939041704cfa58aff--
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 13:38:24 -0500

 --Apple-Mail=_C088DF19-48F2-4EDC-9DB0-95911410C1EA
 Content-Transfer-Encoding: quoted-printable
 Content-Type: text/plain;
 	charset=utf-8
 
 
 Eric's request is philosophically correct.=20
 
 At the moment the creator of typed modules imposes his thinking on =
 untyped modules via require/typed. If something goes wrong with these =
 imports, we blame the untyped module yet its creator had no say -- not =
 even a chance -- to express what kind of types might express a =
 specification for one of his exports. Hence we keep warning people that =
 contract violations do not necessarily mean a contract party got =
 something wrong; it really may mean that the contract -- or the type =
 specification that generated the contact -- is wrong.=20
 
 To balance the current situation, we really want=20
 
  -- provide/typed=20
  -- define-type in untyped modules=20
  -- require-a-type so that untyped modules can deal with types written =
 by a typed module=20
 
 While I admit that this addition violates the 'TR is for porting untyped =
 modules into the typed world, w/o changing the rest of the code base' =
 philosophy, the reality is that we are facing a bi-directional channel =
 situation. Our world is higher-order, and as a result, it should not =
 surprise us to find situations such as=20
 
   Base ;; converted to TR
    |
    |=20
   Server ;; still in Untyped=20
    |
    |
   Client ;; also converted to TR
 
 Eric's proposal would give Server a chance to express itself for Client =
 and Client wouldn't have to guess what Server meant.=20
 
 
 
 
 
 
 
 On Nov 29, 2012, at 12:23 PM, Eric Dobson wrote:
 
 > So what I meant was a nice way to import types from the base =
 libraries, which it seems is not provided.
 >=20
 > The require/untyped-contract seems like it is on the other side of the =
 provide/require fence. Also it seem to add a couple more definitions =
 which then gets confusing because the expanded id has different bindings =
 depending on whether it is used in a typed module or untyped module. My =
 request would only require adding annotations about existing bindings.
 >=20
 > The original purpose of this FR was that I was thinking of writing a =
 module that was complicated and used features not supported by TR (the =
 ffi). But I wanted it supported seemlessly in the rest of my TR program. =
 require/typed requires work in every importing module, while this would =
 require only work in the defining module. It is currently possible to =
 define a sister typed module and use require/typed/provide, but this =
 also runs into a binding issue and requires a different module for typed =
 versus untyped code.
 >=20
 >=20
 > On Thu, Nov 29, 2012 at 9:09 AM, Neil Toronto <neil.toronto@gmail.com> =
 wrote:
 > You can already do that. Choose them from `typed/racket/base' using =
 (require (only-in typed/racket/base T1 T2 ...)). Or you can (require =
 typed/racket/base) if you don't mind it doing... some weird things. I =
 can't recall exactly what the weird things are.
 >=20
 > If you mean the act of binding types to module exports, then you can =
 do that using a typed submodule. The `typed/untyped-utils' module =
 (currently undocumented - I'll get to it eventually) exports a macro =
 called `require/untyped-contract' that expands to a typed submodule. =
 It's meant to be used in an untyped parent module. The typed submodule =
 exists just to give new types to existing values, using the same name. =
 It might be close to what you're looking for.
 >=20
 > Neil =E2=8A=A5
 >=20
 >=20
 > On 11/29/2012 09:57 AM, Eric Dobson wrote:
 > Yes, and there would need to be support for having the type names =
 bound
 > in an untyped program.
 >=20
 >=20
 > On Wed, Nov 28, 2012 at 8:32 PM, Sam Tobin-Hochstadt =
 <samth@ccs.neu.edu
 > <mailto:samth@ccs.neu.edu>> wrote:
 >=20
 >     On Wed, Nov 28, 2012 at 8:28 PM,  <eric.n.dobson@gmail.com
 >     <mailto:eric.n.dobson@gmail.com>> wrote:
 >      >
 >      > There should be a form provide/typed that works like the =
 reverse
 >     of require/typed. It is used in an untyped module whose exports
 >     should be treated as typed for use in other typed modules.
 >=20
 >     So this would basically be `provide/contract` plus a `#%type-decl`
 >     module?
 >=20
 >     --
 >     sam th
 >     samth@ccs.neu.edu <mailto:samth@ccs.neu.edu>
 >=20
 >=20
 >=20
 >=20
 
 
 --Apple-Mail=_C088DF19-48F2-4EDC-9DB0-95911410C1EA
 Content-Disposition: attachment;
 	filename=smime.p7s
 Content-Type: application/pkcs7-signature;
 	name=smime.p7s
 Content-Transfer-Encoding: base64
 
 MIAGCSqGSIb3DQEHAqCAMIACAQExCzAJBgUrDgMCGgUAMIAGCSqGSIb3DQEHAQAAoIIMTDCCBVYw
 ggQ+oAMCAQICEHbDqMitQnj5Qd81mMX31uMwDQYJKoZIhvcNAQEFBQAwgd0xCzAJBgNVBAYTAlVT
 MRcwFQYDVQQKEw5WZXJpU2lnbiwgSW5jLjEfMB0GA1UECxMWVmVyaVNpZ24gVHJ1c3QgTmV0d29y
 azE7MDkGA1UECxMyVGVybXMgb2YgdXNlIGF0IGh0dHBzOi8vd3d3LnZlcmlzaWduLmNvbS9ycGEg
 KGMpMDkxHjAcBgNVBAsTFVBlcnNvbmEgTm90IFZhbGlkYXRlZDE3MDUGA1UEAxMuVmVyaVNpZ24g
 Q2xhc3MgMSBJbmRpdmlkdWFsIFN1YnNjcmliZXIgQ0EgLSBHMzAeFw0xMjA3MjYwMDAwMDBaFw0x
 MzA3MjYyMzU5NTlaMIIBGTEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlT
 aWduIFRydXN0IE5ldHdvcmsxRjBEBgNVBAsTPXd3dy52ZXJpc2lnbi5jb20vcmVwb3NpdG9yeS9S
 UEEgSW5jb3JwLiBieSBSZWYuLExJQUIuTFREKGMpOTgxHjAcBgNVBAsTFVBlcnNvbmEgTm90IFZh
 bGlkYXRlZDEzMDEGA1UECxMqRGlnaXRhbCBJRCBDbGFzcyAxIC0gTmV0c2NhcGUgRnVsbCBTZXJ2
 aWNlMRswGQYDVQQDFBJNYXR0aGlhcyBGZWxsZWlzZW4xIzAhBgkqhkiG9w0BCQEWFG1hdHRoaWFz
 QGNjcy5uZXUuZWR1MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxoivceU706ZnD2XD
 JfoNFd4KTbYA9AObozHkSZ6BJLC8oSGjakZu6m11azFwk5LfPOjd7dQIKw9uDhmT1e4q6jP+B1FC
 a1qqwm7Rw9PcFhqYFBlE8MbqJUXJW53Ynw3dK2XiUNqTXFcBa2otI8XxMtrQch4f9oMUy+aIn/fZ
 QQDbkkzuwz3884xSbm0IMDneYUC6FF1OJe2+fkMqHqEDsSgY97RFcjdgTCOB012odwGhxJ3rIGaX
 WUs7ttjnftzyGODVILMIx8RBJpGJ+Ur4R67SJygV8Clpg1RBuRUSNaZAN0tCjO9YSkb9HfF2tAx9
 POWmQXdTtNNjZfJPbTVnkQIDAQABo4HSMIHPMAkGA1UdEwQCMAAwRAYDVR0gBD0wOzA5BgtghkgB
 hvhFAQcXATAqMCgGCCsGAQUFBwIBFhxodHRwczovL3d3dy52ZXJpc2lnbi5jb20vcnBhMAsGA1Ud
 DwQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDBAYIKwYBBQUHAwIwUAYDVR0fBEkwRzBFoEOgQYY/
 aHR0cDovL2luZGMxZGlnaXRhbGlkLWczLWNybC52ZXJpc2lnbi5jb20vSW5kQzFEaWdpdGFsSUQt
 RzMuY3JsMA0GCSqGSIb3DQEBBQUAA4IBAQCeAXGCjjlMmU1wb3Ii4V0yNygujjQcvJstFh7IyVcM
 oD5/5Ar7b36JL1O2tpBosTf0pVZaORKCMPAf1IfBS48CvvqSoeVyXCFG1goXDjr7Ut+ZwosuFXdr
 2gD6u9EftuoUy+UBdz46NcN9YC0WbX7CrRE96XxvYwPfWnGIjsoNY7WqFI4f7HLlM5dCmAOXySsw
 EbPKpflzEGPU8aKf4FqTX9ne+hTzPbCf5CDJdzrdyn5bQkqvSzxw+P3tvQSU9lnyZkG7wZ1cibna
 QIuSNEe+HKOKcEfeTeD50JhLa43RE24nMsaXWdX61VTiPE/2Y9woEVLxXBp+AFpMZjGYsF/yMIIG
 7jCCBdagAwIBAgIQcRVmBUrkkSFN6bxE+azT3DANBgkqhkiG9w0BAQUFADCByjELMAkGA1UEBhMC
 VVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3
 b3JrMTowOAYDVQQLEzEoYykgMTk5OSBWZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVz
 ZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2lnbiBDbGFzcyAxIFB1YmxpYyBQcmltYXJ5IENlcnRpZmlj
 YXRpb24gQXV0aG9yaXR5IC0gRzMwHhcNMDkwNTAxMDAwMDAwWhcNMTkwNDMwMjM1OTU5WjCB3TEL
 MAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBU
 cnVzdCBOZXR3b3JrMTswOQYDVQQLEzJUZXJtcyBvZiB1c2UgYXQgaHR0cHM6Ly93d3cudmVyaXNp
 Z24uY29tL3JwYSAoYykwOTEeMBwGA1UECxMVUGVyc29uYSBOb3QgVmFsaWRhdGVkMTcwNQYDVQQD
 Ey5WZXJpU2lnbiBDbGFzcyAxIEluZGl2aWR1YWwgU3Vic2NyaWJlciBDQSAtIEczMIIBIjANBgkq
 hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7cRH3yooHXwGa7vXITLJbBOP6bGNQU4099oL42r6ZYgg
 CxET6ZvgSU6Lb9UB0F8NR5GKWkx0Pj/GkQm7TDSejW6hglFi92l2WJYHr54UGAdPWr2f0jGyVBlz
 RmoZQhHsEnMhjfXcMM3l2VYKMcU2bSkUl70t2olHGYjYSwQ967Y8Zx50ABMN0Ibak2f4MwOuGjxr
 aXj2wCyO4YM/d/mZ//6fUlrCtIcK2GypR8FUKWVDPkrAlh/Brfd3r2yxBF6+wbaULZeQLSfSux7p
 g2qE9sSyriMGZSalJ1grByK0b6ZiSBp38tVQJ5op05b7KPW6JHZi44xZ6/tu1ULEvkHH9QIDAQAB
 o4ICuTCCArUwNAYIKwYBBQUHAQEEKDAmMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC52ZXJpc2ln
 bi5jb20wEgYDVR0TAQH/BAgwBgEB/wIBADBwBgNVHSAEaTBnMGUGC2CGSAGG+EUBBxcBMFYwKAYI
 KwYBBQUHAgEWHGh0dHBzOi8vd3d3LnZlcmlzaWduLmNvbS9jcHMwKgYIKwYBBQUHAgIwHhocaHR0
 cHM6Ly93d3cudmVyaXNpZ24uY29tL3JwYTA0BgNVHR8ELTArMCmgJ6AlhiNodHRwOi8vY3JsLnZl
 cmlzaWduLmNvbS9wY2ExLWczLmNybDAOBgNVHQ8BAf8EBAMCAQYwbgYIKwYBBQUHAQwEYjBgoV6g
 XDBaMFgwVhYJaW1hZ2UvZ2lmMCEwHzAHBgUrDgMCGgQUS2u5KJYGDLvQUjibKaxLB4shBRgwJhYk
 aHR0cDovL2xvZ28udmVyaXNpZ24uY29tL3ZzbG9nbzEuZ2lmMC4GA1UdEQQnMCWkIzAhMR8wHQYD
 VQQDExZQcml2YXRlTGFiZWw0LTIwNDgtMTE4MB0GA1UdDgQWBBR5R2EIQf04BKJL57XM9UP2SSsR
 +DCB8QYDVR0jBIHpMIHmoYHQpIHNMIHKMQswCQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24s
 IEluYy4xHzAdBgNVBAsTFlZlcmlTaWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5
 IFZlcmlTaWduLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlT
 aWduIENsYXNzIDEgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBHM4IR
 AItbdVaEVIULAM+vOEjOsaQwDQYJKoZIhvcNAQEFBQADggEBADlNz0GZgbWpBbVSOOk5hIls5DSo
 WufYbAlMJBq6WaSHO3Mh8ZOBz79oY1pn/jWFK6HDXaNKwjoZ3TDWzE3v8dKBl8pUWkO/N4t6jhmN
 D0OojPKvYLMVirOVnDzgnrMnmKQ1chfl/Cpdh9OKDcLRRSr4wPSsKpM61a4ScAjr+zvid+zoK2Q1
 ds262uDRyxTWcVibvtU+fbbZ6CTFJGZMXZEfdrMXPn8NxiGJL7M3uKH/XLJtSd5lUkL7DojS7Uod
 v0vj+Mxy+kgOZY5JyNb4mZg7t5Q+MXEGh/psWVMu198r7V9jAKwV7QO4VRaMxmgD5yKocwuxvKDa
 UljdCg5/wYIxggSLMIIEhwIBATCB8jCB3TELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWdu
 LCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTswOQYDVQQLEzJUZXJtcyBv
 ZiB1c2UgYXQgaHR0cHM6Ly93d3cudmVyaXNpZ24uY29tL3JwYSAoYykwOTEeMBwGA1UECxMVUGVy
 c29uYSBOb3QgVmFsaWRhdGVkMTcwNQYDVQQDEy5WZXJpU2lnbiBDbGFzcyAxIEluZGl2aWR1YWwg
 U3Vic2NyaWJlciBDQSAtIEczAhB2w6jIrUJ4+UHfNZjF99bjMAkGBSsOAwIaBQCgggJtMBgGCSqG
 SIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEyMTEyOTE4MzgyNVowIwYJKoZI
 hvcNAQkEMRYEFIbswfpOfufwmCW7H0PzSG1HUzLEMIIBAwYJKwYBBAGCNxAEMYH1MIHyMIHdMQsw
 CQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlTaWduIFRy
 dXN0IE5ldHdvcmsxOzA5BgNVBAsTMlRlcm1zIG9mIHVzZSBhdCBodHRwczovL3d3dy52ZXJpc2ln
 bi5jb20vcnBhIChjKTA5MR4wHAYDVQQLExVQZXJzb25hIE5vdCBWYWxpZGF0ZWQxNzA1BgNVBAMT
 LlZlcmlTaWduIENsYXNzIDEgSW5kaXZpZHVhbCBTdWJzY3JpYmVyIENBIC0gRzMCEHbDqMitQnj5
 Qd81mMX31uMwggEFBgsqhkiG9w0BCRACCzGB9aCB8jCB3TELMAkGA1UEBhMCVVMxFzAVBgNVBAoT
 DlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTswOQYDVQQL
 EzJUZXJtcyBvZiB1c2UgYXQgaHR0cHM6Ly93d3cudmVyaXNpZ24uY29tL3JwYSAoYykwOTEeMBwG
 A1UECxMVUGVyc29uYSBOb3QgVmFsaWRhdGVkMTcwNQYDVQQDEy5WZXJpU2lnbiBDbGFzcyAxIElu
 ZGl2aWR1YWwgU3Vic2NyaWJlciBDQSAtIEczAhB2w6jIrUJ4+UHfNZjF99bjMA0GCSqGSIb3DQEB
 AQUABIIBAGmObc/P6y00RCrg1vjfj+Pd29bhMbDLL6YTuBVcY105qUsCQLNnTwDZbR4+mdTu3Zf8
 i0kJkOhodPQuJI7Pco1AlR0rcuM6+QOylxL8q/7hq6Dd7MmFhEV2VErxw3OuA2h0pCFKHJjkuxHO
 QlucqQqPcrwU9FMBtIzvrp+jYZWrM6AGxn3UiDE4SAryg0CnGWb8P9UNE3R2ahZVXsaIOWWe08El
 zi8LsJB9HnuscLAWIVS8MbR4oEtPnmOW6paeebFXqN7OhqQ8jBLxbylLR9tBoLGCJGxIT8mByG+K
 ZYD7boyMYDt/cCJWcyEruKEu8kV3toPVFDw+Mp8lJH8vbvwAAAAAAAA=
 
 --Apple-Mail=_C088DF19-48F2-4EDC-9DB0-95911410C1EA--
From: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 10:46:54 -0800

 On Thu, Nov 29, 2012 at 10:38 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >  -- require-a-type so that untyped modules can deal with types written by a typed module
 
 As Neil points out, we already have this with `require`.
 
 --
 sam th
 samth@ccs.neu.edu
From: Asumu Takikawa <asumu@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 19:11:03 -0500

 On 2012-11-29 13:38:24 -0500, Matthias Felleisen wrote:
 > At the moment the creator of typed modules imposes his thinking on
 > untyped modules via require/typed. If something goes wrong with these
 > imports, we blame the untyped module yet its creator had no say -- not
 > even a chance -- to express what kind of types might express a
 > specification for one of his exports. Hence we keep warning people
 > that contract violations do not necessarily mean a contract party got
 > something wrong; it really may mean that the contract -- or the type
 > specification that generated the contact -- is wrong.
 
 Maybe this suggests that our contract system needs a notion of
 "negotiation" so that components can agree to contracts mutually.
 
 Instead of just raising contract errors, we would also throw negotiation
 errors.
 
 For example, suppose component 'A' provides a value 'a' with contract
 'ctc_a' and 'B' accepts 'a' with contract 'ctc_b'.
 
 If 'ctc_a' passes, but 'ctc_b' fails, we raise an error:
   "Negotiation failed, 'B' demanded a stricter contract"
 
 If 'ctc_b' passes, but 'ctc_a" fails, we again raise an error:
   "Negotiation failed, 'A' demanded a stricter contract"
 
 In other words, negotiations require that the contracts on both sides
 ensure behavioral subtyping in their corresponding directions.
 Currently, Racket only allows 'require' to agree to *the same* contract,
 and hence we never get negotiation failures.
 
 Maybe this could generalize to the case where modules re-provide with
 different contracts.
 
 Cheers,
 Asumu
From: Asumu Takikawa <asumu@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 19:17:50 -0500

 On 2012-11-29 19:11:03 -0500, Asumu Takikawa wrote:
 > Maybe this suggests that our contract system needs a notion of
 > "negotiation" so that components can agree to contracts mutually.
 
 (this ignores any question of the implementability of this feature,
  since this would mean flat checks can't immediately raise an error
  until the other party's contract is known)
 
 Cheers,
 Asumu
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Asumu Takikawa <asumu@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 19:20:27 -0500

 On Nov 29, 2012, at 7:17 PM, Asumu Takikawa <asumu@ccs.neu.edu> wrote:
 
 > On 2012-11-29 19:11:03 -0500, Asumu Takikawa wrote:
 >> Maybe this suggests that our contract system needs a notion of
 >> "negotiation" so that components can agree to contracts mutually.
 > 
 > (this ignores any question of the implementability of this feature,
 > since this would mean flat checks can't immediately raise an error
 > until the other party's contract is known)
 
 I'm not sure why this is.  If you break your own contract (which is what a flat check failure is), can't we still report that early, whether or not we know the other party?  It's only higher-order checks that need to know the other party and that might be affected by negotiation here.
 
 Stevie
From: Asumu Takikawa <asumu@ccs.neu.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 19:25:48 -0500

 On 2012-11-29 19:24:05 -0500, Asumu Takikawa wrote:
 > Hmm, yes. I think you're right. You would just report that your own
 > contract was too strict and negotiation failed before it even began.
 
 Sorry, didn't think this through enough before replying. The issue is
 that you want to distinguish between a "contract violation" and a
 "negotiation failure", which you don't know until you get both
 contracts.
 
 Cheers,
 Asumu
From: Asumu Takikawa <asumu@ccs.neu.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 19:24:05 -0500

 On 2012-11-29 19:20:27 -0500, Stevie Strickland wrote:
 > I'm not sure why this is.  If you break your own contract (which is
 > what a flat check failure is), can't we still report that early,
 > whether or not we know the other party?  It's only higher-order checks
 > that need to know the other party and that might be affected by
 > negotiation here.
 
 Hmm, yes. I think you're right. You would just report that your own
 contract was too strict and negotiation failed before it even began.
 
 Cheers,
 Asumu
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Asumu Takikawa <asumu@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 19:36:50 -0500

 But this _is_ a contract failure.  Are you saying you'd consider it a negotiation failure if the other person was more lenient and would have allowed the value?  Seems to be that a negotiation failure should only be "I would allow the value through at this particular level of checking, but the other person would not, so our expectations mismatched."  This, instead, is "I would never allow this value."
 
 I guess here's what I see:
 
 My contract fails a first-order test (whether or not theirs does): contract error
 Both contracts fail a first-order test: contract error
 My contract passes, their contract fails: negotiation error
 
 Stevie
 
 On Nov 29, 2012, at 7:25 PM, Asumu Takikawa <asumu@ccs.neu.edu> wrote:
 
 > On 2012-11-29 19:24:05 -0500, Asumu Takikawa wrote:
 >> Hmm, yes. I think you're right. You would just report that your own
 >> contract was too strict and negotiation failed before it even began.
 > 
 > Sorry, didn't think this through enough before replying. The issue is
 > that you want to distinguish between a "contract violation" and a
 > "negotiation failure", which you don't know until you get both
 > contracts.
 > 
 > Cheers,
 > Asumu
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 18:53:14 -0600

 FWIW, I've thought about similar things and I think negotiation can be
 captured with the projections we have; you just need to set up the
 blame parties properly. (We would add contract specs on the require
 side.)
 
 The reason I've never seriously considered implementing something like
 this in Racket with untyped/untyped is that in general I think that it
 ends up being a lot of extra writing to write down contracts over and
 over. Indeed, what I imagine people would do is just change the
 contract (or, if that's not feasible, switch to another library that
 has the right contract).
 
 But with types perhaps this becomes more interesting again.
 
 Robby
From: Christos Dimoulas <chrdimo@ccs.neu.edu>
To: Asumu Takikawa <asumu@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 20:28:32 -0500

 On 11/29/12 7:11 PM, Asumu Takikawa wrote:
 > On 2012-11-29 13:38:24 -0500, Matthias Felleisen wrote:
 >> At the moment the creator of typed modules imposes his thinking on
 >> untyped modules via require/typed. If something goes wrong with these
 >> imports, we blame the untyped module yet its creator had no say -- not
 >> even a chance -- to express what kind of types might express a
 >> specification for one of his exports. Hence we keep warning people
 >> that contract violations do not necessarily mean a contract party got
 >> something wrong; it really may mean that the contract -- or the type
 >> specification that generated the contact -- is wrong.
 > Maybe this suggests that our contract system needs a notion of
 > "negotiation" so that components can agree to contracts mutually.
 >
 > Instead of just raising contract errors, we would also throw negotiation
 > errors.
 >
 > For example, suppose component 'A' provides a value 'a' with contract
 > 'ctc_a' and 'B' accepts 'a' with contract 'ctc_b'.
 >
 > If 'ctc_a' passes, but 'ctc_b' fails, we raise an error:
 >    "Negotiation failed, 'B' demanded a stricter contract"
 >
 > If 'ctc_b' passes, but 'ctc_a" fails, we again raise an error:
 >    "Negotiation failed, 'A' demanded a stricter contract"
 
 But 'B' imported 'a' under contract ctc_a and then imposed on it ctc_b. 
 Thus 'B', by importing 'a' under ctc_a, agreed on ctc_a. If a value of 
 'B' violates ctc_a  then I don't see why 'B' shouldn't get blamed.
 
 Also, in terms of debugging, how should the programmer interpret either 
 message? In the first one, it sounds to me like A did something wrong 
 but of course this might not be the case. It does not look better than 
 "blame 'A'" except that it has a milder tone. Similarly for the second, 
 it seems to imply that there is something wrong with 'B' but does not 
 point to where the problem is directly.
 
 Here is another suggestion. Whenever the blamed party is the server 
 party of the initial contract but not the party that applied the 
 contract, then the contract error comes with a warning that says in your 
 first example "'A' broke contract ctc_b but   A never agreed on ctc_b 
 for 'a' so 'B' is asking too much from A". After that message it is 
 clear that A, the client of B, should either change the contract and 
 settle for weaker assurances or search for another server.
 >
 > In other words, negotiations require that the contracts on both sides
 > ensure behavioral subtyping in their corresponding directions.
 > Currently, Racket only allows 'require' to agree to *the same* contract,
 > and hence we never get negotiation failures.
 >
 > Maybe this could generalize to the case where modules re-provide with
 > different contracts.
 >
 > Cheers,
 > Asumu
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Christos Dimoulas <chrdimo@ccs.neu.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 19:30:51 -0600

 You can just use different blame labels in the 4 positions and say
 things like "blame A"  and "blame B" for the "outermost" labels and
 then "Negotiation error: A's version of the contract is too weak for
 B" (or vice versa) when one of the other labels shows up in an error.
 
 Robby
 
 On Thu, Nov 29, 2012 at 7:28 PM, Christos Dimoulas <chrdimo@ccs.neu.edu> wrote:
 > On 11/29/12 7:11 PM, Asumu Takikawa wrote:
 >>
 >> On 2012-11-29 13:38:24 -0500, Matthias Felleisen wrote:
 >>>
 >>> At the moment the creator of typed modules imposes his thinking on
 >>> untyped modules via require/typed. If something goes wrong with these
 >>> imports, we blame the untyped module yet its creator had no say -- not
 >>> even a chance -- to express what kind of types might express a
 >>> specification for one of his exports. Hence we keep warning people
 >>> that contract violations do not necessarily mean a contract party got
 >>> something wrong; it really may mean that the contract -- or the type
 >>> specification that generated the contact -- is wrong.
 >>
 >> Maybe this suggests that our contract system needs a notion of
 >> "negotiation" so that components can agree to contracts mutually.
 >>
 >> Instead of just raising contract errors, we would also throw negotiation
 >> errors.
 >>
 >> For example, suppose component 'A' provides a value 'a' with contract
 >> 'ctc_a' and 'B' accepts 'a' with contract 'ctc_b'.
 >>
 >> If 'ctc_a' passes, but 'ctc_b' fails, we raise an error:
 >>    "Negotiation failed, 'B' demanded a stricter contract"
 >>
 >> If 'ctc_b' passes, but 'ctc_a" fails, we again raise an error:
 >>    "Negotiation failed, 'A' demanded a stricter contract"
 >
 >
 > But 'B' imported 'a' under contract ctc_a and then imposed on it ctc_b. Thus
 > 'B', by importing 'a' under ctc_a, agreed on ctc_a. If a value of 'B'
 > violates ctc_a  then I don't see why 'B' shouldn't get blamed.
 >
 > Also, in terms of debugging, how should the programmer interpret either
 > message? In the first one, it sounds to me like A did something wrong but of
 > course this might not be the case. It does not look better than "blame 'A'"
 > except that it has a milder tone. Similarly for the second, it seems to
 > imply that there is something wrong with 'B' but does not point to where the
 > problem is directly.
 >
 > Here is another suggestion. Whenever the blamed party is the server party of
 > the initial contract but not the party that applied the contract, then the
 > contract error comes with a warning that says in your first example "'A'
 > broke contract ctc_b but   A never agreed on ctc_b for 'a' so 'B' is asking
 > too much from A". After that message it is clear that A, the client of B,
 > should either change the contract and settle for weaker assurances or search
 > for another server.
 >
 >>
 >> In other words, negotiations require that the contracts on both sides
 >> ensure behavioral subtyping in their corresponding directions.
 >> Currently, Racket only allows 'require' to agree to *the same* contract,
 >> and hence we never get negotiation failures.
 >>
 >> Maybe this could generalize to the case where modules re-provide with
 >> different contracts.
 >>
 >> Cheers,
 >> Asumu
 >
 >
From: Christos Dimoulas <chrdimo@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 20:42:53 -0500

 On Thu Nov 29 20:30:51 2012, Robby Findler wrote:
 > You can just use different blame labels in the 4 positions and say
 > things like "blame A"  and "blame B" for the "outermost" labels and
 > then "Negotiation error: A's version of the contract is too weak for
 > B" (or vice versa) when one of the other labels shows up in an error.
 
 That is not very far from what I am suggesting for the first example. I 
 think it would be better to state the secondary message in terms of the 
 contract that is too strong i.e. "A broke ctc_b : ctc_b is too strong 
 for A".
 
 For the second example, though, I don't understand why there should be 
 a negotiation error. 'A' suggested ctc_a, 'B' agreed on it and added 
 something extra. Thus if 'B' breaks ctc_a, it really breaks something 
 it agreed not to break.
 
 >
 > Robby
 >
 > On Thu, Nov 29, 2012 at 7:28 PM, Christos Dimoulas <chrdimo@ccs.neu.edu> wrote:
 >> On 11/29/12 7:11 PM, Asumu Takikawa wrote:
 >>>
 >>> On 2012-11-29 13:38:24 -0500, Matthias Felleisen wrote:
 >>>>
 >>>> At the moment the creator of typed modules imposes his thinking on
 >>>> untyped modules via require/typed. If something goes wrong with these
 >>>> imports, we blame the untyped module yet its creator had no say -- not
 >>>> even a chance -- to express what kind of types might express a
 >>>> specification for one of his exports. Hence we keep warning people
 >>>> that contract violations do not necessarily mean a contract party got
 >>>> something wrong; it really may mean that the contract -- or the type
 >>>> specification that generated the contact -- is wrong.
 >>>
 >>> Maybe this suggests that our contract system needs a notion of
 >>> "negotiation" so that components can agree to contracts mutually.
 >>>
 >>> Instead of just raising contract errors, we would also throw negotiation
 >>> errors.
 >>>
 >>> For example, suppose component 'A' provides a value 'a' with contract
 >>> 'ctc_a' and 'B' accepts 'a' with contract 'ctc_b'.
 >>>
 >>> If 'ctc_a' passes, but 'ctc_b' fails, we raise an error:
 >>>     "Negotiation failed, 'B' demanded a stricter contract"
 >>>
 >>> If 'ctc_b' passes, but 'ctc_a" fails, we again raise an error:
 >>>     "Negotiation failed, 'A' demanded a stricter contract"
 >>
 >>
 >> But 'B' imported 'a' under contract ctc_a and then imposed on it ctc_b. Thus
 >> 'B', by importing 'a' under ctc_a, agreed on ctc_a. If a value of 'B'
 >> violates ctc_a  then I don't see why 'B' shouldn't get blamed.
 >>
 >> Also, in terms of debugging, how should the programmer interpret either
 >> message? In the first one, it sounds to me like A did something wrong but of
 >> course this might not be the case. It does not look better than "blame 'A'"
 >> except that it has a milder tone. Similarly for the second, it seems to
 >> imply that there is something wrong with 'B' but does not point to where the
 >> problem is directly.
 >>
 >> Here is another suggestion. Whenever the blamed party is the server party of
 >> the initial contract but not the party that applied the contract, then the
 >> contract error comes with a warning that says in your first example "'A'
 >> broke contract ctc_b but   A never agreed on ctc_b for 'a' so 'B' is asking
 >> too much from A". After that message it is clear that A, the client of B,
 >> should either change the contract and settle for weaker assurances or search
 >> for another server.
 >>
 >>>
 >>> In other words, negotiations require that the contracts on both sides
 >>> ensure behavioral subtyping in their corresponding directions.
 >>> Currently, Racket only allows 'require' to agree to *the same* contract,
 >>> and hence we never get negotiation failures.
 >>>
 >>> Maybe this could generalize to the case where modules re-provide with
 >>> different contracts.
 >>>
 >>> Cheers,
 >>> Asumu
 >>
 >>
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Christos Dimoulas <chrdimo@ccs.neu.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 20:06:32 -0600

 Can you give a concrete example?
 
 Robby
 
 On Thu, Nov 29, 2012 at 7:42 PM, Christos Dimoulas <chrdimo@ccs.neu.edu> wrote:
 > On Thu Nov 29 20:30:51 2012, Robby Findler wrote:
 >>
 >> You can just use different blame labels in the 4 positions and say
 >> things like "blame A"  and "blame B" for the "outermost" labels and
 >> then "Negotiation error: A's version of the contract is too weak for
 >> B" (or vice versa) when one of the other labels shows up in an error.
 >
 >
 > That is not very far from what I am suggesting for the first example. I
 > think it would be better to state the secondary message in terms of the
 > contract that is too strong i.e. "A broke ctc_b : ctc_b is too strong for
 > A".
 >
 > For the second example, though, I don't understand why there should be a
 > negotiation error. 'A' suggested ctc_a, 'B' agreed on it and added something
 > extra. Thus if 'B' breaks ctc_a, it really breaks something it agreed not to
 > break.
 >
 >
 >>
 >> Robby
 >>
 >> On Thu, Nov 29, 2012 at 7:28 PM, Christos Dimoulas <chrdimo@ccs.neu.edu>
 >> wrote:
 >>>
 >>> On 11/29/12 7:11 PM, Asumu Takikawa wrote:
 >>>>
 >>>>
 >>>> On 2012-11-29 13:38:24 -0500, Matthias Felleisen wrote:
 >>>>>
 >>>>>
 >>>>> At the moment the creator of typed modules imposes his thinking on
 >>>>> untyped modules via require/typed. If something goes wrong with these
 >>>>> imports, we blame the untyped module yet its creator had no say -- not
 >>>>> even a chance -- to express what kind of types might express a
 >>>>> specification for one of his exports. Hence we keep warning people
 >>>>> that contract violations do not necessarily mean a contract party got
 >>>>> something wrong; it really may mean that the contract -- or the type
 >>>>> specification that generated the contact -- is wrong.
 >>>>
 >>>>
 >>>> Maybe this suggests that our contract system needs a notion of
 >>>> "negotiation" so that components can agree to contracts mutually.
 >>>>
 >>>> Instead of just raising contract errors, we would also throw negotiation
 >>>> errors.
 >>>>
 >>>> For example, suppose component 'A' provides a value 'a' with contract
 >>>> 'ctc_a' and 'B' accepts 'a' with contract 'ctc_b'.
 >>>>
 >>>> If 'ctc_a' passes, but 'ctc_b' fails, we raise an error:
 >>>>     "Negotiation failed, 'B' demanded a stricter contract"
 >>>>
 >>>> If 'ctc_b' passes, but 'ctc_a" fails, we again raise an error:
 >>>>     "Negotiation failed, 'A' demanded a stricter contract"
 >>>
 >>>
 >>>
 >>> But 'B' imported 'a' under contract ctc_a and then imposed on it ctc_b.
 >>> Thus
 >>> 'B', by importing 'a' under ctc_a, agreed on ctc_a. If a value of 'B'
 >>> violates ctc_a  then I don't see why 'B' shouldn't get blamed.
 >>>
 >>> Also, in terms of debugging, how should the programmer interpret either
 >>> message? In the first one, it sounds to me like A did something wrong but
 >>> of
 >>> course this might not be the case. It does not look better than "blame
 >>> 'A'"
 >>> except that it has a milder tone. Similarly for the second, it seems to
 >>> imply that there is something wrong with 'B' but does not point to where
 >>> the
 >>> problem is directly.
 >>>
 >>> Here is another suggestion. Whenever the blamed party is the server party
 >>> of
 >>> the initial contract but not the party that applied the contract, then
 >>> the
 >>> contract error comes with a warning that says in your first example "'A'
 >>> broke contract ctc_b but   A never agreed on ctc_b for 'a' so 'B' is
 >>> asking
 >>> too much from A". After that message it is clear that A, the client of B,
 >>> should either change the contract and settle for weaker assurances or
 >>> search
 >>> for another server.
 >>>
 >>>>
 >>>> In other words, negotiations require that the contracts on both sides
 >>>> ensure behavioral subtyping in their corresponding directions.
 >>>> Currently, Racket only allows 'require' to agree to *the same* contract,
 >>>> and hence we never get negotiation failures.
 >>>>
 >>>> Maybe this could generalize to the case where modules re-provide with
 >>>> different contracts.
 >>>>
 >>>> Cheers,
 >>>> Asumu
 >>>
 >>>
 >>>
 >
 >
From: Christos Dimoulas <chrdimo@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 22:07:09 -0500

 First assume that there is a mechanism to attach contracts to imports, 
 a symmetric operation to provide/contract. Let's call it 
 require/contract
 
 #lang racket/load
 
 (module server racket
 
  (provide/contract
    [foo (-> int? int?)])
 
  (define (foo x) (...)))
 
 (module client racket
 
  (require/contract 'server (-> real real))
 
  (foo 1.5))
 
 
 (require 'client)
 
 Here I claim that the client should get blamed for violating the 
 contract of foo even though he attached to foo another contract. Both 
 parties agreed on (-> int? int?) for foo.
 
 On Thu Nov 29 21:06:32 2012, Robby Findler wrote:
 > Can you give a concrete example?
 >
 > Robby
 >
 > On Thu, Nov 29, 2012 at 7:42 PM, Christos Dimoulas <chrdimo@ccs.neu.edu> wrote:
 >> On Thu Nov 29 20:30:51 2012, Robby Findler wrote:
 >>>
 >>> You can just use different blame labels in the 4 positions and say
 >>> things like "blame A"  and "blame B" for the "outermost" labels and
 >>> then "Negotiation error: A's version of the contract is too weak for
 >>> B" (or vice versa) when one of the other labels shows up in an error.
 >>
 >>
 >> That is not very far from what I am suggesting for the first example. I
 >> think it would be better to state the secondary message in terms of the
 >> contract that is too strong i.e. "A broke ctc_b : ctc_b is too strong for
 >> A".
 >>
 >> For the second example, though, I don't understand why there should be a
 >> negotiation error. 'A' suggested ctc_a, 'B' agreed on it and added something
 >> extra. Thus if 'B' breaks ctc_a, it really breaks something it agreed not to
 >> break.
 >>
 >>
 >>>
 >>> Robby
 >>>
 >>> On Thu, Nov 29, 2012 at 7:28 PM, Christos Dimoulas <chrdimo@ccs.neu.edu>
 >>> wrote:
 >>>>
 >>>> On 11/29/12 7:11 PM, Asumu Takikawa wrote:
 >>>>>
 >>>>>
 >>>>> On 2012-11-29 13:38:24 -0500, Matthias Felleisen wrote:
 >>>>>>
 >>>>>>
 >>>>>> At the moment the creator of typed modules imposes his thinking on
 >>>>>> untyped modules via require/typed. If something goes wrong with these
 >>>>>> imports, we blame the untyped module yet its creator had no say -- not
 >>>>>> even a chance -- to express what kind of types might express a
 >>>>>> specification for one of his exports. Hence we keep warning people
 >>>>>> that contract violations do not necessarily mean a contract party got
 >>>>>> something wrong; it really may mean that the contract -- or the type
 >>>>>> specification that generated the contact -- is wrong.
 >>>>>
 >>>>>
 >>>>> Maybe this suggests that our contract system needs a notion of
 >>>>> "negotiation" so that components can agree to contracts mutually.
 >>>>>
 >>>>> Instead of just raising contract errors, we would also throw negotiation
 >>>>> errors.
 >>>>>
 >>>>> For example, suppose component 'A' provides a value 'a' with contract
 >>>>> 'ctc_a' and 'B' accepts 'a' with contract 'ctc_b'.
 >>>>>
 >>>>> If 'ctc_a' passes, but 'ctc_b' fails, we raise an error:
 >>>>>      "Negotiation failed, 'B' demanded a stricter contract"
 >>>>>
 >>>>> If 'ctc_b' passes, but 'ctc_a" fails, we again raise an error:
 >>>>>      "Negotiation failed, 'A' demanded a stricter contract"
 >>>>
 >>>>
 >>>>
 >>>> But 'B' imported 'a' under contract ctc_a and then imposed on it ctc_b.
 >>>> Thus
 >>>> 'B', by importing 'a' under ctc_a, agreed on ctc_a. If a value of 'B'
 >>>> violates ctc_a  then I don't see why 'B' shouldn't get blamed.
 >>>>
 >>>> Also, in terms of debugging, how should the programmer interpret either
 >>>> message? In the first one, it sounds to me like A did something wrong but
 >>>> of
 >>>> course this might not be the case. It does not look better than "blame
 >>>> 'A'"
 >>>> except that it has a milder tone. Similarly for the second, it seems to
 >>>> imply that there is something wrong with 'B' but does not point to where
 >>>> the
 >>>> problem is directly.
 >>>>
 >>>> Here is another suggestion. Whenever the blamed party is the server party
 >>>> of
 >>>> the initial contract but not the party that applied the contract, then
 >>>> the
 >>>> contract error comes with a warning that says in your first example "'A'
 >>>> broke contract ctc_b but   A never agreed on ctc_b for 'a' so 'B' is
 >>>> asking
 >>>> too much from A". After that message it is clear that A, the client of B,
 >>>> should either change the contract and settle for weaker assurances or
 >>>> search
 >>>> for another server.
 >>>>
 >>>>>
 >>>>> In other words, negotiations require that the contracts on both sides
 >>>>> ensure behavioral subtyping in their corresponding directions.
 >>>>> Currently, Racket only allows 'require' to agree to *the same* contract,
 >>>>> and hence we never get negotiation failures.
 >>>>>
 >>>>> Maybe this could generalize to the case where modules re-provide with
 >>>>> different contracts.
 >>>>>
 >>>>> Cheers,
 >>>>> Asumu
 >>>>
 >>>>
 >>>>
 >>
 >>
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Christos Dimoulas <chrdimo@ccs.neu.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 21:59:59 -0600

 I think the intention, iiuc, is to change the meaning of
 provide/contract --- but maybe we should give it another name to help
 this discussion and to avoid backwards incompatibilities -- so that
 you don't think of client agreeing to the contract written in the
 server. Instead, they each agree with the contracts in their own
 modules only, and then you have a separate message when those
 contracts are found to be incompatible. Such a message would naturally
 have both client & server in the error and would essentially be
 telling them "go renegotiate".
 
 Is that a wrong pov?
 
 Robby
 
 On Thu, Nov 29, 2012 at 9:07 PM, Christos Dimoulas <chrdimo@ccs.neu.edu> wrote:
 > First assume that there is a mechanism to attach contracts to imports, a
 > symmetric operation to provide/contract. Let's call it require/contract
 >
 > #lang racket/load
 >
 > (module server racket
 >
 > (provide/contract
 >   [foo (-> int? int?)])
 >
 > (define (foo x) (...)))
 >
 > (module client racket
 >
 > (require/contract 'server (-> real real))
 >
 > (foo 1.5))
 >
 >
 > (require 'client)
 >
 > Here I claim that the client should get blamed for violating the contract of
 > foo even though he attached to foo another contract. Both parties agreed on
 > (-> int? int?) for foo.
 >
 >
 > On Thu Nov 29 21:06:32 2012, Robby Findler wrote:
 >>
 >> Can you give a concrete example?
 >>
 >> Robby
 >>
 >> On Thu, Nov 29, 2012 at 7:42 PM, Christos Dimoulas <chrdimo@ccs.neu.edu>
 >> wrote:
 >>>
 >>> On Thu Nov 29 20:30:51 2012, Robby Findler wrote:
 >>>>
 >>>>
 >>>> You can just use different blame labels in the 4 positions and say
 >>>> things like "blame A"  and "blame B" for the "outermost" labels and
 >>>> then "Negotiation error: A's version of the contract is too weak for
 >>>> B" (or vice versa) when one of the other labels shows up in an error.
 >>>
 >>>
 >>>
 >>> That is not very far from what I am suggesting for the first example. I
 >>> think it would be better to state the secondary message in terms of the
 >>> contract that is too strong i.e. "A broke ctc_b : ctc_b is too strong for
 >>> A".
 >>>
 >>> For the second example, though, I don't understand why there should be a
 >>> negotiation error. 'A' suggested ctc_a, 'B' agreed on it and added
 >>> something
 >>> extra. Thus if 'B' breaks ctc_a, it really breaks something it agreed not
 >>> to
 >>> break.
 >>>
 >>>
 >>>>
 >>>> Robby
 >>>>
 >>>> On Thu, Nov 29, 2012 at 7:28 PM, Christos Dimoulas <chrdimo@ccs.neu.edu>
 >>>> wrote:
 >>>>>
 >>>>>
 >>>>> On 11/29/12 7:11 PM, Asumu Takikawa wrote:
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>> On 2012-11-29 13:38:24 -0500, Matthias Felleisen wrote:
 >>>>>>>
 >>>>>>>
 >>>>>>>
 >>>>>>> At the moment the creator of typed modules imposes his thinking on
 >>>>>>> untyped modules via require/typed. If something goes wrong with these
 >>>>>>> imports, we blame the untyped module yet its creator had no say --
 >>>>>>> not
 >>>>>>> even a chance -- to express what kind of types might express a
 >>>>>>> specification for one of his exports. Hence we keep warning people
 >>>>>>> that contract violations do not necessarily mean a contract party got
 >>>>>>> something wrong; it really may mean that the contract -- or the type
 >>>>>>> specification that generated the contact -- is wrong.
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>> Maybe this suggests that our contract system needs a notion of
 >>>>>> "negotiation" so that components can agree to contracts mutually.
 >>>>>>
 >>>>>> Instead of just raising contract errors, we would also throw
 >>>>>> negotiation
 >>>>>> errors.
 >>>>>>
 >>>>>> For example, suppose component 'A' provides a value 'a' with contract
 >>>>>> 'ctc_a' and 'B' accepts 'a' with contract 'ctc_b'.
 >>>>>>
 >>>>>> If 'ctc_a' passes, but 'ctc_b' fails, we raise an error:
 >>>>>>      "Negotiation failed, 'B' demanded a stricter contract"
 >>>>>>
 >>>>>> If 'ctc_b' passes, but 'ctc_a" fails, we again raise an error:
 >>>>>>      "Negotiation failed, 'A' demanded a stricter contract"
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>> But 'B' imported 'a' under contract ctc_a and then imposed on it ctc_b.
 >>>>> Thus
 >>>>> 'B', by importing 'a' under ctc_a, agreed on ctc_a. If a value of 'B'
 >>>>> violates ctc_a  then I don't see why 'B' shouldn't get blamed.
 >>>>>
 >>>>> Also, in terms of debugging, how should the programmer interpret either
 >>>>> message? In the first one, it sounds to me like A did something wrong
 >>>>> but
 >>>>> of
 >>>>> course this might not be the case. It does not look better than "blame
 >>>>> 'A'"
 >>>>> except that it has a milder tone. Similarly for the second, it seems to
 >>>>> imply that there is something wrong with 'B' but does not point to
 >>>>> where
 >>>>> the
 >>>>> problem is directly.
 >>>>>
 >>>>> Here is another suggestion. Whenever the blamed party is the server
 >>>>> party
 >>>>> of
 >>>>> the initial contract but not the party that applied the contract, then
 >>>>> the
 >>>>> contract error comes with a warning that says in your first example
 >>>>> "'A'
 >>>>> broke contract ctc_b but   A never agreed on ctc_b for 'a' so 'B' is
 >>>>> asking
 >>>>> too much from A". After that message it is clear that A, the client of
 >>>>> B,
 >>>>> should either change the contract and settle for weaker assurances or
 >>>>> search
 >>>>> for another server.
 >>>>>
 >>>>>>
 >>>>>> In other words, negotiations require that the contracts on both sides
 >>>>>> ensure behavioral subtyping in their corresponding directions.
 >>>>>> Currently, Racket only allows 'require' to agree to *the same*
 >>>>>> contract,
 >>>>>> and hence we never get negotiation failures.
 >>>>>>
 >>>>>> Maybe this could generalize to the case where modules re-provide with
 >>>>>> different contracts.
 >>>>>>
 >>>>>> Cheers,
 >>>>>> Asumu
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>
 >>>
 >
 >
From: Asumu Takikawa <asumu@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Christos Dimoulas <chrdimo@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 23:39:25 -0500

 On 2012-11-29 21:59:59 -0600, Robby Findler wrote:
 > Instead, they each agree with the contracts in their own
 > modules only, and then you have a separate message when those
 > contracts are found to be incompatible. Such a message would naturally
 > have both client & server in the error and would essentially be
 > telling them "go renegotiate".
 
 Yes, that was what I was imagining. In particular, one contract party
 provides a value and a (proposed) contract. The other party proposes a
 counter-offer (possibly the same one).
 
 If they both agree, then the contract is complete and the contract
 system just makes sure it's not violated. If they do not agree, then
 the components could not negotiate a contract and a failure is reported.
 
 In Christos's example, when we check the argument position of the
 function contract, 'B' is the server party. 'B' proposes a 'real?'
 contract and 'A' proposes 'int?'. Since they could not come to an
 agreement (1.5 cannot satisfy both), a negotiation error is raised.
 
 i.e., negotiation generalizes naturally to higher-order contracts.
 
 I think the idea is consistent with Christos's proposed error wording
 too.
 
 Cheers,
 Asumu
From: Christos Dimoulas <chrdimo@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Thu, 29 Nov 2012 23:54:12 -0500

 On Thu Nov 29 22:59:59 2012, Robby Findler wrote:
 > I think the intention, iiuc, is to change the meaning of
 > provide/contract --- but maybe we should give it another name to help
 > this discussion and to avoid backwards incompatibilities -- so that
 > you don't think of client agreeing to the contract written in the
 > server. Instead, they each agree with the contracts in their own
 > modules only, and then you have a separate message when those
 > contracts are found to be incompatible. Such a message would naturally
 > have both client & server in the error and would essentially be
 > telling them "go renegotiate".
 
 I guess you refer here to the second part of the message. The blame 
 information stays as is, right?
 
 If not, I think the renegotiate message wouldn't be more helpful than a 
 message saying "someone broke contract x". Note that the party with the 
 ``stronger''  contract (meaning that failed) can also be the one that 
 broke its contract.
 
 >
 > Is that a wrong pov?
 
 The idea of rounds of negotiation is attractive but I am not convinced 
 that it is a realistic representation.
 Usually the client picks a server among those that advertise themselves
 via their interface. I have the impression that the choices about 
 composition happen only on the client side which has access to all the 
 contracts (this makes the agreement part of Asumu's last email, a 
 one-side decision). Negotiation implies a back and forth between the 
 two parties that does not seem to have a computational counterpart. 
 What does the new terminology add to the way we understand contracts?
 
 
 >
 > Robby
 >
 > On Thu, Nov 29, 2012 at 9:07 PM, Christos Dimoulas <chrdimo@ccs.neu.edu> wrote:
 >> First assume that there is a mechanism to attach contracts to imports, a
 >> symmetric operation to provide/contract. Let's call it require/contract
 >>
 >> #lang racket/load
 >>
 >> (module server racket
 >>
 >> (provide/contract
 >>    [foo (-> int? int?)])
 >>
 >> (define (foo x) (...)))
 >>
 >> (module client racket
 >>
 >> (require/contract 'server (-> real real))
 >>
 >> (foo 1.5))
 >>
 >>
 >> (require 'client)
 >>
 >> Here I claim that the client should get blamed for violating the contract of
 >> foo even though he attached to foo another contract. Both parties agreed on
 >> (-> int? int?) for foo.
 >>
 >>
 >> On Thu Nov 29 21:06:32 2012, Robby Findler wrote:
 >>>
 >>> Can you give a concrete example?
 >>>
 >>> Robby
 >>>
 >>> On Thu, Nov 29, 2012 at 7:42 PM, Christos Dimoulas <chrdimo@ccs.neu.edu>
 >>> wrote:
 >>>>
 >>>> On Thu Nov 29 20:30:51 2012, Robby Findler wrote:
 >>>>>
 >>>>>
 >>>>> You can just use different blame labels in the 4 positions and say
 >>>>> things like "blame A"  and "blame B" for the "outermost" labels and
 >>>>> then "Negotiation error: A's version of the contract is too weak for
 >>>>> B" (or vice versa) when one of the other labels shows up in an error.
 >>>>
 >>>>
 >>>>
 >>>> That is not very far from what I am suggesting for the first example. I
 >>>> think it would be better to state the secondary message in terms of the
 >>>> contract that is too strong i.e. "A broke ctc_b : ctc_b is too strong for
 >>>> A".
 >>>>
 >>>> For the second example, though, I don't understand why there should be a
 >>>> negotiation error. 'A' suggested ctc_a, 'B' agreed on it and added
 >>>> something
 >>>> extra. Thus if 'B' breaks ctc_a, it really breaks something it agreed not
 >>>> to
 >>>> break.
 >>>>
 >>>>
 >>>>>
 >>>>> Robby
 >>>>>
 >>>>> On Thu, Nov 29, 2012 at 7:28 PM, Christos Dimoulas <chrdimo@ccs.neu.edu>
 >>>>> wrote:
 >>>>>>
 >>>>>>
 >>>>>> On 11/29/12 7:11 PM, Asumu Takikawa wrote:
 >>>>>>>
 >>>>>>>
 >>>>>>>
 >>>>>>> On 2012-11-29 13:38:24 -0500, Matthias Felleisen wrote:
 >>>>>>>>
 >>>>>>>>
 >>>>>>>>
 >>>>>>>> At the moment the creator of typed modules imposes his thinking on
 >>>>>>>> untyped modules via require/typed. If something goes wrong with these
 >>>>>>>> imports, we blame the untyped module yet its creator had no say --
 >>>>>>>> not
 >>>>>>>> even a chance -- to express what kind of types might express a
 >>>>>>>> specification for one of his exports. Hence we keep warning people
 >>>>>>>> that contract violations do not necessarily mean a contract party got
 >>>>>>>> something wrong; it really may mean that the contract -- or the type
 >>>>>>>> specification that generated the contact -- is wrong.
 >>>>>>>
 >>>>>>>
 >>>>>>>
 >>>>>>> Maybe this suggests that our contract system needs a notion of
 >>>>>>> "negotiation" so that components can agree to contracts mutually.
 >>>>>>>
 >>>>>>> Instead of just raising contract errors, we would also throw
 >>>>>>> negotiation
 >>>>>>> errors.
 >>>>>>>
 >>>>>>> For example, suppose component 'A' provides a value 'a' with contract
 >>>>>>> 'ctc_a' and 'B' accepts 'a' with contract 'ctc_b'.
 >>>>>>>
 >>>>>>> If 'ctc_a' passes, but 'ctc_b' fails, we raise an error:
 >>>>>>>       "Negotiation failed, 'B' demanded a stricter contract"
 >>>>>>>
 >>>>>>> If 'ctc_b' passes, but 'ctc_a" fails, we again raise an error:
 >>>>>>>       "Negotiation failed, 'A' demanded a stricter contract"
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>> But 'B' imported 'a' under contract ctc_a and then imposed on it ctc_b.
 >>>>>> Thus
 >>>>>> 'B', by importing 'a' under ctc_a, agreed on ctc_a. If a value of 'B'
 >>>>>> violates ctc_a  then I don't see why 'B' shouldn't get blamed.
 >>>>>>
 >>>>>> Also, in terms of debugging, how should the programmer interpret either
 >>>>>> message? In the first one, it sounds to me like A did something wrong
 >>>>>> but
 >>>>>> of
 >>>>>> course this might not be the case. It does not look better than "blame
 >>>>>> 'A'"
 >>>>>> except that it has a milder tone. Similarly for the second, it seems to
 >>>>>> imply that there is something wrong with 'B' but does not point to
 >>>>>> where
 >>>>>> the
 >>>>>> problem is directly.
 >>>>>>
 >>>>>> Here is another suggestion. Whenever the blamed party is the server
 >>>>>> party
 >>>>>> of
 >>>>>> the initial contract but not the party that applied the contract, then
 >>>>>> the
 >>>>>> contract error comes with a warning that says in your first example
 >>>>>> "'A'
 >>>>>> broke contract ctc_b but   A never agreed on ctc_b for 'a' so 'B' is
 >>>>>> asking
 >>>>>> too much from A". After that message it is clear that A, the client of
 >>>>>> B,
 >>>>>> should either change the contract and settle for weaker assurances or
 >>>>>> search
 >>>>>> for another server.
 >>>>>>
 >>>>>>>
 >>>>>>> In other words, negotiations require that the contracts on both sides
 >>>>>>> ensure behavioral subtyping in their corresponding directions.
 >>>>>>> Currently, Racket only allows 'require' to agree to *the same*
 >>>>>>> contract,
 >>>>>>> and hence we never get negotiation failures.
 >>>>>>>
 >>>>>>> Maybe this could generalize to the case where modules re-provide with
 >>>>>>> different contracts.
 >>>>>>>
 >>>>>>> Cheers,
 >>>>>>> Asumu
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>
 >>>>
 >>
 >>
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Christos Dimoulas <chrdimo@ccs.neu.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Fri, 30 Nov 2012 06:51:41 -0600

 On Thu, Nov 29, 2012 at 10:54 PM, Christos Dimoulas <chrdimo@ccs.neu.edu> wrote:
 >
 >
 > On Thu Nov 29 22:59:59 2012, Robby Findler wrote:
 >>
 >> I think the intention, iiuc, is to change the meaning of
 >> provide/contract --- but maybe we should give it another name to help
 >> this discussion and to avoid backwards incompatibilities -- so that
 >> you don't think of client agreeing to the contract written in the
 >> server. Instead, they each agree with the contracts in their own
 >> modules only, and then you have a separate message when those
 >> contracts are found to be incompatible. Such a message would naturally
 >> have both client & server in the error and would essentially be
 >> telling them "go renegotiate".
 >
 >
 > I guess you refer here to the second part of the message. The blame
 > information stays as is, right?
 
 The blame information for the negotiation enabled version of
 provide/contract is not the same as the other. In the negotiation one,
 you have the same positive party as you currently have in
 provide/contract, but a new negative party. On the require side, you
 have the same negative party as you'd get in the provide/contract
 world, but a new positive one. And you have to compose the contracts
 in the right order so that when a violation would trigger two
 different blames, you get the correct one.
 
 > If not, I think the renegotiate message wouldn't be more helpful than a
 > message saying "someone broke contract x". Note that the party with the
 > ``stronger''  contract (meaning that failed) can also be the one that broke
 > its contract.
 
 I presume that most uses of this would be in situations where the two
 parties were reasonably confident that either the contracts were
 actually the same, or that the differences corresponded to things that
 didn't happen at runtime. Then they'd learn when they were wrong.
 
 Just like the current situation, where we're mostly sure the contracts
 are not wrong. :)
 
 >
 >>
 >> Is that a wrong pov?
 >
 >
 > The idea of rounds of negotiation is attractive but I am not convinced that
 > it is a realistic representation.
 > Usually the client picks a server among those that advertise themselves
 > via their interface. I have the impression that the choices about
 > composition happen only on the client side which has access to all the
 > contracts (this makes the agreement part of Asumu's last email, a one-side
 > decision). Negotiation implies a back and forth between the two parties that
 > does not seem to have a computational counterpart.
 
 I was thinking of it as a "propose, counter propose, done"
 negotiation. "re"negotiation would be editing the contracts -- but
 could happen on each side independently.
 
 > What does the new
 > terminology add to the way we understand contracts?
 
 It adds a new way to use them, and exploring that could lead to other
 things, I don't know. Initially, however, I'd say that one could make
 something to experiment with that expands into 'contract' as we have
 it already.
 
 Robby
From: Christos Dimoulas <chrdimo@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Fri, 30 Nov 2012 08:35:35 -0500

 On Fri Nov 30 07:51:41 2012, Robby Findler wrote:
 > On Thu, Nov 29, 2012 at 10:54 PM, Christos Dimoulas <chrdimo@ccs.neu.edu> wrote:
 >>
 >>
 >> On Thu Nov 29 22:59:59 2012, Robby Findler wrote:
 >>>
 >>> I think the intention, iiuc, is to change the meaning of
 >>> provide/contract --- but maybe we should give it another name to help
 >>> this discussion and to avoid backwards incompatibilities -- so that
 >>> you don't think of client agreeing to the contract written in the
 >>> server. Instead, they each agree with the contracts in their own
 >>> modules only, and then you have a separate message when those
 >>> contracts are found to be incompatible. Such a message would naturally
 >>> have both client & server in the error and would essentially be
 >>> telling them "go renegotiate".
 >>
 >>
 >> I guess you refer here to the second part of the message. The blame
 >> information stays as is, right?
 >
 > The blame information for the negotiation enabled version of
 > provide/contract is not the same as the other. In the negotiation one,
 > you have the same positive party as you currently have in
 > provide/contract, but a new negative party. On the require side, you
 > have the same negative party as you'd get in the provide/contract
 > world, but a new positive one. And you have to compose the contracts
 > in the right order so that when a violation would trigger two
 > different blames, you get the correct one.
 >
 
 I see what you mean now. I initially considered that in Assumu's 
 example ctc_a and ctc_b get composed and give a ctc_a_b contract 
 between A and B. I think your last message implies that this is not the 
 case and proposes another semantics:
 1) each module has an inner and outer surface (think of a module as a 
 cell with a very thick membrane), the outer surface is a proxy for the 
 inner whithin which all the real stuff reside, component composition 
 occurs on the outter surfaces that get connected, the client's outer 
 surface absorbs the server's outer surface,
 2) ctc_a defines a boundary between A's inner surface and A's outer 
 surface,
 3) ctc_b defines a boundary between B's inner surface and B's outer 
 surface,
 4)  when we put the two modules together, their outter surface's 
 collapse to the same blame label that indicates the gluing party, in 
 our case B's outter surface because B is the client,
 5) a failure that blames the outer surface comes with the explanatory 
 failed negotiation message
 6) when one of the modules does not put a contract on its side we 
 assume a never failing contract
 
 This makes a lot of sense! (... and it is also natural for our theory 
 model where we can simply stack the two contracts with distinct 
 monitors ... and it seems easy to implement too).
 
 Thanks!
 
 
 >> If not, I think the renegotiate message wouldn't be more helpful than a
 >> message saying "someone broke contract x". Note that the party with the
 >> ``stronger''  contract (meaning that failed) can also be the one that broke
 >> its contract.
 >
 > I presume that most uses of this would be in situations where the two
 > parties were reasonably confident that either the contracts were
 > actually the same, or that the differences corresponded to things that
 > didn't happen at runtime. Then they'd learn when they were wrong.
 >
 > Just like the current situation, where we're mostly sure the contracts
 > are not wrong. :)
 >
 >>
 >>>
 >>> Is that a wrong pov?
 >>
 >>
 >> The idea of rounds of negotiation is attractive but I am not convinced that
 >> it is a realistic representation.
 >> Usually the client picks a server among those that advertise themselves
 >> via their interface. I have the impression that the choices about
 >> composition happen only on the client side which has access to all the
 >> contracts (this makes the agreement part of Asumu's last email, a one-side
 >> decision). Negotiation implies a back and forth between the two parties that
 >> does not seem to have a computational counterpart.
 >
 > I was thinking of it as a "propose, counter propose, done"
 > negotiation. "re"negotiation would be editing the contracts -- but
 > could happen on each side independently.
 >
 >> What does the new
 >> terminology add to the way we understand contracts?
 >
 > It adds a new way to use them, and exploring that could lead to other
 > things, I don't know. Initially, however, I'd say that one could make
 > something to experiment with that expands into 'contract' as we have
 > it already.
 >
 > Robby
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Christos Dimoulas <chrdimo@ccs.neu.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Fri, 30 Nov 2012 10:01:02 -0600

 --e89a8fb1ff16a3253404cfb881b2
 Content-Type: text/plain; charset=UTF-8
 
 Yes! (almost) exactly!
 
 I think we'd not need to collapse those two membranes, as it may be
 interesting for the programmer to learn which contract turned out to be the
 stronger one. I'm not sure about this, tho.
 
 But yes! Exactly! :)
 
 ------------
 
 So, now that we're on the same page, I want to re-raise the issue of
 contract duplication. I fear that much of the time the two contracts (in
 the negotiation) will end up just being the same. So if we want to have
 this kind of a framework, then we need some way to make that common case
 not painful.
 
 So, lets put on our language designer hats and revisit Matthias's idea of a
 "contract module" where instead of writing
 
   (provide (contract-out [f ...] [g ...] [h ...]))
 
 you instead make a new module that has ONLY the contracts (even better: it
 comes with scribble'd docs and a test suite (the test suite serving as a
 rudimentary form of specification)). Lets say that module is named "C".
 Then, you can say "my module A provides the interface specified in module
 C" instead of writing out all of the contracts directly in "my module".
 Then, someone else (a client) can say "my module wants something that
 implements interface C-prime" where C-prime is yet another module that can
 be implemented as a simple delta to C.
 
 .... and I feel like this email is one where we're going to go off the
 rails -- I feel like I cannot effectively communicate my imagination of
 this in this setting. But maybe ..... lets try at least one round of
 emails...?
 
 Robby
 
 On Friday, November 30, 2012, Christos Dimoulas wrote:
 
 > On Fri Nov 30 07:51:41 2012, Robby Findler wrote:
 >
 >> On Thu, Nov 29, 2012 at 10:54 PM, Christos Dimoulas <chrdimo@ccs.neu.edu>
 >> wrote:
 >>
 >>>
 >>>
 >>> On Thu Nov 29 22:59:59 2012, Robby Findler wrote:
 >>>
 >>>>
 >>>> I think the intention, iiuc, is to change the meaning of
 >>>> provide/contract --- but maybe we should give it another name to help
 >>>> this discussion and to avoid backwards incompatibilities -- so that
 >>>> you don't think of client agreeing to the contract written in the
 >>>> server. Instead, they each agree with the contracts in their own
 >>>> modules only, and then you have a separate message when those
 >>>> contracts are found to be incompatible. Such a message would naturally
 >>>> have both client & server in the error and would essentially be
 >>>> telling them "go renegotiate".
 >>>>
 >>>
 >>>
 >>> I guess you refer here to the second part of the message. The blame
 >>> information stays as is, right?
 >>>
 >>
 >> The blame information for the negotiation enabled version of
 >> provide/contract is not the same as the other. In the negotiation one,
 >> you have the same positive party as you currently have in
 >> provide/contract, but a new negative party. On the require side, you
 >> have the same negative party as you'd get in the provide/contract
 >> world, but a new positive one. And you have to compose the contracts
 >> in the right order so that when a violation would trigger two
 >> different blames, you get the correct one.
 >>
 >>
 > I see what you mean now. I initially considered that in Assumu's example
 > ctc_a and ctc_b get composed and give a ctc_a_b contract between A and B. I
 > think your last message implies that this is not the case and proposes
 > another semantics:
 > 1) each module has an inner and outer surface (think of a module as a cell
 > with a very thick membrane), the outer surface is a proxy for the inner
 > whithin which all the real stuff reside, component composition occurs on
 > the outter surfaces that get connected, the client's outer surface absorbs
 > the server's outer surface,
 > 2) ctc_a defines a boundary between A's inner surface and A's outer
 > surface,
 > 3) ctc_b defines a boundary between B's inner surface and B's outer
 > surface,
 > 4)  when we put the two modules together, their outter surface's collapse
 > to the same blame label that indicates the gluing party, in our case B's
 > outter surface because B is the client,
 > 5) a failure that blames the outer surface comes with the explanatory
 > failed negotiation message
 > 6) when one of the modules does not put a contract on its side we assume a
 > never failing contract
 >
 > This makes a lot of sense! (... and it is also natural for our theory
 > model where we can simply stack the two contracts with distinct monitors
 > ... and it seems easy to implement too).
 >
 > Thanks!
 >
 >
 >  If not, I think the renegotiate message wouldn't be more helpful than a
 >>> message saying "someone broke contract x". Note that the party with the
 >>> ``stronger''  contract (meaning that failed) can also be the one that
 >>> broke
 >>> its contract.
 >>>
 >>
 >> I presume that most uses of this would be in situations where the two
 >> parties were reasonably confident that either the contracts were
 >> actually the same, or that the differences corresponded to things that
 >> didn't happen at runtime. Then they'd learn when they were wrong.
 >>
 >> Just like the current situation, where we're mostly sure the contracts
 >> are not wrong. :)
 >>
 >>
 >>>
 >>>> Is that a wrong pov?
 >>>>
 >>>
 >>>
 >>> The idea of rounds of negotiation is attractive but I am not convinced
 >>> that
 >>> it is a realistic representation.
 >>> Usually the client picks a server among those that advertise themselves
 >>> via their interface. I have the impression that the choices about
 >>> composition happen only on the client side which has access to all the
 >>> contracts (this makes the agreement part of Asumu's last email, a
 >>> one-side
 >>> decision). Negotiation implies a back and forth between the two parties
 >>> that
 >>> does not seem to have a computational counterpart.
 >>>
 >>
 >> I was thinking of it as a "propose, counter propose, done"
 >> negotiation. "re"negotiation would be editing the contracts -- but
 >> could happen on each side independently.
 >>
 >>  What does the new
 >>> terminology add to the way we understand contracts?
 >>>
 >>
 >> It adds a new way to use them, and exploring that could lead to other
 >> things, I don't know. Initially, however, I'd say that one could make
 >> something to experiment with that expands into 'contract' as we have
 >> it already.
 >>
 >> Robby
 >>
 >
 >
 >
 
 --e89a8fb1ff16a3253404cfb881b2
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 Yes! (almost) exactly!<div><br></div><div>I think we&#39;d not need to coll=
 apse those two membranes, as it may be interesting for the programmer to le=
 arn which contract turned out to be the stronger one. I&#39;m not sure abou=
 t this, tho.</div>
 <div><br></div><div>But yes! Exactly! :)</div><div><br></div><div>---------=
 ---</div><div><br></div><div>So, now that we&#39;re on the same page, I wan=
 t to re-raise the issue of contract duplication. I fear that much of the ti=
 me the two contracts (in the negotiation) will end up just being the same. =
 So if we want to have this kind of a framework, then we need some way to ma=
 ke that common case not painful.=C2=A0</div>
 <div><br></div><div>So, lets put on our language designer hats and=C2=A0rev=
 isit Matthias&#39;s idea of a &quot;contract module&quot; where instead of =
 writing=C2=A0</div><div><br></div><div>=C2=A0 (provide (contract-out [f ...=
 ] [g ...] [h ...]))</div>
 <div><br></div><div>you instead make a new module that has ONLY the contrac=
 ts (even better: it comes with scribble&#39;d docs and a test suite (the te=
 st suite serving as a rudimentary form of specification)). Lets say that mo=
 dule is named &quot;C&quot;. Then, you can say &quot;my module A provides t=
 he interface specified in module C&quot; instead of writing out all of the =
 contracts directly in &quot;my module&quot;. Then, someone else (a client) =
 can say &quot;my module wants something that implements interface C-prime&q=
 uot; where C-prime is yet another module that can be implemented as a simpl=
 e delta to C.</div>
 <div><br></div><div>.... and I feel like this email is one where we&#39;re =
 going to go off the rails -- I feel like I cannot effectively communicate m=
 y imagination of this in this setting. But maybe ..... lets try at least on=
 e round of emails...?</div>
 <div><br></div><div>Robby<br><br>On Friday, November 30, 2012, Christos Dim=
 oulas  wrote:<br><blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8=
 ex;border-left:1px #ccc solid;padding-left:1ex">On Fri Nov 30 07:51:41 2012=
 , Robby Findler wrote:<br>
 
 <blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
 x #ccc solid;padding-left:1ex">
 On Thu, Nov 29, 2012 at 10:54 PM, Christos Dimoulas &lt;<a>chrdimo@ccs.neu.=
 edu</a>&gt; wrote:<br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
 x #ccc solid;padding-left:1ex">
 <br>
 <br>
 On Thu Nov 29 22:59:59 2012, Robby Findler wrote:<br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
 x #ccc solid;padding-left:1ex">
 <br>
 I think the intention, iiuc, is to change the meaning of<br>
 provide/contract --- but maybe we should give it another name to help<br>
 this discussion and to avoid backwards incompatibilities -- so that<br>
 you don&#39;t think of client agreeing to the contract written in the<br>
 server. Instead, they each agree with the contracts in their own<br>
 modules only, and then you have a separate message when those<br>
 contracts are found to be incompatible. Such a message would naturally<br>
 have both client &amp; server in the error and would essentially be<br>
 telling them &quot;go renegotiate&quot;.<br>
 </blockquote>
 <br>
 <br>
 I guess you refer here to the second part of the message. The blame<br>
 information stays as is, right?<br>
 </blockquote>
 <br>
 The blame information for the negotiation enabled version of<br>
 provide/contract is not the same as the other. In the negotiation one,<br>
 you have the same positive party as you currently have in<br>
 provide/contract, but a new negative party. On the require side, you<br>
 have the same negative party as you&#39;d get in the provide/contract<br>
 world, but a new positive one. And you have to compose the contracts<br>
 in the right order so that when a violation would trigger two<br>
 different blames, you get the correct one.<br>
 <br>
 </blockquote>
 <br>
 I see what you mean now. I initially considered that in Assumu&#39;s exampl=
 e ctc_a and ctc_b get composed and give a ctc_a_b contract between A and B.=
  I think your last message implies that this is not the case and proposes a=
 nother semantics:<br>
 
 1) each module has an inner and outer surface (think of a module as a cell =
 with a very thick membrane), the outer surface is a proxy for the inner whi=
 thin which all the real stuff reside, component composition occurs on the o=
 utter surfaces that get connected, the client&#39;s outer surface absorbs t=
 he server&#39;s outer surface,<br>
 
 2) ctc_a defines a boundary between A&#39;s inner surface and A&#39;s outer=
  surface,<br>
 3) ctc_b defines a boundary between B&#39;s inner surface and B&#39;s outer=
  surface,<br>
 4) =C2=A0when we put the two modules together, their outter surface&#39;s c=
 ollapse to the same blame label that indicates the gluing party, in our cas=
 e B&#39;s outter surface because B is the client,<br>
 5) a failure that blames the outer surface comes with the explanatory faile=
 d negotiation message<br>
 6) when one of the modules does not put a contract on its side we assume a =
 never failing contract<br>
 <br>
 This makes a lot of sense! (... and it is also natural for our theory model=
  where we can simply stack the two contracts with distinct monitors ... and=
  it seems easy to implement too).<br>
 <br>
 Thanks!<br>
 <br>
 <br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
 x #ccc solid;padding-left:1ex"><blockquote class=3D"gmail_quote" style=3D"m=
 argin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">
 If not, I think the renegotiate message wouldn&#39;t be more helpful than a=
 <br>
 message saying &quot;someone broke contract x&quot;. Note that the party wi=
 th the<br>
 ``stronger&#39;&#39; =C2=A0contract (meaning that failed) can also be the o=
 ne that broke<br>
 its contract.<br>
 </blockquote>
 <br>
 I presume that most uses of this would be in situations where the two<br>
 parties were reasonably confident that either the contracts were<br>
 actually the same, or that the differences corresponded to things that<br>
 didn&#39;t happen at runtime. Then they&#39;d learn when they were wrong.<b=
 r>
 <br>
 Just like the current situation, where we&#39;re mostly sure the contracts<=
 br>
 are not wrong. :)<br>
 <br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
 x #ccc solid;padding-left:1ex">
 <br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
 x #ccc solid;padding-left:1ex">
 <br>
 Is that a wrong pov?<br>
 </blockquote>
 <br>
 <br>
 The idea of rounds of negotiation is attractive but I am not convinced that=
 <br>
 it is a realistic representation.<br>
 Usually the client picks a server among those that advertise themselves<br>
 via their interface. I have the impression that the choices about<br>
 composition happen only on the client side which has access to all the<br>
 contracts (this makes the agreement part of Asumu&#39;s last email, a one-s=
 ide<br>
 decision). Negotiation implies a back and forth between the two parties tha=
 t<br>
 does not seem to have a computational counterpart.<br>
 </blockquote>
 <br>
 I was thinking of it as a &quot;propose, counter propose, done&quot;<br>
 negotiation. &quot;re&quot;negotiation would be editing the contracts -- bu=
 t<br>
 could happen on each side independently.<br>
 <br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
 x #ccc solid;padding-left:1ex">
 What does the new<br>
 terminology add to the way we understand contracts?<br>
 </blockquote>
 <br>
 It adds a new way to use them, and exploring that could lead to other<br>
 things, I don&#39;t know. Initially, however, I&#39;d say that one could ma=
 ke<br>
 something to experiment with that expands into &#39;contract&#39; as we hav=
 e<br>
 it already.<br>
 <br>
 Robby<br>
 </blockquote>
 <br>
 <br>
 </blockquote></div>
 
 --e89a8fb1ff16a3253404cfb881b2--
From: Christos Dimoulas <chrdimo@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Fri, 30 Nov 2012 12:43:33 -0500

 On Fri Nov 30 11:01:02 2012, Robby Findler wrote:
 > Yes! (almost) exactly!
 >
 > I think we'd not need to collapse those two membranes, as it may be
 > interesting for the programmer to learn which contract turned out to
 > be the stronger one. I'm not sure about this, tho.
 >
 
  I think that collapsing the two outer labels to the label of the 
 client:
 
 a) still allows to detect whose contract is stronger; the contract of 
 the party that is the negative label on the flat contract that failed 
 (but I do think that in each contract you need to keep track of both 
 modules for the negotiation message to make sense, these are not blame 
 labels but additional debugging info),
 b) it gives an additional bit of information; it tells you who is 
 responsible for the composition, like a third party that brought the 
 two together, has access to both contracts and because of that has 
 obligations (think of it as the negotiator).
 
 
 > But yes! Exactly! :)
 >
 > ------------
 >
 > So, now that we're on the same page, I want to re-raise the issue of
 > contract duplication. I fear that much of the time the two contracts
 > (in the negotiation) will end up just being the same. So if we want to
 > have this kind of a framework, then we need some way to make that
 > common case not painful.
 >
 > So, lets put on our language designer hats and revisit Matthias's idea
 > of a "contract module" where instead of writing
 >
 >   (provide (contract-out [f ...] [g ...] [h ...]))
 >
 > you instead make a new module that has ONLY the contracts (even
 > better: it comes with scribble'd docs and a test suite (the test suite
 > serving as a rudimentary form of specification)). Lets say that module
 > is named "C". Then, you can say "my module A provides the interface
 > specified in module C" instead of writing out all of the contracts
 > directly in "my module". Then, someone else (a client) can say "my
 > module wants something that implements interface C-prime" where
 > C-prime is yet another module that can be implemented as a simple
 > delta to C.
 >
 
 This is a great idea! Separate interface files for each module that can 
 be published independently of the implementation.
 
 Two things though:
 
 1) How about functions that contracts depend on? If they are not 
 defined in the same file as the contract the contract may be hard to 
 understand.
 
 2) Since contracts are first-class values, contract reuse is currently 
 possible. I believe your proposal aims to something more; to  make  
 writing interfaces a central part of programming in Racket, right?
 
 
 > .... and I feel like this email is one where we're going to go off the
 > rails -- I feel like I cannot effectively communicate my imagination
 > of this in this setting. But maybe ..... lets try at least one round
 > of emails...?
 >
 > Robby
 >
 > On Friday, November 30, 2012, Christos Dimoulas wrote:
 >
 >     On Fri Nov 30 07:51:41 2012, Robby Findler wrote:
 >
 >         On Thu, Nov 29, 2012 at 10:54 PM, Christos Dimoulas
 >         <chrdimo@ccs.neu.edu> wrote:
 >
 >
 >
 >             On Thu Nov 29 22:59:59 2012, Robby Findler wrote:
 >
 >
 >                 I think the intention, iiuc, is to change the meaning of
 >                 provide/contract --- but maybe we should give it
 >                 another name to help
 >                 this discussion and to avoid backwards
 >                 incompatibilities -- so that
 >                 you don't think of client agreeing to the contract
 >                 written in the
 >                 server. Instead, they each agree with the contracts in
 >                 their own
 >                 modules only, and then you have a separate message
 >                 when those
 >                 contracts are found to be incompatible. Such a message
 >                 would naturally
 >                 have both client & server in the error and would
 >                 essentially be
 >                 telling them "go renegotiate".
 >
 >
 >
 >             I guess you refer here to the second part of the message.
 >             The blame
 >             information stays as is, right?
 >
 >
 >         The blame information for the negotiation enabled version of
 >         provide/contract is not the same as the other. In the
 >         negotiation one,
 >         you have the same positive party as you currently have in
 >         provide/contract, but a new negative party. On the require
 >         side, you
 >         have the same negative party as you'd get in the provide/contract
 >         world, but a new positive one. And you have to compose the
 >         contracts
 >         in the right order so that when a violation would trigger two
 >         different blames, you get the correct one.
 >
 >
 >     I see what you mean now. I initially considered that in Assumu's
 >     example ctc_a and ctc_b get composed and give a ctc_a_b contract
 >     between A and B. I think your last message implies that this is
 >     not the case and proposes another semantics:
 >     1) each module has an inner and outer surface (think of a module
 >     as a cell with a very thick membrane), the outer surface is a
 >     proxy for the inner whithin which all the real stuff reside,
 >     component composition occurs on the outter surfaces that get
 >     connected, the client's outer surface absorbs the server's outer
 >     surface,
 >     2) ctc_a defines a boundary between A's inner surface and A's
 >     outer surface,
 >     3) ctc_b defines a boundary between B's inner surface and B's
 >     outer surface,
 >     4)  when we put the two modules together, their outter surface's
 >     collapse to the same blame label that indicates the gluing party,
 >     in our case B's outter surface because B is the client,
 >     5) a failure that blames the outer surface comes with the
 >     explanatory failed negotiation message
 >     6) when one of the modules does not put a contract on its side we
 >     assume a never failing contract
 >
 >     This makes a lot of sense! (... and it is also natural for our
 >     theory model where we can simply stack the two contracts with
 >     distinct monitors ... and it seems easy to implement too).
 >
 >     Thanks!
 >
 >
 >             If not, I think the renegotiate message wouldn't be more
 >             helpful than a
 >             message saying "someone broke contract x". Note that the
 >             party with the
 >             ``stronger''  contract (meaning that failed) can also be
 >             the one that broke
 >             its contract.
 >
 >
 >         I presume that most uses of this would be in situations where
 >         the two
 >         parties were reasonably confident that either the contracts were
 >         actually the same, or that the differences corresponded to
 >         things that
 >         didn't happen at runtime. Then they'd learn when they were wrong.
 >
 >         Just like the current situation, where we're mostly sure the
 >         contracts
 >         are not wrong. :)
 >
 >
 >
 >                 Is that a wrong pov?
 >
 >
 >
 >             The idea of rounds of negotiation is attractive but I am
 >             not convinced that
 >             it is a realistic representation.
 >             Usually the client picks a server among those that
 >             advertise themselves
 >             via their interface. I have the impression that the
 >             choices about
 >             composition happen only on the client side which has
 >             access to all the
 >             contracts (this makes the agreement part of Asumu's last
 >             email, a one-side
 >             decision). Negotiation implies a back and forth between
 >             the two parties that
 >             does not seem to have a computational counterpart.
 >
 >
 >         I was thinking of it as a "propose, counter propose, done"
 >         negotiation. "re"negotiation would be editing the contracts -- but
 >         could happen on each side independently.
 >
 >             What does the new
 >             terminology add to the way we understand contracts?
 >
 >
 >         It adds a new way to use them, and exploring that could lead
 >         to other
 >         things, I don't know. Initially, however, I'd say that one
 >         could make
 >         something to experiment with that expands into 'contract' as
 >         we have
 >         it already.
 >
 >         Robby
 >
 >
 >
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Christos Dimoulas <chrdimo@ccs.neu.edu>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Fri, 30 Nov 2012 12:15:03 -0600

 On Fri, Nov 30, 2012 at 11:43 AM, Christos Dimoulas <chrdimo@ccs.neu.edu> wrote:
 > On Fri Nov 30 11:01:02 2012, Robby Findler wrote:
 >>
 >> Yes! (almost) exactly!
 >>
 >> I think we'd not need to collapse those two membranes, as it may be
 >> interesting for the programmer to learn which contract turned out to
 >> be the stronger one. I'm not sure about this, tho.
 >>
 >
 > I think that collapsing the two outer labels to the label of the client:
 >
 > a) still allows to detect whose contract is stronger; the contract of the
 > party that is the negative label on the flat contract that failed (but I do
 > think that in each contract you need to keep track of both modules for the
 > negotiation message to make sense, these are not blame labels but additional
 > debugging info),
 > b) it gives an additional bit of information; it tells you who is
 > responsible for the composition, like a third party that brought the two
 > together, has access to both contracts and because of that has obligations
 > (think of it as the negotiator).
 
 I think you can collapse them and it is okay. I would have tried not
 collapsing first just to see if that extra distinction ends up feeling
 useful on some examples. I don't think you can recover that
 information if you collapse things, tho, but I will easily grant that
 it might turn out to be unhelpful.
 
 But I hope we can agree that collapsing the two "inner" things loses
 information, it doesn't gain it. You go from 4 distinct labels to 3.
 
 >
 >> But yes! Exactly! :)
 >>
 >> ------------
 >>
 >> So, now that we're on the same page, I want to re-raise the issue of
 >> contract duplication. I fear that much of the time the two contracts
 >> (in the negotiation) will end up just being the same. So if we want to
 >> have this kind of a framework, then we need some way to make that
 >> common case not painful.
 >>
 >> So, lets put on our language designer hats and revisit Matthias's idea
 >> of a "contract module" where instead of writing
 >>
 >>   (provide (contract-out [f ...] [g ...] [h ...]))
 >>
 >> you instead make a new module that has ONLY the contracts (even
 >> better: it comes with scribble'd docs and a test suite (the test suite
 >> serving as a rudimentary form of specification)). Lets say that module
 >> is named "C". Then, you can say "my module A provides the interface
 >> specified in module C" instead of writing out all of the contracts
 >> directly in "my module". Then, someone else (a client) can say "my
 >> module wants something that implements interface C-prime" where
 >> C-prime is yet another module that can be implemented as a simple
 >> delta to C.
 >>
 >
 > This is a great idea! Separate interface files for each module that can be
 > published independently of the implementation.
 >
 > Two things though:
 >
 > 1) How about functions that contracts depend on? If they are not defined in
 > the same file as the contract the contract may be hard to understand.
 
 They would have to be in there. I have in mind that these modules are
 really just regular modules-- they just can export a "bundle" that one
 can later stick onto another module to say "this module exports what
 that one over there says to export".
 
 > 2) Since contracts are first-class values, contract reuse is currently
 > possible. I believe your proposal aims to something more; to  make  writing
 > interfaces a central part of programming in Racket, right?
 
 Yes! (And let me say again that Matthias has been pushing for this for
 some time. I've agreed, but I haven't really seen the pieces come
 together like I'm starting to see them come together now, so I didn't
 actually _do_ anything.)
 
 But we would also, I imagine, get more contract re-use than we're
 currently getting ....
 
 Robby
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Christos Dimoulas <chrdimo@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>,
        claire alvis <claire.alvis@gmail.com>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Sat, 1 Dec 2012 14:21:56 -0500

 Sorry guys for not following this thread in real time. I have finally had enough time to read and absorb. 
 
 Some thoughts: 
 
 1. Christos's remark that 
 
 > [w]henever the blamed party is the server party of the initial contract but not the party that applied the contract, then the contract error comes with a warning that says in your first example "'A' broke contract ctc_b but   A never agreed on ctc_b for 'a' so 'B' is asking too much from A". After that message it is clear that A, the client of B, should either change the contract and settle for weaker assurances or search for another server.
 
 comes really close to what I had in mind when I first replied. In the original case, the Untyped module is unlikely to come with type-like specifications; the Typed module is imposing its will on the untyped module however. So saying 'A never agreed to ctc_b' is really good. 
 
 Can we implement this, especially for this use case? 
 
 ;; ------------------------------------------------------------------------
 
 2. I like the idea of contract negotiation. I am not sure I see a real use case yet. For those of you who read German, I think it is mentioned in the Austrian (?) thesis I have been trying to read for 10 years now. Eiffel/first-order/software-engineering-astronautics is what comes to mind when I do. 
 
 ;; ------------------------------------------------------------------------
 
 3. As Robby mentioned, I have argued for separate contract modules for a couple of years now. I first asked Matthew whether we could get this for Units and he/Scott got us #lang unit and friends. I put Stevie on contracts for units but it didn't get me where I imagined I wanted to be, and we went off in a different direction anyway. 
 
 My inspiration has been Modula II for those who know it. It injected the idea of interface modules into the world a long time ago, but it got it wrong. 
 
 When I write contracts, I imagine writing a separate module fragment: 
 
   (provide/contract ...)
   followed by all the definitions necessary for someone to make sense of the contract. 
 
 I love Robby's scribble and test suite ideas. They add value! 
 
 If we go to a module-unit like world where people can describe interfaces in separate modules, I imagine that we write plain old modules BUT we will also need operations on such interface modules. For example, I can imagine writing 
 
  #lang module #:interface foo.rkt with ... 
 
 where the with clause adds/subtracts/modifies from the interface. 
 
 We might be able to do all this with macros on (sub)modules (at least for now). 
 
 ;; ------------------------------------------------------------------------
 
 If we want to continue pushing Racket as *the* language with *the* contract system (I know this is just a fragment but a good academic and possibly SE story), this would be a really good direction to follow up on. In particular, it would help us escape from the "Racket's contracts are all about obscure higher-order stuff" corner because I think this model is good for first-order contracts too. 
 
 
 -- Matthias
 
 
  
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Christos Dimoulas <chrdimo@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>,
        claire alvis <claire.alvis@gmail.com>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Sat, 1 Dec 2012 14:29:55 -0600

 On Sat, Dec 1, 2012 at 1:21 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >
 > Sorry guys for not following this thread in real time. I have finally had enough time to read and absorb.
 >
 > Some thoughts:
 >
 > 1. Christos's remark that
 >
 >> [w]henever the blamed party is the server party of the initial contract but not the party that applied the contract, then the contract error comes with a warning that says in your first example "'A' broke contract ctc_b but   A never agreed on ctc_b for 'a' so 'B' is asking too much from A". After that message it is clear that A, the client of B, should either change the contract and settle for weaker assurances or search for another server.
 >
 > comes really close to what I had in mind when I first replied. In the original case, the Untyped module is unlikely to come with type-like specifications; the Typed module is imposing its will on the untyped module however. So saying 'A never agreed to ctc_b' is really good.
 >
 > Can we implement this, especially for this use case?
 
 Yes, I think so.
 
 > ;; ------------------------------------------------------------------------
 >
 > 2. I like the idea of contract negotiation. I am not sure I see a real use case yet. For those of you who read German, I think it is mentioned in the Austrian (?) thesis I have been trying to read for 10 years now. Eiffel/first-order/software-engineering-astronautics is what comes to mind when I do.
 >
 > ;; ------------------------------------------------------------------------
 >
 > 3. As Robby mentioned, I have argued for separate contract modules for a couple of years now. I first asked Matthew whether we could get this for Units and he/Scott got us #lang unit and friends. I put Stevie on contracts for units but it didn't get me where I imagined I wanted to be, and we went off in a different direction anyway.
 >
 > My inspiration has been Modula II for those who know it. It injected the idea of interface modules into the world a long time ago, but it got it wrong.
 >
 > When I write contracts, I imagine writing a separate module fragment:
 >
 >   (provide/contract ...)
 >   followed by all the definitions necessary for someone to make sense of the contract.
 >
 > I love Robby's scribble and test suite ideas. They add value!
 >
 > If we go to a module-unit like world where people can describe interfaces in separate modules, I imagine that we write plain old modules BUT we will also need operations on such interface modules. For example, I can imagine writing
 >
 >  #lang module #:interface foo.rkt with ...
 >
 > where the with clause adds/subtracts/modifies from the interface.
 >
 > We might be able to do all this with macros on (sub)modules (at least for now).
 
 I think we can do this in the world of values mostly; at least my hope
 is that we can avoid having to make up the 701st language. :)
 
 (I'm specifically thinking of your "with" annotation there-- I would
 hope that could be some new primitive function that we can use in a
 contract-specification module.)
 
 > ;; ------------------------------------------------------------------------
 >
 > If we want to continue pushing Racket as *the* language with *the* contract system (I know this is just a fragment but a good academic and possibly SE story), this would be a really good direction to follow up on. In particular, it would help us escape from the "Racket's contracts are all about obscure higher-order stuff" corner because I think this model is good for first-order contracts too.
 >
 
 Yes, that makes a lot of sense to me, too.
 
 Robby
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Christos Dimoulas <chrdimo@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>,
        claire alvis <claire.alvis@gmail.com>
Subject: Re: [racket-bug] all/13322: Support for provide/typed
Date: Sat, 1 Dec 2012 20:22:59 -0500

 Let's go for it. 
 
 
 On Dec 1, 2012, at 3:29 PM, Robby Findler wrote:
 
 > On Sat, Dec 1, 2012 at 1:21 PM, Matthias Felleisen <matthias@ccs.neu.edu> wrote:
 >> 
 >> Sorry guys for not following this thread in real time. I have finally had enough time to read and absorb.
 >> 
 >> Some thoughts:
 >> 
 >> 1. Christos's remark that
 >> 
 >>> [w]henever the blamed party is the server party of the initial contract but not the party that applied the contract, then the contract error comes with a warning that says in your first example "'A' broke contract ctc_b but   A never agreed on ctc_b for 'a' so 'B' is asking too much from A". After that message it is clear that A, the client of B, should either change the contract and settle for weaker assurances or search for another server.
 >> 
 >> comes really close to what I had in mind when I first replied. In the original case, the Untyped module is unlikely to come with type-like specifications; the Typed module is imposing its will on the untyped module however. So saying 'A never agreed to ctc_b' is really good.
 >> 
 >> Can we implement this, especially for this use case?
 > 
 > Yes, I think so.
 > 
 >> ;; ------------------------------------------------------------------------
 >> 
 >> 2. I like the idea of contract negotiation. I am not sure I see a real use case yet. For those of you who read German, I think it is mentioned in the Austrian (?) thesis I have been trying to read for 10 years now. Eiffel/first-order/software-engineering-astronautics is what comes to mind when I do.
 >> 
 >> ;; ------------------------------------------------------------------------
 >> 
 >> 3. As Robby mentioned, I have argued for separate contract modules for a couple of years now. I first asked Matthew whether we could get this for Units and he/Scott got us #lang unit and friends. I put Stevie on contracts for units but it didn't get me where I imagined I wanted to be, and we went off in a different direction anyway.
 >> 
 >> My inspiration has been Modula II for those who know it. It injected the idea of interface modules into the world a long time ago, but it got it wrong.
 >> 
 >> When I write contracts, I imagine writing a separate module fragment:
 >> 
 >>  (provide/contract ...)
 >>  followed by all the definitions necessary for someone to make sense of the contract.
 >> 
 >> I love Robby's scribble and test suite ideas. They add value!
 >> 
 >> If we go to a module-unit like world where people can describe interfaces in separate modules, I imagine that we write plain old modules BUT we will also need operations on such interface modules. For example, I can imagine writing
 >> 
 >> #lang module #:interface foo.rkt with ...
 >> 
 >> where the with clause adds/subtracts/modifies from the interface.
 >> 
 >> We might be able to do all this with macros on (sub)modules (at least for now).
 > 
 > I think we can do this in the world of values mostly; at least my hope
 > is that we can avoid having to make up the 701st language. :)
 > 
 > (I'm specifically thinking of your "with" annotation there-- I would
 > hope that could be some new primitive function that we can use in a
 > contract-specification module.)
 > 
 >> ;; ------------------------------------------------------------------------
 >> 
 >> If we want to continue pushing Racket as *the* language with *the* contract system (I know this is just a fragment but a good academic and possibly SE story), this would be a really good direction to follow up on. In particular, it would help us escape from the "Racket's contracts are all about obscure higher-order stuff" corner because I think this model is good for first-order contracts too.
 >> 
 > 
 > Yes, that makes a lot of sense to me, too.
 > 
 > Robby
 
 

