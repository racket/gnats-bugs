From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Sun Dec  6 23:17:08 2009
Received: from mail-gx0-f227.google.com (mail-gx0-f227.google.com [209.85.217.227])
	by champlain.ccs.neu.edu (8.14.2/8.14.2) with ESMTP id nB74H38t032119
	for <bugs@bugs.plt-scheme.org>; Sun, 6 Dec 2009 23:17:03 -0500
Message-Id: <200912070417.nB74H1fP032113@champlain.ccs.neu.edu>
Date: Sun, 6 Dec 2009 23:17:01 -0500
From: sk@cs.brown.edu
To: bugs@plt-scheme.org
Subject: TS claims to type Scheme, but doesn't

>Number:         10646
>Category:       typed-scheme
>Synopsis:       TS claims to type Scheme, but doesn't
>Class:          sw-bug
>Responsible:    samth
>Severity:       non-critical
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Sun Dec 06 23:20:01 -0500 2009
>Closed-Date:    Thu Jan 07 11:48:31 -0500 2010
>Last-Modified:  Thu Jan 07 11:48:31 -0500 2010
>Originator:     Shriram Krishnamurthi
>Organization:
plt
>Submitter-Id:   unknown
>Release:        4.2.1
>Environment:
windows "Windows NT 5.1 (Build 2600) Service Pack 2" (win32\i386\3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 245319828

Collections:
(("C:\\Documents and Settings\\sk\\Application Data\\PLT Scheme\\4.2.1\\collects" non-existent-path) ("C:\\Program Files\\PLT\\4.2.1\\collects" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compiler" "config" "defaults" "deinprogramm" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "games" "graphics" "gui-debugger" "help" "hierlist" "htdch" "htdp" "html" "icons" "info-domain" "lang" "launcher" "lazy" "macro-debugger" "make" "mred" "mrlib" "mysterx" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "planet" "plot" "preprocessor" "profile" "profj" "r5rs" "r6rs" "readline" "redex" "rnrs" "s-exp" "scheme" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" "slideshow" "srfi" "stepper" "string-constants" "stxclass" "swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engine" "tex2page" "texpict" "trace" "typed" "typed-scheme" "version" "web-server" "wxme" "xml"))
Computer Language: (("Module") (#(#t write mixed-fraction-e #f #t debug) (default) #() "#lang scheme\n" #t))
>Description:
The functions are totally uninteresting, only the pattern of using OR.

(define: (f1) : (U Number Boolean)
  ;; don't care!
  (if (even? (random 10))
      (random 5)
      #f))

Let's try:

(define: (f2) : Number
  (or (f1) -1))

typecheck: Expected Number, but got (U Number Boolean)

Oh, alright, maybe I need to make the IF explicit:

(define: (f2) : Number
  (let ([v (f1)])
    (if v
        v
        -1)))

typecheck: Expected Number, but got (U Number Boolean)

So instead I have to write:

(define: (f2) : Number
  (let ([v (f1)])
    (if (number? v)
        v
        -1)))

If-splitting should know better.
>How-To-Repeat:
See Description.
>Fix:
>Audit-Trail:
From: Carl Eastlund <cce@plt-scheme.org>
To: Sam TH <samth@ccs.neu.edu>
Cc: sk <sk@cs.brown.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:26:01 -0500

 It's not a bug, it's an ill-typed program.  You declared a type
 including Boolean, then ignored the possibility of #t.  Here's a fixed
 version:
 
 #lang typed-scheme
 
 (define: (f1) : (U Number #f)
  ;; don't care!
  (if (even? (random 10))
      (random 5)
      #f))
 
 ;; Let's try:
 
 (define: (f2) : Number
  (or (f1) -1))
 
 Carl Eastlund
From: Sam TH <samth@ccs.neu.edu>
To: sk <sk@cs.brown.edu>, bugs <bugs@plt-scheme.org>
Cc: nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:24:14 -0500

 This is a long-standing bug.  The problem is the difference between:
 
 (if e1 #t e2)
 
 and
 
 (let ([tmp e1]) (if tmp tmp e2))
 
 The local binding loses the connection between the interesting content
 of `e1' and its truth value.
 
 sam th
 
 On Sun, Dec 6, 2009 at 11:20 PM,  <sk@cs.brown.edu> wrote:
 > A new problem report is waiting at
 > =A0http://bugs.plt-scheme.org/query/?cmd=3Dview&pr=3D10646
 >
 > Reported by Shriram Krishnamurthi for release: 4.2.1
 >
 > *** Description:
 > The functions are totally uninteresting, only the pattern of using OR.
 >
 > (define: (f1) : (U Number Boolean)
 > =A0;; don't care!
 > =A0(if (even? (random 10))
 > =A0 =A0 =A0(random 5)
 > =A0 =A0 =A0#f))
 >
 > Let's try:
 >
 > (define: (f2) : Number
 > =A0(or (f1) -1))
 >
 > typecheck: Expected Number, but got (U Number Boolean)
 >
 > Oh, alright, maybe I need to make the IF explicit:
 >
 > (define: (f2) : Number
 > =A0(let ([v (f1)])
 > =A0 =A0(if v
 > =A0 =A0 =A0 =A0v
 > =A0 =A0 =A0 =A0-1)))
 >
 > typecheck: Expected Number, but got (U Number Boolean)
 >
 > So instead I have to write:
 >
 > (define: (f2) : Number
 > =A0(let ([v (f1)])
 > =A0 =A0(if (number? v)
 > =A0 =A0 =A0 =A0v
 > =A0 =A0 =A0 =A0-1)))
 >
 > If-splitting should know better.
 >
 > *** How to repeat:
 > See Description.
 >
 > *** Environment:
 > windows "Windows NT 5.1 (Build 2600) Service Pack 2" (win32\i386\3m) (get=
 -display-depth) =3D 32
 > Human Language: english
 > (current-memory-use) 245319828
 >
 > Collections:
 > (("C:\\Documents and Settings\\sk\\Application Data\\PLT Scheme\\4.2.1\\c=
 ollects" non-existent-path) ("C:\\Program Files\\PLT\\4.2.1\\collects" "2ht=
 dp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compiler" "conf=
 ig" "defaults" "deinprogramm" "drscheme" "dynext" "embedded-gui" "eopl" "er=
 rortrace" "ffi" "file" "framework" "frtime" "games" "graphics" "gui-debugge=
 r" "help" "hierlist" "htdch" "htdp" "html" "icons" "info-domain" "lang" "la=
 uncher" "lazy" "macro-debugger" "make" "mred" "mrlib" "mysterx" "mzcom" "mz=
 lib" "mzscheme" "net" "openssl" "parser-tools" "planet" "plot" "preprocesso=
 r" "profile" "profj" "r5rs" "r6rs" "readline" "redex" "rnrs" "s-exp" "schem=
 e" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" "slideshow" "=
 srfi" "stepper" "string-constants" "stxclass" "swindle" "syntax" "syntax-co=
 lor" "teachpack" "test-box-recovery" "test-engine" "tex2page" "texpict" "tr=
 ace" "typed" "typed-scheme" "version" "web-server" "wxme" "xml"))
 > Computer Language: (("Module") (#(#t write mixed-fraction-e #f #t debug) =
 (default) #() "#lang scheme\n" #t))
 >
 >
 
 
 
 --=20
 sam th
 samth@ccs.neu.edu
From: Shriram Krishnamurthi <sk@cs.brown.edu>
To: Sam TH <samth@ccs.neu.edu>
Cc: bugs <bugs@plt-scheme.org>, nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:27:07 -0500

 Why not make False a type?  Wouldn't that help?
From: Carl Eastlund <cce@plt-scheme.org>
To: Shriram Krishnamurthi <sk@cs.brown.edu>
Cc: Sam TH <samth@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:30:20 -0500

 On Sun, Dec 6, 2009 at 11:28 PM, Carl Eastlund <cce@plt-scheme.org> wrote:
 > On Sun, Dec 6, 2009 at 11:27 PM, Shriram Krishnamurthi <sk@cs.brown.edu> =
 wrote:
 >> Why not make False a type? =A0Wouldn't that help?
 >
 > It is. =A0It's spelled "#f". =A0You can always do:
 >
 > (define-type-alias False #f)
 >
 > --Carl
 
 (I imagine I just said the same thing twice before you had the chance
 to read the first one.  Apologies for any redundancy, repetition, or
 redundancy.)
 
 --Carl
 
 P.S. Or repetition.
 
 --Carl
From: Shriram Krishnamurthi <sk@cs.brown.edu>
To: Carl Eastlund <cce@plt-scheme.org>
Cc: Sam TH <samth@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:31:17 -0500

 Perfect.  I guessed False and when it didn't work, assumed falsehood
 wasn't a type.  It works now!
 
 I must say it seems very inconsistent to call it "#f" when the rest
 are "String", "Number", etc.  I suggest building in this alias to make
 the type language more consistent.  I cannot imagine remembering this
 inconsistency six months from now.
 
 Shriram
 
 On Sun, Dec 6, 2009 at 11:28 PM, Carl Eastlund <cce@plt-scheme.org> wrote:
 > On Sun, Dec 6, 2009 at 11:27 PM, Shriram Krishnamurthi <sk@cs.brown.edu> =
 wrote:
 >> Why not make False a type? =A0Wouldn't that help?
 >
 > It is. =A0It's spelled "#f". =A0You can always do:
 >
 > (define-type-alias False #f)
 >
 > --Carl
 >
From: Carl Eastlund <cce@plt-scheme.org>
To: Shriram Krishnamurthi <sk@cs.brown.edu>
Cc: Sam TH <samth@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:28:11 -0500

 On Sun, Dec 6, 2009 at 11:27 PM, Shriram Krishnamurthi <sk@cs.brown.edu> wr=
 ote:
 > Why not make False a type? =A0Wouldn't that help?
 
 It is.  It's spelled "#f".  You can always do:
 
 (define-type-alias False #f)
 
 --Carl
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Shriram Krishnamurthi <sk@cs.brown.edu>
Cc: Carl Eastlund <cce@plt-scheme.org>, Sam TH <samth@ccs.neu.edu>,
        bugs <bugs@plt-scheme.org>, nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:34:31 -0500

 I ran into this recently when I translated a little graph editor into =
 Typed Scheme.=20
 
 I even sent it to Sam, w/o response ...=20
 
 
 
 
 On Dec 6, 2009, at 11:31 PM, Shriram Krishnamurthi wrote:
 
 > Perfect.  I guessed False and when it didn't work, assumed falsehood
 > wasn't a type.  It works now!
 >=20
 > I must say it seems very inconsistent to call it "#f" when the rest
 > are "String", "Number", etc.  I suggest building in this alias to make
 > the type language more consistent.  I cannot imagine remembering this
 > inconsistency six months from now.
 >=20
 > Shriram
 >=20
 > On Sun, Dec 6, 2009 at 11:28 PM, Carl Eastlund <cce@plt-scheme.org> =
 wrote:
 >> On Sun, Dec 6, 2009 at 11:27 PM, Shriram Krishnamurthi =
 <sk@cs.brown.edu> wrote:
 >>> Why not make False a type?  Wouldn't that help?
 >>=20
 >> It is.  It's spelled "#f".  You can always do:
 >>=20
 >> (define-type-alias False #f)
 >>=20
 >> --Carl
 >>=20
 
From: Carl Eastlund <cce@plt-scheme.org>
To: Shriram Krishnamurthi <sk@cs.brown.edu>
Cc: Sam TH <samth@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:37:59 -0500

 On Sun, Dec 6, 2009 at 11:31 PM, Shriram Krishnamurthi <sk@cs.brown.edu> wr=
 ote:
 > Perfect. =A0I guessed False and when it didn't work, assumed falsehood
 > wasn't a type. =A0It works now!
 >
 > I must say it seems very inconsistent to call it "#f" when the rest
 > are "String", "Number", etc. =A0I suggest building in this alias to make
 > the type language more consistent. =A0I cannot imagine remembering this
 > inconsistency six months from now.
 
 It's not an inconsistency, all constants (quoted or self-quoting) may
 be used as singleton types.  So #f is a type, and so are:
 
 #t
 5
 -3/4
 "Ceci n'est pas une type."
 'a-symbol
 '()
 '(ceci n (quote est) pas une s-expression)
 
 It's a useful feature, e.g. for writing enumeration types.  You could
 also have a few specific names, like True, False, Null, and so forth,
 but in some sense those would be the inconsistencies.
 
 --Carl
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Carl Eastlund <cce@plt-scheme.org>
Cc: Shriram Krishnamurthi <sk@cs.brown.edu>, Sam TH <samth@ccs.neu.edu>,
        bugs <bugs@plt-scheme.org>, nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:39:41 -0500

 Spidey started that way. Eventually we had to introduce a knob for =
 restricting the size of types it would track through programs. That was =
 one place that suggested switching from inference to explicit =
 declarations.=20
 
 
 On Dec 6, 2009, at 11:37 PM, Carl Eastlund wrote:
 
 > On Sun, Dec 6, 2009 at 11:31 PM, Shriram Krishnamurthi =
 <sk@cs.brown.edu> wrote:
 >> Perfect.  I guessed False and when it didn't work, assumed falsehood
 >> wasn't a type.  It works now!
 >>=20
 >> I must say it seems very inconsistent to call it "#f" when the rest
 >> are "String", "Number", etc.  I suggest building in this alias to =
 make
 >> the type language more consistent.  I cannot imagine remembering this
 >> inconsistency six months from now.
 >=20
 > It's not an inconsistency, all constants (quoted or self-quoting) may
 > be used as singleton types.  So #f is a type, and so are:
 >=20
 > #t
 > 5
 > -3/4
 > "Ceci n'est pas une type."
 > 'a-symbol
 > '()
 > '(ceci n (quote est) pas une s-expression)
 >=20
 > It's a useful feature, e.g. for writing enumeration types.  You could
 > also have a few specific names, like True, False, Null, and so forth,
 > but in some sense those would be the inconsistencies.
 >=20
 > --Carl
 
From: Shriram Krishnamurthi <sk@cs.brown.edu>
To: Carl Eastlund <cce@plt-scheme.org>
Cc: Sam TH <samth@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:43:21 -0500

 I must confess that after I sent my message, I went back and changed
 one of the : Number to : (U Number 3), hit F5, and sat back to watch
 the error and gloat.
 
 When it gave no error, I hastily closed DrScheme because I realized
 that otherwise I'll spend all night trying to figure out what this
 means and what its limits are, and never get any sleep.
 
 I still think False merits special consideration due to its hallowed
 place in Scheme (as enshrined by the primitives and the language's
 implicit type system), but at least I see I can't argue this on
 grounds of consistency.
 
 Shriram
 
 On Sun, Dec 6, 2009 at 11:37 PM, Carl Eastlund <cce@plt-scheme.org> wrote:
 > On Sun, Dec 6, 2009 at 11:31 PM, Shriram Krishnamurthi <sk@cs.brown.edu> =
 wrote:
 >> Perfect. =A0I guessed False and when it didn't work, assumed falsehood
 >> wasn't a type. =A0It works now!
 >>
 >> I must say it seems very inconsistent to call it "#f" when the rest
 >> are "String", "Number", etc. =A0I suggest building in this alias to make
 >> the type language more consistent. =A0I cannot imagine remembering this
 >> inconsistency six months from now.
 >
 > It's not an inconsistency, all constants (quoted or self-quoting) may
 > be used as singleton types. =A0So #f is a type, and so are:
 >
 > #t
 > 5
 > -3/4
 > "Ceci n'est pas une type."
 > 'a-symbol
 > '()
 > '(ceci n (quote est) pas une s-expression)
 >
 > It's a useful feature, e.g. for writing enumeration types. =A0You could
 > also have a few specific names, like True, False, Null, and so forth,
 > but in some sense those would be the inconsistencies.
 >
 > --Carl
 >
From: Carl Eastlund <cce@plt-scheme.org>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Sam TH <samth@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:43:28 -0500

 That was *supposed* to be off list, but was not.  Ah well.  I fail at
 teh internets.
 
 Carl Eastlund
 
 
 
 On Sun, Dec 6, 2009 at 11:43 PM, Carl Eastlund <cce@plt-scheme.org> wrote:
 > On Sun, Dec 6, 2009 at 11:40 PM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >>
 >> False is a special case. Let's add it.
 >
 > [off list]
 >
 > My first thought was, "so is Three". =A0I see your point, but you had an
 > odd way of saying it in a conversation already all about special
 > cases.
 >
 > --Carl
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, Sam TH <samth@ccs.neu.edu>,
        bugs <bugs@plt-scheme.org>, nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:40:37 -0500

 False is a special case. Let's add it. 
 
 
 On Dec 6, 2009, at 11:39 PM, Eli Barzilay wrote:
 
 > On Dec  6, Shriram Krishnamurthi wrote:
 >> Perfect.  I guessed False and when it didn't work, assumed falsehood
 >> wasn't a type.  It works now!
 >> 
 >> I must say it seems very inconsistent to call it "#f" when the rest
 >> are "String", "Number", etc.  I suggest building in this alias to
 >> make the type language more consistent.  I cannot imagine
 >> remembering this inconsistency six months from now.
 > 
 > My guess is that you think that this is something like the cute
 > Haskell thing of making the syntax of types similar to the syntax of
 > their constructors (I forgot if there was some name for this).  But TS
 > simply treats any datum as a potential singleton type, for example:
 > 
 >  (: foo : (3 -> 3))
 >  (define (foo x) x)
 > 
 > (And my guess is that Sam would object to `False' in the same way that
 > he'll object to `Three'.  (And in that case I +1 him in advance.  (But
 > my experience is that having me say that will quickly convince him the
 > other way around.)))
 > 
 > -- 
 >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                    http://barzilay.org/                   Maze is Life!
 
From: Carl Eastlund <cce@plt-scheme.org>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Sam TH <samth@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:43:04 -0500

 On Sun, Dec 6, 2009 at 11:40 PM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > False is a special case. Let's add it.
 
 [off list]
 
 My first thought was, "so is Three".  I see your point, but you had an
 odd way of saying it in a conversation already all about special
 cases.
 
 --Carl
From: Eli Barzilay <eli@barzilay.org>
To: Shriram Krishnamurthi <sk@cs.brown.edu>
Cc: Carl Eastlund <cce@plt-scheme.org>, Sam TH <samth@ccs.neu.edu>,
        bugs <bugs@plt-scheme.org>, nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:39:56 -0500

 On Dec  6, Shriram Krishnamurthi wrote:
 > Perfect.  I guessed False and when it didn't work, assumed falsehood
 > wasn't a type.  It works now!
 > 
 > I must say it seems very inconsistent to call it "#f" when the rest
 > are "String", "Number", etc.  I suggest building in this alias to
 > make the type language more consistent.  I cannot imagine
 > remembering this inconsistency six months from now.
 
 My guess is that you think that this is something like the cute
 Haskell thing of making the syntax of types similar to the syntax of
 their constructors (I forgot if there was some name for this).  But TS
 simply treats any datum as a potential singleton type, for example:
 
   (: foo : (3 -> 3))
   (define (foo x) x)
 
 (And my guess is that Sam would object to `False' in the same way that
 he'll object to `Three'.  (And in that case I +1 him in advance.  (But
 my experience is that having me say that will quickly convince him the
 other way around.)))
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Eli Barzilay <eli@barzilay.org>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, Sam TH <samth@ccs.neu.edu>,
        bugs <bugs@plt-scheme.org>, nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:49:03 -0500

 On Dec  6, Matthias Felleisen wrote:
 > False is a special case. Let's add it. 
 
 Not that I think that this is necessary, but in case Sam adds this,
 then it's fair to mention True and Null as similar kinds of
 exceptions.  (The last one can easily drag EmptyString in, and other
 fun stuff.)
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, Sam TH <samth@ccs.neu.edu>,
        bugs <bugs@plt-scheme.org>, nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:55:36 -0500

 Not True. 
 
 Empty? perhaps. 
 
 
 On Dec 6, 2009, at 11:49 PM, Eli Barzilay wrote:
 
 > On Dec  6, Matthias Felleisen wrote:
 >> False is a special case. Let's add it. 
 > 
 > Not that I think that this is necessary, but in case Sam adds this,
 > then it's fair to mention True and Null as similar kinds of
 > exceptions.  (The last one can easily drag EmptyString in, and other
 > fun stuff.)
 > 
 > -- 
 >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                    http://barzilay.org/                   Maze is Life!
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, Sam TH <samth@ccs.neu.edu>,
        bugs <bugs@plt-scheme.org>, nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Sun, 6 Dec 2009 23:57:10 -0500

 Nice isn't it? 
 
 #lang typed-scheme
 (: f ((U Number 3) -> 3))
 (define (f x) 4)
 
 
From: Sam TH <samth@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 00:13:36 -0500

 On Sun, Dec 6, 2009 at 11:49 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > On Dec =A06, Matthias Felleisen wrote:
 >> False is a special case. Let's add it.
 >
 > Not that I think that this is necessary, but in case Sam adds this,
 > then it's fair to mention True and Null as similar kinds of
 > exceptions. =A0(The last one can easily drag EmptyString in, and other
 > fun stuff.)
 
 Just to surprise Eli, I agree with him.  `False' is a good idea, since
 Shriram expected it.  `True' is needed for symettrey and the principle
 of least surprise.  `Null' is something that trips people up who used
 to using `null' in programs instead of '() or (list) [1].  But
 EmptyString is not needed (and what would be the point - String isn't
 a recursive datatype).
 
 [1] Note that (List) is a perfectly good type for the empty list, as well.
 
 --=20
 sam th
 samth@ccs.neu.edu
From: Sam TH <samth@ccs.neu.edu>
To: Shriram Krishnamurthi <sk@cs.brown.edu>
Cc: Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 09:05:55 -0500

 On Sun, Dec 6, 2009 at 11:43 PM, Shriram Krishnamurthi <sk@cs.brown.edu> wrote:
 > I must confess that after I sent my message, I went back and changed
 > one of the : Number to : (U Number 3), hit F5, and sat back to watch
 > the error and gloat.
 >
 > When it gave no error, I hastily closed DrScheme because I realized
 > that otherwise I'll spend all night trying to figure out what this
 > means and what its limits are, and never get any sleep.
 
 It turns out to be less complex than you think:
 
 (U Number 3) = Number, because of subtyping.
 
 Most such singleton types are inhabited only by the obvious constant
 expressions and variables of that type.
 
 You can use various comparison predicates (like `equal?') to check for
 such types.
 
 There's nothing fancy for arithmetic, or anything like that.
 -- 
 sam th
 samth@ccs.neu.edu
From: Sam TH <samth@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 09:17:21 -0500

 On Sun, Dec 6, 2009 at 11:57 PM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 > #lang typed-scheme
 > (: f ((U Number 3) -> 3))
 > (define (f x) 4)
 
 The error message produced here brings up an interesting point:
 
 expected 3, got Integer
 
 The reason it says this is that by default, numeric literals do not
 get assigned a singleton type.  Only symbols, booleans and keywords
 do.  This means that some programs get a less specific type than they
 could by default, but others typecheck where they wouldn't.  For
 example:
 
 (let ([x 7])
    (lambda () (set! x 17)))
 
 if `x' is inferred to have type 7, then the `set!' is an error.
 
 Feedback on this design decision is encouraged.
 -- 
 sam th
 samth@ccs.neu.edu
From: Sam TH <samth@ccs.neu.edu>
To: Carl Eastlund <cce@plt-scheme.org>
Cc: sk <sk@cs.brown.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 09:20:01 -0500

 On Sun, Dec 6, 2009 at 11:26 PM, Carl Eastlund <cce@plt-scheme.org> wrote:
 > It's not a bug, it's an ill-typed program. =A0You declared a type
 > including Boolean, then ignored the possibility of #t. =A0Here's a fixed
 > version:
 
 Right.  I saw `or' in the first example, and immediately thought of
 the problem with `or' that I mentioned in my response, rather than
 reading the actual code.
 --=20
 sam th
 samth@ccs.neu.edu
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam TH <samth@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 09:37:48 -0500

 On Dec 7, 2009, at 9:17 AM, Sam TH wrote:
 
 > On Sun, Dec 6, 2009 at 11:57 PM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> #lang typed-scheme
 >> (: f ((U Number 3) -> 3))
 >> (define (f x) 4)
 > 
 > The error message produced here brings up an interesting point:
 > 
 > expected 3, got Integer
 
 You won't believe it but I just though it was cute. Here
 is another one: 
 
   #lang typed-scheme
   (: f ((U Number 3) -> 3))
   (define (f x) (+ 1 2))
 
 I consider the error justified. To me a `3' in a type 
 signals a syntactic constant not an expression that may 
 yield 3 at run-time. 
 
 
 > The reason it says this is that by default, numeric literals do not
 > get assigned a singleton type.  Only symbols, booleans and keywords
 > do.  This means that some programs get a less specific type than they
 > could by default, but others typecheck where they wouldn't.  For
 > example:
 > 
 > (let ([x 7])
 >   (lambda () (set! x 17)))
 > 
 > if `x' is inferred to have type 7, then the `set!' is an error.
 > 
 > Feedback on this design decision is encouraged.
 
 You might consider an asymmetric design. 
 
 For (define x 7) you will have the whole number hierarchy available
 one day. Is 7 in Complex or in {7}? (I am using {} to indicate type.)
 
 the asymmetry could be this: 
 
 -- A constant variable is assigned the most specific type. 
 -- A mutable variable is assigned a type that depends on the 
    assignment statements. The above would then be {7, 17}. 
 
 Can you show me examples where this fails? 
 
 -- Matthias
 
 
 
 
 
 
From: Sam TH <samth@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 09:51:47 -0500

 On Mon, Dec 7, 2009 at 9:37 AM, Matthias Felleisen <matthias@ccs.neu.edu> w=
 rote:
 > On Dec 7, 2009, at 9:17 AM, Sam TH wrote:
 >
 >> On Sun, Dec 6, 2009 at 11:57 PM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>> #lang typed-scheme
 >>> (: f ((U Number 3) -> 3))
 >>> (define (f x) 4)
 >>
 >> The error message produced here brings up an interesting point:
 >>
 >> expected 3, got Integer
 >
 > You won't believe it but I just though it was cute. Here
 > is another one:
 >
 > =A0#lang typed-scheme
 > =A0(: f ((U Number 3) -> 3))
 > =A0(define (f x) (+ 1 2))
 >
 > I consider the error justified. To me a `3' in a type
 > signals a syntactic constant not an expression that may
 > yield 3 at run-time.
 
 Right.  I don't have any plans to make that function typecheck at that type=
 .
 
 >> The reason it says this is that by default, numeric literals do not
 >> get assigned a singleton type. =A0Only symbols, booleans and keywords
 >> do. =A0This means that some programs get a less specific type than they
 >> could by default, but others typecheck where they wouldn't. =A0For
 >> example:
 >>
 >> (let ([x 7])
 >> =A0 (lambda () (set! x 17)))
 >>
 >> if `x' is inferred to have type 7, then the `set!' is an error.
 >>
 >> Feedback on this design decision is encouraged.
 >
 > You might consider an asymmetric design.
 >
 > For (define x 7) you will have the whole number hierarchy available
 > one day. Is 7 in Complex or in {7}? (I am using {} to indicate type.)
 >
 > the asymmetry could be this:
 >
 > -- A constant variable is assigned the most specific type.
 > -- A mutable variable is assigned a type that depends on the
 > =A0 assignment statements. The above would then be {7, 17}.
 >
 > Can you show me examples where this fails?
 
 First, it means that type inference is no longer local.
 
 Second, it doesn't work for mutable structures:
 
 (let ([x (vector 7)])
    (vector-set! x 0 17))
 
 Third, it causes problems for loop variable inference:
 
 (let loop ([x 7])
    (if (=3D x 17)
        12
        (loop (add1 x))))
 
 Is that call to `loop' type-correct?  Not if `loop' expects only
 values of type {7} as arguments.
 --=20
 sam th
 samth@ccs.neu.edu
From: Eli Barzilay <eli@barzilay.org>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam TH <samth@ccs.neu.edu>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 10:02:42 -0500

 On Dec  7, Matthias Felleisen wrote:
 > On Dec 7, 2009, at 9:17 AM, Sam TH wrote:
 > 
 > > On Sun, Dec 6, 2009 at 11:57 PM, Matthias Felleisen
 > > <matthias@ccs.neu.edu> wrote:
 > >> #lang typed-scheme
 > >> (: f ((U Number 3) -> 3))
 > >> (define (f x) 4)
 > > 
 > > The error message produced here brings up an interesting point:
 > > 
 > > expected 3, got Integer
 > 
 > You won't believe it but I just though it was cute. Here
 > is another one: 
 > 
 >   #lang typed-scheme
 >   (: f ((U Number 3) -> 3))
 >   (define (f x) (+ 1 2))
 > 
 > I consider the error justified. To me a `3' in a type 
 > signals a syntactic constant not an expression that may 
 > yield 3 at run-time. 
 
 This seems to me like a reasonable behavior -- but the error message
 is what seems confusing.  How about just extending it for "Expected A,
 but got B" cases where A is a subtype of B?  Something like a
 parenthetical comment saying "not all 3s are Integers" or "singletons
 must be syntactic" or whatever.  I think that especially while TS is
 establishing itself, something like this is useful since otherwise
 people are likely to keep complaining that TS is broken.
 
 
 > [...]
 > the asymmetry could be this: 
 > 
 > -- A constant variable is assigned the most specific type. 
 > -- A mutable variable is assigned a type that depends on the 
 >    assignment statements. The above would then be {7, 17}. 
 
 Isn't this exactly what it's doing with boxes?
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam TH <samth@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 10:34:02 -0500

 On Dec 7, 2009, at 9:51 AM, Sam TH wrote:
 
 > First, it means that type inference is no longer local.
 
 I don't mind a module-local inference. For anything else, assume the  
 information from the module interface.
 
 
 > Second, it doesn't work for mutable structures:
 >
 > (let ([x (vector 7)])
 >   (vector-set! x 0 17))
 
 Mutable structures should force programmers to declare types.
 
 
 > Third, it causes problems for loop variable inference:
 >
 > (let loop ([x 7])
 >   (if (= x 17)
 >       12
 >       (loop (add1 x))))
 >
 > Is that call to `loop' type-correct?  Not if `loop' expects only
 > values of type {7} as arguments.
 
 This one's bad. But since you really see this in the type checker
 
   ((some-recursive-lambda (x) ...)
     7)
 
 perhaps the proper way to do this is to force people to declare a  
 type, too.
 
From: Sam TH <samth@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 10:42:13 -0500

 On Mon, Dec 7, 2009 at 10:34 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > On Dec 7, 2009, at 9:51 AM, Sam TH wrote:
 >
 >> First, it means that type inference is no longer local.
 >
 > I don't mind a module-local inference. For anything else, assume the
 > information from the module interface.
 
 ML has module-local inference.  It's too hard to understand, and too
 algorithmically complex in the presence of subtyping in general.  In
 this specific case it's probably easier to implement, but still
 potentially hard to understand for users.
 
 >> Second, it doesn't work for mutable structures:
 >>
 >> (let ([x (vector 7)])
 >> =A0(vector-set! x 0 17))
 >
 > Mutable structures should force programmers to declare types.
 
 Too bad you can't tell from the type system what allocates mutable structur=
 e.
 
 >> Third, it causes problems for loop variable inference:
 >>
 >> (let loop ([x 7])
 >> =A0(if (=3D x 17)
 >> =A0 =A0 =A012
 >> =A0 =A0 =A0(loop (add1 x))))
 >>
 >> Is that call to `loop' type-correct? =A0Not if `loop' expects only
 >> values of type {7} as arguments.
 >
 > This one's bad. But since you really see this in the type checker
 >
 > =A0((some-recursive-lambda (x) ...)
 > =A0 7)
 >
 > perhaps the proper way to do this is to force people to declare a type, t=
 oo.
 
 The fact that the typechecker only sees the expansion isn't a reason
 to make people write extra type annotations.  Right now this program
 works, and I'm reluctant to break it unless there are lots of real
 programs that need singleton numeric types and don't want to add
 annotations to make them work.
 
 --=20
 sam th
 samth@ccs.neu.edu
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam TH <samth@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 10:53:45 -0500

 On Dec 7, 2009, at 10:42 AM, Sam TH wrote:
 
 >>>
 >>> Third, it causes problems for loop variable inference:
 >>>
 >>> (let loop ([x 7])
 >>>  (if (= x 17)
 >>>      12
 >>>      (loop (add1 x))))
 >>>
 >>> Is that call to `loop' type-correct?  Not if `loop' expects only
 >>> values of type {7} as arguments.
 >>
 >> This one's bad. But since you really see this in the type checker
 >>
 >>  ((some-recursive-lambda (x) ...)
 >>   7)
 >>
 >> perhaps the proper way to do this is to force people to declare a  
 >> type, too.
 >
 > The fact that the typechecker only sees the expansion isn't a reason
 > to make people write extra type annotations.  Right now this program
 > works, and I'm reluctant to break it unless there are lots of real
 > programs that need singleton numeric types and don't want to add
 > annotations to make them work.
 
 I just typed this into drscheme and it fails to start with !!!!!
 
 ---------------------------------------
 (let loop ([x 7])
   (if (= x 17)
       12
       (loop (add1 x))))
 
 . typecheck: untyped var: loop in: loop
 ---------------------------------------
 
 I had first tried this:
 
 (let loop ([x -1])
    (if (< (real-part x) -2)
        3
        (loop (sqrt x))))
 
 just to see how you'd do with this one.
 
From: Sam TH <samth@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 10:58:46 -0500

 On Mon, Dec 7, 2009 at 10:53 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > On Dec 7, 2009, at 10:42 AM, Sam TH wrote:
 >
 >>>>
 >>>> Third, it causes problems for loop variable inference:
 >>>>
 >>>> (let loop ([x 7])
 >>>> =A0(if (=3D x 17)
 >>>> =A0 =A0 12
 >>>> =A0 =A0 (loop (add1 x))))
 >>>>
 >>>> Is that call to `loop' type-correct? =A0Not if `loop' expects only
 >>>> values of type {7} as arguments.
 >>>
 >>> This one's bad. But since you really see this in the type checker
 >>>
 >>> =A0((some-recursive-lambda (x) ...)
 >>> =A07)
 >>>
 >>> perhaps the proper way to do this is to force people to declare a type,
 >>> too.
 >>
 >> The fact that the typechecker only sees the expansion isn't a reason
 >> to make people write extra type annotations. =A0Right now this program
 >> works, and I'm reluctant to break it unless there are lots of real
 >> programs that need singleton numeric types and don't want to add
 >> annotations to make them work.
 >
 > I just typed this into drscheme and it fails to start with !!!!!
 
 It will only work when there's an expected type (for the result type
 of the recursive function).
 
 So this works:
 
 (: const Number)
 (define const
 (let loop ([x 7])
  (if (=3D x 17)
     12
     (loop (add1 x)))))
 
 Sorry for not being clearer.
 
 >
 > ---------------------------------------
 > (let loop ([x 7])
 > =A0(if (=3D x 17)
 > =A0 =A0 12
 > =A0 =A0 (loop (add1 x))))
 >
 > . typecheck: untyped var: loop in: loop
 > ---------------------------------------
 >
 > I had first tried this:
 >
 > (let loop ([x -1])
 > =A0(if (< (real-part x) -2)
 > =A0 =A0 =A03
 > =A0 =A0 =A0(loop (sqrt x))))
 >
 > just to see how you'd do with this one.
 >
 >
 
 
 
 --=20
 sam th
 samth@ccs.neu.edu
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam TH <samth@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 11:04:24 -0500

 On Dec 7, 2009, at 10:58 AM, Sam TH wrote:
 
 > It will only work when there's an expected type (for the result type
 > of the recursive function).
 >
 > So this works:
 >
 > (: const Number)
 > (define const
 > (let loop ([x 7])
 > (if (= x 17)
 >    12
 >    (loop (add1 x)))))
 >
 > Sorry for not being clearer.
 
 
 So this fails anyway:
 
 (: z 3)
 (define z
    (let loop ([x -1])
      (if (< (real-part x) -2)
          3
          (loop (sqrt x)))))
 
 typecheck: Expected Integer, but got Number 
From: Sam TH <samth@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Shriram Krishnamurthi <sk@cs.brown.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10646: TS claims to type Scheme, but doesn't
Date: Mon, 7 Dec 2009 11:45:53 -0500

 On Mon, Dec 7, 2009 at 11:04 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > On Dec 7, 2009, at 10:58 AM, Sam TH wrote:
 >
 >> It will only work when there's an expected type (for the result type
 >> of the recursive function).
 >>
 >> So this works:
 >>
 >> (: const Number)
 >> (define const
 >> (let loop ([x 7])
 >> (if (=3D x 17)
 >> =A0 12
 >> =A0 (loop (add1 x)))))
 >>
 >> Sorry for not being clearer.
 >
 >
 > So this fails anyway:
 >
 > (: z 3)
 > (define z
 > =A0(let loop ([x -1])
 > =A0 =A0(if (< (real-part x) -2)
 > =A0 =A0 =A0 =A03
 > =A0 =A0 =A0 =A0(loop (sqrt x)))))
 >
 > typecheck: Expected Integer, but got Number
 
 Right, it's guessing that you meant for `x' to be an Integer, based on
 the initial value.
 
 This typechecks (and infinite-loops) fine:
 
 (: z 3)
 (define z
 
  (let loop ([#{x : Number} -1])
    (if (< (real-part x) -2)
        3
       (loop (sqrt x)))))
 
 This is one case where I've thought about using another algorithm to
 try to improve the results of inference, but it hasn't gone beyond
 idle thoughts.
 
 --=20
 sam th
 samth@ccs.neu.edu

Responsible changed from "nobody" to "samth" by samth at Wed, 06 Jan 2010 20:19:29 -0500
Reason>>> ts


State changed from "open" to "closed" by samth at Thu, 07 Jan 2010 11:48:31 -0500
Reason>>> The new type names have been added.  The rest of this wasn't
a bug.

