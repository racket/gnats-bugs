From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Mon Apr  5 22:45:27 2010
Received: from mail-yx0-f191.google.com (mail-yx0-f191.google.com [209.85.210.191])
	by champlain.ccs.neu.edu (8.14.3/8.14.3) with ESMTP id o362jPMS010523
	for <bugs@bugs.plt-scheme.org>; Mon, 5 Apr 2010 22:45:25 -0400
Message-Id: <201004060245.o362jJ7q010513@champlain.ccs.neu.edu>
Date: Mon, 5 Apr 2010 22:45:19 -0400
From: dvanhorn@ccs.neu.edu
To: bugs@plt-scheme.org
Subject: Typed Scheme: occurence typing unions of structs and procs

>Number:         10844
>Category:       typed-scheme
>Synopsis:       Typed Scheme: occurence typing unions of structs and procs
>Class:          sw-bug
>Responsible:    samth
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Mon Apr 05 22:48:01 -0400 2010
>Closed-Date:    Wed Aug 18 10:08:03 -0400 2010
>Last-Modified:  Fri Sep 03 20:59:10 -0400 2010
>Originator:     David Van Horn
>Organization:
plt
>Submitter-Id:   unknown
>Release:        4.2.5.4-svn2apr2010
>Environment:
macosx "Darwin doom 10.2.0 Darwin Kernel Version 10.2.0: Tue Nov  3 10:37:10 PST 2009; root:xnu-1486.2.11~1/RELEASE_I386 i386" (i386-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 297925944

Collections:
(("/Users/dvanhorn/Library/PLT Scheme/4.2.5.4/collects" non-existent-path) ("/Applications/plt/collects" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compiler" "config" "defaults" "deinprogramm" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "games" "graphics" "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" "hierlist" "honu" "htdp" "html" "icons" "info-domain" "lang" "launcher" "lazy" "macro-debugger" "make" "meta" "mred" "mrlib" "mysterx" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "reader" "readline" "redex" "repos-time-stamp" "rnrs" "s-exp" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" "string-constants" "swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engine" "tests" "tex2page" "texpict" "trace" "typed" "typed-!
 scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml"))
Computer Language: (("Determine language from source") (#(#t write mixed-fraction-e #f #t debug) (default) #() "#lang scheme\n" #t))
>Description:
(define-struct: bar ())

(define: (f [x : (U bar (-> Number))]) : (-> Number)
  (if (procedure? x)
      x
      (λ () 7)))

The use of procedure? should be sufficient to type x at the 
only procedural variant of its union type: (-> Number).  Instead,
TS assigns the then-occurrence type Procedure, and the program 
doesn't type check.

Notice that the struct-ness of the other variant is important.
If you replace bar with Number, for example, the program type
checks as expected.
>How-To-Repeat:
>Fix:
>Audit-Trail:
From: Ryan Culpepper <ryanc@ccs.neu.edu>
To: dvanhorn@ccs.neu.edu, bugs@plt-scheme.org
Cc: 
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of
 structs and procs
Date: Mon, 05 Apr 2010 23:15:52 -0400

 dvanhorn@ccs.neu.edu wrote:
 > A new problem report is waiting at
 >   http://bugs.plt-scheme.org/query/?cmd=view&pr=10844
 > 
 > Reported by David Van Horn for release: 4.2.5.4-svn2apr2010
 > 
 > *** Description:
 > (define-struct: bar ())
 > 
 > (define: (f [x : (U bar (-> Number))]) : (-> Number)
 >   (if (procedure? x)
 >       x
 >       (λ () 7)))
 > 
 > The use of procedure? should be sufficient to type x at the 
 > only procedural variant of its union type: (-> Number).  Instead,
 > TS assigns the then-occurrence type Procedure, and the program 
 > doesn't type check.
 > 
 > Notice that the struct-ness of the other variant is important.
 > If you replace bar with Number, for example, the program type
 > checks as expected.
 
 I suspect this is a feature. It is possible to create a sub-struct of 
 bar that acts as a procedure (prop:procedure).
 
 Ryan
 
 
 > *** How to repeat:
 > 
 > 
 > *** Environment:
 > macosx "Darwin doom 10.2.0 Darwin Kernel Version 10.2.0: Tue Nov  3 10:37:10 PST 2009; root:xnu-1486.2.11~1/RELEASE_I386 i386" (i386-macosx/3m) (get-display-depth) = 32
 > Human Language: english
 > (current-memory-use) 297925944
 > 
 > Collections:
 > (("/Users/dvanhorn/Library/PLT Scheme/4.2.5.4/collects" non-existent-path) ("/Applications/plt/collects" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compiler" "config" "defaults" "deinprogramm" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "games" "graphics" "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" "hierlist" "honu" "htdp" "html" "icons" "info-domain" "lang" "launcher" "lazy" "macro-debugger" "make" "meta" "mred" "mrlib" "mysterx" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "reader" "readline" "redex" "repos-time-stamp" "rnrs" "s-exp" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" "string-constants" "swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engine" "tests" "tex2page" "texpict" "trace" "typed" "typed
 -!
 >  scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml"))
 > Computer Language: (("Determine language from source") (#(#t write mixed-fraction-e #f #t debug) (default) #() "#lang scheme\n" #t))
 > 
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: dvanhorn@ccs.neu.edu, bugs@plt-scheme.org
Cc: nobody@plt-scheme.org, bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of structs and procs
Date: Tue, 6 Apr 2010 09:26:15 -0400

 A struct could be interpreted as a procedure, which few people know. =20
 So I am not as surprised. Naturally a small change like the following =20=
 
 works:
 
 (define-struct: bar ())
 
 (define: (f [x : (U bar (-> Number))]) : (-> Number)
   (if (bar? x)
       (=CE=BB () 7)
       x))
 
 
 
 
 
 On Apr 5, 2010, at 10:48 PM, dvanhorn@ccs.neu.edu wrote:
 
 > A new problem report is waiting at
 >  http://bugs.plt-scheme.org/query/?cmd=3Dview&pr=3D10844
 >
 > Reported by David Van Horn for release: 4.2.5.4-svn2apr2010
 >
 > *** Description:
 > (define-struct: bar ())
 >
 > (define: (f [x : (U bar (-> Number))]) : (-> Number)
 >  (if (procedure? x)
 >      x
 >      (=CE=BB () 7)))
 >
 > The use of procedure? should be sufficient to type x at the
 > only procedural variant of its union type: (-> Number).  Instead,
 > TS assigns the then-occurrence type Procedure, and the program
 > doesn't type check.
 >
 > Notice that the struct-ness of the other variant is important.
 > If you replace bar with Number, for example, the program type
 > checks as expected.
 >
 > *** How to repeat:
 >
 >
 > *** Environment:
 > macosx "Darwin doom 10.2.0 Darwin Kernel Version 10.2.0: Tue Nov  3 =20=
 
 > 10:37:10 PST 2009; root:xnu-1486.2.11~1/RELEASE_I386 i386" (i386-=20
 > macosx/3m) (get-display-depth) =3D 32
 > Human Language: english
 > (current-memory-use) 297925944
 >
 > Collections:
 > (("/Users/dvanhorn/Library/PLT Scheme/4.2.5.4/collects" non-existent-=20=
 
 > path) ("/Applications/plt/collects" "2htdp" "afm" "algol60" "at-exp" =20=
 
 > "browser" "combinator-parser" "compiler" "config" "defaults" =20
 > "deinprogramm" "drscheme" "dynext" "embedded-gui" "eopl" =20
 > "errortrace" "ffi" "file" "framework" "frtime" "games" "graphics" =20
 > "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" =20
 > "hierlist" "honu" "htdp" "html" "icons" "info-domain" "lang" =20
 > "launcher" "lazy" "macro-debugger" "make" "meta" "mred" "mrlib" =20
 > "mysterx" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" =20=
 
 > "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" =20
 > "reader" "readline" "redex" "repos-time-stamp" "rnrs" "s-exp" =20
 > "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" =20
 > "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" =20
 > "string-constants" "swindle" "syntax" "syntax-color" "teachpack" =20
 > "test-box-recovery" "test-engine" "tests" "tex2page" "texpict" =20
 > "trace" "typed" "typed-!
 > scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml"))
 > Computer Language: (("Determine language from source") (#(#t write =20
 > mixed-fraction-e #f #t debug) (default) #() "#lang scheme\n" #t))
 >
 
From: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
To: dvanhorn@ccs.neu.edu, bugs@plt-scheme.org
Cc: nobody@plt-scheme.org, bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of 
	structs and procs
Date: Tue, 6 Apr 2010 09:46:46 -0400

 On Mon, Apr 5, 2010 at 10:48 PM,  <dvanhorn@ccs.neu.edu> wrote:
 > A new problem report is waiting at
 > =A0http://bugs.plt-scheme.org/query/?cmd=3Dview&pr=3D10844
 >
 > Reported by David Van Horn for release: 4.2.5.4-svn2apr2010
 >
 > *** Description:
 > (define-struct: bar ())
 >
 > (define: (f [x : (U bar (-> Number))]) : (-> Number)
 > =A0(if (procedure? x)
 > =A0 =A0 =A0x
 > =A0 =A0 =A0(=EB () 7)))
 >
 > The use of procedure? should be sufficient to type x at the
 > only procedural variant of its union type: (-> Number). =A0Instead,
 > TS assigns the then-occurrence type Procedure, and the program
 > doesn't type check.
 
 Thinking about this more, Matthias is right that structs-as-procedures
 means that what you want isn't sound.  For example, add this to the
 end of your program:
 
 (define-struct: (foo bar) () #:property prop:procedure (lambda _ #f))
 
 (f (make-foo))
 --=20
 sam th
 samth@ccs.neu.edu
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>
Cc: David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of  structs and procs
Date: Tue, 6 Apr 2010 09:50:07 -0400

 Even though my thinking is correct -- thanks for the confirmation -- I =20=
 
 think that this is one of those "surprise!" elements of Typed Scheme =20
 that I'd prefer not to encounter in a programming language. Or let me =20=
 
 rephrase this in the context of our recent discussion on structs:
 
    how many languages make structs applicable?
 
 -- Matthias
 
 
 
 
 
 On Apr 6, 2010, at 9:46 AM, Sam Tobin-Hochstadt wrote:
 
 > On Mon, Apr 5, 2010 at 10:48 PM,  <dvanhorn@ccs.neu.edu> wrote:
 >> A new problem report is waiting at
 >>  http://bugs.plt-scheme.org/query/?cmd=3Dview&pr=3D10844
 >>
 >> Reported by David Van Horn for release: 4.2.5.4-svn2apr2010
 >>
 >> *** Description:
 >> (define-struct: bar ())
 >>
 >> (define: (f [x : (U bar (-> Number))]) : (-> Number)
 >>  (if (procedure? x)
 >>      x
 >>      (=CE=BB () 7)))
 >>
 >> The use of procedure? should be sufficient to type x at the
 >> only procedural variant of its union type: (-> Number).  Instead,
 >> TS assigns the then-occurrence type Procedure, and the program
 >> doesn't type check.
 >
 > Thinking about this more, Matthias is right that structs-as-procedures
 > means that what you want isn't sound.  For example, add this to the
 > end of your program:
 >
 > (define-struct: (foo bar) () #:property prop:procedure (lambda _ #f))
 >
 > (f (make-foo))
 > --=20
 > sam th
 > samth@ccs.neu.edu
 
From: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, David Van Horn <dvanhorn@ccs.neu.edu>,
        bugs <bugs@plt-scheme.org>, nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of 
	structs and procs
Date: Tue, 6 Apr 2010 09:57:12 -0400

 On Tue, Apr 6, 2010 at 9:50 AM, Matthias Felleisen <matthias@ccs.neu.edu> w=
 rote:
 >
 > Even though my thinking is correct -- thanks for the confirmation -- I th=
 ink
 > that this is one of those "surprise!" elements of Typed Scheme that I'd
 > prefer not to encounter in a programming language. Or let me rephrase thi=
 s
 > in the context of our recent discussion on structs:
 >
 > =A0how many languages make structs applicable?
 
 I don't think this is a struct issue, really.  Consider an imaginary
 Java with unions and occurrence typing:
 
 class Foo { ... } // does not implement P
 interface P { ... }
 
 void m(Union<Foo,P> x) {
   if (x instanceof P) {
   ...
   } else {
   ...
  }
 }
 
 Can we assume that `x' is not a `Foo' in the then branch?  No, because
 we could subclass Foo with a class that implements P.
 
 The problem here is a non-tree-shaped subtyping hierarchy (properties,
 multiple interface implementation, etc), plus an open world.  I don't
 think we want to, or can, give those up.
 --=20
 sam th
 samth@ccs.neu.edu
From: David Van Horn <dvanhorn@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of
 	structs and procs
Date: Tue, 06 Apr 2010 10:01:15 -0400

 On 4/6/10 9:57 AM, Sam Tobin-Hochstadt wrote:
 > On Tue, Apr 6, 2010 at 9:50 AM, Matthias Felleisen<matthias@ccs.neu.edu>  wrote:
 >>
 >> Even though my thinking is correct -- thanks for the confirmation -- I think
 >> that this is one of those "surprise!" elements of Typed Scheme that I'd
 >> prefer not to encounter in a programming language. Or let me rephrase this
 >> in the context of our recent discussion on structs:
 >>
 >>   how many languages make structs applicable?
 >
 > I don't think this is a struct issue, really.  Consider an imaginary
 > Java with unions and occurrence typing:
 >
 > class Foo { ... } // does not implement P
 > interface P { ... }
 >
 > void m(Union<Foo,P>  x) {
 >    if (x instanceof P) {
 >    ...
 >    } else {
 >    ...
 >   }
 > }
 >
 > Can we assume that `x' is not a `Foo' in the then branch?  No, because
 > we could subclass Foo with a class that implements P.
 >
 > The problem here is a non-tree-shaped subtyping hierarchy (properties,
 > multiple interface implementation, etc), plus an open world.  I don't
 > think we want to, or can, give those up.
 
 I'm fine with withdrawing this bug report.  It now makes sense to me 
 that procedure? can't distinguish between a procedure and a structure.
 
 David
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, David Van Horn <dvanhorn@ccs.neu.edu>,
        bugs <bugs@plt-scheme.org>, nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of  structs and procs
Date: Tue, 6 Apr 2010 10:08:26 -0400

 I understand this. What we can argue then is that the type system at  
 least helps you reason about the problems of such naive tests  
 properly. I  -- as an unwashed Schemer and Racketeer -- would have  
 'blessed' the program before David submitted the bug report -- Matthias
 
 
 
 
 
 On Apr 6, 2010, at 9:57 AM, Sam Tobin-Hochstadt wrote:
 
 > On Tue, Apr 6, 2010 at 9:50 AM, Matthias Felleisen <matthias@ccs.neu.edu 
 > > wrote:
 >>
 >> Even though my thinking is correct -- thanks for the confirmation  
 >> -- I think
 >> that this is one of those "surprise!" elements of Typed Scheme that  
 >> I'd
 >> prefer not to encounter in a programming language. Or let me  
 >> rephrase this
 >> in the context of our recent discussion on structs:
 >>
 >>  how many languages make structs applicable?
 >
 > I don't think this is a struct issue, really.  Consider an imaginary
 > Java with unions and occurrence typing:
 >
 > class Foo { ... } // does not implement P
 > interface P { ... }
 >
 > void m(Union<Foo,P> x) {
 >  if (x instanceof P) {
 >  ...
 >  } else {
 >  ...
 > }
 > }
 >
 > Can we assume that `x' is not a `Foo' in the then branch?  No, because
 > we could subclass Foo with a class that implements P.
 >
 > The problem here is a non-tree-shaped subtyping hierarchy (properties,
 > multiple interface implementation, etc), plus an open world.  I don't
 > think we want to, or can, give those up.
 > -- 
 > sam th
 > samth@ccs.neu.edu
 
From: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, David Van Horn <dvanhorn@ccs.neu.edu>,
        bugs <bugs@plt-scheme.org>, nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of 
	structs and procs
Date: Tue, 6 Apr 2010 10:15:13 -0400

 On Tue, Apr 6, 2010 at 10:08 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > I understand this. What we can argue then is that the type system at leas=
 t
 > helps you reason about the problems of such naive tests properly. I =A0--=
  as
 > an unwashed Schemer and Racketeer -- would have 'blessed' the program bef=
 ore
 > David submitted the bug report -- Matthias
 
 In fact, I told David that he was right to think that this was a bug -
 that's why he submitted the bug report.
 
 I think the real lesson is that the closed-world assumption is baked
 into our brains, and it takes a lot of work to avoid making it.
 
 >
 >
 >
 >
 >
 > On Apr 6, 2010, at 9:57 AM, Sam Tobin-Hochstadt wrote:
 >
 >> On Tue, Apr 6, 2010 at 9:50 AM, Matthias Felleisen <matthias@ccs.neu.edu=
 >
 >> wrote:
 >>>
 >>> Even though my thinking is correct -- thanks for the confirmation -- I
 >>> think
 >>> that this is one of those "surprise!" elements of Typed Scheme that I'd
 >>> prefer not to encounter in a programming language. Or let me rephrase
 >>> this
 >>> in the context of our recent discussion on structs:
 >>>
 >>> =A0how many languages make structs applicable?
 >>
 >> I don't think this is a struct issue, really. =A0Consider an imaginary
 >> Java with unions and occurrence typing:
 >>
 >> class Foo { ... } // does not implement P
 >> interface P { ... }
 >>
 >> void m(Union<Foo,P> x) {
 >> =A0if (x instanceof P) {
 >> =A0...
 >> =A0} else {
 >> =A0...
 >> }
 >> }
 >>
 >> Can we assume that `x' is not a `Foo' in the then branch? =A0No, because
 >> we could subclass Foo with a class that implements P.
 >>
 >> The problem here is a non-tree-shaped subtyping hierarchy (properties,
 >> multiple interface implementation, etc), plus an open world. =A0I don't
 >> think we want to, or can, give those up.
 >> --
 >> sam th
 >> samth@ccs.neu.edu
 >
 >
 
 
 
 --=20
 sam th
 samth@ccs.neu.edu
From: Carl Eastlund <cce@plt-scheme.org>
To: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of 
	structs and procs
Date: Tue, 6 Apr 2010 10:24:58 -0400

 On Tue, Apr 6, 2010 at 10:15 AM, Sam Tobin-Hochstadt <samth@ccs.neu.edu> wr=
 ote:
 > On Tue, Apr 6, 2010 at 10:08 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >>
 >> I understand this. What we can argue then is that the type system at lea=
 st
 >> helps you reason about the problems of such naive tests properly. I =A0-=
 - as
 >> an unwashed Schemer and Racketeer -- would have 'blessed' the program be=
 fore
 >> David submitted the bug report -- Matthias
 >
 > In fact, I told David that he was right to think that this was a bug -
 > that's why he submitted the bug report.
 >
 > I think the real lesson is that the closed-world assumption is baked
 > into our brains, and it takes a lot of work to avoid making it.
 
 Perhaps this suggests that define-struct should have a #:closed or
 #:final option?  Or even better, for this kind of reasoning, that that
 should be the default, and it should have a #:open option for
 intentional super-structs?
 
 --Carl
From: David Van Horn <dvanhorn@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of
 	structs and procs
Date: Tue, 06 Apr 2010 10:33:30 -0400

 On 4/6/10 10:15 AM, Sam Tobin-Hochstadt wrote:
 > I think the real lesson is that the closed-world assumption is baked
 > into our brains, and it takes a lot of work to avoid making it.
 
 Since a stated goal of TS is to model the kind of reasoning Scheme 
 programmers use -- if it's baked into our brains maybe it should be 
 baked into TS, in which case Carl's proposal makes a lot of sense to me.
 
 It is unfortunate that subtyping and applicable structs conspire to rule 
 out a simple example that uses neither.
 
 David
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of  structs and procs
Date: Tue, 6 Apr 2010 10:34:39 -0400

 On Apr 6, 2010, at 10:15 AM, Sam Tobin-Hochstadt wrote:
 > On Tue, Apr 6, 2010 at 10:08 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >>=20
 >> I understand this. What we can argue then is that the type system at =
 least
 >> helps you reason about the problems of such naive tests properly. I  =
 -- as
 >> an unwashed Schemer and Racketeer -- would have 'blessed' the program =
 before
 >> David submitted the bug report -- Matthias
 >=20
 > In fact, I told David that he was right to think that this was a bug -
 > that's why he submitted the bug report.
 >=20
 > I think the real lesson is that the closed-world assumption is baked
 > into our brains, and it takes a lot of work to avoid making it.
 
 Having thought about this, I thought I'd try the following program when =
 I came in:
 
 #lang typed/scheme
 
 (define-struct: bar ())
 
 (define: (f [x : (U bar (-> Number))]) : (-> Number)
  (cond
    [(and (bar? x) (procedure? x)) x]
    [(procedure? x) x]
    [else (=CE=BB () 7)]))
 
 After some thought, that obviously doesn't work, since we can't be sure =
 that the prop:procedure on any bar-based struct is a thunk that returns =
 a number.  However, it seems like the following _should_ work:
 
 #lang typed/scheme
 
 (define-struct: bar ())
 
 (define: (f [x : (U bar (-> Number))]) : (-> Number)
  (cond
    [(and (bar? x) (procedure? x)) (=CE=BB () 7)]
    [(procedure? x) x]
    [else (=CE=BB () 7)]))
 
 This one currently doesn't typecheck, but it should, right?  Unless =
 there's some small detail I'm missing...
 
 Stevie=
From: Robby Findler <robby@eecs.northwestern.edu>
To: David Van Horn <dvanhorn@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of 
	structs and procs
Date: Tue, 6 Apr 2010 09:35:16 -0500

 I don't think we want to make the world more closed by default.
 
 But the example isn't ruled out -- you just have to reverse the test, right?
 
 Robby
 
 On Tue, Apr 6, 2010 at 9:33 AM, David Van Horn <dvanhorn@ccs.neu.edu> wrote:
 > On 4/6/10 10:15 AM, Sam Tobin-Hochstadt wrote:
 >>
 >> I think the real lesson is that the closed-world assumption is baked
 >> into our brains, and it takes a lot of work to avoid making it.
 >
 > Since a stated goal of TS is to model the kind of reasoning Scheme
 > programmers use -- if it's baked into our brains maybe it should be baked
 > into TS, in which case Carl's proposal makes a lot of sense to me.
 >
 > It is unfortunate that subtyping and applicable structs conspire to rule out
 > a simple example that uses neither.
 >
 > David
 >
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of  structs and procs
Date: Tue, 6 Apr 2010 10:38:33 -0400

 On Apr 6, 2010, at 10:34 AM, Stevie Strickland wrote:
 > #lang typed/scheme
 >=20
 > (define-struct: bar ())
 >=20
 > (define: (f [x : (U bar (-> Number))]) : (-> Number)
 > (cond
 >   [(and (bar? x) (procedure? x)) (=CE=BB () 7)]
 >   [(procedure? x) x]
 >   [else (=CE=BB () 7)]))
 >=20
 > This one currently doesn't typecheck, but it should, right?  Unless =
 there's some small detail I'm missing...
 
 (Having thought about it, this is the equivalent of reversing the test =
 in a weird way.  This is the result you'd likely get from someone =
 understanding the typechecking error in the original program, and fixing =
 based on the error instead of rethinking the problem.)
 
 Stevie=
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Carl Eastlund <cce@plt-scheme.org>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of  structs and procs
Date: Tue, 6 Apr 2010 10:47:08 -0400

 #:closed is a good idea!
 
 
 On Apr 6, 2010, at 10:24 AM, Carl Eastlund wrote:
 
 > On Tue, Apr 6, 2010 at 10:15 AM, Sam Tobin-Hochstadt <samth@ccs.neu.edu 
 > > wrote:
 >> On Tue, Apr 6, 2010 at 10:08 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> I understand this. What we can argue then is that the type system  
 >>> at least
 >>> helps you reason about the problems of such naive tests properly.  
 >>> I  -- as
 >>> an unwashed Schemer and Racketeer -- would have 'blessed' the  
 >>> program before
 >>> David submitted the bug report -- Matthias
 >>
 >> In fact, I told David that he was right to think that this was a  
 >> bug -
 >> that's why he submitted the bug report.
 >>
 >> I think the real lesson is that the closed-world assumption is baked
 >> into our brains, and it takes a lot of work to avoid making it.
 >
 > Perhaps this suggests that define-struct should have a #:closed or
 > #:final option?  Or even better, for this kind of reasoning, that that
 > should be the default, and it should have a #:open option for
 > intentional super-structs?
 >
 > --Carl
 
From: David Van Horn <dvanhorn@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of
 	structs and procs
Date: Tue, 06 Apr 2010 10:46:20 -0400

 On 4/6/10 10:35 AM, Robby Findler wrote:
 > But the example isn't ruled out -- you just have to reverse the test, right?
 
 Right -- but now you're talking about rewriting code and rearranging the 
 logic of control flow.  It's easy in this example but it sucks when the 
 program is big and old and you didn't write it (which is the context my 
 example is coming from).
 
 David
From: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of 
	structs and procs
Date: Tue, 6 Apr 2010 10:46:11 -0400

 On Tue, Apr 6, 2010 at 10:38 AM, Stevie Strickland <sstrickl@ccs.neu.edu> w=
 rote:
 > On Apr 6, 2010, at 10:34 AM, Stevie Strickland wrote:
 >> #lang typed/scheme
 >>
 >> (define-struct: bar ())
 >>
 >> (define: (f [x : (U bar (-> Number))]) : (-> Number)
 >> (cond
 >> =A0 [(and (bar? x) (procedure? x)) (=EB () 7)]
 >> =A0 [(procedure? x) x]
 >> =A0 [else (=EB () 7)]))
 >>
 >> This one currently doesn't typecheck, but it should, right? =A0Unless th=
 ere's some small detail I'm missing...
 >
 > (Having thought about it, this is the equivalent of reversing the test in=
  a weird way. =A0This is the result you'd likely get from someone understan=
 ding the typechecking error in the original program, and fixing based on th=
 e error instead of rethinking the problem.)
 
 Yes, exactly.  And it should work once the ICFP paper is fully
 implemented on trunk.
 --=20
 sam th
 samth@ccs.neu.edu
From: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
To: David Van Horn <dvanhorn@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of 
	structs and procs
Date: Tue, 6 Apr 2010 10:48:45 -0400

 On Tue, Apr 6, 2010 at 10:33 AM, David Van Horn <dvanhorn@ccs.neu.edu> wrote:
 > On 4/6/10 10:15 AM, Sam Tobin-Hochstadt wrote:
 >>
 >> I think the real lesson is that the closed-world assumption is baked
 >> into our brains, and it takes a lot of work to avoid making it.
 >
 > Since a stated goal of TS is to model the kind of reasoning Scheme
 > programmers use -- if it's baked into our brains maybe it should be baked
 > into TS, in which case Carl's proposal makes a lot of sense to me.
 
 I think Carl's proposal makes sense (though not as the default).
 
 But I think that everyone (not just Scheme programmers, or just
 programmers) tends to assume that all of the relevant information is
 whatever they're looking at right now.  In an open-world system, that
 assumption is fundamentally wrong, but I think that's a tension we'll
 mostly have to live with, in programming and in everything else.
 -- 
 sam th
 samth@ccs.neu.edu
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Carl Eastlund <cce@plt-scheme.org>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of 
	structs and procs
Date: Tue, 6 Apr 2010 09:54:47 -0500

 Yeah, I think so too.
 
 Robby
 
 On Tue, Apr 6, 2010 at 9:47 AM, Matthias Felleisen <matthias@ccs.neu.edu> w=
 rote:
 >
 > #:closed is a good idea!
 >
 >
 > On Apr 6, 2010, at 10:24 AM, Carl Eastlund wrote:
 >
 >> On Tue, Apr 6, 2010 at 10:15 AM, Sam Tobin-Hochstadt <samth@ccs.neu.edu>
 >> wrote:
 >>>
 >>> On Tue, Apr 6, 2010 at 10:08 AM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>>
 >>>> I understand this. What we can argue then is that the type system at
 >>>> least
 >>>> helps you reason about the problems of such naive tests properly. I =
 =C2=A0--
 >>>> as
 >>>> an unwashed Schemer and Racketeer -- would have 'blessed' the program
 >>>> before
 >>>> David submitted the bug report -- Matthias
 >>>
 >>> In fact, I told David that he was right to think that this was a bug -
 >>> that's why he submitted the bug report.
 >>>
 >>> I think the real lesson is that the closed-world assumption is baked
 >>> into our brains, and it takes a lot of work to avoid making it.
 >>
 >> Perhaps this suggests that define-struct should have a #:closed or
 >> #:final option? =C2=A0Or even better, for this kind of reasoning, that t=
 hat
 >> should be the default, and it should have a #:open option for
 >> intentional super-structs?
 >>
 >> --Carl
 >
 >
From: Eli Barzilay <eli@barzilay.org>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of 
	structs and procs
Date: Tue, 6 Apr 2010 11:07:01 -0400

 Which kind of "closedness" is this -- forbidding any substructs, or
 just substructs with different properties (like procedures)=3F  How
 about having both -- closing a struct for no substructs in addition to
 closed properties so I can make a struct that can serve as a super
 struct but they're all guaranteed to have the same `prop:procedure'
 value that I used=3F
 
 
 On Apr  6, Robby Findler wrote:
 > Yeah, I think so too.
 >=20
 > Robby
 >=20
 > On Tue, Apr 6, 2010 at 9:47 AM, Matthias Felleisen <matthias@ccs.neu.=
 edu> wrote:
 > >
 > > #:closed is a good idea!
 > >
 > >
 > > On Apr 6, 2010, at 10:24 AM, Carl Eastlund wrote:
 > >
 > >> Perhaps this suggests that define-struct should have a #:closed or=
 
 > >> #:final option=3F =C2=A0Or even better, for this kind of reasoning=
 , that
 > >> that should be the default, and it should have a #:open option
 > >> for intentional super-structs=3F
 
 --=20
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay=
 :
                     http://barzilay.org/                   Maze is Life=
 !
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Carl Eastlund <cce@plt-scheme.org>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of  structs and procs
Date: Tue, 6 Apr 2010 11:11:40 -0400

 On Apr 6, 2010, at 10:47 AM, Matthias Felleisen wrote:
 > #:closed is a good idea!
 
 It is indeed, and I'll +1 its addition, but it's not the whole story.  =
 For example, I've had programs in the past where I want to program as if =
 I had ML-style datatypes:
 
 (define-struct ast ( ... )) ;; some common features to all AST nodes
 (define-struct (ast-lam ast) (binds body))
 (define-struct (ast-app ast) (rator rand))
 (define-struct (ast-var ast) (name))
 
 And where I'd like to close ast (and its children) from further =
 extension.  If we had a way of writing such groups of structs in a way =
 that the group was closed from outside a certain region, then perhaps =
 Typed Scheme could use that effectively to type programs that work under =
 the assumption that the family of structs is closed.
 
 And better yet, if I come back and revisit my design to add new types of =
 AST nodes, then for programs that are conditionally walking the types of =
 children, like:
 
 (: typecheck (-> ast type))
 (define (typecheck a)
   (cond
    [(ast-lam? a) ...]
    [(ast-app? a) ...]
    [(ast-var? a) ...]))
 
 Typed Scheme will no longer typecheck the outdated definitions, alerting =
 me to the fact that now there are new cases I need to handle.
 
 (I was thinking about this in discussing with Matthias in the hall that =
 Carl's probably right, in that most people using structs are thinking of =
 them like data types, not classes, and thus closed by default makes =
 sense.  However, I thought about my own uses in programs like the above, =
 and realized my argument was actually wrong, because of the use of =
 parent structs as anchors for data type definitions.)
 
 Stevie=
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of 
	structs and procs
Date: Tue, 6 Apr 2010 09:33:20 -0600

 I guess the generalization would be a guard on subtyping (i.e., a
 procedure attached to a structure type that is applied to any subtype
 of the structure type, which the guard can reject by raising an
 exception or refine by returning a different structure type).
 
 At Tue, 6 Apr 2010 11:07:01 -0400, Eli Barzilay wrote:
 > Which kind of "closedness" is this -- forbidding any substructs, or
 > just substructs with different properties (like procedures)?  How
 > about having both -- closing a struct for no substructs in addition to
 > closed properties so I can make a struct that can serve as a super
 > struct but they're all guaranteed to have the same `prop:procedure'
 > value that I used?
 >=20
 >=20
 > On Apr  6, Robby Findler wrote:
 > > Yeah, I think so too.
 > >=20
 > > Robby
 > >=20
 > > On Tue, Apr 6, 2010 at 9:47 AM, Matthias Felleisen <matthias@ccs.neu.ed=
 u>=20
 > wrote:
 > > >
 > > > #:closed is a good idea!
 > > >
 > > >
 > > > On Apr 6, 2010, at 10:24 AM, Carl Eastlund wrote:
 > > >
 > > >> Perhaps this suggests that define-struct should have a #:closed or
 > > >> #:final option? =C2=A0Or even better, for this kind of reasoning, th=
 at
 > > >> that should be the default, and it should have a #:open option
 > > >> for intentional super-structs?
 >=20
 > --=20
 >           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                     http://barzilay.org/                   Maze is Life!
From: Ryan Culpepper <ryanc@ccs.neu.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of
  structs and procs
Date: Tue, 06 Apr 2010 12:20:57 -0400

 Stevie Strickland wrote:
 > On Apr 6, 2010, at 10:47 AM, Matthias Felleisen wrote:
 >> #:closed is a good idea!
 > 
 > It is indeed, and I'll +1 its addition, but it's not the whole story.
 > 
 > For example, I've had programs in the past where I want to program as if
 > I had ML-style datatypes:
 > 
 > (define-struct ast ( ... )) ;; some common features to all AST nodes
 > (define-struct (ast-lam ast) (binds body))
 > (define-struct (ast-app ast) (rator rand))
 > (define-struct (ast-var ast) (name))
 > 
 > And where I'd like to close ast (and its children) from further
 > extension. If we had a way of writing such groups of structs in a way
 > that the group was closed from outside a certain region, then perhaps
 > Typed Scheme could use that effectively to type programs that work under
 > the assumption that the family of structs is closed.
 
 I'd just like to bring up the Fortress solution to this problem: 
 comprises clauses. That is, you would write
 
 trait ast comprises {ast-lam, ast-app, ast-var} ... end
 object ast-lam extends trait ... end
 object ast-app extends trait ... end
 object ast-var extends trait ... end
 
 (For the purpose of this example, "trait" means struct/type-like thing, 
 and "object" means trait that can't be extended.)
 
 There are also excluding clauses, that assert that two types never have 
 a common subtype.
 
 Another thought: perhaps it's not realistic for Typed Scheme to have the 
 same defaults as Scheme/Racket. For example, Typed Scheme might be less 
 surprising if typed structs were closed by default, rather than 
 Scheme/Racket's open by default.
 
 Ryan
 
 
 
 > And better yet, if I come back and revisit my design to add new types
 > of AST nodes, then for programs that are conditionally walking the types
 > of children, like:
 > 
 > (: typecheck (-> ast type))
 > (define (typecheck a)
 >   (cond
 >    [(ast-lam? a) ...]
 >    [(ast-app? a) ...]
 >    [(ast-var? a) ...]))
 > 
 > Typed Scheme will no longer typecheck the outdated definitions,
 alerting me to the fact that now there are new cases I need to handle.
 > 
 > (I was thinking about this in discussing with Matthias in the hall
 > that Carl's probably right, in that most people using structs are
 > thinking of them like data types, not classes, and thus closed by
 > default makes sense. However, I thought about my own uses in programs
 > like the above, and realized my argument was actually wrong, because of
 > the use of parent structs as anchors for data type definitions.)
 > 
 > Stevie
 
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Ryan Culpepper <ryanc@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of structs and procs
Date: Tue, 6 Apr 2010 13:22:39 -0400

 On Apr 6, 2010, at 12:20 PM, Ryan Culpepper wrote:
 > I'd just like to bring up the Fortress solution to this problem: =
 comprises clauses. That is, you would write
 >=20
 > trait ast comprises {ast-lam, ast-app, ast-var} ... end
 > object ast-lam extends trait ... end
 > object ast-app extends trait ... end
 > object ast-var extends trait ... end
 >=20
 > (For the purpose of this example, "trait" means struct/type-like =
 thing, and "object" means trait that can't be extended.)
 
 But this doesn't do everything I want, right?  I want to say that, =
 outside of the region of code that defines all those extensions to ast, =
 there are no other extensions to ast.  In other words, outside of that =
 region, we are guaranteed that the ast family is completely closed.
 
 Stevie=
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: Ryan Culpepper <ryanc@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>,
        Sam Tobin-Hochstadt <samth@ccs.neu.edu>,
        Matthew Flatt <mflatt@cs.utah.edu>,
        David Van Horn <dvanhorn@ccs.neu.edu>, bugs <bugs@plt-scheme.org>,
        nobody <nobody@plt-scheme.org>,
        bug-notification <bug-notification@plt-scheme.org>
Subject: Re: [plt-bug] all/10844: Typed Scheme: occurence typing unions of structs and procs
Date: Tue, 6 Apr 2010 13:28:08 -0400

 On Apr 6, 2010, at 1:22 PM, Stevie Strickland wrote:
 > On Apr 6, 2010, at 12:20 PM, Ryan Culpepper wrote:
 >> I'd just like to bring up the Fortress solution to this problem: =
 comprises clauses. That is, you would write
 >>=20
 >> trait ast comprises {ast-lam, ast-app, ast-var} ... end
 >> object ast-lam extends trait ... end
 >> object ast-app extends trait ... end
 >> object ast-var extends trait ... end
 >>=20
 >> (For the purpose of this example, "trait" means struct/type-like =
 thing, and "object" means trait that can't be extended.)
 >=20
 > But this doesn't do everything I want, right?  I want to say that, =
 outside of the region of code that defines all those extensions to ast, =
 there are no other extensions to ast.  In other words, outside of that =
 region, we are guaranteed that the ast family is completely closed.
 
 Sorry, I totally missed the whole point of your post by overlooking the =
 comprises clause somehow.  I retract what I said.
 
 Stevie=

State changed from "open" to "closed" by samth at Wed, 18 Aug 2010 10:08:03 -0400
Reason>>> We decided this wasn't a bug. Perhaps #:closed should be
submitted as a separate feature request.


