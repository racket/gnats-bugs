From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Tue Mar 25 22:58:25 2014
Received: from mail-ob0-f180.google.com (mail-ob0-f180.google.com [209.85.214.180])
	by winooski.ccs.neu.edu (8.14.7/8.14.7) with ESMTP id s2Q2wOSZ010690
	for <bugs@bugs.plt-scheme.org>; Tue, 25 Mar 2014 22:58:24 -0400
Message-Id: <201403260258.s2Q2wMfB010683@winooski.ccs.neu.edu>
Date: Tue, 25 Mar 2014 22:58:22 -0400
From: eric.n.dobson@gmail.com
To: bugs@racket-lang.org
Subject: TR should print more complicated filters

>Number:         14423
>Category:       typed-scheme
>Synopsis:       TR should print more complicated filters
>Class:          sw-bug
>Responsible:    samth
>Severity:       serious
>Priority:       medium
>State:          open
>Confidential:   no
>Arrival-Date:   Tue Mar 25 23:00:02 -0400 2014
>Last-Modified:  Wed May 07 00:27:35 -0400 2014
>Originator:     Eric Dobson
>Organization:
plt
>Submitter-Id:   unknown
>Release:        HEAD
>Environment:
MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.27 Safari/537.36
>Description:
The type of filter as currently displayed by TR is very wrong.

>How-To-Repeat:
endobson@yggdrasil () ~/proj/racket/plt % racket
-> (require typed/racket)
-> filter                                                                                                                                                                                                                                
- : (All (a b)
      (case->
       (-> (-> a Any) (Listof a) (Listof b))
       (-> (-> a Any) (Listof a) (Listof a))))
#<procedure:filter>
-> 
>Fix:
>Audit-Trail:
From: Asumu Takikawa <asumu@ccs.neu.edu>
To: eric.n.dobson@gmail.com, bugs@racket-lang.org
Cc: nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 00:39:54 -0400

 On 2014-03-25 23:00:02 -0400, eric.n.dobson@gmail.com wrote:
 > *** Description:
 > The type of filter as currently displayed by TR is very wrong.
 >
 > *** How to repeat:
 > endobson@yggdrasil () ~/proj/racket/plt % racket
 > -> (require typed/racket)
 > -> filter
 > - : (All (a b)
 >       (case->
 >        (-> (-> a Any) (Listof a) (Listof b))
 >        (-> (-> a Any) (Listof a) (Listof a))))
 > #<procedure:filter>
 
 Any suggestions on how to print it? Printing the (-> a Any) as
 (-> a Any : b) doesn't seem to work, because that's not an asymmetric
 filter like the one in the type.
 
 Printing the full filter is possible, but should it still print that
 even when `print-complicated-filters?` is set to #f? (the default)
 
 Cheers,
 Asumu
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Asumu Takikawa <asumu@ccs.neu.edu>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Tue, 25 Mar 2014 23:04:26 -0700

 When is print-complicated-filters ever not false? I only recently
 added setting it to true during the typechecking tests because
 otherwise I would get errors where the expected and actual looked the
 same but were different.
 
 Why should we not be printing the full filters all the time? I assume
 most functions have -top-filter anyways.
 
 On Tue, Mar 25, 2014 at 9:39 PM, Asumu Takikawa <asumu@ccs.neu.edu> wrote:
 > On 2014-03-25 23:00:02 -0400, eric.n.dobson@gmail.com wrote:
 >> *** Description:
 >> The type of filter as currently displayed by TR is very wrong.
 >>
 >> *** How to repeat:
 >> endobson@yggdrasil () ~/proj/racket/plt % racket
 >> -> (require typed/racket)
 >> -> filter
 >> - : (All (a b)
 >>       (case->
 >>        (-> (-> a Any) (Listof a) (Listof b))
 >>        (-> (-> a Any) (Listof a) (Listof a))))
 >> #<procedure:filter>
 >
 > Any suggestions on how to print it? Printing the (-> a Any) as
 > (-> a Any : b) doesn't seem to work, because that's not an asymmetric
 > filter like the one in the type.
 >
 > Printing the full filter is possible, but should it still print that
 > even when `print-complicated-filters?` is set to #f? (the default)
 >
 > Cheers,
 > Asumu
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 09:27:45 -0400

 On Wed, Mar 26, 2014 at 2:04 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > When is print-complicated-filters ever not false? I only recently
 > added setting it to true during the typechecking tests because
 > otherwise I would get errors where the expected and actual looked the
 > same but were different.
 >
 > Why should we not be printing the full filters all the time? I assume
 > most functions have -top-filter anyways.
 
 Because most of the time, the filters are excess information that just
 confuse people.  This happens especially with user-written functions,
 where it's easy to get filters even though you don't care.
 
 Sam
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, Asumu Takikawa <asumu@ccs.neu.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 09:52:12 -0400

 Can we use Vincent's 'show more type' facility to compromise here? 
 
 In general, I agree that I don't want to see filters especially when I come from a 'fully typed' perspective. 
 
 BUT, when I finally grok TR, I think I do want the option of seeing filters. 
 
 
 
 
 On Mar 26, 2014, at 9:27 AM, Sam Tobin-Hochstadt wrote:
 
 > On Wed, Mar 26, 2014 at 2:04 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> When is print-complicated-filters ever not false? I only recently
 >> added setting it to true during the typechecking tests because
 >> otherwise I would get errors where the expected and actual looked the
 >> same but were different.
 >> 
 >> Why should we not be printing the full filters all the time? I assume
 >> most functions have -top-filter anyways.
 > 
 > Because most of the time, the filters are excess information that just
 > confuse people.  This happens especially with user-written functions,
 > where it's easy to get filters even though you don't care.
 > 
 > Sam
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, Asumu Takikawa <asumu@ccs.neu.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 10:14:06 -0400

 On Wed, Mar 26, 2014 at 9:52 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > Can we use Vincent's 'show more type' facility to compromise here?
 >
 > In general, I agree that I don't want to see filters especially when I come from a 'fully typed' perspective.
 
 I don't understand what you mean about filters vs a "fully-typed perspective".
 
 > BUT, when I finally grok TR, I think I do want the option of seeing filters.
 >
 >
 >
 >
 > On Mar 26, 2014, at 9:27 AM, Sam Tobin-Hochstadt wrote:
 >
 >> On Wed, Mar 26, 2014 at 2:04 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>> When is print-complicated-filters ever not false? I only recently
 >>> added setting it to true during the typechecking tests because
 >>> otherwise I would get errors where the expected and actual looked the
 >>> same but were different.
 >>>
 >>> Why should we not be printing the full filters all the time? I assume
 >>> most functions have -top-filter anyways.
 >>
 >> Because most of the time, the filters are excess information that just
 >> confuse people.  This happens especially with user-written functions,
 >> where it's easy to get filters even though you don't care.
 >>
 >> Sam
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, Asumu Takikawa <asumu@ccs.neu.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 10:48:18 -0400

 I am imagining people who start a program in #lang typed/racket, perhaps never think about the underlying filters, and just don't think of the idioms that these accommodate. Someone who likes parens and Cardelli's type-ful programming. 
 
 
 
 
 
 On Mar 26, 2014, at 10:14 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > On Wed, Mar 26, 2014 at 9:52 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> Can we use Vincent's 'show more type' facility to compromise here?
 >> 
 >> In general, I agree that I don't want to see filters especially when I come from a 'fully typed' perspective.
 > 
 > I don't understand what you mean about filters vs a "fully-typed perspective".
 > 
 >> BUT, when I finally grok TR, I think I do want the option of seeing filters.
 >> 
 >> 
 >> 
 >> 
 >> On Mar 26, 2014, at 9:27 AM, Sam Tobin-Hochstadt wrote:
 >> 
 >>> On Wed, Mar 26, 2014 at 2:04 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> When is print-complicated-filters ever not false? I only recently
 >>>> added setting it to true during the typechecking tests because
 >>>> otherwise I would get errors where the expected and actual looked the
 >>>> same but were different.
 >>>> 
 >>>> Why should we not be printing the full filters all the time? I assume
 >>>> most functions have -top-filter anyways.
 >>> 
 >>> Because most of the time, the filters are excess information that just
 >>> confuse people.  This happens especially with user-written functions,
 >>> where it's easy to get filters even though you don't care.
 >>> 
 >>> Sam
 >> 
 
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, Asumu Takikawa <asumu@ccs.neu.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 10:55:26 -0400

 On Mar 26, 2014, at 10:52 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > To me this seems like programming in ML and "just not thinking" about
 > the type variables.
 
 
 I disagree. ML is about HM inference, and the enlightened crowd has understood HMI to be of less value than type-ful programming. TR appears to be a good expressive vehicle for that. 
 
 
 
 > Filters aren't just about porting code -- they're
 > fundamental to how the whole thing works even for fully typed
 > programs.
 
 
 I understand that. Still there are many situations where I don't care to see them. 
 
 
 
 
 > 
 > On Wed, Mar 26, 2014 at 10:48 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> I am imagining people who start a program in #lang typed/racket, perhaps never think about the underlying filters, and just don't think of the idioms that these accommodate. Someone who likes parens and Cardelli's type-ful programming.
 >> 
 >> 
 >> 
 >> 
 >> 
 >> On Mar 26, 2014, at 10:14 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >> 
 >>> On Wed, Mar 26, 2014 at 9:52 AM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>> 
 >>>> Can we use Vincent's 'show more type' facility to compromise here?
 >>>> 
 >>>> In general, I agree that I don't want to see filters especially when I come from a 'fully typed' perspective.
 >>> 
 >>> I don't understand what you mean about filters vs a "fully-typed perspective".
 >>> 
 >>>> BUT, when I finally grok TR, I think I do want the option of seeing filters.
 >>>> 
 >>>> 
 >>>> 
 >>>> 
 >>>> On Mar 26, 2014, at 9:27 AM, Sam Tobin-Hochstadt wrote:
 >>>> 
 >>>>> On Wed, Mar 26, 2014 at 2:04 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>> When is print-complicated-filters ever not false? I only recently
 >>>>>> added setting it to true during the typechecking tests because
 >>>>>> otherwise I would get errors where the expected and actual looked the
 >>>>>> same but were different.
 >>>>>> 
 >>>>>> Why should we not be printing the full filters all the time? I assume
 >>>>>> most functions have -top-filter anyways.
 >>>>> 
 >>>>> Because most of the time, the filters are excess information that just
 >>>>> confuse people.  This happens especially with user-written functions,
 >>>>> where it's easy to get filters even though you don't care.
 >>>>> 
 >>>>> Sam
 >>>> 
 >> 
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, Asumu Takikawa <asumu@ccs.neu.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 10:52:38 -0400

 To me this seems like programming in ML and "just not thinking" about
 the type variables.  Filters aren't just about porting code -- they're
 fundamental to how the whole thing works even for fully typed
 programs.
 
 On Wed, Mar 26, 2014 at 10:48 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > I am imagining people who start a program in #lang typed/racket, perhaps never think about the underlying filters, and just don't think of the idioms that these accommodate. Someone who likes parens and Cardelli's type-ful programming.
 >
 >
 >
 >
 >
 > On Mar 26, 2014, at 10:14 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >> On Wed, Mar 26, 2014 at 9:52 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> Can we use Vincent's 'show more type' facility to compromise here?
 >>>
 >>> In general, I agree that I don't want to see filters especially when I come from a 'fully typed' perspective.
 >>
 >> I don't understand what you mean about filters vs a "fully-typed perspective".
 >>
 >>> BUT, when I finally grok TR, I think I do want the option of seeing filters.
 >>>
 >>>
 >>>
 >>>
 >>> On Mar 26, 2014, at 9:27 AM, Sam Tobin-Hochstadt wrote:
 >>>
 >>>> On Wed, Mar 26, 2014 at 2:04 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>> When is print-complicated-filters ever not false? I only recently
 >>>>> added setting it to true during the typechecking tests because
 >>>>> otherwise I would get errors where the expected and actual looked the
 >>>>> same but were different.
 >>>>>
 >>>>> Why should we not be printing the full filters all the time? I assume
 >>>>> most functions have -top-filter anyways.
 >>>>
 >>>> Because most of the time, the filters are excess information that just
 >>>> confuse people.  This happens especially with user-written functions,
 >>>> where it's easy to get filters even though you don't care.
 >>>>
 >>>> Sam
 >>>
 >
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, Asumu Takikawa <asumu@ccs.neu.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 10:57:03 -0400

 On Wed, Mar 26, 2014 at 10:55 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 >
 >
 > On Mar 26, 2014, at 10:52 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >> To me this seems like programming in ML and "just not thinking" about
 >> the type variables.
 >
 >
 > I disagree. ML is about HM inference, and the enlightened crowd has understood HMI to be of less value than type-ful programming. TR appears to be a good expressive vehicle for that.
 
 I was unclear -- I don't mean variables in the unification sense, but
 in the System F sense.
 
 >
 >
 >> Filters aren't just about porting code -- they're
 >> fundamental to how the whole thing works even for fully typed
 >> programs.
 >
 >
 > I understand that. Still there are many situations where I don't care to see them.
 >
 >
 >
 >
 >>
 >> On Wed, Mar 26, 2014 at 10:48 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> I am imagining people who start a program in #lang typed/racket, perhaps never think about the underlying filters, and just don't think of the idioms that these accommodate. Someone who likes parens and Cardelli's type-ful programming.
 >>>
 >>>
 >>>
 >>>
 >>>
 >>> On Mar 26, 2014, at 10:14 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>
 >>>> On Wed, Mar 26, 2014 at 9:52 AM, Matthias Felleisen
 >>>> <matthias@ccs.neu.edu> wrote:
 >>>>>
 >>>>> Can we use Vincent's 'show more type' facility to compromise here?
 >>>>>
 >>>>> In general, I agree that I don't want to see filters especially when I come from a 'fully typed' perspective.
 >>>>
 >>>> I don't understand what you mean about filters vs a "fully-typed perspective".
 >>>>
 >>>>> BUT, when I finally grok TR, I think I do want the option of seeing filters.
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>> On Mar 26, 2014, at 9:27 AM, Sam Tobin-Hochstadt wrote:
 >>>>>
 >>>>>> On Wed, Mar 26, 2014 at 2:04 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>> When is print-complicated-filters ever not false? I only recently
 >>>>>>> added setting it to true during the typechecking tests because
 >>>>>>> otherwise I would get errors where the expected and actual looked the
 >>>>>>> same but were different.
 >>>>>>>
 >>>>>>> Why should we not be printing the full filters all the time? I assume
 >>>>>>> most functions have -top-filter anyways.
 >>>>>>
 >>>>>> Because most of the time, the filters are excess information that just
 >>>>>> confuse people.  This happens especially with user-written functions,
 >>>>>> where it's easy to get filters even though you don't care.
 >>>>>>
 >>>>>> Sam
 >>>>>
 >>>
 >
From: Neil Toronto <neil.toronto@gmail.com>
To: Matthias Felleisen <matthias@ccs.neu.edu>,
        Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, Asumu Takikawa <asumu@ccs.neu.edu>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 09:12:47 -0600

 I think I program in TR the way Matthias is describing. I usually don't 
 want to see filters, but just assume that they work behind-the-scenes 
 magic that corresponds with what I think should be provable about my 
 programs. But I want the option to make everything explicit when my 
 intuition fails.
 
 Neil
 
 On 03/26/2014 08:55 AM, Matthias Felleisen wrote:
 >
 >
 >
 > On Mar 26, 2014, at 10:52 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >> To me this seems like programming in ML and "just not thinking" about
 >> the type variables.
 >
 >
 > I disagree. ML is about HM inference, and the enlightened crowd has understood HMI to be of less value than type-ful programming. TR appears to be a good expressive vehicle for that.
 >
 >
 >
 >> Filters aren't just about porting code -- they're
 >> fundamental to how the whole thing works even for fully typed
 >> programs.
 >
 >
 > I understand that. Still there are many situations where I don't care to see them.
 >
 >
 >
 >
 >>
 >> On Wed, Mar 26, 2014 at 10:48 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> I am imagining people who start a program in #lang typed/racket, perhaps never think about the underlying filters, and just don't think of the idioms that these accommodate. Someone who likes parens and Cardelli's type-ful programming.
 >>>
 >>>
 >>>
 >>>
 >>>
 >>> On Mar 26, 2014, at 10:14 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>
 >>>> On Wed, Mar 26, 2014 at 9:52 AM, Matthias Felleisen
 >>>> <matthias@ccs.neu.edu> wrote:
 >>>>>
 >>>>> Can we use Vincent's 'show more type' facility to compromise here?
 >>>>>
 >>>>> In general, I agree that I don't want to see filters especially when I come from a 'fully typed' perspective.
 >>>>
 >>>> I don't understand what you mean about filters vs a "fully-typed perspective".
 >>>>
 >>>>> BUT, when I finally grok TR, I think I do want the option of seeing filters.
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>> On Mar 26, 2014, at 9:27 AM, Sam Tobin-Hochstadt wrote:
 >>>>>
 >>>>>> On Wed, Mar 26, 2014 at 2:04 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>> When is print-complicated-filters ever not false? I only recently
 >>>>>>> added setting it to true during the typechecking tests because
 >>>>>>> otherwise I would get errors where the expected and actual looked the
 >>>>>>> same but were different.
 >>>>>>>
 >>>>>>> Why should we not be printing the full filters all the time? I assume
 >>>>>>> most functions have -top-filter anyways.
 >>>>>>
 >>>>>> Because most of the time, the filters are excess information that just
 >>>>>> confuse people.  This happens especially with user-written functions,
 >>>>>> where it's easy to get filters even though you don't care.
 >>>>>>
 >>>>>> Sam
 >>>>>
 >>>
 >
 
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Neil Toronto <neil.toronto@gmail.com>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Sam Tobin-Hochstadt <samth@cs.indiana.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 09:06:11 -0700

 Quote from Sam:
 Because most of the time, the filters are excess information that just
 confuse people.  This happens especially with user-written functions,
 where it's easy to get filters even though you don't care.
 
 But that leaves off the flip side of things where the filters are
 important information and not providing them to the user is confusing,
 like this example. Also I'm not sure what the issue with having user
 written functions have filters is. Is it the derived issue of then
 reporting error messages with filters? In that case can you give an
 example where the error message is bad if I turn on
 print-complex-filters?
 
 The only way that I can see filters ocurring is that a user writes
 (define (f x) <body>) and we infer filters during the body, and
 incorporate them into result part of f. Then the only time this would
 be revealed to the user is if those filters do not line up with
 expectations. But in those cases the expected filters must be non
 trivial and so revealing to the user that filters exist and are
 complicated is required.
 
 On Wed, Mar 26, 2014 at 8:12 AM, Neil Toronto <neil.toronto@gmail.com> wrote:
 > I think I program in TR the way Matthias is describing. I usually don't want
 > to see filters, but just assume that they work behind-the-scenes magic that
 > corresponds with what I think should be provable about my programs. But I
 > want the option to make everything explicit when my intuition fails.
 >
 > Neil
 >
 >
 > On 03/26/2014 08:55 AM, Matthias Felleisen wrote:
 >>
 >>
 >>
 >>
 >> On Mar 26, 2014, at 10:52 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu>
 >> wrote:
 >>
 >>> To me this seems like programming in ML and "just not thinking" about
 >>> the type variables.
 >>
 >>
 >>
 >> I disagree. ML is about HM inference, and the enlightened crowd has
 >> understood HMI to be of less value than type-ful programming. TR appears to
 >> be a good expressive vehicle for that.
 >>
 >>
 >>
 >>> Filters aren't just about porting code -- they're
 >>> fundamental to how the whole thing works even for fully typed
 >>> programs.
 >>
 >>
 >>
 >> I understand that. Still there are many situations where I don't care to
 >> see them.
 >>
 >>
 >>
 >>
 >>>
 >>> On Wed, Mar 26, 2014 at 10:48 AM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>>
 >>>>
 >>>> I am imagining people who start a program in #lang typed/racket, perhaps
 >>>> never think about the underlying filters, and just don't think of the idioms
 >>>> that these accommodate. Someone who likes parens and Cardelli's type-ful
 >>>> programming.
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>
 >>>> On Mar 26, 2014, at 10:14 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu>
 >>>> wrote:
 >>>>
 >>>>> On Wed, Mar 26, 2014 at 9:52 AM, Matthias Felleisen
 >>>>> <matthias@ccs.neu.edu> wrote:
 >>>>>>
 >>>>>>
 >>>>>> Can we use Vincent's 'show more type' facility to compromise here?
 >>>>>>
 >>>>>> In general, I agree that I don't want to see filters especially when I
 >>>>>> come from a 'fully typed' perspective.
 >>>>>
 >>>>>
 >>>>> I don't understand what you mean about filters vs a "fully-typed
 >>>>> perspective".
 >>>>>
 >>>>>> BUT, when I finally grok TR, I think I do want the option of seeing
 >>>>>> filters.
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>>
 >>>>>> On Mar 26, 2014, at 9:27 AM, Sam Tobin-Hochstadt wrote:
 >>>>>>
 >>>>>>> On Wed, Mar 26, 2014 at 2:04 AM, Eric Dobson
 >>>>>>> <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>
 >>>>>>>> When is print-complicated-filters ever not false? I only recently
 >>>>>>>> added setting it to true during the typechecking tests because
 >>>>>>>> otherwise I would get errors where the expected and actual looked
 >>>>>>>> the
 >>>>>>>> same but were different.
 >>>>>>>>
 >>>>>>>> Why should we not be printing the full filters all the time? I
 >>>>>>>> assume
 >>>>>>>> most functions have -top-filter anyways.
 >>>>>>>
 >>>>>>>
 >>>>>>> Because most of the time, the filters are excess information that
 >>>>>>> just
 >>>>>>> confuse people.  This happens especially with user-written functions,
 >>>>>>> where it's easy to get filters even though you don't care.
 >>>>>>>
 >>>>>>> Sam
 >>>>>>
 >>>>>>
 >>>>
 >>
 >
From: Asumu Takikawa <asumu@ccs.neu.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 12:10:51 -0400

 On 2014-03-25 23:04:26 -0700, Eric Dobson wrote:
 > When is print-complicated-filters ever not false? I only recently
 > added setting it to true during the typechecking tests because
 > otherwise I would get errors where the expected and actual looked the
 > same but were different.
 
 It's currently always #f because it's not exposed to the user. I have a
 branch laying around that allows toggling it from the REPL.
 
 Also, TR was always printing the full filters in v6.0 and before because
 it was effectively ignoring the parameter. I'm not sure if that was
 intentional or was a regression (v4.90.0.1 doesn't print a filter for
 `(lambda (x) x)` for example).
 
 Cheers,
 Asumu
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Neil Toronto <neil.toronto@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 12:19:06 -0400

 On Wed, Mar 26, 2014 at 12:06 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >
 > The only way that I can see filters ocurring is that a user writes
 > (define (f x) <body>) and we infer filters during the body, and
 > incorporate them into result part of f. Then the only time this would
 > be revealed to the user is if those filters do not line up with
 > expectations. But in those cases the expected filters must be non
 > trivial and so revealing to the user that filters exist and are
 > complicated is required.
 
 The simplest place this comes up is that (lambda (x) x) has
 non-trivial filters.  You can see that easily either by just typing it
 in at the repl and looking at the type you get (I'm pretty sure I
 remember people asking "what are these other things in the type?"), or
 by writing a program like this:
 
 (define a (lambda ([x : Integer]) x))
 (define b : (Number -> Number) a)
 
 Right now, the error message doesn't mention filters, and adding them
 in would be confusing -- it makes it look like the problem is the
 difference in filters.
 
 Sam
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Neil Toronto <neil.toronto@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 09:31:08 -0700

 I think that that this error message is worse.
 
 tmp/tmp.rkt:9:10: Type Checker: type mismatch
   expected: (-> Integer Integer)
   given: (-> Integer Integer)
   in: a
   context...:
    /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-toplevel.rkt:249:0:
 type-check
    /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/tc-setup.rkt:82:0:
 tc-module/full
    /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typed-racket.rkt:25:4
    standard-module-name-resolver
 
 for the program
 
 #lang typed/racket
 
 (: a (Integer -> Integer))
 (define (a x) x)
 
 (: b (Integer -> Integer : #:+ (Integer @ 0)))
 (define b a)
 
 Even if I understand filters, the error message is useless.
 
 It seems like what we need is for check-below to construct better
 error messages in the case of function types. Because it currently
 does a good job of only bringing up filters if they are necessary in
 the first order case.
 
 On Wed, Mar 26, 2014 at 9:19 AM, Sam Tobin-Hochstadt
 <samth@cs.indiana.edu> wrote:
 > On Wed, Mar 26, 2014 at 12:06 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>
 >> The only way that I can see filters ocurring is that a user writes
 >> (define (f x) <body>) and we infer filters during the body, and
 >> incorporate them into result part of f. Then the only time this would
 >> be revealed to the user is if those filters do not line up with
 >> expectations. But in those cases the expected filters must be non
 >> trivial and so revealing to the user that filters exist and are
 >> complicated is required.
 >
 > The simplest place this comes up is that (lambda (x) x) has
 > non-trivial filters.  You can see that easily either by just typing it
 > in at the repl and looking at the type you get (I'm pretty sure I
 > remember people asking "what are these other things in the type?"), or
 > by writing a program like this:
 >
 > (define a (lambda ([x : Integer]) x))
 > (define b : (Number -> Number) a)
 >
 > Right now, the error message doesn't mention filters, and adding them
 > in would be confusing -- it makes it look like the problem is the
 > difference in filters.
 >
 > Sam
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Neil Toronto <neil.toronto@gmail.com>,
        Matthias Felleisen <matthias@ccs.neu.edu>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 12:36:27 -0400

 On Wed, Mar 26, 2014 at 12:31 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > I think that that this error message is worse.
 >
 > tmp/tmp.rkt:9:10: Type Checker: type mismatch
 >   expected: (-> Integer Integer)
 >   given: (-> Integer Integer)
 >   in: a
 >   context...:
 >    /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-toplevel.rkt:249:0:
 > type-check
 >    /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/tc-setup.rkt:82:0:
 > tc-module/full
 >    /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typed-racket.rkt:25:4
 >    standard-module-name-resolver
 >
 > for the program
 >
 > #lang typed/racket
 >
 > (: a (Integer -> Integer))
 > (define (a x) x)
 >
 > (: b (Integer -> Integer : #:+ (Integer @ 0)))
 > (define b a)
 >
 > Even if I understand filters, the error message is useless.
 
 Right, I agree that this is a problem. But I don't think
 unconditionally printing filters is the solution.
 
 > It seems like what we need is for check-below to construct better
 > error messages in the case of function types. Because it currently
 > does a good job of only bringing up filters if they are necessary in
 > the first order case.
 
 I agree.
 
 Sam
 
 > On Wed, Mar 26, 2014 at 9:19 AM, Sam Tobin-Hochstadt
 > <samth@cs.indiana.edu> wrote:
 >> On Wed, Mar 26, 2014 at 12:06 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>
 >>> The only way that I can see filters ocurring is that a user writes
 >>> (define (f x) <body>) and we infer filters during the body, and
 >>> incorporate them into result part of f. Then the only time this would
 >>> be revealed to the user is if those filters do not line up with
 >>> expectations. But in those cases the expected filters must be non
 >>> trivial and so revealing to the user that filters exist and are
 >>> complicated is required.
 >>
 >> The simplest place this comes up is that (lambda (x) x) has
 >> non-trivial filters.  You can see that easily either by just typing it
 >> in at the repl and looking at the type you get (I'm pretty sure I
 >> remember people asking "what are these other things in the type?"), or
 >> by writing a program like this:
 >>
 >> (define a (lambda ([x : Integer]) x))
 >> (define b : (Number -> Number) a)
 >>
 >> Right now, the error message doesn't mention filters, and adding them
 >> in would be confusing -- it makes it look like the problem is the
 >> difference in filters.
 >>
 >> Sam
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 12:43:08 -0400

 Can we have a metric for such error messages that says "if expected is too close to given, print filters too". 
 
 
 On Mar 26, 2014, at 12:36 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > On Wed, Mar 26, 2014 at 12:31 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> I think that that this error message is worse.
 >> 
 >> tmp/tmp.rkt:9:10: Type Checker: type mismatch
 >>  expected: (-> Integer Integer)
 >>  given: (-> Integer Integer)
 >>  in: a
 >>  context...:
 >>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-toplevel.rkt:249:0:
 >> type-check
 >>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/tc-setup.rkt:82:0:
 >> tc-module/full
 >>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typed-racket.rkt:25:4
 >>   standard-module-name-resolver
 >> 
 >> for the program
 >> 
 >> #lang typed/racket
 >> 
 >> (: a (Integer -> Integer))
 >> (define (a x) x)
 >> 
 >> (: b (Integer -> Integer : #:+ (Integer @ 0)))
 >> (define b a)
 >> 
 >> Even if I understand filters, the error message is useless.
 > 
 > Right, I agree that this is a problem. But I don't think
 > unconditionally printing filters is the solution.
 > 
 >> It seems like what we need is for check-below to construct better
 >> error messages in the case of function types. Because it currently
 >> does a good job of only bringing up filters if they are necessary in
 >> the first order case.
 > 
 > I agree.
 > 
 > Sam
 > 
 >> On Wed, Mar 26, 2014 at 9:19 AM, Sam Tobin-Hochstadt
 >> <samth@cs.indiana.edu> wrote:
 >>> On Wed, Mar 26, 2014 at 12:06 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> 
 >>>> The only way that I can see filters ocurring is that a user writes
 >>>> (define (f x) <body>) and we infer filters during the body, and
 >>>> incorporate them into result part of f. Then the only time this would
 >>>> be revealed to the user is if those filters do not line up with
 >>>> expectations. But in those cases the expected filters must be non
 >>>> trivial and so revealing to the user that filters exist and are
 >>>> complicated is required.
 >>> 
 >>> The simplest place this comes up is that (lambda (x) x) has
 >>> non-trivial filters.  You can see that easily either by just typing it
 >>> in at the repl and looking at the type you get (I'm pretty sure I
 >>> remember people asking "what are these other things in the type?"), or
 >>> by writing a program like this:
 >>> 
 >>> (define a (lambda ([x : Integer]) x))
 >>> (define b : (Number -> Number) a)
 >>> 
 >>> Right now, the error message doesn't mention filters, and adding them
 >>> in would be confusing -- it makes it look like the problem is the
 >>> difference in filters.
 >>> 
 >>> Sam
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 12:45:17 -0400

 Well, what you really want is "do expected and given differ only in filters".
 
 Sam
 
 On Wed, Mar 26, 2014 at 12:43 PM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > Can we have a metric for such error messages that says "if expected is too close to given, print filters too".
 >
 >
 > On Mar 26, 2014, at 12:36 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >> On Wed, Mar 26, 2014 at 12:31 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>> I think that that this error message is worse.
 >>>
 >>> tmp/tmp.rkt:9:10: Type Checker: type mismatch
 >>>  expected: (-> Integer Integer)
 >>>  given: (-> Integer Integer)
 >>>  in: a
 >>>  context...:
 >>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-toplevel.rkt:249:0:
 >>> type-check
 >>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/tc-setup.rkt:82:0:
 >>> tc-module/full
 >>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typed-racket.rkt:25:4
 >>>   standard-module-name-resolver
 >>>
 >>> for the program
 >>>
 >>> #lang typed/racket
 >>>
 >>> (: a (Integer -> Integer))
 >>> (define (a x) x)
 >>>
 >>> (: b (Integer -> Integer : #:+ (Integer @ 0)))
 >>> (define b a)
 >>>
 >>> Even if I understand filters, the error message is useless.
 >>
 >> Right, I agree that this is a problem. But I don't think
 >> unconditionally printing filters is the solution.
 >>
 >>> It seems like what we need is for check-below to construct better
 >>> error messages in the case of function types. Because it currently
 >>> does a good job of only bringing up filters if they are necessary in
 >>> the first order case.
 >>
 >> I agree.
 >>
 >> Sam
 >>
 >>> On Wed, Mar 26, 2014 at 9:19 AM, Sam Tobin-Hochstadt
 >>> <samth@cs.indiana.edu> wrote:
 >>>> On Wed, Mar 26, 2014 at 12:06 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>
 >>>>> The only way that I can see filters ocurring is that a user writes
 >>>>> (define (f x) <body>) and we infer filters during the body, and
 >>>>> incorporate them into result part of f. Then the only time this would
 >>>>> be revealed to the user is if those filters do not line up with
 >>>>> expectations. But in those cases the expected filters must be non
 >>>>> trivial and so revealing to the user that filters exist and are
 >>>>> complicated is required.
 >>>>
 >>>> The simplest place this comes up is that (lambda (x) x) has
 >>>> non-trivial filters.  You can see that easily either by just typing it
 >>>> in at the repl and looking at the type you get (I'm pretty sure I
 >>>> remember people asking "what are these other things in the type?"), or
 >>>> by writing a program like this:
 >>>>
 >>>> (define a (lambda ([x : Integer]) x))
 >>>> (define b : (Number -> Number) a)
 >>>>
 >>>> Right now, the error message doesn't mention filters, and adding them
 >>>> in would be confusing -- it makes it look like the problem is the
 >>>> difference in filters.
 >>>>
 >>>> Sam
 >
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Neil Toronto <neil.toronto@gmail.com>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 09:49:14 -0700

 Sorry Sam's example differs in more than filters, but I still believe
 that if the expected has filters then the error message should.
 
 On Wed, Mar 26, 2014 at 9:48 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > I think it is 'does the expected have (non-trivial) filters', since
 > differing only in filters happens in both Sam and my examples, but I
 > believe we only want the filters to show up in mine.
 >
 > On Wed, Mar 26, 2014 at 9:45 AM, Sam Tobin-Hochstadt
 > <samth@cs.indiana.edu> wrote:
 >> Well, what you really want is "do expected and given differ only in filters".
 >>
 >> Sam
 >>
 >> On Wed, Mar 26, 2014 at 12:43 PM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> Can we have a metric for such error messages that says "if expected is too close to given, print filters too".
 >>>
 >>>
 >>> On Mar 26, 2014, at 12:36 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>
 >>>> On Wed, Mar 26, 2014 at 12:31 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>> I think that that this error message is worse.
 >>>>>
 >>>>> tmp/tmp.rkt:9:10: Type Checker: type mismatch
 >>>>>  expected: (-> Integer Integer)
 >>>>>  given: (-> Integer Integer)
 >>>>>  in: a
 >>>>>  context...:
 >>>>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-toplevel.rkt:249:0:
 >>>>> type-check
 >>>>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/tc-setup.rkt:82:0:
 >>>>> tc-module/full
 >>>>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typed-racket.rkt:25:4
 >>>>>   standard-module-name-resolver
 >>>>>
 >>>>> for the program
 >>>>>
 >>>>> #lang typed/racket
 >>>>>
 >>>>> (: a (Integer -> Integer))
 >>>>> (define (a x) x)
 >>>>>
 >>>>> (: b (Integer -> Integer : #:+ (Integer @ 0)))
 >>>>> (define b a)
 >>>>>
 >>>>> Even if I understand filters, the error message is useless.
 >>>>
 >>>> Right, I agree that this is a problem. But I don't think
 >>>> unconditionally printing filters is the solution.
 >>>>
 >>>>> It seems like what we need is for check-below to construct better
 >>>>> error messages in the case of function types. Because it currently
 >>>>> does a good job of only bringing up filters if they are necessary in
 >>>>> the first order case.
 >>>>
 >>>> I agree.
 >>>>
 >>>> Sam
 >>>>
 >>>>> On Wed, Mar 26, 2014 at 9:19 AM, Sam Tobin-Hochstadt
 >>>>> <samth@cs.indiana.edu> wrote:
 >>>>>> On Wed, Mar 26, 2014 at 12:06 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>
 >>>>>>> The only way that I can see filters ocurring is that a user writes
 >>>>>>> (define (f x) <body>) and we infer filters during the body, and
 >>>>>>> incorporate them into result part of f. Then the only time this would
 >>>>>>> be revealed to the user is if those filters do not line up with
 >>>>>>> expectations. But in those cases the expected filters must be non
 >>>>>>> trivial and so revealing to the user that filters exist and are
 >>>>>>> complicated is required.
 >>>>>>
 >>>>>> The simplest place this comes up is that (lambda (x) x) has
 >>>>>> non-trivial filters.  You can see that easily either by just typing it
 >>>>>> in at the repl and looking at the type you get (I'm pretty sure I
 >>>>>> remember people asking "what are these other things in the type?"), or
 >>>>>> by writing a program like this:
 >>>>>>
 >>>>>> (define a (lambda ([x : Integer]) x))
 >>>>>> (define b : (Number -> Number) a)
 >>>>>>
 >>>>>> Right now, the error message doesn't mention filters, and adding them
 >>>>>> in would be confusing -- it makes it look like the problem is the
 >>>>>> difference in filters.
 >>>>>>
 >>>>>> Sam
 >>>
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Neil Toronto <neil.toronto@gmail.com>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 09:48:17 -0700

 I think it is 'does the expected have (non-trivial) filters', since
 differing only in filters happens in both Sam and my examples, but I
 believe we only want the filters to show up in mine.
 
 On Wed, Mar 26, 2014 at 9:45 AM, Sam Tobin-Hochstadt
 <samth@cs.indiana.edu> wrote:
 > Well, what you really want is "do expected and given differ only in filters".
 >
 > Sam
 >
 > On Wed, Mar 26, 2014 at 12:43 PM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >>
 >> Can we have a metric for such error messages that says "if expected is too close to given, print filters too".
 >>
 >>
 >> On Mar 26, 2014, at 12:36 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>
 >>> On Wed, Mar 26, 2014 at 12:31 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> I think that that this error message is worse.
 >>>>
 >>>> tmp/tmp.rkt:9:10: Type Checker: type mismatch
 >>>>  expected: (-> Integer Integer)
 >>>>  given: (-> Integer Integer)
 >>>>  in: a
 >>>>  context...:
 >>>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-toplevel.rkt:249:0:
 >>>> type-check
 >>>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/tc-setup.rkt:82:0:
 >>>> tc-module/full
 >>>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typed-racket.rkt:25:4
 >>>>   standard-module-name-resolver
 >>>>
 >>>> for the program
 >>>>
 >>>> #lang typed/racket
 >>>>
 >>>> (: a (Integer -> Integer))
 >>>> (define (a x) x)
 >>>>
 >>>> (: b (Integer -> Integer : #:+ (Integer @ 0)))
 >>>> (define b a)
 >>>>
 >>>> Even if I understand filters, the error message is useless.
 >>>
 >>> Right, I agree that this is a problem. But I don't think
 >>> unconditionally printing filters is the solution.
 >>>
 >>>> It seems like what we need is for check-below to construct better
 >>>> error messages in the case of function types. Because it currently
 >>>> does a good job of only bringing up filters if they are necessary in
 >>>> the first order case.
 >>>
 >>> I agree.
 >>>
 >>> Sam
 >>>
 >>>> On Wed, Mar 26, 2014 at 9:19 AM, Sam Tobin-Hochstadt
 >>>> <samth@cs.indiana.edu> wrote:
 >>>>> On Wed, Mar 26, 2014 at 12:06 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>
 >>>>>> The only way that I can see filters ocurring is that a user writes
 >>>>>> (define (f x) <body>) and we infer filters during the body, and
 >>>>>> incorporate them into result part of f. Then the only time this would
 >>>>>> be revealed to the user is if those filters do not line up with
 >>>>>> expectations. But in those cases the expected filters must be non
 >>>>>> trivial and so revealing to the user that filters exist and are
 >>>>>> complicated is required.
 >>>>>
 >>>>> The simplest place this comes up is that (lambda (x) x) has
 >>>>> non-trivial filters.  You can see that easily either by just typing it
 >>>>> in at the repl and looking at the type you get (I'm pretty sure I
 >>>>> remember people asking "what are these other things in the type?"), or
 >>>>> by writing a program like this:
 >>>>>
 >>>>> (define a (lambda ([x : Integer]) x))
 >>>>> (define b : (Number -> Number) a)
 >>>>>
 >>>>> Right now, the error message doesn't mention filters, and adding them
 >>>>> in would be confusing -- it makes it look like the problem is the
 >>>>> difference in filters.
 >>>>>
 >>>>> Sam
 >>
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Neil Toronto <neil.toronto@gmail.com>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 12:57:41 -0400

 I think that makes sense as a heuristic for the moment.
 
 Sam
 
 On Wed, Mar 26, 2014 at 12:49 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > Sorry Sam's example differs in more than filters, but I still believe
 > that if the expected has filters then the error message should.
 >
 > On Wed, Mar 26, 2014 at 9:48 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> I think it is 'does the expected have (non-trivial) filters', since
 >> differing only in filters happens in both Sam and my examples, but I
 >> believe we only want the filters to show up in mine.
 >>
 >> On Wed, Mar 26, 2014 at 9:45 AM, Sam Tobin-Hochstadt
 >> <samth@cs.indiana.edu> wrote:
 >>> Well, what you really want is "do expected and given differ only in filters".
 >>>
 >>> Sam
 >>>
 >>> On Wed, Mar 26, 2014 at 12:43 PM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>>
 >>>> Can we have a metric for such error messages that says "if expected is too close to given, print filters too".
 >>>>
 >>>>
 >>>> On Mar 26, 2014, at 12:36 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>>
 >>>>> On Wed, Mar 26, 2014 at 12:31 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>> I think that that this error message is worse.
 >>>>>>
 >>>>>> tmp/tmp.rkt:9:10: Type Checker: type mismatch
 >>>>>>  expected: (-> Integer Integer)
 >>>>>>  given: (-> Integer Integer)
 >>>>>>  in: a
 >>>>>>  context...:
 >>>>>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-toplevel.rkt:249:0:
 >>>>>> type-check
 >>>>>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/tc-setup.rkt:82:0:
 >>>>>> tc-module/full
 >>>>>>   /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typed-racket.rkt:25:4
 >>>>>>   standard-module-name-resolver
 >>>>>>
 >>>>>> for the program
 >>>>>>
 >>>>>> #lang typed/racket
 >>>>>>
 >>>>>> (: a (Integer -> Integer))
 >>>>>> (define (a x) x)
 >>>>>>
 >>>>>> (: b (Integer -> Integer : #:+ (Integer @ 0)))
 >>>>>> (define b a)
 >>>>>>
 >>>>>> Even if I understand filters, the error message is useless.
 >>>>>
 >>>>> Right, I agree that this is a problem. But I don't think
 >>>>> unconditionally printing filters is the solution.
 >>>>>
 >>>>>> It seems like what we need is for check-below to construct better
 >>>>>> error messages in the case of function types. Because it currently
 >>>>>> does a good job of only bringing up filters if they are necessary in
 >>>>>> the first order case.
 >>>>>
 >>>>> I agree.
 >>>>>
 >>>>> Sam
 >>>>>
 >>>>>> On Wed, Mar 26, 2014 at 9:19 AM, Sam Tobin-Hochstadt
 >>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>> On Wed, Mar 26, 2014 at 12:06 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>
 >>>>>>>> The only way that I can see filters ocurring is that a user writes
 >>>>>>>> (define (f x) <body>) and we infer filters during the body, and
 >>>>>>>> incorporate them into result part of f. Then the only time this would
 >>>>>>>> be revealed to the user is if those filters do not line up with
 >>>>>>>> expectations. But in those cases the expected filters must be non
 >>>>>>>> trivial and so revealing to the user that filters exist and are
 >>>>>>>> complicated is required.
 >>>>>>>
 >>>>>>> The simplest place this comes up is that (lambda (x) x) has
 >>>>>>> non-trivial filters.  You can see that easily either by just typing it
 >>>>>>> in at the repl and looking at the type you get (I'm pretty sure I
 >>>>>>> remember people asking "what are these other things in the type?"), or
 >>>>>>> by writing a program like this:
 >>>>>>>
 >>>>>>> (define a (lambda ([x : Integer]) x))
 >>>>>>> (define b : (Number -> Number) a)
 >>>>>>>
 >>>>>>> Right now, the error message doesn't mention filters, and adding them
 >>>>>>> in would be confusing -- it makes it look like the problem is the
 >>>>>>> difference in filters.
 >>>>>>>
 >>>>>>> Sam
 >>>>
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Neil Toronto <neil.toronto@gmail.com>,
        Asumu Takikawa <asumu@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14423: TR should print more complicated filters
Date: Wed, 26 Mar 2014 13:39:18 -0400

 Let's try it out. 
 
 On Mar 26, 2014, at 12:57 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > I think that makes sense as a heuristic for the moment.
 > 
 > Sam
 > 
 > On Wed, Mar 26, 2014 at 12:49 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> Sorry Sam's example differs in more than filters, but I still believe
 >> that if the expected has filters then the error message should.
 >> 
 >> On Wed, Mar 26, 2014 at 9:48 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>> I think it is 'does the expected have (non-trivial) filters', since
 >>> differing only in filters happens in both Sam and my examples, but I
 >>> believe we only want the filters to show up in mine.
 >>> 
 >>> On Wed, Mar 26, 2014 at 9:45 AM, Sam Tobin-Hochstadt
 >>> <samth@cs.indiana.edu> wrote:
 >>>> Well, what you really want is "do expected and given differ only in filters".
 >>>> 
 >>>> Sam
 >>>> 
 >>>> On Wed, Mar 26, 2014 at 12:43 PM, Matthias Felleisen
 >>>> <matthias@ccs.neu.edu> wrote:
 >>>>> 
 >>>>> Can we have a metric for such error messages that says "if expected is too close to given, print filters too".
 >>>>> 
 >>>>> 
 >>>>> On Mar 26, 2014, at 12:36 PM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >>>>> 
 >>>>>> On Wed, Mar 26, 2014 at 12:31 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>> I think that that this error message is worse.
 >>>>>>> 
 >>>>>>> tmp/tmp.rkt:9:10: Type Checker: type mismatch
 >>>>>>> expected: (-> Integer Integer)
 >>>>>>> given: (-> Integer Integer)
 >>>>>>> in: a
 >>>>>>> context...:
 >>>>>>>  /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-toplevel.rkt:249:0:
 >>>>>>> type-check
 >>>>>>>  /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/tc-setup.rkt:82:0:
 >>>>>>> tc-module/full
 >>>>>>>  /Users/endobson/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typed-racket.rkt:25:4
 >>>>>>>  standard-module-name-resolver
 >>>>>>> 
 >>>>>>> for the program
 >>>>>>> 
 >>>>>>> #lang typed/racket
 >>>>>>> 
 >>>>>>> (: a (Integer -> Integer))
 >>>>>>> (define (a x) x)
 >>>>>>> 
 >>>>>>> (: b (Integer -> Integer : #:+ (Integer @ 0)))
 >>>>>>> (define b a)
 >>>>>>> 
 >>>>>>> Even if I understand filters, the error message is useless.
 >>>>>> 
 >>>>>> Right, I agree that this is a problem. But I don't think
 >>>>>> unconditionally printing filters is the solution.
 >>>>>> 
 >>>>>>> It seems like what we need is for check-below to construct better
 >>>>>>> error messages in the case of function types. Because it currently
 >>>>>>> does a good job of only bringing up filters if they are necessary in
 >>>>>>> the first order case.
 >>>>>> 
 >>>>>> I agree.
 >>>>>> 
 >>>>>> Sam
 >>>>>> 
 >>>>>>> On Wed, Mar 26, 2014 at 9:19 AM, Sam Tobin-Hochstadt
 >>>>>>> <samth@cs.indiana.edu> wrote:
 >>>>>>>> On Wed, Mar 26, 2014 at 12:06 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>>>> 
 >>>>>>>>> The only way that I can see filters ocurring is that a user writes
 >>>>>>>>> (define (f x) <body>) and we infer filters during the body, and
 >>>>>>>>> incorporate them into result part of f. Then the only time this would
 >>>>>>>>> be revealed to the user is if those filters do not line up with
 >>>>>>>>> expectations. But in those cases the expected filters must be non
 >>>>>>>>> trivial and so revealing to the user that filters exist and are
 >>>>>>>>> complicated is required.
 >>>>>>>> 
 >>>>>>>> The simplest place this comes up is that (lambda (x) x) has
 >>>>>>>> non-trivial filters.  You can see that easily either by just typing it
 >>>>>>>> in at the repl and looking at the type you get (I'm pretty sure I
 >>>>>>>> remember people asking "what are these other things in the type?"), or
 >>>>>>>> by writing a program like this:
 >>>>>>>> 
 >>>>>>>> (define a (lambda ([x : Integer]) x))
 >>>>>>>> (define b : (Number -> Number) a)
 >>>>>>>> 
 >>>>>>>> Right now, the error message doesn't mention filters, and adding them
 >>>>>>>> in would be confusing -- it makes it look like the problem is the
 >>>>>>>> difference in filters.
 >>>>>>>> 
 >>>>>>>> Sam
 >>>>> 
 
 


----------
A commit by asumu@racket-lang.org was marked as relevant
  http://git.racket-lang.org/plt/commit/6c97d96853
  | Add a syntax for some asymmetric predicate filters
  | 
  | Relevant for PR 14423

