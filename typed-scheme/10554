From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Sun Nov  1 02:27:41 2009
Received: from mail-yx0-f192.google.com (mail-yx0-f192.google.com [209.85.210.192])
	by champlain.ccs.neu.edu (8.14.2/8.14.2) with ESMTP id nA17RbZI031515
	for <bugs@bugs.plt-scheme.org>; Sun, 1 Nov 2009 02:27:37 -0500
Message-Id: <200911010727.nA17RZKf031508@champlain.ccs.neu.edu>
Date: Sun, 1 Nov 2009 02:27:35 -0500
From: eli@barzilay.org
To: bugs@plt-scheme.org
Subject: TS: haunted lists

>Number:         10554
>Category:       typed-scheme
>Synopsis:       TS: haunted lists
>Class:          sw-bug
>Responsible:    samth
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Sun Nov 01 02:28:01 -0500 2009
>Closed-Date:    Wed Jan 06 20:08:18 -0500 2010
>Last-Modified:  Wed Jan 06 23:04:01 -0500 2010
>Originator:     Eli Barzilay
>Organization:
plt
>Submitter-Id:   unknown
>Release:        4.2.2
>Environment:
unix "Linux winooski.ccs.neu.edu 2.6.23.17-88.fc7 #1 SMP Thu May 15 00:02:29 EDT 2008 x86_64 x86_64 x86_64 GNU/Linux" (x86_64-linux/3m) (get-display-depth) = 16
Human Language: english
(current-memory-use) 421988808

Collections:
(("/home/eli/.plt-scheme/4.2.2/collects" "info-domain" "pl") ("/home/eli/plt/collects" "icons" "ffi" "mred" "dynext" "mzscheme" "make" "preprocessor" "file" "openssl" "sgl" "scriblib" "s-exp" "slideshow" "mysterx" "graphics" "test-engine" "scheme" "frtime" "wxme" "lazy" "mzlib" "macro-debugger" "scribble" "syntax-color" "mzcom" "help" "swindle" "config" "net" "hierlist" "test-box-recovery" "2htdp" "profile" "trace" "mrlib" "algol60" "browser" "framework" "typed-scheme" "at-exp" "info-domain" "compiler" "errortrace" "eopl" "syntax" "combinator-parser" "string-constants" "html" "slatex" "stepper" "launcher" "htdp" "lang" "rnrs" "setup" "deinprogramm" "plot" "teachpack" "xml" "scribblings" "planet" "readline" "parser-tools" "embedded-gui" "drscheme" "defaults" "srfi" "afm" "r6rs" "version" "typed" "texpict" "games" "tex2page" "gui-debugger" "web-server" "r5rs" "redex"))
Computer Language: (("Module") (#(#t write mixed-fraction-e #f #t debug) (default) #() "#lang scheme\n" #t))
>Description:
Given the program below, things usually work fine:

  > (flip string-ref)
  - : (Number String -> Char)
  #<procedure>

but, with `list-ref', something goes wrong:

  > (flip list-ref)
  - : (Integer (U '() (Pair (U) (Listof (U)))) -> Any)
  #<procedure>

and a similar thing haunts `cons', only here the rash has spread to the other
argument too:

  > (flip cons)
  - : ((U '() (Pair (U) (Listof (U)))) (U) -> (Listof Any))
>How-To-Repeat:
#lang typed-scheme
(: flip (All (A B C) ((A B -> C) -> (B A -> C))))
(define (flip f) (lambda (x y) (f y x)))
>Fix:
>Audit-Trail:
Responsible changed from "nobody" to "samth" by samth at Sun, 01 Nov 2009 07:35:22 -0500
Reason>>> ts

State changed from "open" to "closed" by samth at Sun, 01 Nov 2009 07:35:22 -0500
Reason>>> not a bug

From: Sam TH <samth@ccs.neu.edu>
To: eli@barzilay.org, bugs@plt-scheme.org
Cc: 
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 08:37:20 -0400

 On Sun, Nov 1, 2009 at 3:28 AM,  <eli@barzilay.org> wrote:
 > A new problem report is waiting at
 > =A0http://bugs.plt-scheme.org/query/?cmd=3Dview&pr=3D10554
 >
 > Reported by Eli Barzilay for release: 4.2.2
 >
 > *** Description:
 > Given the program below, things usually work fine:
 >
 > =A0> (flip string-ref)
 > =A0- : (Number String -> Char)
 > =A0#<procedure>
 >
 > but, with `list-ref', something goes wrong:
 >
 > =A0> (flip list-ref)
 > =A0- : (Integer (U '() (Pair (U) (Listof (U)))) -> Any)
 > =A0#<procedure>
 >
 > and a similar thing haunts `cons', only here the rash has spread to the o=
 ther
 > argument too:
 >
 > =A0> (flip cons)
 > =A0- : ((U '() (Pair (U) (Listof (U)))) (U) -> (Listof Any))
 
 This isn't a bug.  Typed Scheme isn't ML - it won't generalize these
 to be polymorphic functions.  In order to get the answer you want,
 you'll need to explicitly indicate the type you want to instantiate
 `cons' or `list-ref' at.
 --=20
 sam th
 samth@ccs.neu.edu

State changed from "closed" to "open" by eli at Sun, 01 Nov 2009 13:19:16 -0500
Reason>>> !

From: Eli Barzilay <eli@barzilay.org>
To: Sam TH <samth@ccs.neu.edu>
Cc: bugs@plt-scheme.org, Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 13:27:31 -0500

 On Nov  1, Sam TH wrote:
 > On Sun, Nov 1, 2009 at 3:28 AM,  <eli@barzilay.org> wrote:
 > > A new problem report is waiting at
 > > =C2=A0http://bugs.plt-scheme.org/query/=3Fcmd=3Dview&pr=3D10554
 > >
 > > Reported by Eli Barzilay for release: 4.2.2
 > >
 > > *** Description:
 > > Given the program below, things usually work fine:
 > >
 > > =C2=A0> (flip string-ref)
 > > =C2=A0- : (Number String -> Char)
 > > =C2=A0#<procedure>
 > >
 > > but, with `list-ref', something goes wrong:
 > >
 > > =C2=A0> (flip list-ref)
 > > =C2=A0- : (Integer (U '() (Pair (U) (Listof (U)))) -> Any)
 > > =C2=A0#<procedure>
 > >
 > > and a similar thing haunts `cons', only here the rash has spread to=
  the other
 > > argument too:
 > >
 > > =C2=A0> (flip cons)
 > > =C2=A0- : ((U '() (Pair (U) (Listof (U)))) (U) -> (Listof Any))
 >=20
 > This isn't a bug.  Typed Scheme isn't ML - it won't generalize these
 > to be polymorphic functions.  In order to get the answer you want,
 > you'll need to explicitly indicate the type you want to instantiate
 > `cons' or `list-ref' at.
 
 I've tried it with
 
   (define snoc (flip (ann cons (All (A) (A (Listof A) -> (Listof A)))))=
 )
 
 which doesn't work (see the other email with eta expansion).  The next
 step was
 
   (: kons : (All (A) (A (Listof A) -> (Listof A))))
   (define (kons x xs) (cons x xs))
   (define snok (flip kons))
 
 and that's still bogus.
 
 Eventually, I was able to do this by using a very specific type,
 
   (define snoc
     (flip (ann cons (Integer (Listof Integer) -> (Listof Integer)))))
 
 which produces a strange type:
 
   - : ((U '() (Pair Integer (Listof Integer))) Integer -> (Listof Integ=
 er))
 
 In any case, this whole thing means that a function like `flip' is
 not practical for use in typed scheme.  That is, IMO, definitely a
 bug.
 
 --=20
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay=
 :
                     http://barzilay.org/                   Maze is Life=
 !
From: Sam TH <samth@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: bugs@plt-scheme.org, Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 16:43:31 -0500

 On Sun, Nov 1, 2009 at 1:27 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > On Nov =A01, Sam TH wrote:
 >> On Sun, Nov 1, 2009 at 3:28 AM, =A0<eli@barzilay.org> wrote:
 >> > A new problem report is waiting at
 >> > =A0http://bugs.plt-scheme.org/query/?cmd=3Dview&pr=3D10554
 >> >
 >> > Reported by Eli Barzilay for release: 4.2.2
 >> >
 >> > *** Description:
 >> > Given the program below, things usually work fine:
 >> >
 >> > =A0> (flip string-ref)
 >> > =A0- : (Number String -> Char)
 >> > =A0#<procedure>
 >> >
 >> > but, with `list-ref', something goes wrong:
 >> >
 >> > =A0> (flip list-ref)
 >> > =A0- : (Integer (U '() (Pair (U) (Listof (U)))) -> Any)
 >> > =A0#<procedure>
 >> >
 >> > and a similar thing haunts `cons', only here the rash has spread to th=
 e other
 >> > argument too:
 >> >
 >> > =A0> (flip cons)
 >> > =A0- : ((U '() (Pair (U) (Listof (U)))) (U) -> (Listof Any))
 >>
 >> This isn't a bug. =A0Typed Scheme isn't ML - it won't generalize these
 >> to be polymorphic functions. =A0In order to get the answer you want,
 >> you'll need to explicitly indicate the type you want to instantiate
 >> `cons' or `list-ref' at.
 >
 > I've tried it with
 >
 > =A0(define snoc (flip (ann cons (All (A) (A (Listof A) -> (Listof A))))))
 >
 > which doesn't work (see the other email with eta expansion). =A0The next
 > step was
 >
 > =A0(: kons : (All (A) (A (Listof A) -> (Listof A))))
 > =A0(define (kons x xs) (cons x xs))
 > =A0(define snok (flip kons))
 >
 > and that's still bogus.
 >
 > Eventually, I was able to do this by using a very specific type,
 >
 > =A0(define snoc
 > =A0 =A0(flip (ann cons (Integer (Listof Integer) -> (Listof Integer)))))
 >
 > which produces a strange type:
 >
 > =A0- : ((U '() (Pair Integer (Listof Integer))) Integer -> (Listof Intege=
 r))
 >
 > In any case, this whole thing means that a function like `flip' is
 > not practical for use in typed scheme. =A0That is, IMO, definitely a
 > bug.
 
 
 First, what I said was that you need to *instantiate* it with the
 appropriate type.  The problem is that polymorphic arguments to
 polymorphic functions isn't handled by the inference algorithm.
 That's not a bug, that's an open research problem.  Would you
 preferred that it errored whenever you tried to do that, instead of
 working in some cases?
 
 Either way, `flip' won't be very useful for `cons' in the near future,
 which is no more a 'bug' than the fact that occurrence typing doesn't
 work in ML.
 
 --=20
 sam th
 samth@ccs.neu.edu
From: Eli Barzilay <eli@barzilay.org>
To: Sam TH <samth@ccs.neu.edu>
Cc: bugs@plt-scheme.org, Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 16:50:51 -0500

 On Nov  1, Sam TH wrote:
 > On Sun, Nov 1, 2009 at 1:27 PM, Eli Barzilay <eli@barzilay.org> wrote=
 :
 > > On Nov =C2=A01, Sam TH wrote:
 > >> On Sun, Nov 1, 2009 at 3:28 AM, =C2=A0<eli@barzilay.org> wrote:
 > >> > A new problem report is waiting at
 > >> > =C2=A0http://bugs.plt-scheme.org/query/=3Fcmd=3Dview&pr=3D10554
 > >> >
 > >> > Reported by Eli Barzilay for release: 4.2.2
 > >> >
 > >> > *** Description:
 > >> > Given the program below, things usually work fine:
 > >> >
 > >> > =C2=A0> (flip string-ref)
 > >> > =C2=A0- : (Number String -> Char)
 > >> > =C2=A0#<procedure>
 > >> >
 > >> > but, with `list-ref', something goes wrong:
 > >> >
 > >> > =C2=A0> (flip list-ref)
 > >> > =C2=A0- : (Integer (U '() (Pair (U) (Listof (U)))) -> Any)
 > >> > =C2=A0#<procedure>
 > >> >
 > >> > and a similar thing haunts `cons', only here the rash has spread=
  to the other
 > >> > argument too:
 > >> >
 > >> > =C2=A0> (flip cons)
 > >> > =C2=A0- : ((U '() (Pair (U) (Listof (U)))) (U) -> (Listof Any))
 > >>
 > >> This isn't a bug. =C2=A0Typed Scheme isn't ML - it won't generaliz=
 e these
 > >> to be polymorphic functions. =C2=A0In order to get the answer you =
 want,
 > >> you'll need to explicitly indicate the type you want to instantiat=
 e
 > >> `cons' or `list-ref' at.
 > >
 > > I've tried it with
 > >
 > > =C2=A0(define snoc (flip (ann cons (All (A) (A (Listof A) -> (Listo=
 f A))))))
 > >
 > > which doesn't work (see the other email with eta expansion). =C2=A0=
 The next
 > > step was
 > >
 > > =C2=A0(: kons : (All (A) (A (Listof A) -> (Listof A))))
 > > =C2=A0(define (kons x xs) (cons x xs))
 > > =C2=A0(define snok (flip kons))
 > >
 > > and that's still bogus.
 > >
 > > Eventually, I was able to do this by using a very specific type,
 > >
 > > =C2=A0(define snoc
 > > =C2=A0 =C2=A0(flip (ann cons (Integer (Listof Integer) -> (Listof I=
 nteger)))))
 > >
 > > which produces a strange type:
 > >
 > > =C2=A0- : ((U '() (Pair Integer (Listof Integer))) Integer -> (List=
 of Integer))
 > >
 > > In any case, this whole thing means that a function like `flip' is
 > > not practical for use in typed scheme. =C2=A0That is, IMO, definite=
 ly a
 > > bug.
 >=20
 > First, what I said was that you need to *instantiate* it with the
 > appropriate type.  The problem is that polymorphic arguments to
 > polymorphic functions isn't handled by the inference algorithm.
 > That's not a bug, that's an open research problem.  Would you
 > preferred that it errored whenever you tried to do that, instead of
 > working in some cases=3F
 
 Yes -- an error message saying "you need to instantiate this type" is
 much better than getting a useless type with (U)s.  But even with the
 general problem, it seems weird that it doesn't handle such simple
 combinators like `flip', where doing the type inference seems like
 it's relatively simple.
 
 
 > Either way, `flip' won't be very useful for `cons' in the near
 > future, which is no more a 'bug' than the fact that occurrence
 > typing doesn't work in ML.
 
 So you should mark it as analyzed, which is for problems that are
 known but are not currently solvable.
 
 --=20
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay=
 :
                     http://barzilay.org/                   Maze is Life=
 !
From: Sam TH <samth@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: bugs@plt-scheme.org, Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 16:59:18 -0500

 On Sun, Nov 1, 2009 at 4:50 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > On Nov =A01, Sam TH wrote:
 >> On Sun, Nov 1, 2009 at 1:27 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> > On Nov =A01, Sam TH wrote:
 >> >> On Sun, Nov 1, 2009 at 3:28 AM, =A0<eli@barzilay.org> wrote:
 >> >> > A new problem report is waiting at
 >> >> > =A0http://bugs.plt-scheme.org/query/?cmd=3Dview&pr=3D10554
 >> >> >
 >> >> > Reported by Eli Barzilay for release: 4.2.2
 >> >> >
 >> >> > *** Description:
 >> >> > Given the program below, things usually work fine:
 >> >> >
 >> >> > =A0> (flip string-ref)
 >> >> > =A0- : (Number String -> Char)
 >> >> > =A0#<procedure>
 >> >> >
 >> >> > but, with `list-ref', something goes wrong:
 >> >> >
 >> >> > =A0> (flip list-ref)
 >> >> > =A0- : (Integer (U '() (Pair (U) (Listof (U)))) -> Any)
 >> >> > =A0#<procedure>
 >> >> >
 >> >> > and a similar thing haunts `cons', only here the rash has spread to=
  the other
 >> >> > argument too:
 >> >> >
 >> >> > =A0> (flip cons)
 >> >> > =A0- : ((U '() (Pair (U) (Listof (U)))) (U) -> (Listof Any))
 >> >>
 >> >> This isn't a bug. =A0Typed Scheme isn't ML - it won't generalize thes=
 e
 >> >> to be polymorphic functions. =A0In order to get the answer you want,
 >> >> you'll need to explicitly indicate the type you want to instantiate
 >> >> `cons' or `list-ref' at.
 >> >
 >> > I've tried it with
 >> >
 >> > =A0(define snoc (flip (ann cons (All (A) (A (Listof A) -> (Listof A)))=
 )))
 >> >
 >> > which doesn't work (see the other email with eta expansion). =A0The ne=
 xt
 >> > step was
 >> >
 >> > =A0(: kons : (All (A) (A (Listof A) -> (Listof A))))
 >> > =A0(define (kons x xs) (cons x xs))
 >> > =A0(define snok (flip kons))
 >> >
 >> > and that's still bogus.
 >> >
 >> > Eventually, I was able to do this by using a very specific type,
 >> >
 >> > =A0(define snoc
 >> > =A0 =A0(flip (ann cons (Integer (Listof Integer) -> (Listof Integer)))=
 ))
 >> >
 >> > which produces a strange type:
 >> >
 >> > =A0- : ((U '() (Pair Integer (Listof Integer))) Integer -> (Listof Int=
 eger))
 >> >
 >> > In any case, this whole thing means that a function like `flip' is
 >> > not practical for use in typed scheme. =A0That is, IMO, definitely a
 >> > bug.
 >>
 >> First, what I said was that you need to *instantiate* it with the
 >> appropriate type. =A0The problem is that polymorphic arguments to
 >> polymorphic functions isn't handled by the inference algorithm.
 >> That's not a bug, that's an open research problem. =A0Would you
 >> preferred that it errored whenever you tried to do that, instead of
 >> working in some cases?
 >
 > Yes -- an error message saying "you need to instantiate this type" is
 > much better than getting a useless type with (U)s. =A0But even with the
 > general problem, it seems weird that it doesn't handle such simple
 > combinators like `flip', where doing the type inference seems like
 > it's relatively simple.
 
 So, you think it's better to get that error in all cases than having
 it work in some cases, but not in others?
 
 >> Either way, `flip' won't be very useful for `cons' in the near
 >> future, which is no more a 'bug' than the fact that occurrence
 >> typing doesn't work in ML.
 >
 > So you should mark it as analyzed, which is for problems that are
 > known but are not currently solvable.
 
 This is not a bug!  It's not a 'bug that I've analyzed', any more than
 the fact that TS doesn't make your coffee in the morning is a bug.
 
 --=20
 sam th
 samth@ccs.neu.edu
From: Eli Barzilay <eli@barzilay.org>
To: Sam TH <samth@ccs.neu.edu>
Cc: bugs@plt-scheme.org, Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 17:05:15 -0500

 On Nov  1, Sam TH wrote:
 > On Sun, Nov 1, 2009 at 4:50 PM, Eli Barzilay <eli@barzilay.org> wrote=
 :
 > > On Nov =C2=A01, Sam TH wrote:
 > >> On Sun, Nov 1, 2009 at 1:27 PM, Eli Barzilay <eli@barzilay.org> wr=
 ote:
 > >> > On Nov =C2=A01, Sam TH wrote:
 > >> >> On Sun, Nov 1, 2009 at 3:28 AM, =C2=A0<eli@barzilay.org> wrote:=
 
 > >> >> > A new problem report is waiting at
 > >> >> > =C2=A0http://bugs.plt-scheme.org/query/=3Fcmd=3Dview&pr=3D105=
 54
 > >> >> >
 > >> >> > Reported by Eli Barzilay for release: 4.2.2
 > >> >> >
 > >> >> > *** Description:
 > >> >> > Given the program below, things usually work fine:
 > >> >> >
 > >> >> > =C2=A0> (flip string-ref)
 > >> >> > =C2=A0- : (Number String -> Char)
 > >> >> > =C2=A0#<procedure>
 > >> >> >
 > >> >> > but, with `list-ref', something goes wrong:
 > >> >> >
 > >> >> > =C2=A0> (flip list-ref)
 > >> >> > =C2=A0- : (Integer (U '() (Pair (U) (Listof (U)))) -> Any)
 > >> >> > =C2=A0#<procedure>
 > >> >> >
 > >> >> > and a similar thing haunts `cons', only here the rash has spr=
 ead to the other
 > >> >> > argument too:
 > >> >> >
 > >> >> > =C2=A0> (flip cons)
 > >> >> > =C2=A0- : ((U '() (Pair (U) (Listof (U)))) (U) -> (Listof Any=
 ))
 > >> >>
 > >> >> This isn't a bug. =C2=A0Typed Scheme isn't ML - it won't genera=
 lize these
 > >> >> to be polymorphic functions. =C2=A0In order to get the answer y=
 ou want,
 > >> >> you'll need to explicitly indicate the type you want to instant=
 iate
 > >> >> `cons' or `list-ref' at.
 > >> >
 > >> > I've tried it with
 > >> >
 > >> > =C2=A0(define snoc (flip (ann cons (All (A) (A (Listof A) -> (Li=
 stof A))))))
 > >> >
 > >> > which doesn't work (see the other email with eta expansion). =C2=
 =A0The next
 > >> > step was
 > >> >
 > >> > =C2=A0(: kons : (All (A) (A (Listof A) -> (Listof A))))
 > >> > =C2=A0(define (kons x xs) (cons x xs))
 > >> > =C2=A0(define snok (flip kons))
 > >> >
 > >> > and that's still bogus.
 > >> >
 > >> > Eventually, I was able to do this by using a very specific type,=
 
 > >> >
 > >> > =C2=A0(define snoc
 > >> > =C2=A0 =C2=A0(flip (ann cons (Integer (Listof Integer) -> (Listo=
 f Integer)))))
 > >> >
 > >> > which produces a strange type:
 > >> >
 > >> > =C2=A0- : ((U '() (Pair Integer (Listof Integer))) Integer -> (L=
 istof Integer))
 > >> >
 > >> > In any case, this whole thing means that a function like `flip' =
 is
 > >> > not practical for use in typed scheme. =C2=A0That is, IMO, defin=
 itely a
 > >> > bug.
 > >>
 > >> First, what I said was that you need to *instantiate* it with the
 > >> appropriate type. =C2=A0The problem is that polymorphic arguments =
 to
 > >> polymorphic functions isn't handled by the inference algorithm.
 > >> That's not a bug, that's an open research problem. =C2=A0Would you=
 
 > >> preferred that it errored whenever you tried to do that, instead o=
 f
 > >> working in some cases=3F
 > >
 > > Yes -- an error message saying "you need to instantiate this type" =
 is
 > > much better than getting a useless type with (U)s. =C2=A0But even w=
 ith the
 > > general problem, it seems weird that it doesn't handle such simple
 > > combinators like `flip', where doing the type inference seems like
 > > it's relatively simple.
 >=20
 > So, you think it's better to get that error in all cases than having
 > it work in some cases, but not in others=3F
 
 I don't know about other cases.  The specific type that I got for
 (flip cons) was useless enough that an error would be better.
 
 
 > >> Either way, `flip' won't be very useful for `cons' in the near
 > >> future, which is no more a 'bug' than the fact that occurrence
 > >> typing doesn't work in ML.
 > >
 > > So you should mark it as analyzed, which is for problems that are
 > > known but are not currently solvable.
 >=20
 > This is not a bug!  It's not a 'bug that I've analyzed', any more
 > than the fact that TS doesn't make your coffee in the morning is a
 > bug.
 
 It is a bug in the sense that a relatively simple piece of code is not
 usable in TS.  It's a bug in the sense that TS is supposed to make it
 possible to type Scheme code -- in the same way that with a
 conventional HM type system I'd complain about the lack of unions as a
 bug.
 
 --=20
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay=
 :
                     http://barzilay.org/                   Maze is Life=
 !
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Sam TH <samth@ccs.neu.edu>, bugs@plt-scheme.org
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 19:07:16 -0500

 On Nov 1, 2009, at 5:05 PM, Eli Barzilay wrote:
 
 > in the same way that with a
 > conventional HM type system I'd complain about the lack of unions as a
 > bug.
 
 
 And the ML people would NEVER EVER leave this kind of bug report open.  
 I have to agree with Sam here, based on my experience with Andrew and  
 the value restriction. This is an open RESEARCH PROBLEM not an OPEN/ 
 ANALYZED bug report.
 
From: Eli Barzilay <eli@barzilay.org>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam TH <samth@ccs.neu.edu>, bugs@plt-scheme.org
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 20:37:21 -0500

 On Nov  1, Matthias Felleisen wrote:
 > On Nov 1, 2009, at 5:05 PM, Eli Barzilay wrote:
 > 
 > > in the same way that with a conventional HM type system I'd
 > > complain about the lack of unions as a bug.
 > 
 > And the ML people would NEVER EVER leave this kind of bug report open.  
 
 Exactly -- and that's the whole point: the ML people had the type
 system as a something set in stone...  If you run into some problem
 with it, then there's nothing to do -- either learn to work around it,
 or switch to a different language.  OTOH, the whole idea with TS, at
 least as much as I've seen you publicize it as, is "you can add types
 to any Scheme code".  If you're taking this "any" as "any, provided
 it's not using X, Y, or Z", then this is qualitatively the same as
 using the ML type system when "X, Y, Z" are chosen differently.
 
 
 > I have to agree with Sam here, based on my experience with Andrew and  
 > the value restriction. This is an open RESEARCH PROBLEM not an OPEN/ 
 > ANALYZED bug report.
 
 And so is a statically typed language with arbitrary unions, and
 fighting to get that right was important enough to do.  Don't get me
 wrong: I completely understand your point -- I'm just saying that this
 point reads to me as "we wanted to allow static typing of arbitrary
 Scheme code, we now covered 95% of such code, the last 5% is not worth
 the effort".  Seal this bug report as "not a bug", and (IMO) this
 confirms this view.
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Sam TH <samth@ccs.neu.edu>, bugs@plt-scheme.org
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 22:35:57 -0500

 On Nov 1, 2009, at 8:37 PM, Eli Barzilay wrote:
 
 > On Nov  1, Matthias Felleisen wrote:
 >> On Nov 1, 2009, at 5:05 PM, Eli Barzilay wrote:
 >>
 >>> in the same way that with a conventional HM type system I'd
 >>> complain about the lack of unions as a bug.
 >>
 >> And the ML people would NEVER EVER leave this kind of bug report  
 >> open.
 >
 > Exactly -- and that's the whole point: the ML people had the type
 > system as a something set in stone...  If you run into some problem
 > with it, then there's nothing to do -- either learn to work around it,
 > or switch to a different language.  OTOH, the whole idea with TS, at
 > least as much as I've seen you publicize it as, is "you can add types
 > to any Scheme code".  If you're taking this "any" as "any, provided
 > it's not using X, Y, or Z", then this is qualitatively the same as
 > using the ML type system when "X, Y, Z" are chosen differently.
 
 
 Nope. We allow you to leave code in untyped form. ML doesn't.
 
 
 
 >> I have to agree with Sam here, based on my experience with Andrew and
 >> the value restriction. This is an open RESEARCH PROBLEM not an OPEN/
 >> ANALYZED bug report.
 >
 > And so is a statically typed language with arbitrary unions, and
 > fighting to get that right was important enough to do.  Don't get me
 > wrong: I completely understand your point -- I'm just saying that this
 > point reads to me as "we wanted to allow static typing of arbitrary
 > Scheme code, we now covered 95% of such code, the last 5% is not worth
 > the effort".  Seal this bug report as "not a bug", and (IMO) this
 > confirms this view.
 
 
 Again, this is about research not a small bug. I can see you asking
 Sam to put this on his list but not as a bug. (BTW, my hunch is that
 this canNOT be done; ever)
 
From: Eli Barzilay <eli@barzilay.org>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam TH <samth@ccs.neu.edu>, bugs@plt-scheme.org
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 22:50:27 -0500

 On Nov  1, Matthias Felleisen wrote:
 > On Nov 1, 2009, at 8:37 PM, Eli Barzilay wrote:
 > 
 > > On Nov  1, Matthias Felleisen wrote:
 > >
 > > Exactly -- and that's the whole point: the ML people had the type
 > > system as a something set in stone...  If you run into some
 > > problem with it, then there's nothing to do -- either learn to
 > > work around it, or switch to a different language.  OTOH, the
 > > whole idea with TS, at least as much as I've seen you publicize it
 > > as, is "you can add types to any Scheme code".  If you're taking
 > > this "any" as "any, provided it's not using X, Y, or Z", then this
 > > is qualitatively the same as using the ML type system when "X, Y,
 > > Z" are chosen differently.
 > 
 > Nope. We allow you to leave code in untyped form. ML doesn't.
 
 But this doesn't help me to *use* `flip' in TS code.  You could just
 as well go with any type system -- including ML -- since the result is
 still in PLT, then I can always leave code untyped.  (Alternatively,
 if we take PLT as a collection of languages, then "leaving code
 untyped" is the same as "switch to a different language" in the
 above.)
 
 
 > >> I have to agree with Sam here, based on my experience with Andrew
 > >> and the value restriction. This is an open RESEARCH PROBLEM not
 > >> an OPEN/ ANALYZED bug report.
 > >
 > > And so is a statically typed language with arbitrary unions, and
 > > fighting to get that right was important enough to do.  Don't get
 > > me wrong: I completely understand your point -- I'm just saying
 > > that this point reads to me as "we wanted to allow static typing
 > > of arbitrary Scheme code, we now covered 95% of such code, the
 > > last 5% is not worth the effort".  Seal this bug report as "not a
 > > bug", and (IMO) this confirms this view.
 > 
 > Again, this is about research not a small bug. I can see you asking
 > Sam to put this on his list but not as a bug. (BTW, my hunch is that
 > this canNOT be done; ever)
 
 This sounds odd, so I'll bite.  For *just* the type of `flip' that I
 used,
 
   (: flip (All (A B C) ((A B -> C) -> (B A -> C))))
 
 what goes wrong if I allow the system to do the obvious thing?
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Sam TH <samth@ccs.neu.edu>, bugs@plt-scheme.org
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 22:52:39 -0500

 type inference goes wrong. It would go wrong in ML, Haskell, and the  
 local inference algorithm.
 
 
 
 
 
 On Nov 1, 2009, at 10:50 PM, Eli Barzilay wrote:
 
 > On Nov  1, Matthias Felleisen wrote:
 >> On Nov 1, 2009, at 8:37 PM, Eli Barzilay wrote:
 >>
 >>> On Nov  1, Matthias Felleisen wrote:
 >>>
 >>> Exactly -- and that's the whole point: the ML people had the type
 >>> system as a something set in stone...  If you run into some
 >>> problem with it, then there's nothing to do -- either learn to
 >>> work around it, or switch to a different language.  OTOH, the
 >>> whole idea with TS, at least as much as I've seen you publicize it
 >>> as, is "you can add types to any Scheme code".  If you're taking
 >>> this "any" as "any, provided it's not using X, Y, or Z", then this
 >>> is qualitatively the same as using the ML type system when "X, Y,
 >>> Z" are chosen differently.
 >>
 >> Nope. We allow you to leave code in untyped form. ML doesn't.
 >
 > But this doesn't help me to *use* `flip' in TS code.  You could just
 > as well go with any type system -- including ML -- since the result is
 > still in PLT, then I can always leave code untyped.  (Alternatively,
 > if we take PLT as a collection of languages, then "leaving code
 > untyped" is the same as "switch to a different language" in the
 > above.)
 >
 >
 >>>> I have to agree with Sam here, based on my experience with Andrew
 >>>> and the value restriction. This is an open RESEARCH PROBLEM not
 >>>> an OPEN/ ANALYZED bug report.
 >>>
 >>> And so is a statically typed language with arbitrary unions, and
 >>> fighting to get that right was important enough to do.  Don't get
 >>> me wrong: I completely understand your point -- I'm just saying
 >>> that this point reads to me as "we wanted to allow static typing
 >>> of arbitrary Scheme code, we now covered 95% of such code, the
 >>> last 5% is not worth the effort".  Seal this bug report as "not a
 >>> bug", and (IMO) this confirms this view.
 >>
 >> Again, this is about research not a small bug. I can see you asking
 >> Sam to put this on his list but not as a bug. (BTW, my hunch is that
 >> this canNOT be done; ever)
 >
 > This sounds odd, so I'll bite.  For *just* the type of `flip' that I
 > used,
 >
 >  (: flip (All (A B C) ((A B -> C) -> (B A -> C))))
 >
 > what goes wrong if I allow the system to do the obvious thing?
 >
 > -- 
 >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli  
 > Barzilay:
 >                    http://barzilay.org/                   Maze is  
 > Life!
 
From: Sam TH <samth@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>, bugs@plt-scheme.org
Subject: Re: [plt-bug] all/10554: TS: haunted lists
Date: Sun, 1 Nov 2009 23:19:55 -0500

 On Sun, Nov 1, 2009 at 10:50 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >
 >> Again, this is about research not a small bug. I can see you asking
 >> Sam to put this on his list but not as a bug. (BTW, my hunch is that
 >> this canNOT be done; ever)
 >
 > This sounds odd, so I'll bite. =A0For *just* the type of `flip' that I
 > used,
 >
 > =A0(: flip (All (A B C) ((A B -> C) -> (B A -> C))))
 >
 > what goes wrong if I allow the system to do the obvious thing?
 
 To be a little less cryptic than Matthias, the problem is subtyping.
 Type inference in ML and Haskell doesn't have to deal with subtyping,
 but Typed Scheme does.  In the most general case, full type inference
 with subtyping and bounded polymorphism is undecidable.  Right now,
 Typed Scheme doesn't have bounded polymorphism (although it should
 probably be added) and it doesn't try to do full type inference, as
 you're discovering, making the problem tractable.  However, type
 inference with polymorphism and subtyping is not well-studied.  For
 example, I don't know of any work that deals with polymorphism,
 subtyping, and explicit recursive types.  Or true union types.
 
 There are, to my knowledge, two published incomplete algorithms for
 doing inference with subtyping and polymorphism, one of which Typed
 Scheme uses (and extends significantly).  But that algorithm doesn't
 treat the problem of polymorphic arguments at all.  Nor does it try to
 infer the types of lambda-bound variables, another significant
 annoyance for Typed Scheme.  The other algorithm might succeed in some
 of these cases, at the price of less predictable behavior, but I don't
 know.
 
 So, in short, of course this case looks obvious.  But if you have a
 solution that works in a lot of cases, that's publishable research.
 
 --=20
 sam th
 samth@ccs.neu.edu

State changed from "open" to "closed" by samth at Wed, 06 Jan 2010 20:08:18 -0500
Reason>>> not a bug.
There are lots of places where better inference is
desirable, but it's not a bug.  
If you need to use `flip', you need explicit instantiation.

From: Eli Barzilay <eli@barzilay.org>
To: bugs@plt-scheme.org
Cc: samth@plt-scheme.org, Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] typed-scheme/10554 TS: haunted lists
Date: Wed, 6 Jan 2010 20:15:56 -0500

 =46rom a user perspective, this is most definitely a bug.  Even an error
 would be better than inferring a useless type with (U)s.
 
 
 On Jan  6, samth@plt-scheme.org wrote:
 >=20
 > State changed from "open" to "closed" by samth at Wed, 06 Jan 2010
 > 20:08:18 -0500
 > Reason>>> not a bug.
 > There are lots of places where better inference is desirable, but
 > it's not a bug.  If you need to use `flip', you need explicit
 > instantiation.
 >=20
 > View:
 >   http://bugs.plt-scheme.org/query/=3Fcmd=3Dview&pr=3D10554
 
 --=20
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay=
 :
                     http://barzilay.org/                   Maze is Life=
 !
From: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: bugs@plt-scheme.org, Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] typed-scheme/10554 TS: haunted lists
Date: Wed, 6 Jan 2010 20:34:03 -0500

 I'll see if an error breaks anything.
 
 On Wed, Jan 6, 2010 at 8:15 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > From a user perspective, this is most definitely a bug. =A0Even an error
 > would be better than inferring a useless type with (U)s.
 >
 >
 > On Jan =A06, samth@plt-scheme.org wrote:
 >>
 >> State changed from "open" to "closed" by samth at Wed, 06 Jan 2010
 >> 20:08:18 -0500
 >> Reason>>> not a bug.
 >> There are lots of places where better inference is desirable, but
 >> it's not a bug. =A0If you need to use `flip', you need explicit
 >> instantiation.
 >>
 >> View:
 >> =A0 http://bugs.plt-scheme.org/query/?cmd=3Dview&pr=3D10554
 >
 > --
 > =A0 =A0 =A0 =A0 =A0((lambda (x) (x x)) (lambda (x) (x x))) =A0 =A0 =A0 =
 =A0 =A0Eli Barzilay:
 > =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0http://barzilay.org/ =A0 =A0 =A0 =
 =A0 =A0 =A0 =A0 =A0 =A0 Maze is Life!
 >
 
 
 
 --=20
 sam th
 samth@ccs.neu.edu
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, bugs@plt-scheme.org
Subject: Re: [plt-bug] typed-scheme/10554 TS: haunted lists
Date: Wed, 6 Jan 2010 20:50:46 -0500

 I second Eli's opinion here, which means it isn't an error report but a =
 change request. The inference of (U) will render the result nearly =
 useless; an error forces the programmer to instantiate this thing =
 properly or to abstract over the type variables and that will make the =
 result useful. If an error is implementable, go for it.=20
 
 
 
 
 
 
 On Jan 6, 2010, at 8:34 PM, Sam Tobin-Hochstadt wrote:
 
 > I'll see if an error breaks anything.
 >=20
 > On Wed, Jan 6, 2010 at 8:15 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> =46rom a user perspective, this is most definitely a bug.  Even an =
 error
 >> would be better than inferring a useless type with (U)s.
 >>=20
 >>=20
 >> On Jan  6, samth@plt-scheme.org wrote:
 >>>=20
 >>> State changed from "open" to "closed" by samth at Wed, 06 Jan 2010
 >>> 20:08:18 -0500
 >>> Reason>>> not a bug.
 >>> There are lots of places where better inference is desirable, but
 >>> it's not a bug.  If you need to use `flip', you need explicit
 >>> instantiation.
 >>>=20
 >>> View:
 >>>   http://bugs.plt-scheme.org/query/?cmd=3Dview&pr=3D10554
 >>=20
 >> --
 >>          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli =
 Barzilay:
 >>                    http://barzilay.org/                   Maze is =
 Life!
 >>=20
 >=20
 >=20
 >=20
 > --=20
 > sam th
 > samth@ccs.neu.edu
 
From: Eli Barzilay <eli@barzilay.org>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs@plt-scheme.org
Subject: Re: [plt-bug] typed-scheme/10554 TS: haunted lists
Date: Wed, 6 Jan 2010 21:27:50 -0500

 On Jan  6, Matthias Felleisen wrote:
 > I second Eli's opinion here, which means it isn't an error report
 > but a change request. The inference of (U) will render the result
 > nearly useless; an error forces the programmer to instantiate this
 > thing properly or to abstract over the type variables and that will
 > make the result useful. If an error is implementable, go for it.
 
 A related feature request that will avoid a good part of this problem:
 render (U) as something like `Nothing'.  This way, instead of getting
 a weird looking (U) which most people have no clue what it means,
 they'll see something readable -- which will be a good signal that
 something is wrong, and it might even make sense.  (Consider these
 questions on the mailing list or some FAQ: once answered, it's easy to
 remember "`Nothing' means something went wrong in the inference, you
 need more types" as opposed to (U).)  It will also be much clearer
 when you look at the type of `error' and `call/cc'.
 
 (And BTW, I used `Nothing' rather than `Bottom', because (a) the latter
 requires some knowledge of what `Bottom' is that less people have, and
 (b) because then `Any' would be better named `Top' (and `Any' is
 better than `Top' for the same reason as (a).))
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Sam Tobin-Hochstadt <samth@ccs.neu.edu>, bugs@plt-scheme.org
Subject: Re: [plt-bug] typed-scheme/10554 TS: haunted lists
Date: Wed, 6 Jan 2010 23:00:48 -0500

 I second this, too. Top and bottom are Mathematicians' names. 
 
 
 On Jan 6, 2010, at 9:27 PM, Eli Barzilay wrote:
 
 > On Jan  6, Matthias Felleisen wrote:
 >> I second Eli's opinion here, which means it isn't an error report
 >> but a change request. The inference of (U) will render the result
 >> nearly useless; an error forces the programmer to instantiate this
 >> thing properly or to abstract over the type variables and that will
 >> make the result useful. If an error is implementable, go for it.
 > 
 > A related feature request that will avoid a good part of this problem:
 > render (U) as something like `Nothing'.  This way, instead of getting
 > a weird looking (U) which most people have no clue what it means,
 > they'll see something readable -- which will be a good signal that
 > something is wrong, and it might even make sense.  (Consider these
 > questions on the mailing list or some FAQ: once answered, it's easy to
 > remember "`Nothing' means something went wrong in the inference, you
 > need more types" as opposed to (U).)  It will also be much clearer
 > when you look at the type of `error' and `call/cc'.
 > 
 > (And BTW, I used `Nothing' rather than `Bottom', because (a) the latter
 > requires some knowledge of what `Bottom' is that less people have, and
 > (b) because then `Any' would be better named `Top' (and `Any' is
 > better than `Top' for the same reason as (a).))
 > 
 > -- 
 >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                    http://barzilay.org/                   Maze is Life!
 
