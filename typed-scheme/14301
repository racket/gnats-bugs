From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Sat Jan 18 16:35:24 2014
Received: from mail-ob0-f173.google.com (mail-ob0-f173.google.com [209.85.214.173])
	by winooski.ccs.neu.edu (8.14.7/8.14.7) with ESMTP id s0ILZK0c015248
	for <bugs@bugs.plt-scheme.org>; Sat, 18 Jan 2014 16:35:20 -0500
Message-Id: <201401182135.s0ILZH2L015241@winooski.ccs.neu.edu>
Date: Sat, 18 Jan 2014 16:35:17 -0500
From: tonyg@ccs.neu.edu
To: bugs@racket-lang.org
Subject: Unexpected TR complaint: "Type Checker: The type of vm-process cannot be converted to a contract"

>Number:         14301
>Category:       typed-scheme
>Synopsis:       Unexpected TR complaint: "Type Checker: The type of vm-process cannot be converted to a contract"
>Class:          sw-bug
>Responsible:    samth
>Severity:       serious
>Priority:       medium
>State:          open
>Confidential:   no
>Arrival-Date:   Sat Jan 18 16:36:01 -0500 2014
>Last-Modified:  Thu Jan 23 23:49:04 -0500 2014
>Originator:     Tony Garnock-Jones
>Organization:
plt
>Submitter-Id:   unknown
>Release:        6.0.0.1--2014-01-18(54e24e42/d)
>Environment:
macosx "Darwin skip 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7 16:33:36 PDT 2011; root:xnu-1504.15.3~1/RELEASE_I386 i386" (x86_64-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 286753084
Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()
raco pkg (show):
/Users/tonyg/src/racket/racket/share/devel-pkgs:
 Package              Checksum    Source
 main-distribution    #f          (static-link ../../../pkgs/main-distribution)
 plt-services         #f          (static-link ../../../pkgs/plt-services)
 racket-lib           #f          (static-link ../../../pkgs/racket-pkgs/racket-lib)
 [207 auto-installed packages not shown]
Installation-wide:
 [none]
User-specific for installation "development":
 [none]



Collections:
("/Users/tonyg/Library/Racket/development/collects"
 (non-existent-path))
("/Users/tonyg/src/racket/racket/collects"
 (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))

Recent Internal Errors: 
Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t none) (default) #() "#lang racket\n" #f #t ((main) (test)) #t))
>Description:
After Eric Dobson's recent round of refactoring of TR's contract-generation mechanism, Marketplace will no longer compile, complaining that "Type Checker: The type of vm-processes cannot be converted to a contract" when compiling support/gui.rkt.

None of the Marketplace code has changed; it's unclear whether I am doing something that is now genuinely no longer supported by TR, or whether there's a problem with TR's contract generation.

Git bisect reports that the last known-good commit, where Marketplace built without problems, is e32a760. The first known-bad commit is 608eb9d. Commits between these two failed to build to completion, so I don't know which one caused the problem :-(

I have reproduced the problem without the entirety of Marketplace. Please see below.
>How-To-Repeat:
;; File 20140118-inner.rkt:
#lang typed/racket/base
(provide (all-defined-out))
(struct: vm ([process : Process]))
(define-type Process (All (R) (CoProcess R) -> R))
(define-type (CoProcess R) (All (State) (action State) -> R))
(struct: (State) action ([k : (State -> (action State))]))

;; File 20140118-outer.rkt:
#lang racket/base
(require "20140118-inner.rkt")
vm-process

;; Instructions: raco make 20140118-outer.rkt
;; Expected: successful compile.
;; Actual result: "The type of vm-process cannot be converted to a contract"
>Fix:
>Audit-Trail:
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: tonyg@ccs.neu.edu, bugs@racket-lang.org
Cc: nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/14301: Unexpected TR complaint: "Type Checker: The type of vm-process cannot be converted to a contract"
Date: Sat, 18 Jan 2014 16:37:45 -0500

 Great bug report. 
 
 
 On Jan 18, 2014, at 4:36 PM, tonyg@ccs.neu.edu wrote:
 
 > A new problem report is waiting at
 >  http://bugs.racket-lang.org/query/?cmd=view&pr=14301
 > 
 > Reported by Tony Garnock-Jones for release: 6.0.0.1--2014-01-18(54e24e42/d)
 > 
 > *** Description:
 > After Eric Dobson's recent round of refactoring of TR's contract-generation mechanism, Marketplace will no longer compile, complaining that "Type Checker: The type of vm-processes cannot be converted to a contract" when compiling support/gui.rkt.
 > 
 > None of the Marketplace code has changed; it's unclear whether I am doing something that is now genuinely no longer supported by TR, or whether there's a problem with TR's contract generation.
 > 
 > Git bisect reports that the last known-good commit, where Marketplace built without problems, is e32a760. The first known-bad commit is 608eb9d. Commits between these two failed to build to completion, so I don't know which one caused the problem :-(
 > 
 > I have reproduced the problem without the entirety of Marketplace. Please see below.
 > 
 > *** How to repeat:
 > ;; File 20140118-inner.rkt:
 > #lang typed/racket/base
 > (provide (all-defined-out))
 > (struct: vm ([process : Process]))
 > (define-type Process (All (R) (CoProcess R) -> R))
 > (define-type (CoProcess R) (All (State) (action State) -> R))
 > (struct: (State) action ([k : (State -> (action State))]))
 > 
 > ;; File 20140118-outer.rkt:
 > #lang racket/base
 > (require "20140118-inner.rkt")
 > vm-process
 > 
 > ;; Instructions: raco make 20140118-outer.rkt
 > ;; Expected: successful compile.
 > ;; Actual result: "The type of vm-process cannot be converted to a contract"
 > 
 > *** Environment:
 > macosx "Darwin skip 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7 16:33:36 PDT 2011; root:xnu-1504.15.3~1/RELEASE_I386 i386" (x86_64-macosx/3m) (get-display-depth) = 32
 > Human Language: english
 > (current-memory-use) 286753084
 > Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()
 > raco pkg (show):
 > /Users/tonyg/src/racket/racket/share/devel-pkgs:
 > Package              Checksum    Source
 > main-distribution    #f          (static-link ../../../pkgs/main-distribution)
 > plt-services         #f          (static-link ../../../pkgs/plt-services)
 > racket-lib           #f          (static-link ../../../pkgs/racket-pkgs/racket-lib)
 > [207 auto-installed packages not shown]
 > Installation-wide:
 > [none]
 > User-specific for installation "development":
 > [none]
 > 
 > 
 > 
 > Collections:
 > ("/Users/tonyg/Library/Racket/development/collects"
 > (non-existent-path))
 > ("/Users/tonyg/src/racket/racket/collects"
 > (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "raco" "reader" "realm" "s-exp" "setup" "syntax" "unstable" "version" "xml"))
 > 
 > Recent Internal Errors: 
 > Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t none) (default) #() "#lang racket\n" #f #t ((main) (test)) #t))
 > 
 
 
From: Tony Garnock-Jones <tonyg@ccs.neu.edu>
To: bugs@racket-lang.org, bug-notification@racket-lang.org
Cc: 
Subject: Re: [racket-bug] all/14301: Unexpected TR complaint: "Type Checker:
 The type of vm-process cannot be converted to a contract"
Date: Sat, 18 Jan 2014 16:50:12 -0500

 Also relevant: if I change the definition of "action" from
 
 (struct: (State) action ([k : (State -> (action State))]))
 
 to the more-or-less equivalent
 
 (define-type (action State) (Rec X (State -> X)))
 
 then it compiles 20140118-outer.rkt successfully.
 
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Tony Garnock-Jones <tonyg@ccs.neu.edu>
Cc: bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14301: Unexpected TR complaint: "Type Checker:
 The type of vm-process cannot be converted to a contract"
Date: Sun, 19 Jan 2014 10:10:46 -0800

 I'm not certain this is a bug. My changes made TR generate more
 correct contracts in some cases, and recursive uses of polymorphic
 types is one of them. Your 'more-or-less' equivalent type gives good
 evidence for this.
 
 The program is this:
 
 #lang racket/load
 
 (module tr typed/racket/base
   (provide (all-defined-out))
 
   (define-type (CoProcess R) (All (State) (action State) -> R))
   (struct: (State) action ([k : (State -> (action State))]))
 
   (: process ((All (State) (action State) -> #f) -> #f))
   (define (process co-p)
     #f)
 
   )
 
 
 
 
 (require 'tr)
 (print process)
 (newline)
 
 
 So we need to generate a contract for a process, and fail.
 
 The static contract we generate is
 (->/sc (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc (->/sc State4
 n*5)))) n*5) (flat/sc (flat-named-contract '#f (lambda (x) (equal? x
 '#f)))))))
 
 [The parametric var doesn't currently print, but it is State4 in this
 case. Also ->/sc doesn't print a final return type if it doesn't have
 one.]
 
 But the core part is: (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc
 (->/sc State4 n*5)))) n*5)
 
 (->/sc State4 n*5) is an impersonator contract which is not allowed as
 a field contract of an immutable struct, and so we cannot make a
 contract out of this. Without the struct you can have an impersonator
 contract. Another solution is to make the struct mutable, which would
 allow for impersonator contracts on fields.
 
 The problem with this reasoning is that it looks like the last good
 commit you gave had the same static contract. So I need to investigate
 more.
 
 
 On Sat, Jan 18, 2014 at 1:50 PM, Tony Garnock-Jones <tonyg@ccs.neu.edu> wrote:
 > Also relevant: if I change the definition of "action" from
 >
 > (struct: (State) action ([k : (State -> (action State))]))
 >
 > to the more-or-less equivalent
 >
 > (define-type (action State) (Rec X (State -> X)))
 >
 > then it compiles 20140118-outer.rkt successfully.
 >
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Tony Garnock-Jones <tonyg@ccs.neu.edu>
Cc: bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14301: Unexpected TR complaint: "Type Checker:
 The type of vm-process cannot be converted to a contract"
Date: Sun, 19 Jan 2014 10:35:57 -0800

 f17f6655dd2400ffb91e1116513db4ce2056b743 is the change that breaks it,
 but this is also the change that introduced a latent bug so needs
 e164a959eb3aa97938fb4ae9f98cfb67aee38b9f to fix it.
 
 The problem is that this looks like it was fixing another bug where
 the restriction to being a chaperone contract wasn't enforced
 statically.
 
 
 #lang racket/load
 
 (module tr typed/racket/base
   (provide (all-defined-out))
 
   (define-type (CoProcess R) (All (State) (action State) -> R))
   (struct: (State) action ([k : (State -> (action State))]))
 
   (: loop-action (All (State) (-> (action State))))
   (define (loop-action)
     (action (λ: ([s : State]) ((inst loop-action State)))))
 
   (: process ((All (State) (action State) -> #f) -> #f))
   (define (process co-p)
     (co-p ((inst loop-action #f))))
 
   )
 
 (require 'tr)
 (process (lambda (x) #f))
 
 This program fails with a contract system error because TR isn't
 correctly enforcing the checks before creating the contracts at
 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 commit').
 
 It also fails right before any of the static contract work. Thus I
 think this is not a bug.
 
 On Sun, Jan 19, 2014 at 10:10 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > I'm not certain this is a bug. My changes made TR generate more
 > correct contracts in some cases, and recursive uses of polymorphic
 > types is one of them. Your 'more-or-less' equivalent type gives good
 > evidence for this.
 >
 > The program is this:
 >
 > #lang racket/load
 >
 > (module tr typed/racket/base
 >   (provide (all-defined-out))
 >
 >   (define-type (CoProcess R) (All (State) (action State) -> R))
 >   (struct: (State) action ([k : (State -> (action State))]))
 >
 >   (: process ((All (State) (action State) -> #f) -> #f))
 >   (define (process co-p)
 >     #f)
 >
 >   )
 >
 >
 >
 >
 > (require 'tr)
 > (print process)
 > (newline)
 >
 >
 > So we need to generate a contract for a process, and fail.
 >
 > The static contract we generate is
 > (->/sc (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc (->/sc State4
 > n*5)))) n*5) (flat/sc (flat-named-contract '#f (lambda (x) (equal? x
 > '#f)))))))
 >
 > [The parametric var doesn't currently print, but it is State4 in this
 > case. Also ->/sc doesn't print a final return type if it doesn't have
 > one.]
 >
 > But the core part is: (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc
 > (->/sc State4 n*5)))) n*5)
 >
 > (->/sc State4 n*5) is an impersonator contract which is not allowed as
 > a field contract of an immutable struct, and so we cannot make a
 > contract out of this. Without the struct you can have an impersonator
 > contract. Another solution is to make the struct mutable, which would
 > allow for impersonator contracts on fields.
 >
 > The problem with this reasoning is that it looks like the last good
 > commit you gave had the same static contract. So I need to investigate
 > more.
 >
 >
 > On Sat, Jan 18, 2014 at 1:50 PM, Tony Garnock-Jones <tonyg@ccs.neu.edu> wrote:
 >> Also relevant: if I change the definition of "action" from
 >>
 >> (struct: (State) action ([k : (State -> (action State))]))
 >>
 >> to the more-or-less equivalent
 >>
 >> (define-type (action State) (Rec X (State -> X)))
 >>
 >> then it compiles 20140118-outer.rkt successfully.
 >>
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Tony Garnock-Jones <tonyg@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14301: Unexpected TR complaint: "Type Checker: The type of vm-process cannot be converted to a contract"
Date: Sun, 19 Jan 2014 17:01:57 -0500

 Eric, can you explain the last two paragraphs: 
 
 > This program fails with a contract system error because TR isn't
 > correctly enforcing the checks before creating the contracts at
 > 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 > commit').
 > 
 > It also fails right before any of the static contract work. Thus I
 > think this is not a bug.
 
 especially the TR 's not correctly enforcing the checks? 
 
 
 
 
 On Jan 19, 2014, at 1:35 PM, Eric Dobson wrote:
 
 > f17f6655dd2400ffb91e1116513db4ce2056b743 is the change that breaks it,
 > but this is also the change that introduced a latent bug so needs
 > e164a959eb3aa97938fb4ae9f98cfb67aee38b9f to fix it.
 > 
 > The problem is that this looks like it was fixing another bug where
 > the restriction to being a chaperone contract wasn't enforced
 > statically.
 > 
 > 
 > #lang racket/load
 > 
 > (module tr typed/racket/base
 >  (provide (all-defined-out))
 > 
 >  (define-type (CoProcess R) (All (State) (action State) -> R))
 >  (struct: (State) action ([k : (State -> (action State))]))
 > 
 >  (: loop-action (All (State) (-> (action State))))
 >  (define (loop-action)
 >    (action (λ: ([s : State]) ((inst loop-action State)))))
 > 
 >  (: process ((All (State) (action State) -> #f) -> #f))
 >  (define (process co-p)
 >    (co-p ((inst loop-action #f))))
 > 
 >  )
 > 
 > (require 'tr)
 > (process (lambda (x) #f))
 > 
 > This program fails with a contract system error because TR isn't
 > correctly enforcing the checks before creating the contracts at
 > 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 > commit').
 > 
 > It also fails right before any of the static contract work. Thus I
 > think this is not a bug.
 > 
 > On Sun, Jan 19, 2014 at 10:10 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> I'm not certain this is a bug. My changes made TR generate more
 >> correct contracts in some cases, and recursive uses of polymorphic
 >> types is one of them. Your 'more-or-less' equivalent type gives good
 >> evidence for this.
 >> 
 >> The program is this:
 >> 
 >> #lang racket/load
 >> 
 >> (module tr typed/racket/base
 >>  (provide (all-defined-out))
 >> 
 >>  (define-type (CoProcess R) (All (State) (action State) -> R))
 >>  (struct: (State) action ([k : (State -> (action State))]))
 >> 
 >>  (: process ((All (State) (action State) -> #f) -> #f))
 >>  (define (process co-p)
 >>    #f)
 >> 
 >>  )
 >> 
 >> 
 >> 
 >> 
 >> (require 'tr)
 >> (print process)
 >> (newline)
 >> 
 >> 
 >> So we need to generate a contract for a process, and fail.
 >> 
 >> The static contract we generate is
 >> (->/sc (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc (->/sc State4
 >> n*5)))) n*5) (flat/sc (flat-named-contract '#f (lambda (x) (equal? x
 >> '#f)))))))
 >> 
 >> [The parametric var doesn't currently print, but it is State4 in this
 >> case. Also ->/sc doesn't print a final return type if it doesn't have
 >> one.]
 >> 
 >> But the core part is: (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc
 >> (->/sc State4 n*5)))) n*5)
 >> 
 >> (->/sc State4 n*5) is an impersonator contract which is not allowed as
 >> a field contract of an immutable struct, and so we cannot make a
 >> contract out of this. Without the struct you can have an impersonator
 >> contract. Another solution is to make the struct mutable, which would
 >> allow for impersonator contracts on fields.
 >> 
 >> The problem with this reasoning is that it looks like the last good
 >> commit you gave had the same static contract. So I need to investigate
 >> more.
 >> 
 >> 
 >> On Sat, Jan 18, 2014 at 1:50 PM, Tony Garnock-Jones <tonyg@ccs.neu.edu> wrote:
 >>> Also relevant: if I change the definition of "action" from
 >>> 
 >>> (struct: (State) action ([k : (State -> (action State))]))
 >>> 
 >>> to the more-or-less equivalent
 >>> 
 >>> (define-type (action State) (Rec X (State -> X)))
 >>> 
 >>> then it compiles 20140118-outer.rkt successfully.
 >>> 
 
 
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Tony Garnock-Jones <tonyg@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14301: Unexpected TR complaint: "Type Checker:
 The type of vm-process cannot be converted to a contract"
Date: Sun, 19 Jan 2014 14:17:34 -0800

 From scratch:
 
 The following program has all the essential elemnts of the original bug report:
 #lang racket/load
 
 (module tr typed/racket/base
   (provide (all-defined-out))
 
   (define-type (CoProcess R) (All (State) (action State) -> R))
   (struct: (State) action ([k : (State -> (action State))]))
 
   (: loop-action (All (State) (-> (action State))))
   (define (loop-action)
     (action (λ: ([s : State]) ((inst loop-action State)))))
 
   (: process ((All (State) (action State) -> #f) -> #f))
   (define (process co-p)
     (co-p ((inst loop-action #f))))
 
   )
 
 (require 'tr)
 (process (lambda (x) #f))
 
 Before any of the static contract changes this gave an error like this
 at run time:
 
 struct/dc: contract violation
   expected: a chaperone-contract? for field (#:selector action-k)
   given: #<contract: (-> State4 (recursive-contract n*56 #:impersonator))>
   context...:
    /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/struct-dc.rkt:505:0:
 build-struct/dc
    /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/parametric.rkt:35:7:
 wrap
    /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/parametric.rkt:54:12
    /Users/endobson/tmp/tmp2.rkt: [running body]
 
 Up through 1acd1537e8e439376da4c925dd4cc96334467f16, this behavior should hold.
 
 f17f6655dd2400ffb91e1116513db4ce2056b743, fixes a bug in the logic (at
 expansion time) that was supposed to detect impersonator contracts in
 field contracts so that we don't generate code that fails with this
 error. So at that commit instead of generating code to generate
 contracts that fails at run time we instead generate an error message
 saying that it is impossible to generate a contract for the type.
 
 Does that explain it better?
 
 On Sun, Jan 19, 2014 at 2:01 PM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > Eric, can you explain the last two paragraphs:
 >
 >> This program fails with a contract system error because TR isn't
 >> correctly enforcing the checks before creating the contracts at
 >> 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 >> commit').
 >>
 >> It also fails right before any of the static contract work. Thus I
 >> think this is not a bug.
 >
 > especially the TR 's not correctly enforcing the checks?
 >
 >
 >
 >
 > On Jan 19, 2014, at 1:35 PM, Eric Dobson wrote:
 >
 >> f17f6655dd2400ffb91e1116513db4ce2056b743 is the change that breaks it,
 >> but this is also the change that introduced a latent bug so needs
 >> e164a959eb3aa97938fb4ae9f98cfb67aee38b9f to fix it.
 >>
 >> The problem is that this looks like it was fixing another bug where
 >> the restriction to being a chaperone contract wasn't enforced
 >> statically.
 >>
 >>
 >> #lang racket/load
 >>
 >> (module tr typed/racket/base
 >>  (provide (all-defined-out))
 >>
 >>  (define-type (CoProcess R) (All (State) (action State) -> R))
 >>  (struct: (State) action ([k : (State -> (action State))]))
 >>
 >>  (: loop-action (All (State) (-> (action State))))
 >>  (define (loop-action)
 >>    (action (λ: ([s : State]) ((inst loop-action State)))))
 >>
 >>  (: process ((All (State) (action State) -> #f) -> #f))
 >>  (define (process co-p)
 >>    (co-p ((inst loop-action #f))))
 >>
 >>  )
 >>
 >> (require 'tr)
 >> (process (lambda (x) #f))
 >>
 >> This program fails with a contract system error because TR isn't
 >> correctly enforcing the checks before creating the contracts at
 >> 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 >> commit').
 >>
 >> It also fails right before any of the static contract work. Thus I
 >> think this is not a bug.
 >>
 >> On Sun, Jan 19, 2014 at 10:10 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>> I'm not certain this is a bug. My changes made TR generate more
 >>> correct contracts in some cases, and recursive uses of polymorphic
 >>> types is one of them. Your 'more-or-less' equivalent type gives good
 >>> evidence for this.
 >>>
 >>> The program is this:
 >>>
 >>> #lang racket/load
 >>>
 >>> (module tr typed/racket/base
 >>>  (provide (all-defined-out))
 >>>
 >>>  (define-type (CoProcess R) (All (State) (action State) -> R))
 >>>  (struct: (State) action ([k : (State -> (action State))]))
 >>>
 >>>  (: process ((All (State) (action State) -> #f) -> #f))
 >>>  (define (process co-p)
 >>>    #f)
 >>>
 >>>  )
 >>>
 >>>
 >>>
 >>>
 >>> (require 'tr)
 >>> (print process)
 >>> (newline)
 >>>
 >>>
 >>> So we need to generate a contract for a process, and fail.
 >>>
 >>> The static contract we generate is
 >>> (->/sc (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc (->/sc State4
 >>> n*5)))) n*5) (flat/sc (flat-named-contract '#f (lambda (x) (equal? x
 >>> '#f)))))))
 >>>
 >>> [The parametric var doesn't currently print, but it is State4 in this
 >>> case. Also ->/sc doesn't print a final return type if it doesn't have
 >>> one.]
 >>>
 >>> But the core part is: (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc
 >>> (->/sc State4 n*5)))) n*5)
 >>>
 >>> (->/sc State4 n*5) is an impersonator contract which is not allowed as
 >>> a field contract of an immutable struct, and so we cannot make a
 >>> contract out of this. Without the struct you can have an impersonator
 >>> contract. Another solution is to make the struct mutable, which would
 >>> allow for impersonator contracts on fields.
 >>>
 >>> The problem with this reasoning is that it looks like the last good
 >>> commit you gave had the same static contract. So I need to investigate
 >>> more.
 >>>
 >>>
 >>> On Sat, Jan 18, 2014 at 1:50 PM, Tony Garnock-Jones <tonyg@ccs.neu.edu> wrote:
 >>>> Also relevant: if I change the definition of "action" from
 >>>>
 >>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>
 >>>> to the more-or-less equivalent
 >>>>
 >>>> (define-type (action State) (Rec X (State -> X)))
 >>>>
 >>>> then it compiles 20140118-outer.rkt successfully.
 >>>>
 >
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Tony Garnock-Jones <tonyg@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14301: Unexpected TR complaint: "Type Checker: The type of vm-process cannot be converted to a contract"
Date: Mon, 20 Jan 2014 10:53:07 -0500

 Yes, that explains the last few exchanges well. Thanks. 
 
 What I don't understand is your claim that Tony's bug isn't a bug. 
 I thought that typed Marketplace ran fine and now it no longer runs. 
 
 
 On Jan 19, 2014, at 5:17 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 
 > From scratch:
 > 
 > The following program has all the essential elemnts of the original bug report:
 > #lang racket/load
 > 
 > (module tr typed/racket/base
 >  (provide (all-defined-out))
 > 
 >  (define-type (CoProcess R) (All (State) (action State) -> R))
 >  (struct: (State) action ([k : (State -> (action State))]))
 > 
 >  (: loop-action (All (State) (-> (action State))))
 >  (define (loop-action)
 >    (action (λ: ([s : State]) ((inst loop-action State)))))
 > 
 >  (: process ((All (State) (action State) -> #f) -> #f))
 >  (define (process co-p)
 >    (co-p ((inst loop-action #f))))
 > 
 >  )
 > 
 > (require 'tr)
 > (process (lambda (x) #f))
 > 
 > Before any of the static contract changes this gave an error like this
 > at run time:
 > 
 > struct/dc: contract violation
 >  expected: a chaperone-contract? for field (#:selector action-k)
 >  given: #<contract: (-> State4 (recursive-contract n*56 #:impersonator))>
 >  context...:
 >   /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/struct-dc.rkt:505:0:
 > build-struct/dc
 >   /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/parametric.rkt:35:7:
 > wrap
 >   /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/parametric.rkt:54:12
 >   /Users/endobson/tmp/tmp2.rkt: [running body]
 > 
 > Up through 1acd1537e8e439376da4c925dd4cc96334467f16, this behavior should hold.
 > 
 > f17f6655dd2400ffb91e1116513db4ce2056b743, fixes a bug in the logic (at
 > expansion time) that was supposed to detect impersonator contracts in
 > field contracts so that we don't generate code that fails with this
 > error. So at that commit instead of generating code to generate
 > contracts that fails at run time we instead generate an error message
 > saying that it is impossible to generate a contract for the type.
 > 
 > Does that explain it better?
 > 
 > On Sun, Jan 19, 2014 at 2:01 PM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> Eric, can you explain the last two paragraphs:
 >> 
 >>> This program fails with a contract system error because TR isn't
 >>> correctly enforcing the checks before creating the contracts at
 >>> 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 >>> commit').
 >>> 
 >>> It also fails right before any of the static contract work. Thus I
 >>> think this is not a bug.
 >> 
 >> especially the TR 's not correctly enforcing the checks?
 >> 
 >> 
 >> 
 >> 
 >> On Jan 19, 2014, at 1:35 PM, Eric Dobson wrote:
 >> 
 >>> f17f6655dd2400ffb91e1116513db4ce2056b743 is the change that breaks it,
 >>> but this is also the change that introduced a latent bug so needs
 >>> e164a959eb3aa97938fb4ae9f98cfb67aee38b9f to fix it.
 >>> 
 >>> The problem is that this looks like it was fixing another bug where
 >>> the restriction to being a chaperone contract wasn't enforced
 >>> statically.
 >>> 
 >>> 
 >>> #lang racket/load
 >>> 
 >>> (module tr typed/racket/base
 >>> (provide (all-defined-out))
 >>> 
 >>> (define-type (CoProcess R) (All (State) (action State) -> R))
 >>> (struct: (State) action ([k : (State -> (action State))]))
 >>> 
 >>> (: loop-action (All (State) (-> (action State))))
 >>> (define (loop-action)
 >>>   (action (λ: ([s : State]) ((inst loop-action State)))))
 >>> 
 >>> (: process ((All (State) (action State) -> #f) -> #f))
 >>> (define (process co-p)
 >>>   (co-p ((inst loop-action #f))))
 >>> 
 >>> )
 >>> 
 >>> (require 'tr)
 >>> (process (lambda (x) #f))
 >>> 
 >>> This program fails with a contract system error because TR isn't
 >>> correctly enforcing the checks before creating the contracts at
 >>> 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 >>> commit').
 >>> 
 >>> It also fails right before any of the static contract work. Thus I
 >>> think this is not a bug.
 >>> 
 >>> On Sun, Jan 19, 2014 at 10:10 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> I'm not certain this is a bug. My changes made TR generate more
 >>>> correct contracts in some cases, and recursive uses of polymorphic
 >>>> types is one of them. Your 'more-or-less' equivalent type gives good
 >>>> evidence for this.
 >>>> 
 >>>> The program is this:
 >>>> 
 >>>> #lang racket/load
 >>>> 
 >>>> (module tr typed/racket/base
 >>>> (provide (all-defined-out))
 >>>> 
 >>>> (define-type (CoProcess R) (All (State) (action State) -> R))
 >>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>> 
 >>>> (: process ((All (State) (action State) -> #f) -> #f))
 >>>> (define (process co-p)
 >>>>   #f)
 >>>> 
 >>>> )
 >>>> 
 >>>> 
 >>>> 
 >>>> 
 >>>> (require 'tr)
 >>>> (print process)
 >>>> (newline)
 >>>> 
 >>>> 
 >>>> So we need to generate a contract for a process, and fail.
 >>>> 
 >>>> The static contract we generate is
 >>>> (->/sc (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc (->/sc State4
 >>>> n*5)))) n*5) (flat/sc (flat-named-contract '#f (lambda (x) (equal? x
 >>>> '#f)))))))
 >>>> 
 >>>> [The parametric var doesn't currently print, but it is State4 in this
 >>>> case. Also ->/sc doesn't print a final return type if it doesn't have
 >>>> one.]
 >>>> 
 >>>> But the core part is: (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc
 >>>> (->/sc State4 n*5)))) n*5)
 >>>> 
 >>>> (->/sc State4 n*5) is an impersonator contract which is not allowed as
 >>>> a field contract of an immutable struct, and so we cannot make a
 >>>> contract out of this. Without the struct you can have an impersonator
 >>>> contract. Another solution is to make the struct mutable, which would
 >>>> allow for impersonator contracts on fields.
 >>>> 
 >>>> The problem with this reasoning is that it looks like the last good
 >>>> commit you gave had the same static contract. So I need to investigate
 >>>> more.
 >>>> 
 >>>> 
 >>>> On Sat, Jan 18, 2014 at 1:50 PM, Tony Garnock-Jones <tonyg@ccs.neu.edu> wrote:
 >>>>> Also relevant: if I change the definition of "action" from
 >>>>> 
 >>>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>> 
 >>>>> to the more-or-less equivalent
 >>>>> 
 >>>>> (define-type (action State) (Rec X (State -> X)))
 >>>>> 
 >>>>> then it compiles 20140118-outer.rkt successfully.
 >>>>> 
 >> 
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Tony Garnock-Jones <tonyg@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14301: Unexpected TR complaint: "Type Checker:
 The type of vm-process cannot be converted to a contract"
Date: Mon, 20 Jan 2014 11:09:12 -0500

 On Mon, Jan 20, 2014 at 10:53 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > Yes, that explains the last few exchanges well. Thanks.
 >
 > What I don't understand is your claim that Tony's bug isn't a bug.
 > I thought that typed Marketplace ran fine and now it no longer runs.
 
 I think what's going on here is that the new error causes more
 programs to fail than the previous error, because the previous error
 only happened if the contract was genuinely used. For example, this
 program:
 
 ```
 #lang racket
 (module m racket
   (struct p (x))
 
   (define c (letrec ((r
                       (or/c p?
                             (recursive-contract
                              (struct/c p r)))))
               r))
 
   (define x (p 1))
 
   (provide/contract [x c]))
 
 (require 'm)
 
 x
 ```
 
 runs without error.  However, if you take out the `p?`, it produces an
 error from the contract system saying that we needed a chaperone
 contract, but got an impersonator contract.  Typed Racket used to
 generate contracts like this, but now it just refuses, and the program
 always errors, but with a sensible error message.
 
 I'm not sure there's a better solution here.
 
 Sam
 
 
 >
 > On Jan 19, 2014, at 5:17 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >
 >> From scratch:
 >>
 >> The following program has all the essential elemnts of the original bug report:
 >> #lang racket/load
 >>
 >> (module tr typed/racket/base
 >>  (provide (all-defined-out))
 >>
 >>  (define-type (CoProcess R) (All (State) (action State) -> R))
 >>  (struct: (State) action ([k : (State -> (action State))]))
 >>
 >>  (: loop-action (All (State) (-> (action State))))
 >>  (define (loop-action)
 >>    (action (λ: ([s : State]) ((inst loop-action State)))))
 >>
 >>  (: process ((All (State) (action State) -> #f) -> #f))
 >>  (define (process co-p)
 >>    (co-p ((inst loop-action #f))))
 >>
 >>  )
 >>
 >> (require 'tr)
 >> (process (lambda (x) #f))
 >>
 >> Before any of the static contract changes this gave an error like this
 >> at run time:
 >>
 >> struct/dc: contract violation
 >>  expected: a chaperone-contract? for field (#:selector action-k)
 >>  given: #<contract: (-> State4 (recursive-contract n*56 #:impersonator))>
 >>  context...:
 >>   /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/struct-dc.rkt:505:0:
 >> build-struct/dc
 >>   /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/parametric.rkt:35:7:
 >> wrap
 >>   /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/parametric.rkt:54:12
 >>   /Users/endobson/tmp/tmp2.rkt: [running body]
 >>
 >> Up through 1acd1537e8e439376da4c925dd4cc96334467f16, this behavior should hold.
 >>
 >> f17f6655dd2400ffb91e1116513db4ce2056b743, fixes a bug in the logic (at
 >> expansion time) that was supposed to detect impersonator contracts in
 >> field contracts so that we don't generate code that fails with this
 >> error. So at that commit instead of generating code to generate
 >> contracts that fails at run time we instead generate an error message
 >> saying that it is impossible to generate a contract for the type.
 >>
 >> Does that explain it better?
 >>
 >> On Sun, Jan 19, 2014 at 2:01 PM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> Eric, can you explain the last two paragraphs:
 >>>
 >>>> This program fails with a contract system error because TR isn't
 >>>> correctly enforcing the checks before creating the contracts at
 >>>> 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 >>>> commit').
 >>>>
 >>>> It also fails right before any of the static contract work. Thus I
 >>>> think this is not a bug.
 >>>
 >>> especially the TR 's not correctly enforcing the checks?
 >>>
 >>>
 >>>
 >>>
 >>> On Jan 19, 2014, at 1:35 PM, Eric Dobson wrote:
 >>>
 >>>> f17f6655dd2400ffb91e1116513db4ce2056b743 is the change that breaks it,
 >>>> but this is also the change that introduced a latent bug so needs
 >>>> e164a959eb3aa97938fb4ae9f98cfb67aee38b9f to fix it.
 >>>>
 >>>> The problem is that this looks like it was fixing another bug where
 >>>> the restriction to being a chaperone contract wasn't enforced
 >>>> statically.
 >>>>
 >>>>
 >>>> #lang racket/load
 >>>>
 >>>> (module tr typed/racket/base
 >>>> (provide (all-defined-out))
 >>>>
 >>>> (define-type (CoProcess R) (All (State) (action State) -> R))
 >>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>
 >>>> (: loop-action (All (State) (-> (action State))))
 >>>> (define (loop-action)
 >>>>   (action (λ: ([s : State]) ((inst loop-action State)))))
 >>>>
 >>>> (: process ((All (State) (action State) -> #f) -> #f))
 >>>> (define (process co-p)
 >>>>   (co-p ((inst loop-action #f))))
 >>>>
 >>>> )
 >>>>
 >>>> (require 'tr)
 >>>> (process (lambda (x) #f))
 >>>>
 >>>> This program fails with a contract system error because TR isn't
 >>>> correctly enforcing the checks before creating the contracts at
 >>>> 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 >>>> commit').
 >>>>
 >>>> It also fails right before any of the static contract work. Thus I
 >>>> think this is not a bug.
 >>>>
 >>>> On Sun, Jan 19, 2014 at 10:10 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>> I'm not certain this is a bug. My changes made TR generate more
 >>>>> correct contracts in some cases, and recursive uses of polymorphic
 >>>>> types is one of them. Your 'more-or-less' equivalent type gives good
 >>>>> evidence for this.
 >>>>>
 >>>>> The program is this:
 >>>>>
 >>>>> #lang racket/load
 >>>>>
 >>>>> (module tr typed/racket/base
 >>>>> (provide (all-defined-out))
 >>>>>
 >>>>> (define-type (CoProcess R) (All (State) (action State) -> R))
 >>>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>>
 >>>>> (: process ((All (State) (action State) -> #f) -> #f))
 >>>>> (define (process co-p)
 >>>>>   #f)
 >>>>>
 >>>>> )
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>> (require 'tr)
 >>>>> (print process)
 >>>>> (newline)
 >>>>>
 >>>>>
 >>>>> So we need to generate a contract for a process, and fail.
 >>>>>
 >>>>> The static contract we generate is
 >>>>> (->/sc (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc (->/sc State4
 >>>>> n*5)))) n*5) (flat/sc (flat-named-contract '#f (lambda (x) (equal? x
 >>>>> '#f)))))))
 >>>>>
 >>>>> [The parametric var doesn't currently print, but it is State4 in this
 >>>>> case. Also ->/sc doesn't print a final return type if it doesn't have
 >>>>> one.]
 >>>>>
 >>>>> But the core part is: (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc
 >>>>> (->/sc State4 n*5)))) n*5)
 >>>>>
 >>>>> (->/sc State4 n*5) is an impersonator contract which is not allowed as
 >>>>> a field contract of an immutable struct, and so we cannot make a
 >>>>> contract out of this. Without the struct you can have an impersonator
 >>>>> contract. Another solution is to make the struct mutable, which would
 >>>>> allow for impersonator contracts on fields.
 >>>>>
 >>>>> The problem with this reasoning is that it looks like the last good
 >>>>> commit you gave had the same static contract. So I need to investigate
 >>>>> more.
 >>>>>
 >>>>>
 >>>>> On Sat, Jan 18, 2014 at 1:50 PM, Tony Garnock-Jones <tonyg@ccs.neu.edu> wrote:
 >>>>>> Also relevant: if I change the definition of "action" from
 >>>>>>
 >>>>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>>>
 >>>>>> to the more-or-less equivalent
 >>>>>>
 >>>>>> (define-type (action State) (Rec X (State -> X)))
 >>>>>>
 >>>>>> then it compiles 20140118-outer.rkt successfully.
 >>>>>>
 >>>
 >
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Tony Garnock-Jones <tonyg@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14301: Unexpected TR complaint: "Type Checker: The type of vm-process cannot be converted to a contract"
Date: Mon, 20 Jan 2014 11:20:59 -0500

 Duh, how obvious. Thanks. 
 
 ;; -- 
 
 Isn't part of the problem that recursive contracts mean you need some way of constructing cyclic values and we don't construct cyclic values w/o set-able fields? 
 
 
 
 
 
 On Jan 20, 2014, at 11:09 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > On Mon, Jan 20, 2014 at 10:53 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> Yes, that explains the last few exchanges well. Thanks.
 >> 
 >> What I don't understand is your claim that Tony's bug isn't a bug.
 >> I thought that typed Marketplace ran fine and now it no longer runs.
 > 
 > I think what's going on here is that the new error causes more
 > programs to fail than the previous error, because the previous error
 > only happened if the contract was genuinely used. For example, this
 > program:
 > 
 > ```
 > #lang racket
 > (module m racket
 >  (struct p (x))
 > 
 >  (define c (letrec ((r
 >                      (or/c p?
 >                            (recursive-contract
 >                             (struct/c p r)))))
 >              r))
 > 
 >  (define x (p 1))
 > 
 >  (provide/contract [x c]))
 > 
 > (require 'm)
 > 
 > x
 > ```
 > 
 > runs without error.  However, if you take out the `p?`, it produces an
 > error from the contract system saying that we needed a chaperone
 > contract, but got an impersonator contract.  Typed Racket used to
 > generate contracts like this, but now it just refuses, and the program
 > always errors, but with a sensible error message.
 > 
 > I'm not sure there's a better solution here.
 > 
 > Sam
 > 
 > 
 >> 
 >> On Jan 19, 2014, at 5:17 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> 
 >>> From scratch:
 >>> 
 >>> The following program has all the essential elemnts of the original bug report:
 >>> #lang racket/load
 >>> 
 >>> (module tr typed/racket/base
 >>> (provide (all-defined-out))
 >>> 
 >>> (define-type (CoProcess R) (All (State) (action State) -> R))
 >>> (struct: (State) action ([k : (State -> (action State))]))
 >>> 
 >>> (: loop-action (All (State) (-> (action State))))
 >>> (define (loop-action)
 >>>   (action (λ: ([s : State]) ((inst loop-action State)))))
 >>> 
 >>> (: process ((All (State) (action State) -> #f) -> #f))
 >>> (define (process co-p)
 >>>   (co-p ((inst loop-action #f))))
 >>> 
 >>> )
 >>> 
 >>> (require 'tr)
 >>> (process (lambda (x) #f))
 >>> 
 >>> Before any of the static contract changes this gave an error like this
 >>> at run time:
 >>> 
 >>> struct/dc: contract violation
 >>> expected: a chaperone-contract? for field (#:selector action-k)
 >>> given: #<contract: (-> State4 (recursive-contract n*56 #:impersonator))>
 >>> context...:
 >>>  /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/struct-dc.rkt:505:0:
 >>> build-struct/dc
 >>>  /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/parametric.rkt:35:7:
 >>> wrap
 >>>  /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/parametric.rkt:54:12
 >>>  /Users/endobson/tmp/tmp2.rkt: [running body]
 >>> 
 >>> Up through 1acd1537e8e439376da4c925dd4cc96334467f16, this behavior should hold.
 >>> 
 >>> f17f6655dd2400ffb91e1116513db4ce2056b743, fixes a bug in the logic (at
 >>> expansion time) that was supposed to detect impersonator contracts in
 >>> field contracts so that we don't generate code that fails with this
 >>> error. So at that commit instead of generating code to generate
 >>> contracts that fails at run time we instead generate an error message
 >>> saying that it is impossible to generate a contract for the type.
 >>> 
 >>> Does that explain it better?
 >>> 
 >>> On Sun, Jan 19, 2014 at 2:01 PM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>> 
 >>>> Eric, can you explain the last two paragraphs:
 >>>> 
 >>>>> This program fails with a contract system error because TR isn't
 >>>>> correctly enforcing the checks before creating the contracts at
 >>>>> 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 >>>>> commit').
 >>>>> 
 >>>>> It also fails right before any of the static contract work. Thus I
 >>>>> think this is not a bug.
 >>>> 
 >>>> especially the TR 's not correctly enforcing the checks?
 >>>> 
 >>>> 
 >>>> 
 >>>> 
 >>>> On Jan 19, 2014, at 1:35 PM, Eric Dobson wrote:
 >>>> 
 >>>>> f17f6655dd2400ffb91e1116513db4ce2056b743 is the change that breaks it,
 >>>>> but this is also the change that introduced a latent bug so needs
 >>>>> e164a959eb3aa97938fb4ae9f98cfb67aee38b9f to fix it.
 >>>>> 
 >>>>> The problem is that this looks like it was fixing another bug where
 >>>>> the restriction to being a chaperone contract wasn't enforced
 >>>>> statically.
 >>>>> 
 >>>>> 
 >>>>> #lang racket/load
 >>>>> 
 >>>>> (module tr typed/racket/base
 >>>>> (provide (all-defined-out))
 >>>>> 
 >>>>> (define-type (CoProcess R) (All (State) (action State) -> R))
 >>>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>> 
 >>>>> (: loop-action (All (State) (-> (action State))))
 >>>>> (define (loop-action)
 >>>>>  (action (λ: ([s : State]) ((inst loop-action State)))))
 >>>>> 
 >>>>> (: process ((All (State) (action State) -> #f) -> #f))
 >>>>> (define (process co-p)
 >>>>>  (co-p ((inst loop-action #f))))
 >>>>> 
 >>>>> )
 >>>>> 
 >>>>> (require 'tr)
 >>>>> (process (lambda (x) #f))
 >>>>> 
 >>>>> This program fails with a contract system error because TR isn't
 >>>>> correctly enforcing the checks before creating the contracts at
 >>>>> 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 >>>>> commit').
 >>>>> 
 >>>>> It also fails right before any of the static contract work. Thus I
 >>>>> think this is not a bug.
 >>>>> 
 >>>>> On Sun, Jan 19, 2014 at 10:10 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>> I'm not certain this is a bug. My changes made TR generate more
 >>>>>> correct contracts in some cases, and recursive uses of polymorphic
 >>>>>> types is one of them. Your 'more-or-less' equivalent type gives good
 >>>>>> evidence for this.
 >>>>>> 
 >>>>>> The program is this:
 >>>>>> 
 >>>>>> #lang racket/load
 >>>>>> 
 >>>>>> (module tr typed/racket/base
 >>>>>> (provide (all-defined-out))
 >>>>>> 
 >>>>>> (define-type (CoProcess R) (All (State) (action State) -> R))
 >>>>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>>> 
 >>>>>> (: process ((All (State) (action State) -> #f) -> #f))
 >>>>>> (define (process co-p)
 >>>>>>  #f)
 >>>>>> 
 >>>>>> )
 >>>>>> 
 >>>>>> 
 >>>>>> 
 >>>>>> 
 >>>>>> (require 'tr)
 >>>>>> (print process)
 >>>>>> (newline)
 >>>>>> 
 >>>>>> 
 >>>>>> So we need to generate a contract for a process, and fail.
 >>>>>> 
 >>>>>> The static contract we generate is
 >>>>>> (->/sc (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc (->/sc State4
 >>>>>> n*5)))) n*5) (flat/sc (flat-named-contract '#f (lambda (x) (equal? x
 >>>>>> '#f)))))))
 >>>>>> 
 >>>>>> [The parametric var doesn't currently print, but it is State4 in this
 >>>>>> case. Also ->/sc doesn't print a final return type if it doesn't have
 >>>>>> one.]
 >>>>>> 
 >>>>>> But the core part is: (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc
 >>>>>> (->/sc State4 n*5)))) n*5)
 >>>>>> 
 >>>>>> (->/sc State4 n*5) is an impersonator contract which is not allowed as
 >>>>>> a field contract of an immutable struct, and so we cannot make a
 >>>>>> contract out of this. Without the struct you can have an impersonator
 >>>>>> contract. Another solution is to make the struct mutable, which would
 >>>>>> allow for impersonator contracts on fields.
 >>>>>> 
 >>>>>> The problem with this reasoning is that it looks like the last good
 >>>>>> commit you gave had the same static contract. So I need to investigate
 >>>>>> more.
 >>>>>> 
 >>>>>> 
 >>>>>> On Sat, Jan 18, 2014 at 1:50 PM, Tony Garnock-Jones <tonyg@ccs.neu.edu> wrote:
 >>>>>>> Also relevant: if I change the definition of "action" from
 >>>>>>> 
 >>>>>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>>>> 
 >>>>>>> to the more-or-less equivalent
 >>>>>>> 
 >>>>>>> (define-type (action State) (Rec X (State -> X)))
 >>>>>>> 
 >>>>>>> then it compiles 20140118-outer.rkt successfully.
 >>>>>>> 
 >>>> 
 >> 
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>,
        Tony Garnock-Jones <tonyg@ccs.neu.edu>, bugs <bugs@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14301: Unexpected TR complaint: "Type Checker:
 The type of vm-process cannot be converted to a contract"
Date: Mon, 20 Jan 2014 11:25:32 -0500

 On Mon, Jan 20, 2014 at 11:20 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > Duh, how obvious. Thanks.
 >
 > ;; --
 >
 > Isn't part of the problem that recursive contracts mean you need some way of constructing cyclic values and we don't construct cyclic values w/o set-able fields?
 
 No. Recursive contracts construct cyclic values by using closures --
 they're basically the same as `delay`. It's the delaying that makes
 the incorrect program work anyway; as we know, lazy evaluation
 produces more answers than strict evaluation.
 
 >
 >
 >
 >
 >
 > On Jan 20, 2014, at 11:09 AM, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 >
 >> On Mon, Jan 20, 2014 at 10:53 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> Yes, that explains the last few exchanges well. Thanks.
 >>>
 >>> What I don't understand is your claim that Tony's bug isn't a bug.
 >>> I thought that typed Marketplace ran fine and now it no longer runs.
 >>
 >> I think what's going on here is that the new error causes more
 >> programs to fail than the previous error, because the previous error
 >> only happened if the contract was genuinely used. For example, this
 >> program:
 >>
 >> ```
 >> #lang racket
 >> (module m racket
 >>  (struct p (x))
 >>
 >>  (define c (letrec ((r
 >>                      (or/c p?
 >>                            (recursive-contract
 >>                             (struct/c p r)))))
 >>              r))
 >>
 >>  (define x (p 1))
 >>
 >>  (provide/contract [x c]))
 >>
 >> (require 'm)
 >>
 >> x
 >> ```
 >>
 >> runs without error.  However, if you take out the `p?`, it produces an
 >> error from the contract system saying that we needed a chaperone
 >> contract, but got an impersonator contract.  Typed Racket used to
 >> generate contracts like this, but now it just refuses, and the program
 >> always errors, but with a sensible error message.
 >>
 >> I'm not sure there's a better solution here.
 >>
 >> Sam
 >>
 >>
 >>>
 >>> On Jan 19, 2014, at 5:17 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>
 >>>> From scratch:
 >>>>
 >>>> The following program has all the essential elemnts of the original bug report:
 >>>> #lang racket/load
 >>>>
 >>>> (module tr typed/racket/base
 >>>> (provide (all-defined-out))
 >>>>
 >>>> (define-type (CoProcess R) (All (State) (action State) -> R))
 >>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>
 >>>> (: loop-action (All (State) (-> (action State))))
 >>>> (define (loop-action)
 >>>>   (action (λ: ([s : State]) ((inst loop-action State)))))
 >>>>
 >>>> (: process ((All (State) (action State) -> #f) -> #f))
 >>>> (define (process co-p)
 >>>>   (co-p ((inst loop-action #f))))
 >>>>
 >>>> )
 >>>>
 >>>> (require 'tr)
 >>>> (process (lambda (x) #f))
 >>>>
 >>>> Before any of the static contract changes this gave an error like this
 >>>> at run time:
 >>>>
 >>>> struct/dc: contract violation
 >>>> expected: a chaperone-contract? for field (#:selector action-k)
 >>>> given: #<contract: (-> State4 (recursive-contract n*56 #:impersonator))>
 >>>> context...:
 >>>>  /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/struct-dc.rkt:505:0:
 >>>> build-struct/dc
 >>>>  /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/parametric.rkt:35:7:
 >>>> wrap
 >>>>  /Users/endobson/proj/racket/plt/racket/collects/racket/contract/private/parametric.rkt:54:12
 >>>>  /Users/endobson/tmp/tmp2.rkt: [running body]
 >>>>
 >>>> Up through 1acd1537e8e439376da4c925dd4cc96334467f16, this behavior should hold.
 >>>>
 >>>> f17f6655dd2400ffb91e1116513db4ce2056b743, fixes a bug in the logic (at
 >>>> expansion time) that was supposed to detect impersonator contracts in
 >>>> field contracts so that we don't generate code that fails with this
 >>>> error. So at that commit instead of generating code to generate
 >>>> contracts that fails at run time we instead generate an error message
 >>>> saying that it is impossible to generate a contract for the type.
 >>>>
 >>>> Does that explain it better?
 >>>>
 >>>> On Sun, Jan 19, 2014 at 2:01 PM, Matthias Felleisen
 >>>> <matthias@ccs.neu.edu> wrote:
 >>>>>
 >>>>> Eric, can you explain the last two paragraphs:
 >>>>>
 >>>>>> This program fails with a contract system error because TR isn't
 >>>>>> correctly enforcing the checks before creating the contracts at
 >>>>>> 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 >>>>>> commit').
 >>>>>>
 >>>>>> It also fails right before any of the static contract work. Thus I
 >>>>>> think this is not a bug.
 >>>>>
 >>>>> especially the TR 's not correctly enforcing the checks?
 >>>>>
 >>>>>
 >>>>>
 >>>>>
 >>>>> On Jan 19, 2014, at 1:35 PM, Eric Dobson wrote:
 >>>>>
 >>>>>> f17f6655dd2400ffb91e1116513db4ce2056b743 is the change that breaks it,
 >>>>>> but this is also the change that introduced a latent bug so needs
 >>>>>> e164a959eb3aa97938fb4ae9f98cfb67aee38b9f to fix it.
 >>>>>>
 >>>>>> The problem is that this looks like it was fixing another bug where
 >>>>>> the restriction to being a chaperone contract wasn't enforced
 >>>>>> statically.
 >>>>>>
 >>>>>>
 >>>>>> #lang racket/load
 >>>>>>
 >>>>>> (module tr typed/racket/base
 >>>>>> (provide (all-defined-out))
 >>>>>>
 >>>>>> (define-type (CoProcess R) (All (State) (action State) -> R))
 >>>>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>>>
 >>>>>> (: loop-action (All (State) (-> (action State))))
 >>>>>> (define (loop-action)
 >>>>>>  (action (λ: ([s : State]) ((inst loop-action State)))))
 >>>>>>
 >>>>>> (: process ((All (State) (action State) -> #f) -> #f))
 >>>>>> (define (process co-p)
 >>>>>>  (co-p ((inst loop-action #f))))
 >>>>>>
 >>>>>> )
 >>>>>>
 >>>>>> (require 'tr)
 >>>>>> (process (lambda (x) #f))
 >>>>>>
 >>>>>> This program fails with a contract system error because TR isn't
 >>>>>> correctly enforcing the checks before creating the contracts at
 >>>>>> 1acd1537e8e439376da4c925dd4cc96334467f16 (one before the 'breaking
 >>>>>> commit').
 >>>>>>
 >>>>>> It also fails right before any of the static contract work. Thus I
 >>>>>> think this is not a bug.
 >>>>>>
 >>>>>> On Sun, Jan 19, 2014 at 10:10 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>>> I'm not certain this is a bug. My changes made TR generate more
 >>>>>>> correct contracts in some cases, and recursive uses of polymorphic
 >>>>>>> types is one of them. Your 'more-or-less' equivalent type gives good
 >>>>>>> evidence for this.
 >>>>>>>
 >>>>>>> The program is this:
 >>>>>>>
 >>>>>>> #lang racket/load
 >>>>>>>
 >>>>>>> (module tr typed/racket/base
 >>>>>>> (provide (all-defined-out))
 >>>>>>>
 >>>>>>> (define-type (CoProcess R) (All (State) (action State) -> R))
 >>>>>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>>>>
 >>>>>>> (: process ((All (State) (action State) -> #f) -> #f))
 >>>>>>> (define (process co-p)
 >>>>>>>  #f)
 >>>>>>>
 >>>>>>> )
 >>>>>>>
 >>>>>>>
 >>>>>>>
 >>>>>>>
 >>>>>>> (require 'tr)
 >>>>>>> (print process)
 >>>>>>> (newline)
 >>>>>>>
 >>>>>>>
 >>>>>>> So we need to generate a contract for a process, and fail.
 >>>>>>>
 >>>>>>> The static contract we generate is
 >>>>>>> (->/sc (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc (->/sc State4
 >>>>>>> n*5)))) n*5) (flat/sc (flat-named-contract '#f (lambda (x) (equal? x
 >>>>>>> '#f)))))))
 >>>>>>>
 >>>>>>> [The parametric var doesn't currently print, but it is State4 in this
 >>>>>>> case. Also ->/sc doesn't print a final return type if it doesn't have
 >>>>>>> one.]
 >>>>>>>
 >>>>>>> But the core part is: (parametric->/sc (->/sc (rec/sc ((n*5 (struct/sc
 >>>>>>> (->/sc State4 n*5)))) n*5)
 >>>>>>>
 >>>>>>> (->/sc State4 n*5) is an impersonator contract which is not allowed as
 >>>>>>> a field contract of an immutable struct, and so we cannot make a
 >>>>>>> contract out of this. Without the struct you can have an impersonator
 >>>>>>> contract. Another solution is to make the struct mutable, which would
 >>>>>>> allow for impersonator contracts on fields.
 >>>>>>>
 >>>>>>> The problem with this reasoning is that it looks like the last good
 >>>>>>> commit you gave had the same static contract. So I need to investigate
 >>>>>>> more.
 >>>>>>>
 >>>>>>>
 >>>>>>> On Sat, Jan 18, 2014 at 1:50 PM, Tony Garnock-Jones <tonyg@ccs.neu.edu> wrote:
 >>>>>>>> Also relevant: if I change the definition of "action" from
 >>>>>>>>
 >>>>>>>> (struct: (State) action ([k : (State -> (action State))]))
 >>>>>>>>
 >>>>>>>> to the more-or-less equivalent
 >>>>>>>>
 >>>>>>>> (define-type (action State) (Rec X (State -> X)))
 >>>>>>>>
 >>>>>>>> then it compiles 20140118-outer.rkt successfully.
 >>>>>>>>
 >>>>>
 >>>
 >
 

