From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Mon Jun 16 15:30:49 2014
Received: from mail-ob0-f177.google.com (mail-ob0-f177.google.com [209.85.214.177])
	by winooski.ccs.neu.edu (8.14.7/8.14.7) with ESMTP id s5GJUije011724
	for <bugs@bugs.plt-scheme.org>; Mon, 16 Jun 2014 15:30:44 -0400
Message-Id: <201406161930.s5GJUf1v011718@winooski.ccs.neu.edu>
Date: Mon, 16 Jun 2014 15:30:41 -0400
From: alexander@knauth.org
To: bugs@racket-lang.org
Subject: can't convert ((Syntaxof Any) -> Any) to a contract

>Number:         14581
>Category:       typed-scheme
>Synopsis:       can't convert ((Syntaxof Any) -> Any) to a contract
>Class:          sw-bug
>Responsible:    samth
>Severity:       serious
>Priority:       medium
>State:          open
>Confidential:   no
>Arrival-Date:   Mon Jun 16 15:32:01 -0400 2014
>Last-Modified:  Sat Jul 12 23:36:01 -0400 2014
>Originator:     Alex Knauth
>Organization:
plt
>Submitter-Id:   unknown
>Release:        6.0.1.8--2014-05-10(722c4fd/a)
>Environment:
macosx "Darwin Alexander-D-Knauths-Computer-2.local 13.1.0 Darwin Kernel Version 13.1.0: Thu Jan 16 19:40:37 PST 2014; root:xnu-2422.90.20~2/RELEASE_X86_64 x86_64" (x86_64-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 934744728
raco pkg (show):
Installation-wide:
 Package              Checksum                                    Source
 main-distribution    820e85aeae454e9aaa7090e53100c639fc7aac6f    (catalog main-distribution)
 racket-lib           a5ad75266826476cc1034e69afe7ca6740b572d7    (catalog racket-lib)
 [177 auto-installed packages not shown]
User-specific for installation "snapshot":
 Package                Checksum                                    Source
 c                      e53e075ef547c106d5e8092aed2aaae1eb0c4f7d    (catalog c)
 contract-repl          9e96a1ee4f819abab253a1276aaacd8bc21e29b7    (catalog contract-repl)
 drracket-solarized     3c7ac56e3bde4f52653c08ad1058188f9bc10184    (catalog drracket-solarized)
 experimental-lang      #f                                          (link ../../../../Documents/DrRacket/stuff/experimental-lang pkg/experimental-lang)
 first-class-methods    #f                                          (link ../../../../Documents/DrRacket/stuff/first-class-methods pkg/first-class-methods)
 raw-string             c922d2ea88ab98b9bffd5d2c74f48c64cbd75577    (catalog raw-string)



Collections:
("/Users/Alex/Library/Racket/snapshot/collects"
 (non-existent-path))
("/Applications/Racket v6.0.1.8/collects"
 (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "rackunit" "raco" "reader" "realm" "s-exp" "scheme" "setup" "srfi" "syntax" "syntax copy" "unstable" "version" "xml"))

Recent Internal Errors: 
Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang at-exp racket\n" #f #t ((main) (test)) #t))
>Description:
When I do this:
#lang typed/racket
(cast (lambda (x) 0)
      [(Syntaxof Any) -> Any])
It gives me this error:
. Type Checker: Type (-> (Syntaxof Any) Any) could not be 
converted to a contract: required a flat contract but generated a 
chaperone contract in: ((Syntaxof Any) -> Any)

If I replace (Syntaxof Any) with almost anything else (so far) it 
works fine.  
Also, it works with (Syntaxof (U False (Listof Any))), but not 
with (Syntaxof (Listof Any)), which is really weird.  
And why would it require a flat contract?  
>How-To-Repeat:
#lang typed/racket
(cast (lambda (x) 0)
      [(Syntaxof Any) -> Any])
>Fix:
>Audit-Trail:
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Alex Knauth <alexander@knauth.org>, bugs <bugs@racket-lang.org>
Cc: nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sun, 6 Jul 2014 11:52:26 -0700

 The case where it doesn't trigger the error message is the bug.
 
 The reason why it wants a flat contract is that syntax/c requires a
 flat contract.
 http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 
 On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 > A new problem report is waiting at
 >   http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >
 > Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >
 > *** Description:
 > When I do this:
 > #lang typed/racket
 > (cast (lambda (x) 0)
 >       [(Syntaxof Any) -> Any])
 > It gives me this error:
 > . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 > converted to a contract: required a flat contract but generated a
 > chaperone contract in: ((Syntaxof Any) -> Any)
 >
 > If I replace (Syntaxof Any) with almost anything else (so far) it
 > works fine.
 > Also, it works with (Syntaxof (U False (Listof Any))), but not
 > with (Syntaxof (Listof Any)), which is really weird.
 > And why would it require a flat contract?
 >
 > *** How to repeat:
 > #lang typed/racket
 > (cast (lambda (x) 0)
 >       [(Syntaxof Any) -> Any])
 >
 > *** Environment:
 > macosx "Darwin Alexander-D-Knauths-Computer-2.local 13.1.0 Darwin Kernel Version 13.1.0: Thu Jan 16 19:40:37 PST 2014; root:xnu-2422.90.20~2/RELEASE_X86_64 x86_64" (x86_64-macosx/3m) (get-display-depth) = 32
 > Human Language: english
 > (current-memory-use) 934744728
 > raco pkg (show):
 > Installation-wide:
 >  Package              Checksum                                    Source
 >  main-distribution    820e85aeae454e9aaa7090e53100c639fc7aac6f    (catalog main-distribution)
 >  racket-lib           a5ad75266826476cc1034e69afe7ca6740b572d7    (catalog racket-lib)
 >  [177 auto-installed packages not shown]
 > User-specific for installation "snapshot":
 >  Package                Checksum                                    Source
 >  c                      e53e075ef547c106d5e8092aed2aaae1eb0c4f7d    (catalog c)
 >  contract-repl          9e96a1ee4f819abab253a1276aaacd8bc21e29b7    (catalog contract-repl)
 >  drracket-solarized     3c7ac56e3bde4f52653c08ad1058188f9bc10184    (catalog drracket-solarized)
 >  experimental-lang      #f                                          (link ../../../../Documents/DrRacket/stuff/experimental-lang pkg/experimental-lang)
 >  first-class-methods    #f                                          (link ../../../../Documents/DrRacket/stuff/first-class-methods pkg/first-class-methods)
 >  raw-string             c922d2ea88ab98b9bffd5d2c74f48c64cbd75577    (catalog raw-string)
 >
 >
 >
 > Collections:
 > ("/Users/Alex/Library/Racket/snapshot/collects"
 >  (non-existent-path))
 > ("/Applications/Racket v6.0.1.8/collects"
 >  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "rackunit" "raco" "reader" "realm" "s-exp" "scheme" "setup" "srfi" "syntax" "syntax copy" "unstable" "version" "xml"))
 >
 > Recent Internal Errors:
 > Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang at-exp racket\n" #f #t ((main) (test)) #t))
 >
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Alex Knauth <alexander@knauth.org>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sun, 6 Jul 2014 17:44:07 -0500

 Would it be sound for TR to identify those places where any would have
 to be generating a flat contract and generate a contract that just
 rejects all functions (and other ho values)?
 
 Robby
 
 
 On Sun, Jul 6, 2014 at 1:52 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > The case where it doesn't trigger the error message is the bug.
 >
 > The reason why it wants a flat contract is that syntax/c requires a
 > flat contract.
 > http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 >
 > On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 >> A new problem report is waiting at
 >>   http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >>
 >> Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >>
 >> *** Description:
 >> When I do this:
 >> #lang typed/racket
 >> (cast (lambda (x) 0)
 >>       [(Syntaxof Any) -> Any])
 >> It gives me this error:
 >> . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 >> converted to a contract: required a flat contract but generated a
 >> chaperone contract in: ((Syntaxof Any) -> Any)
 >>
 >> If I replace (Syntaxof Any) with almost anything else (so far) it
 >> works fine.
 >> Also, it works with (Syntaxof (U False (Listof Any))), but not
 >> with (Syntaxof (Listof Any)), which is really weird.
 >> And why would it require a flat contract?
 >>
 >> *** How to repeat:
 >> #lang typed/racket
 >> (cast (lambda (x) 0)
 >>       [(Syntaxof Any) -> Any])
 >>
 >> *** Environment:
 >> macosx "Darwin Alexander-D-Knauths-Computer-2.local 13.1.0 Darwin Kernel Version 13.1.0: Thu Jan 16 19:40:37 PST 2014; root:xnu-2422.90.20~2/RELEASE_X86_64 x86_64" (x86_64-macosx/3m) (get-display-depth) = 32
 >> Human Language: english
 >> (current-memory-use) 934744728
 >> raco pkg (show):
 >> Installation-wide:
 >>  Package              Checksum                                    Source
 >>  main-distribution    820e85aeae454e9aaa7090e53100c639fc7aac6f    (catalog main-distribution)
 >>  racket-lib           a5ad75266826476cc1034e69afe7ca6740b572d7    (catalog racket-lib)
 >>  [177 auto-installed packages not shown]
 >> User-specific for installation "snapshot":
 >>  Package                Checksum                                    Source
 >>  c                      e53e075ef547c106d5e8092aed2aaae1eb0c4f7d    (catalog c)
 >>  contract-repl          9e96a1ee4f819abab253a1276aaacd8bc21e29b7    (catalog contract-repl)
 >>  drracket-solarized     3c7ac56e3bde4f52653c08ad1058188f9bc10184    (catalog drracket-solarized)
 >>  experimental-lang      #f                                          (link ../../../../Documents/DrRacket/stuff/experimental-lang pkg/experimental-lang)
 >>  first-class-methods    #f                                          (link ../../../../Documents/DrRacket/stuff/first-class-methods pkg/first-class-methods)
 >>  raw-string             c922d2ea88ab98b9bffd5d2c74f48c64cbd75577    (catalog raw-string)
 >>
 >>
 >>
 >> Collections:
 >> ("/Users/Alex/Library/Racket/snapshot/collects"
 >>  (non-existent-path))
 >> ("/Applications/Racket v6.0.1.8/collects"
 >>  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "rackunit" "raco" "reader" "realm" "s-exp" "scheme" "setup" "srfi" "syntax" "syntax copy" "unstable" "version" "xml"))
 >>
 >> Recent Internal Errors:
 >> Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang at-exp racket\n" #f #t ((main) (test)) #t))
 >>
 
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Alex Knauth <alexander@knauth.org>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sun, 6 Jul 2014 15:55:05 -0700

 I don't think that would work because of blame.
 
 Imagine a function of type (-> (Syntaxof Any)) provided by a typed
 module. If calling this function returns a syntax object with a
 function in it, who is to blame for the contract violation? It
 shoudln't be the untyped caller because they didn't do anything wrong,
 and it shouldn't be the typed module since typed module's shouldn't
 violate contracts.
 
 Also by the time that we can figure out if we require it to be a flat
 contract we have already had to commit to it being a chaperone
 contract for generating recursive contracts.
 
 On Sun, Jul 6, 2014 at 3:44 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > Would it be sound for TR to identify those places where any would have
 > to be generating a flat contract and generate a contract that just
 > rejects all functions (and other ho values)?
 >
 > Robby
 >
 >
 > On Sun, Jul 6, 2014 at 1:52 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> The case where it doesn't trigger the error message is the bug.
 >>
 >> The reason why it wants a flat contract is that syntax/c requires a
 >> flat contract.
 >> http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 >>
 >> On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 >>> A new problem report is waiting at
 >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >>>
 >>> Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >>>
 >>> *** Description:
 >>> When I do this:
 >>> #lang typed/racket
 >>> (cast (lambda (x) 0)
 >>>       [(Syntaxof Any) -> Any])
 >>> It gives me this error:
 >>> . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 >>> converted to a contract: required a flat contract but generated a
 >>> chaperone contract in: ((Syntaxof Any) -> Any)
 >>>
 >>> If I replace (Syntaxof Any) with almost anything else (so far) it
 >>> works fine.
 >>> Also, it works with (Syntaxof (U False (Listof Any))), but not
 >>> with (Syntaxof (Listof Any)), which is really weird.
 >>> And why would it require a flat contract?
 >>>
 >>> *** How to repeat:
 >>> #lang typed/racket
 >>> (cast (lambda (x) 0)
 >>>       [(Syntaxof Any) -> Any])
 >>>
 >>> *** Environment:
 >>> macosx "Darwin Alexander-D-Knauths-Computer-2.local 13.1.0 Darwin Kernel Version 13.1.0: Thu Jan 16 19:40:37 PST 2014; root:xnu-2422.90.20~2/RELEASE_X86_64 x86_64" (x86_64-macosx/3m) (get-display-depth) = 32
 >>> Human Language: english
 >>> (current-memory-use) 934744728
 >>> raco pkg (show):
 >>> Installation-wide:
 >>>  Package              Checksum                                    Source
 >>>  main-distribution    820e85aeae454e9aaa7090e53100c639fc7aac6f    (catalog main-distribution)
 >>>  racket-lib           a5ad75266826476cc1034e69afe7ca6740b572d7    (catalog racket-lib)
 >>>  [177 auto-installed packages not shown]
 >>> User-specific for installation "snapshot":
 >>>  Package                Checksum                                    Source
 >>>  c                      e53e075ef547c106d5e8092aed2aaae1eb0c4f7d    (catalog c)
 >>>  contract-repl          9e96a1ee4f819abab253a1276aaacd8bc21e29b7    (catalog contract-repl)
 >>>  drracket-solarized     3c7ac56e3bde4f52653c08ad1058188f9bc10184    (catalog drracket-solarized)
 >>>  experimental-lang      #f                                          (link ../../../../Documents/DrRacket/stuff/experimental-lang pkg/experimental-lang)
 >>>  first-class-methods    #f                                          (link ../../../../Documents/DrRacket/stuff/first-class-methods pkg/first-class-methods)
 >>>  raw-string             c922d2ea88ab98b9bffd5d2c74f48c64cbd75577    (catalog raw-string)
 >>>
 >>>
 >>>
 >>> Collections:
 >>> ("/Users/Alex/Library/Racket/snapshot/collects"
 >>>  (non-existent-path))
 >>> ("/Applications/Racket v6.0.1.8/collects"
 >>>  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "rackunit" "raco" "reader" "realm" "s-exp" "scheme" "setup" "srfi" "syntax" "syntax copy" "unstable" "version" "xml"))
 >>>
 >>> Recent Internal Errors:
 >>> Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang at-exp racket\n" #f #t ((main) (test)) #t))
 >>>
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Alex Knauth <alexander@knauth.org>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sun, 6 Jul 2014 18:11:37 -0500

 Oh, interesting blame question. I'm not sure what's the right answer
 (to the larger question of "what happens when a value with type
 (Syntaxof Any) flows into an untyped context?").
 
 Robby
 
 On Sun, Jul 6, 2014 at 5:55 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > I don't think that would work because of blame.
 >
 > Imagine a function of type (-> (Syntaxof Any)) provided by a typed
 > module. If calling this function returns a syntax object with a
 > function in it, who is to blame for the contract violation? It
 > shoudln't be the untyped caller because they didn't do anything wrong,
 > and it shouldn't be the typed module since typed module's shouldn't
 > violate contracts.
 >
 > Also by the time that we can figure out if we require it to be a flat
 > contract we have already had to commit to it being a chaperone
 > contract for generating recursive contracts.
 >
 > On Sun, Jul 6, 2014 at 3:44 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> Would it be sound for TR to identify those places where any would have
 >> to be generating a flat contract and generate a contract that just
 >> rejects all functions (and other ho values)?
 >>
 >> Robby
 >>
 >>
 >> On Sun, Jul 6, 2014 at 1:52 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>> The case where it doesn't trigger the error message is the bug.
 >>>
 >>> The reason why it wants a flat contract is that syntax/c requires a
 >>> flat contract.
 >>> http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 >>>
 >>> On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 >>>> A new problem report is waiting at
 >>>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >>>>
 >>>> Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >>>>
 >>>> *** Description:
 >>>> When I do this:
 >>>> #lang typed/racket
 >>>> (cast (lambda (x) 0)
 >>>>       [(Syntaxof Any) -> Any])
 >>>> It gives me this error:
 >>>> . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 >>>> converted to a contract: required a flat contract but generated a
 >>>> chaperone contract in: ((Syntaxof Any) -> Any)
 >>>>
 >>>> If I replace (Syntaxof Any) with almost anything else (so far) it
 >>>> works fine.
 >>>> Also, it works with (Syntaxof (U False (Listof Any))), but not
 >>>> with (Syntaxof (Listof Any)), which is really weird.
 >>>> And why would it require a flat contract?
 >>>>
 >>>> *** How to repeat:
 >>>> #lang typed/racket
 >>>> (cast (lambda (x) 0)
 >>>>       [(Syntaxof Any) -> Any])
 >>>>
 >>>> *** Environment:
 >>>> macosx "Darwin Alexander-D-Knauths-Computer-2.local 13.1.0 Darwin Kernel Version 13.1.0: Thu Jan 16 19:40:37 PST 2014; root:xnu-2422.90.20~2/RELEASE_X86_64 x86_64" (x86_64-macosx/3m) (get-display-depth) = 32
 >>>> Human Language: english
 >>>> (current-memory-use) 934744728
 >>>> raco pkg (show):
 >>>> Installation-wide:
 >>>>  Package              Checksum                                    Source
 >>>>  main-distribution    820e85aeae454e9aaa7090e53100c639fc7aac6f    (catalog main-distribution)
 >>>>  racket-lib           a5ad75266826476cc1034e69afe7ca6740b572d7    (catalog racket-lib)
 >>>>  [177 auto-installed packages not shown]
 >>>> User-specific for installation "snapshot":
 >>>>  Package                Checksum                                    Source
 >>>>  c                      e53e075ef547c106d5e8092aed2aaae1eb0c4f7d    (catalog c)
 >>>>  contract-repl          9e96a1ee4f819abab253a1276aaacd8bc21e29b7    (catalog contract-repl)
 >>>>  drracket-solarized     3c7ac56e3bde4f52653c08ad1058188f9bc10184    (catalog drracket-solarized)
 >>>>  experimental-lang      #f                                          (link ../../../../Documents/DrRacket/stuff/experimental-lang pkg/experimental-lang)
 >>>>  first-class-methods    #f                                          (link ../../../../Documents/DrRacket/stuff/first-class-methods pkg/first-class-methods)
 >>>>  raw-string             c922d2ea88ab98b9bffd5d2c74f48c64cbd75577    (catalog raw-string)
 >>>>
 >>>>
 >>>>
 >>>> Collections:
 >>>> ("/Users/Alex/Library/Racket/snapshot/collects"
 >>>>  (non-existent-path))
 >>>> ("/Applications/Racket v6.0.1.8/collects"
 >>>>  (".gitignore" "acks" "compiler" "data" "db" "dynext" "ffi" "file" "info" "info-domain" "json" "launcher" "net" "openssl" "pkg" "planet" "racket" "rackunit" "raco" "reader" "realm" "s-exp" "scheme" "setup" "srfi" "syntax" "syntax copy" "unstable" "version" "xml"))
 >>>>
 >>>> Recent Internal Errors:
 >>>> Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang at-exp racket\n" #f #t ((main) (test)) #t))
 >>>>
 
From: "Alexander D. Knauth" <alexander@knauth.org>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to a contract
Date: Sun, 6 Jul 2014 20:47:39 -0400

 On Jul 6, 2014, at 2:52 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 
 > The case where it doesn't trigger the error message is the bug.
 > 
 > The reason why it wants a flat contract is that syntax/c requires a
 > flat contract.
 > http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 
 But that shouldn’t be a problem because syntax/c IS receiving a flat contract and should be generating a flat contract.  
 
 (syntax/c any/c) is a fine flat-contract, right?
 
 and (<flat-contract> -> any/c) is a fine chaperone-contract, right?  
 
 So then what’s the problem?  
 
 > 
 > On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 >> A new problem report is waiting at
 >>  http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >> 
 >> Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >> 
 >> *** Description:
 >> When I do this:
 >> #lang typed/racket
 >> (cast (lambda (x) 0)
 >>      [(Syntaxof Any) -> Any])
 >> It gives me this error:
 >> . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 >> converted to a contract: required a flat contract but generated a
 >> chaperone contract in: ((Syntaxof Any) -> Any)
 >> 
 >> If I replace (Syntaxof Any) with almost anything else (so far) it
 >> works fine.
 >> Also, it works with (Syntaxof (U False (Listof Any))), but not
 >> with (Syntaxof (Listof Any)), which is really weird.
 >> And why would it require a flat contract?
 
 What I meant is that it seems like TR is expecting (-> (Syntaxof Any) Any) to generate a flat contract, because
 Any and (Syntaxof Any) should already be generating flat-contracts no problem, right?  
 
 >> 
 >> *** How to repeat:
 >> #lang typed/racket
 >> (cast (lambda (x) 0)
 >>      [(Syntaxof Any) -> Any])
 >> 
 
 
From: Eric Dobson <eric.n.dobson@gmail.com>
To: "Alexander D. Knauth" <alexander@knauth.org>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sun, 6 Jul 2014 17:51:13 -0700

 On Sun, Jul 6, 2014 at 5:47 PM, Alexander D. Knauth
 <alexander@knauth.org> wrote:
 >
 > On Jul 6, 2014, at 2:52 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >
 >> The case where it doesn't trigger the error message is the bug.
 >>
 >> The reason why it wants a flat contract is that syntax/c requires a
 >> flat contract.
 >> http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 >
 > But that shouldnâ€™t be a problem because syntax/c IS receiving a flat contract and should be generating a flat contract.
 >
 > (syntax/c any/c) is a fine flat-contract, right?
 >
 > and (<flat-contract> -> any/c) is a fine chaperone-contract, right?
 >
 > So then whatâ€™s the problem?
 Any does not translate into any/c for values leaving typed/racket. It
 translates to any-wrap/c which prevents higher order values from
 escaping the typed world.
 
 https://github.com/plt/racket/blob/master/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/utils/any-wrap.rkt
 
 Unlike any/c, any-wrap/c is a chaperone contract not a flat contract,
 and that is the underlying issue.
 
 
 >
 >>
 >> On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 >>> A new problem report is waiting at
 >>>  http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >>>
 >>> Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >>>
 >>> *** Description:
 >>> When I do this:
 >>> #lang typed/racket
 >>> (cast (lambda (x) 0)
 >>>      [(Syntaxof Any) -> Any])
 >>> It gives me this error:
 >>> . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 >>> converted to a contract: required a flat contract but generated a
 >>> chaperone contract in: ((Syntaxof Any) -> Any)
 >>>
 >>> If I replace (Syntaxof Any) with almost anything else (so far) it
 >>> works fine.
 >>> Also, it works with (Syntaxof (U False (Listof Any))), but not
 >>> with (Syntaxof (Listof Any)), which is really weird.
 >>> And why would it require a flat contract?
 >
 > What I meant is that it seems like TR is expecting (-> (Syntaxof Any) Any) to generate a flat contract, because
 > Any and (Syntaxof Any) should already be generating flat-contracts no problem, right?
 >
 >>>
 >>> *** How to repeat:
 >>> #lang typed/racket
 >>> (cast (lambda (x) 0)
 >>>      [(Syntaxof Any) -> Any])
 >>>
 >
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: "Alexander D. Knauth" <alexander@knauth.org>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sun, 6 Jul 2014 19:55:12 -0500

 This sounds like something that needs fuller explanation, possibly in
 the TR docs.
 
 Robby
 
 On Sun, Jul 6, 2014 at 7:51 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > On Sun, Jul 6, 2014 at 5:47 PM, Alexander D. Knauth
 > <alexander@knauth.org> wrote:
 >>
 >> On Jul 6, 2014, at 2:52 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>
 >>> The case where it doesn't trigger the error message is the bug.
 >>>
 >>> The reason why it wants a flat contract is that syntax/c requires a
 >>> flat contract.
 >>> http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 >>
 >> But that shouldnâ€™t be a problem because syntax/c IS receiving a flat contract and should be generating a flat contract.
 >>
 >> (syntax/c any/c) is a fine flat-contract, right?
 >>
 >> and (<flat-contract> -> any/c) is a fine chaperone-contract, right?
 >>
 >> So then whatâ€™s the problem?
 > Any does not translate into any/c for values leaving typed/racket. It
 > translates to any-wrap/c which prevents higher order values from
 > escaping the typed world.
 >
 > https://github.com/plt/racket/blob/master/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/utils/any-wrap.rkt
 >
 > Unlike any/c, any-wrap/c is a chaperone contract not a flat contract,
 > and that is the underlying issue.
 >
 >
 >>
 >>>
 >>> On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 >>>> A new problem report is waiting at
 >>>>  http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >>>>
 >>>> Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >>>>
 >>>> *** Description:
 >>>> When I do this:
 >>>> #lang typed/racket
 >>>> (cast (lambda (x) 0)
 >>>>      [(Syntaxof Any) -> Any])
 >>>> It gives me this error:
 >>>> . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 >>>> converted to a contract: required a flat contract but generated a
 >>>> chaperone contract in: ((Syntaxof Any) -> Any)
 >>>>
 >>>> If I replace (Syntaxof Any) with almost anything else (so far) it
 >>>> works fine.
 >>>> Also, it works with (Syntaxof (U False (Listof Any))), but not
 >>>> with (Syntaxof (Listof Any)), which is really weird.
 >>>> And why would it require a flat contract?
 >>
 >> What I meant is that it seems like TR is expecting (-> (Syntaxof Any) Any) to generate a flat contract, because
 >> Any and (Syntaxof Any) should already be generating flat-contracts no problem, right?
 >>
 >>>>
 >>>> *** How to repeat:
 >>>> #lang typed/racket
 >>>> (cast (lambda (x) 0)
 >>>>      [(Syntaxof Any) -> Any])
 >>>>
 >>
 
From: "Alexander D. Knauth" <alexander@knauth.org>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to a contract
Date: Sun, 6 Jul 2014 23:21:00 -0400

 On Jul 6, 2014, at 8:51 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 
 > On Sun, Jul 6, 2014 at 5:47 PM, Alexander D. Knauth
 > <alexander@knauth.org> wrote:
 >> 
 >> On Jul 6, 2014, at 2:52 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> 
 >>> The case where it doesn't trigger the error message is the bug.
 >>> 
 >>> The reason why it wants a flat contract is that syntax/c requires a
 >>> flat contract.
 >>> http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 >> 
 >> But that shouldn’t be a problem because syntax/c IS receiving a flat contract and should be generating a flat contract.
 >> 
 >> (syntax/c any/c) is a fine flat-contract, right?
 >> 
 >> and (<flat-contract> -> any/c) is a fine chaperone-contract, right?
 >> 
 >> So then what’s the problem?
 > Any does not translate into any/c for values leaving typed/racket. It
 > translates to any-wrap/c which prevents higher order values from
 > escaping the typed world.
 > 
 > https://github.com/plt/racket/blob/master/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/utils/any-wrap.rkt
 > 
 > Unlike any/c, any-wrap/c is a chaperone contract not a flat contract,
 > and that is the underlying issue.
 
 I think I understand now, but then why does this work?:
  > (make-predicate (Syntaxof Any))
 - : (-> Any Boolean : (Syntaxof Any))
 #<procedure:syntax?>
 
 This tells me that (Syntaxof Any) converted to a contract is syntax?.  
 
 Or this:
  > (make-predicate Any)
 - : (-> Any Boolean)
 #<flat-contract: any/c>
 
 > 
 > 
 >> 
 >>> 
 >>> On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 >>>> A new problem report is waiting at
 >>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >>>> 
 >>>> Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >>>> 
 >>>> *** Description:
 >>>> When I do this:
 >>>> #lang typed/racket
 >>>> (cast (lambda (x) 0)
 >>>>     [(Syntaxof Any) -> Any])
 >>>> It gives me this error:
 >>>> . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 >>>> converted to a contract: required a flat contract but generated a
 >>>> chaperone contract in: ((Syntaxof Any) -> Any)
 >>>> 
 >>>> If I replace (Syntaxof Any) with almost anything else (so far) it
 >>>> works fine.
 >>>> Also, it works with (Syntaxof (U False (Listof Any))), but not
 >>>> with (Syntaxof (Listof Any)), which is really weird.
 >>>> And why would it require a flat contract?
 >> 
 >> What I meant is that it seems like TR is expecting (-> (Syntaxof Any) Any) to generate a flat contract, because
 >> Any and (Syntaxof Any) should already be generating flat-contracts no problem, right?
 >> 
 >>>> 
 >>>> *** How to repeat:
 >>>> #lang typed/racket
 >>>> (cast (lambda (x) 0)
 >>>>     [(Syntaxof Any) -> Any])
 >>>> 
 >> 
 
 
From: Eric Dobson <eric.n.dobson@gmail.com>
To: "Alexander D. Knauth" <alexander@knauth.org>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sun, 6 Jul 2014 20:25:07 -0700

 Because in those cases the value of type Any is coming from the
 untyped world not going to the untyped world. The contract going from
 untyped to typed is different from the contract going from typed to
 untyped. The reason for this is that we know the typed world will not
 misuse values and so need less checks.
 
 On Sun, Jul 6, 2014 at 8:21 PM, Alexander D. Knauth
 <alexander@knauth.org> wrote:
 >
 > On Jul 6, 2014, at 8:51 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >
 >> On Sun, Jul 6, 2014 at 5:47 PM, Alexander D. Knauth
 >> <alexander@knauth.org> wrote:
 >>>
 >>> On Jul 6, 2014, at 2:52 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>
 >>>> The case where it doesn't trigger the error message is the bug.
 >>>>
 >>>> The reason why it wants a flat contract is that syntax/c requires a
 >>>> flat contract.
 >>>> http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 >>>
 >>> But that shouldnâ€™t be a problem because syntax/c IS receiving a flat contract and should be generating a flat contract.
 >>>
 >>> (syntax/c any/c) is a fine flat-contract, right?
 >>>
 >>> and (<flat-contract> -> any/c) is a fine chaperone-contract, right?
 >>>
 >>> So then whatâ€™s the problem?
 >> Any does not translate into any/c for values leaving typed/racket. It
 >> translates to any-wrap/c which prevents higher order values from
 >> escaping the typed world.
 >>
 >> https://github.com/plt/racket/blob/master/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/utils/any-wrap.rkt
 >>
 >> Unlike any/c, any-wrap/c is a chaperone contract not a flat contract,
 >> and that is the underlying issue.
 >
 > I think I understand now, but then why does this work?:
 >  > (make-predicate (Syntaxof Any))
 > - : (-> Any Boolean : (Syntaxof Any))
 > #<procedure:syntax?>
 >
 > This tells me that (Syntaxof Any) converted to a contract is syntax?.
 >
 > Or this:
 >  > (make-predicate Any)
 > - : (-> Any Boolean)
 > #<flat-contract: any/c>
 >
 >>
 >>
 >>>
 >>>>
 >>>> On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 >>>>> A new problem report is waiting at
 >>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >>>>>
 >>>>> Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >>>>>
 >>>>> *** Description:
 >>>>> When I do this:
 >>>>> #lang typed/racket
 >>>>> (cast (lambda (x) 0)
 >>>>>     [(Syntaxof Any) -> Any])
 >>>>> It gives me this error:
 >>>>> . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 >>>>> converted to a contract: required a flat contract but generated a
 >>>>> chaperone contract in: ((Syntaxof Any) -> Any)
 >>>>>
 >>>>> If I replace (Syntaxof Any) with almost anything else (so far) it
 >>>>> works fine.
 >>>>> Also, it works with (Syntaxof (U False (Listof Any))), but not
 >>>>> with (Syntaxof (Listof Any)), which is really weird.
 >>>>> And why would it require a flat contract?
 >>>
 >>> What I meant is that it seems like TR is expecting (-> (Syntaxof Any) Any) to generate a flat contract, because
 >>> Any and (Syntaxof Any) should already be generating flat-contracts no problem, right?
 >>>
 >>>>>
 >>>>> *** How to repeat:
 >>>>> #lang typed/racket
 >>>>> (cast (lambda (x) 0)
 >>>>>     [(Syntaxof Any) -> Any])
 >>>>>
 >>>
 >
 
From: "Alexander D. Knauth" <alexander@knauth.org>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to a contract
Date: Sun, 6 Jul 2014 23:37:57 -0400

 But in the example I’m trying to use ((Syntaxof Any) -> Any) (it’s actually something else), It’s coming from a dynamic-require and into typed racket, not coming from typed racket and going into untyped racket.  
 
 By the way, is there a typed version of dynamic-require or anything like that?  The function actually comes from a typed module and is being dynamic-required into another typed module.  
 
 On Jul 6, 2014, at 11:25 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 
 > Because in those cases the value of type Any is coming from the
 > untyped world not going to the untyped world. The contract going from
 > untyped to typed is different from the contract going from typed to
 > untyped. The reason for this is that we know the typed world will not
 > misuse values and so need less checks.
 > 
 > On Sun, Jul 6, 2014 at 8:21 PM, Alexander D. Knauth
 > <alexander@knauth.org> wrote:
 >> 
 >> On Jul 6, 2014, at 8:51 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> 
 >>> On Sun, Jul 6, 2014 at 5:47 PM, Alexander D. Knauth
 >>> <alexander@knauth.org> wrote:
 >>>> 
 >>>> On Jul 6, 2014, at 2:52 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> 
 >>>>> The case where it doesn't trigger the error message is the bug.
 >>>>> 
 >>>>> The reason why it wants a flat contract is that syntax/c requires a
 >>>>> flat contract.
 >>>>> http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 >>>> 
 >>>> But that shouldn’t be a problem because syntax/c IS receiving a flat contract and should be generating a flat contract.
 >>>> 
 >>>> (syntax/c any/c) is a fine flat-contract, right?
 >>>> 
 >>>> and (<flat-contract> -> any/c) is a fine chaperone-contract, right?
 >>>> 
 >>>> So then what’s the problem?
 >>> Any does not translate into any/c for values leaving typed/racket. It
 >>> translates to any-wrap/c which prevents higher order values from
 >>> escaping the typed world.
 >>> 
 >>> https://github.com/plt/racket/blob/master/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/utils/any-wrap.rkt
 >>> 
 >>> Unlike any/c, any-wrap/c is a chaperone contract not a flat contract,
 >>> and that is the underlying issue.
 >> 
 >> I think I understand now, but then why does this work?:
 >>> (make-predicate (Syntaxof Any))
 >> - : (-> Any Boolean : (Syntaxof Any))
 >> #<procedure:syntax?>
 >> 
 >> This tells me that (Syntaxof Any) converted to a contract is syntax?.
 >> 
 >> Or this:
 >>> (make-predicate Any)
 >> - : (-> Any Boolean)
 >> #<flat-contract: any/c>
 >> 
 >>> 
 >>> 
 >>>> 
 >>>>> 
 >>>>> On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 >>>>>> A new problem report is waiting at
 >>>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >>>>>> 
 >>>>>> Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >>>>>> 
 >>>>>> *** Description:
 >>>>>> When I do this:
 >>>>>> #lang typed/racket
 >>>>>> (cast (lambda (x) 0)
 >>>>>>    [(Syntaxof Any) -> Any])
 >>>>>> It gives me this error:
 >>>>>> . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 >>>>>> converted to a contract: required a flat contract but generated a
 >>>>>> chaperone contract in: ((Syntaxof Any) -> Any)
 >>>>>> 
 >>>>>> If I replace (Syntaxof Any) with almost anything else (so far) it
 >>>>>> works fine.
 >>>>>> Also, it works with (Syntaxof (U False (Listof Any))), but not
 >>>>>> with (Syntaxof (Listof Any)), which is really weird.
 >>>>>> And why would it require a flat contract?
 >>>> 
 >>>> What I meant is that it seems like TR is expecting (-> (Syntaxof Any) Any) to generate a flat contract, because
 >>>> Any and (Syntaxof Any) should already be generating flat-contracts no problem, right?
 >>>> 
 >>>>>> 
 >>>>>> *** How to repeat:
 >>>>>> #lang typed/racket
 >>>>>> (cast (lambda (x) 0)
 >>>>>>    [(Syntaxof Any) -> Any])
 >>>>>> 
 >>>> 
 >> 
 
 
From: Eric Dobson <eric.n.dobson@gmail.com>
To: "Alexander D. Knauth" <alexander@knauth.org>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sun, 6 Jul 2014 20:43:50 -0700

 If a value of type ((Syntaxof Any) -> Any) is coming from an untyped
 module, then the code implementing the procedure is in untyped racket
 (at least as far as the typechecker knows). Thus values getting passed
 to the procedure from the typed module go to code in the untyped
 module. So even though the import is from untyped to typed, the syntax
 value flows from typed to untyped.
 
 Re: dynamic-require, no there is no typed version.
 
 On Sun, Jul 6, 2014 at 8:37 PM, Alexander D. Knauth
 <alexander@knauth.org> wrote:
 > But in the example Iâ€™m trying to use ((Syntaxof Any) -> Any) (itâ€™s actually something else), Itâ€™s coming from a dynamic-require and into typed racket, not coming from typed racket and going into untyped racket.
 >
 > By the way, is there a typed version of dynamic-require or anything like that?  The function actually comes from a typed module and is being dynamic-required into another typed module.
 >
 > On Jul 6, 2014, at 11:25 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >
 >> Because in those cases the value of type Any is coming from the
 >> untyped world not going to the untyped world. The contract going from
 >> untyped to typed is different from the contract going from typed to
 >> untyped. The reason for this is that we know the typed world will not
 >> misuse values and so need less checks.
 >>
 >> On Sun, Jul 6, 2014 at 8:21 PM, Alexander D. Knauth
 >> <alexander@knauth.org> wrote:
 >>>
 >>> On Jul 6, 2014, at 8:51 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>
 >>>> On Sun, Jul 6, 2014 at 5:47 PM, Alexander D. Knauth
 >>>> <alexander@knauth.org> wrote:
 >>>>>
 >>>>> On Jul 6, 2014, at 2:52 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>
 >>>>>> The case where it doesn't trigger the error message is the bug.
 >>>>>>
 >>>>>> The reason why it wants a flat contract is that syntax/c requires a
 >>>>>> flat contract.
 >>>>>> http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 >>>>>
 >>>>> But that shouldnâ€™t be a problem because syntax/c IS receiving a flat contract and should be generating a flat contract.
 >>>>>
 >>>>> (syntax/c any/c) is a fine flat-contract, right?
 >>>>>
 >>>>> and (<flat-contract> -> any/c) is a fine chaperone-contract, right?
 >>>>>
 >>>>> So then whatâ€™s the problem?
 >>>> Any does not translate into any/c for values leaving typed/racket. It
 >>>> translates to any-wrap/c which prevents higher order values from
 >>>> escaping the typed world.
 >>>>
 >>>> https://github.com/plt/racket/blob/master/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/utils/any-wrap.rkt
 >>>>
 >>>> Unlike any/c, any-wrap/c is a chaperone contract not a flat contract,
 >>>> and that is the underlying issue.
 >>>
 >>> I think I understand now, but then why does this work?:
 >>>> (make-predicate (Syntaxof Any))
 >>> - : (-> Any Boolean : (Syntaxof Any))
 >>> #<procedure:syntax?>
 >>>
 >>> This tells me that (Syntaxof Any) converted to a contract is syntax?.
 >>>
 >>> Or this:
 >>>> (make-predicate Any)
 >>> - : (-> Any Boolean)
 >>> #<flat-contract: any/c>
 >>>
 >>>>
 >>>>
 >>>>>
 >>>>>>
 >>>>>> On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 >>>>>>> A new problem report is waiting at
 >>>>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >>>>>>>
 >>>>>>> Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >>>>>>>
 >>>>>>> *** Description:
 >>>>>>> When I do this:
 >>>>>>> #lang typed/racket
 >>>>>>> (cast (lambda (x) 0)
 >>>>>>>    [(Syntaxof Any) -> Any])
 >>>>>>> It gives me this error:
 >>>>>>> . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 >>>>>>> converted to a contract: required a flat contract but generated a
 >>>>>>> chaperone contract in: ((Syntaxof Any) -> Any)
 >>>>>>>
 >>>>>>> If I replace (Syntaxof Any) with almost anything else (so far) it
 >>>>>>> works fine.
 >>>>>>> Also, it works with (Syntaxof (U False (Listof Any))), but not
 >>>>>>> with (Syntaxof (Listof Any)), which is really weird.
 >>>>>>> And why would it require a flat contract?
 >>>>>
 >>>>> What I meant is that it seems like TR is expecting (-> (Syntaxof Any) Any) to generate a flat contract, because
 >>>>> Any and (Syntaxof Any) should already be generating flat-contracts no problem, right?
 >>>>>
 >>>>>>>
 >>>>>>> *** How to repeat:
 >>>>>>> #lang typed/racket
 >>>>>>> (cast (lambda (x) 0)
 >>>>>>>    [(Syntaxof Any) -> Any])
 >>>>>>>
 >>>>>
 >>>
 >
 
From: "Alexander D. Knauth" <alexander@knauth.org>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to a contract
Date: Mon, 7 Jul 2014 00:12:48 -0400

 On Jul 6, 2014, at 11:43 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 
 > If a value of type ((Syntaxof Any) -> Any) is coming from an untyped
 > module, then the code implementing the procedure is in untyped racket
 > (at least as far as the typechecker knows). Thus values getting passed
 > to the procedure from the typed module go to code in the untyped
 > module. So even though the import is from untyped to typed, the syntax
 > value flows from typed to untyped.
 
 Ok, that makes sense, and explains why this works:
 (cast (Î» (x) #â€™0) [Any -> (Syntaxof Any)])
 But this doesnâ€™t:
 (cast (Î» (x) 0) [(Syntaxof Any) -> Any])
 
 > 
 > Re: dynamic-require, no there is no typed version.
 > 
 > On Sun, Jul 6, 2014 at 8:37 PM, Alexander D. Knauth
 > <alexander@knauth.org> wrote:
 >> But in the example Iâ€™m trying to use ((Syntaxof Any) -> Any) (itâ€™s actually something else), Itâ€™s coming from a dynamic-require and into typed racket, not coming from typed racket and going into untyped racket.
 >> 
 >> By the way, is there a typed version of dynamic-require or anything like that?  The function actually comes from a typed module and is being dynamic-required into another typed module.
 >> 
 >> On Jul 6, 2014, at 11:25 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> 
 >>> Because in those cases the value of type Any is coming from the
 >>> untyped world not going to the untyped world. The contract going from
 >>> untyped to typed is different from the contract going from typed to
 >>> untyped. The reason for this is that we know the typed world will not
 >>> misuse values and so need less checks.
 >>> 
 >>> On Sun, Jul 6, 2014 at 8:21 PM, Alexander D. Knauth
 >>> <alexander@knauth.org> wrote:
 >>>> 
 >>>> On Jul 6, 2014, at 8:51 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>> 
 >>>>> On Sun, Jul 6, 2014 at 5:47 PM, Alexander D. Knauth
 >>>>> <alexander@knauth.org> wrote:
 >>>>>> 
 >>>>>> On Jul 6, 2014, at 2:52 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >>>>>> 
 >>>>>>> The case where it doesn't trigger the error message is the bug.
 >>>>>>> 
 >>>>>>> The reason why it wants a flat contract is that syntax/c requires a
 >>>>>>> flat contract.
 >>>>>>> http://docs.racket-lang.org/reference/data-structure-contracts.html?q=syntax/c#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._syntax%2Fc%29%29
 >>>>>> 
 >>>>>> But that shouldnâ€™t be a problem because syntax/c IS receiving a flat contract and should be generating a flat contract.
 >>>>>> 
 >>>>>> (syntax/c any/c) is a fine flat-contract, right?
 >>>>>> 
 >>>>>> and (<flat-contract> -> any/c) is a fine chaperone-contract, right?
 >>>>>> 
 >>>>>> So then whatâ€™s the problem?
 >>>>> Any does not translate into any/c for values leaving typed/racket. It
 >>>>> translates to any-wrap/c which prevents higher order values from
 >>>>> escaping the typed world.
 >>>>> 
 >>>>> https://github.com/plt/racket/blob/master/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/utils/any-wrap.rkt
 >>>>> 
 >>>>> Unlike any/c, any-wrap/c is a chaperone contract not a flat contract,
 >>>>> and that is the underlying issue.
 >>>> 
 >>>> I think I understand now, but then why does this work?:
 >>>>> (make-predicate (Syntaxof Any))
 >>>> - : (-> Any Boolean : (Syntaxof Any))
 >>>> #<procedure:syntax?>
 >>>> 
 >>>> This tells me that (Syntaxof Any) converted to a contract is syntax?.
 >>>> 
 >>>> Or this:
 >>>>> (make-predicate Any)
 >>>> - : (-> Any Boolean)
 >>>> #<flat-contract: any/c>
 >>>> 
 >>>>> 
 >>>>> 
 >>>>>> 
 >>>>>>> 
 >>>>>>> On Mon, Jun 16, 2014 at 12:32 PM,  <alexander@knauth.org> wrote:
 >>>>>>>> A new problem report is waiting at
 >>>>>>>> http://bugs.racket-lang.org/query/?cmd=view&pr=14581
 >>>>>>>> 
 >>>>>>>> Reported by Alex Knauth for release: 6.0.1.8--2014-05-10(722c4fd/a)
 >>>>>>>> 
 >>>>>>>> *** Description:
 >>>>>>>> When I do this:
 >>>>>>>> #lang typed/racket
 >>>>>>>> (cast (lambda (x) 0)
 >>>>>>>>   [(Syntaxof Any) -> Any])
 >>>>>>>> It gives me this error:
 >>>>>>>> . Type Checker: Type (-> (Syntaxof Any) Any) could not be
 >>>>>>>> converted to a contract: required a flat contract but generated a
 >>>>>>>> chaperone contract in: ((Syntaxof Any) -> Any)
 >>>>>>>> 
 >>>>>>>> If I replace (Syntaxof Any) with almost anything else (so far) it
 >>>>>>>> works fine.
 >>>>>>>> Also, it works with (Syntaxof (U False (Listof Any))), but not
 >>>>>>>> with (Syntaxof (Listof Any)), which is really weird.
 >>>>>>>> And why would it require a flat contract?
 >>>>>> 
 >>>>>> What I meant is that it seems like TR is expecting (-> (Syntaxof Any) Any) to generate a flat contract, because
 >>>>>> Any and (Syntaxof Any) should already be generating flat-contracts no problem, right?
 >>>>>> 
 >>>>>>>> 
 >>>>>>>> *** How to repeat:
 >>>>>>>> #lang typed/racket
 >>>>>>>> (cast (lambda (x) 0)
 >>>>>>>>   [(Syntaxof Any) -> Any])
 >>>>>>>> 
 >>>>>> 
 >>>> 
 >> 
 
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Alex Knauth <alexander@knauth.org>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to a contract
Date: Sat, 12 Jul 2014 14:00:52 -0400

 Off topic but worthwhile knowing: 
 
 
 On Jul 6, 2014, at 6:55 PM, Eric Dobson wrote:
 
 > I don't think that would work because of blame.
 > 
 > Imagine a function of type (-> (Syntaxof Any)) provided by a typed
 > module. If calling this function returns a syntax object with a
 > function in it, who is to blame for the contract violation? It
 > shoudln't be the untyped caller because they didn't do anything wrong,
 > and it shouldn't be the typed module since typed module's shouldn't
 > violate contracts.
 
 
 When we assign blame at the typed-untyped boundary, we really blame
 an imposition of the typed module on the untyped module. After all, 
 the latter was created (according to the philosophy of TR) without
 types in mind and isn't guilty of anything. In contrast, it is the
 typed module (its creator) that demands that functions flowing 
 from UT to TR modules satisfy certain constraints -- all of a 
 sudden and out of the blue. 
 
 So Typed-Untyped blame really just says there is an impedance
 mismatch between the two worlds. 
 
 [[Sam and I are a bit guilty of not clarifying this point better
 in our DLS paper but famed Phil Wadler hit the jackpot with 
 introducing a stupid, useless slogan that might be technically
 correct but at the same time misleading in an insidious manner.]]
 
 
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, Alex Knauth <alexander@knauth.org>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sat, 12 Jul 2014 19:45:30 -0500

 Is there a clever way we can adjust the error messages to make it
 clear that even though it is more likely that the type is right and
 the code wrong, that the type might be wrong too?
 
 Or maybe this is something we should work into all contract violation
 error messages somehow?
 
 Robby
 
 On Sat, Jul 12, 2014 at 1:00 PM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > Off topic but worthwhile knowing:
 >
 >
 > On Jul 6, 2014, at 6:55 PM, Eric Dobson wrote:
 >
 >> I don't think that would work because of blame.
 >>
 >> Imagine a function of type (-> (Syntaxof Any)) provided by a typed
 >> module. If calling this function returns a syntax object with a
 >> function in it, who is to blame for the contract violation? It
 >> shoudln't be the untyped caller because they didn't do anything wrong,
 >> and it shouldn't be the typed module since typed module's shouldn't
 >> violate contracts.
 >
 >
 > When we assign blame at the typed-untyped boundary, we really blame
 > an imposition of the typed module on the untyped module. After all,
 > the latter was created (according to the philosophy of TR) without
 > types in mind and isn't guilty of anything. In contrast, it is the
 > typed module (its creator) that demands that functions flowing
 > from UT to TR modules satisfy certain constraints -- all of a
 > sudden and out of the blue.
 >
 > So Typed-Untyped blame really just says there is an impedance
 > mismatch between the two worlds.
 >
 > [[Sam and I are a bit guilty of not clarifying this point better
 > in our DLS paper but famed Phil Wadler hit the jackpot with
 > introducing a stupid, useless slogan that might be technically
 > correct but at the same time misleading in an insidious manner.]]
 >
 >
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, Alex Knauth <alexander@knauth.org>,
        bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to a contract
Date: Sat, 12 Jul 2014 21:15:11 -0400

 On Jul 12, 2014, at 8:45 PM, Robby Findler wrote:
 
 > Is there a clever way we can adjust the error messages to make it
 > clear that even though it is more likely that the type is right and
 > the code wrong, that the type might be wrong too?
 
 
 Could we hyperlink the word 'contract violation' and 
 color it red (in DrRacket). 
 
 The link should go to a place in the TR docs that spells out
 our interpretation of the Blame Theorem. We could also link 
 the word "blaming". 
 
 A different fix would change the wording. Here is an idea: 
 
 "blaming module: ... (though it is possible a problem with the type interface)" 
 
 Now this is long and ugly but it would certainly catch peoples' eyes. 
 
 
 > Or maybe this is something we should work into all contract violation
 > error messages somehow?
 
 
 Yes! Once we figure out the change to the TR interface we'll do it for contracts in general. 
 
 
 
 
 > 
 > Robby
 > 
 > On Sat, Jul 12, 2014 at 1:00 PM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >> 
 >> Off topic but worthwhile knowing:
 >> 
 >> 
 >> On Jul 6, 2014, at 6:55 PM, Eric Dobson wrote:
 >> 
 >>> I don't think that would work because of blame.
 >>> 
 >>> Imagine a function of type (-> (Syntaxof Any)) provided by a typed
 >>> module. If calling this function returns a syntax object with a
 >>> function in it, who is to blame for the contract violation? It
 >>> shoudln't be the untyped caller because they didn't do anything wrong,
 >>> and it shouldn't be the typed module since typed module's shouldn't
 >>> violate contracts.
 >> 
 >> 
 >> When we assign blame at the typed-untyped boundary, we really blame
 >> an imposition of the typed module on the untyped module. After all,
 >> the latter was created (according to the philosophy of TR) without
 >> types in mind and isn't guilty of anything. In contrast, it is the
 >> typed module (its creator) that demands that functions flowing
 >> from UT to TR modules satisfy certain constraints -- all of a
 >> sudden and out of the blue.
 >> 
 >> So Typed-Untyped blame really just says there is an impedance
 >> mismatch between the two worlds.
 >> 
 >> [[Sam and I are a bit guilty of not clarifying this point better
 >> in our DLS paper but famed Phil Wadler hit the jackpot with
 >> introducing a stupid, useless slogan that might be technically
 >> correct but at the same time misleading in an insidious manner.]]
 >> 
 >> 
 >> 
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Alex Knauth <alexander@knauth.org>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sat, 12 Jul 2014 22:03:55 -0400

 I think there's a confusion here. The problem here is that of the two
 parties, the one representing the typed code should never be blamed.
 It's fine to blame the interface between the typed and untyped code,
 and as Matthias points out, when the interface gets blamed, there's
 some subtlety as to what actually went wrong.
 
 But the problem here is much more serious -- the contract is enforcing
 an invariant that the types don't actually uphold, and so we get blame
 from the side that the soundness theorem says should never be blamed.
 
 Sam
 
 On Sat, Jul 12, 2014 at 8:45 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > Is there a clever way we can adjust the error messages to make it
 > clear that even though it is more likely that the type is right and
 > the code wrong, that the type might be wrong too?
 >
 > Or maybe this is something we should work into all contract violation
 > error messages somehow?
 >
 > Robby
 >
 > On Sat, Jul 12, 2014 at 1:00 PM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >>
 >> Off topic but worthwhile knowing:
 >>
 >>
 >> On Jul 6, 2014, at 6:55 PM, Eric Dobson wrote:
 >>
 >>> I don't think that would work because of blame.
 >>>
 >>> Imagine a function of type (-> (Syntaxof Any)) provided by a typed
 >>> module. If calling this function returns a syntax object with a
 >>> function in it, who is to blame for the contract violation? It
 >>> shoudln't be the untyped caller because they didn't do anything wrong,
 >>> and it shouldn't be the typed module since typed module's shouldn't
 >>> violate contracts.
 >>
 >>
 >> When we assign blame at the typed-untyped boundary, we really blame
 >> an imposition of the typed module on the untyped module. After all,
 >> the latter was created (according to the philosophy of TR) without
 >> types in mind and isn't guilty of anything. In contrast, it is the
 >> typed module (its creator) that demands that functions flowing
 >> from UT to TR modules satisfy certain constraints -- all of a
 >> sudden and out of the blue.
 >>
 >> So Typed-Untyped blame really just says there is an impedance
 >> mismatch between the two worlds.
 >>
 >> [[Sam and I are a bit guilty of not clarifying this point better
 >> in our DLS paper but famed Phil Wadler hit the jackpot with
 >> introducing a stupid, useless slogan that might be technically
 >> correct but at the same time misleading in an insidious manner.]]
 >>
 >>
 >>
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Alex Knauth <alexander@knauth.org>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to a contract
Date: Sat, 12 Jul 2014 22:25:25 -0400

 On Jul 12, 2014, at 10:03 PM, Sam Tobin-Hochstadt wrote:
 
 > I think there's a confusion here. The problem here is that of the two
 > parties, the one representing the typed code should never be blamed.
 > It's fine to blame the interface between the typed and untyped code,
 > and as Matthias points out, when the interface gets blamed, there's
 > some subtlety as to what actually went wrong.
 
 
 Robby says 'type' meaning 'interface.' He understands. 
 
 
 > But the problem here is much more serious -- the contract is enforcing
 > an invariant that the types don't actually uphold, and so we get blame
 > from the side that the soundness theorem says should never be blamed.
 
 
 That's why I labeled my comment 'off topic, but worthwhile knowing'. 
 
 But now that we understand this type-is-wrong business, what is the real problem? Any or its compilation? Can you distill it into one three-line example and a one-sentence explanation. 
 
 
 -- Matthias
 
 
 
 > 
 > Sam
 > 
 > On Sat, Jul 12, 2014 at 8:45 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> Is there a clever way we can adjust the error messages to make it
 >> clear that even though it is more likely that the type is right and
 >> the code wrong, that the type might be wrong too?
 >> 
 >> Or maybe this is something we should work into all contract violation
 >> error messages somehow?
 >> 
 >> Robby
 >> 
 >> On Sat, Jul 12, 2014 at 1:00 PM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>> 
 >>> Off topic but worthwhile knowing:
 >>> 
 >>> 
 >>> On Jul 6, 2014, at 6:55 PM, Eric Dobson wrote:
 >>> 
 >>>> I don't think that would work because of blame.
 >>>> 
 >>>> Imagine a function of type (-> (Syntaxof Any)) provided by a typed
 >>>> module. If calling this function returns a syntax object with a
 >>>> function in it, who is to blame for the contract violation? It
 >>>> shoudln't be the untyped caller because they didn't do anything wrong,
 >>>> and it shouldn't be the typed module since typed module's shouldn't
 >>>> violate contracts.
 >>> 
 >>> 
 >>> When we assign blame at the typed-untyped boundary, we really blame
 >>> an imposition of the typed module on the untyped module. After all,
 >>> the latter was created (according to the philosophy of TR) without
 >>> types in mind and isn't guilty of anything. In contrast, it is the
 >>> typed module (its creator) that demands that functions flowing
 >>> from UT to TR modules satisfy certain constraints -- all of a
 >>> sudden and out of the blue.
 >>> 
 >>> So Typed-Untyped blame really just says there is an impedance
 >>> mismatch between the two worlds.
 >>> 
 >>> [[Sam and I are a bit guilty of not clarifying this point better
 >>> in our DLS paper but famed Phil Wadler hit the jackpot with
 >>> introducing a stupid, useless slogan that might be technically
 >>> correct but at the same time misleading in an insidious manner.]]
 >>> 
 >>> 
 >>> 
 
 
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Alex Knauth <alexander@knauth.org>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sat, 12 Jul 2014 22:35:44 -0400

 On Sat, Jul 12, 2014 at 10:25 PM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 > But now that we understand this type-is-wrong business, what is the real problem? Any or its compilation? Can you distill it into one three-line example and a one-sentence explanation.
 
 
 Here's the shortest explanation I've got:
 
 Robby suggested that in places where flat contracts are required, we
 should generate a flat contract that rejects all non-first-order
 values.
 
 However, Eric pointed out that this doesn't work in general, because
 it could be the _typed_ side that produces the non-first-order value.
 As we know from correct blame, if only the typed side had control over
 the "bad" value, the typed side must be blamed. Therefore, we can't
 generate a contract like this, or the soundness theorem is false.
 
 Here's the example:
 
 (module m1 typed/racket
   (: fun : Number -> Number)
   (define (fun a) (add1 a)
   (define x : (Syntaxof (Number -> Number)) (datum->syntax #f fun))
   (provide x))
 
 What contract should we generate for `x`? Naievly, we should generate
 `(syntax/c (-> number? number?))`. But `syntax/c` requires a flat
 contract. Robby's suggestion would reject non-flat values in syntax,
 so we'd blame the typed side. So we have to have an error which says
 "sorry, can't generate this contract".
 
 Sam
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Eric Dobson <eric.n.dobson@gmail.com>,
        Alex Knauth <alexander@knauth.org>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14581: can't convert ((Syntaxof Any) -> Any) to
 a contract
Date: Sat, 12 Jul 2014 22:34:17 -0500

 --089e0111dd4a6f467904fe0ad955
 Content-Type: text/plain; charset=UTF-8
 
 Yes my suggestion was wrong.
 
 On Sunday, July 13, 2014, Sam Tobin-Hochstadt <samth@cs.indiana.edu> wrote:
 
 > On Sat, Jul 12, 2014 at 10:25 PM, Matthias Felleisen
 > <matthias@ccs.neu.edu <javascript:;>> wrote:
 > > But now that we understand this type-is-wrong business, what is the real
 > problem? Any or its compilation? Can you distill it into one three-line
 > example and a one-sentence explanation.
 >
 >
 > Here's the shortest explanation I've got:
 >
 > Robby suggested that in places where flat contracts are required, we
 > should generate a flat contract that rejects all non-first-order
 > values.
 >
 > However, Eric pointed out that this doesn't work in general, because
 > it could be the _typed_ side that produces the non-first-order value.
 > As we know from correct blame, if only the typed side had control over
 > the "bad" value, the typed side must be blamed. Therefore, we can't
 > generate a contract like this, or the soundness theorem is false.
 >
 > Here's the example:
 >
 > (module m1 typed/racket
 >   (: fun : Number -> Number)
 >   (define (fun a) (add1 a)
 >   (define x : (Syntaxof (Number -> Number)) (datum->syntax #f fun))
 >   (provide x))
 >
 > What contract should we generate for `x`? Naievly, we should generate
 > `(syntax/c (-> number? number?))`. But `syntax/c` requires a flat
 > contract. Robby's suggestion would reject non-flat values in syntax,
 > so we'd blame the typed side. So we have to have an error which says
 > "sorry, can't generate this contract".
 >
 > Sam
 >
 
 --089e0111dd4a6f467904fe0ad955
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 Yes my suggestion was wrong.=C2=A0<span></span><br><br>On Sunday, July 13, =
 2014, Sam Tobin-Hochstadt &lt;<a href=3D"mailto:samth@cs.indiana.edu">samth=
 @cs.indiana.edu</a>&gt; wrote:<br><blockquote class=3D"gmail_quote" style=
 =3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">
 On Sat, Jul 12, 2014 at 10:25 PM, Matthias Felleisen<br>
 &lt;<a href=3D"javascript:;" onclick=3D"_e(event, &#39;cvml&#39;, &#39;matt=
 hias@ccs.neu.edu&#39;)">matthias@ccs.neu.edu</a>&gt; wrote:<br>
 &gt; But now that we understand this type-is-wrong business, what is the re=
 al problem? Any or its compilation? Can you distill it into one three-line =
 example and a one-sentence explanation.<br>
 <br>
 <br>
 Here&#39;s the shortest explanation I&#39;ve got:<br>
 <br>
 Robby suggested that in places where flat contracts are required, we<br>
 should generate a flat contract that rejects all non-first-order<br>
 values.<br>
 <br>
 However, Eric pointed out that this doesn&#39;t work in general, because<br=
 >
 it could be the _typed_ side that produces the non-first-order value.<br>
 As we know from correct blame, if only the typed side had control over<br>
 the &quot;bad&quot; value, the typed side must be blamed. Therefore, we can=
 &#39;t<br>
 generate a contract like this, or the soundness theorem is false.<br>
 <br>
 Here&#39;s the example:<br>
 <br>
 (module m1 typed/racket<br>
 =C2=A0 (: fun : Number -&gt; Number)<br>
 =C2=A0 (define (fun a) (add1 a)<br>
 =C2=A0 (define x : (Syntaxof (Number -&gt; Number)) (datum-&gt;syntax #f fu=
 n))<br>
 =C2=A0 (provide x))<br>
 <br>
 What contract should we generate for `x`? Naievly, we should generate<br>
 `(syntax/c (-&gt; number? number?))`. But `syntax/c` requires a flat<br>
 contract. Robby&#39;s suggestion would reject non-flat values in syntax,<br=
 >
 so we&#39;d blame the typed side. So we have to have an error which says<br=
 >
 &quot;sorry, can&#39;t generate this contract&quot;.<br>
 <br>
 Sam<br>
 </blockquote>
 
 --089e0111dd4a6f467904fe0ad955--
