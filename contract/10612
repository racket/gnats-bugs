From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Tue Nov 24 11:18:07 2009
Received: from mail-yw0-f178.google.com (mail-yw0-f178.google.com [209.85.211.178])
	by champlain.ccs.neu.edu (8.14.2/8.14.2) with ESMTP id nAOGI2pp025520
	for <bugs@bugs.plt-scheme.org>; Tue, 24 Nov 2009 11:18:03 -0500
Message-Id: <200911241618.nAOGI1B8025513@champlain.ccs.neu.edu>
Date: Tue, 24 Nov 2009 11:18:01 -0500
From: samth@ccs.neu.edu
To: bugs@plt-scheme.org
Subject: contracted procedures should report contract errors on wrong arity

>Number:         10612
>Category:       contract
>Synopsis:       contracted procedures should report contract errors on wrong arity
>Class:          change-request
>Responsible:    sstrickl
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Tue Nov 24 11:20:02 -0500 2009
>Closed-Date:    Mon Oct 01 09:59:58 -0400 2012
>Last-Modified:  Mon Oct 01 09:59:58 -0400 2012
>Originator:     Sam TH
>Organization:
plt
>Submitter-Id:   unknown
>Release:        4.2.3.2-svn19nov2009
>Environment:
unix "Linux punge 2.6.31-14-generic #48-Ubuntu SMP Fri Oct 16 14:04:26 UTC 2009 i686 GNU/Linux" (i386-linux/3m) (get-display-depth) = 24
Human Language: english
(current-memory-use) 229335012

Collections:
(("/home/samth/.plt-scheme/4.2.3.2/collects" non-existent-path) ("/home/samth/sw/plt-trunk/collects" "honu" "eopl" "tests" "typed" "test-engine" "errortrace" "sgl" "plot" "combinator-parser" "mzcom" "test-box-recovery" "version" ".svn" "defaults" "deinprogramm" "s-exp" "handin-client" "srpersist" "launcher" "scriblib" "browser" "unstable" "r5rs" "gui-debugger" "at-exp" "swindle" "scheme" "reader" "frtime" "file" "slatex" "net" "wxme" "syntax" "scribblings" "parser-tools" "ffi" "hierlist" "handin-server" "2htdp" "framework" "openssl" "dynext" "slideshow" "games" "xml" "texpict" "graphics" "mzscheme" "profile" "help" "web-server" "trace" "make" "algol60" "mzlib" "icons" "sirmail" "lazy" "mrlib" "setup" "string-constants" "syntax-color" "r6rs" "repos-time-stamp" "drscheme" "lang" "afm" "planet" "typed-scheme" "info-domain" "config" "guibuilder" "stepper" "mred" "embedded-gui" "preprocessor" "readline" "htdp" "compiler" "srfi" "waterworld" "macro-debugger" "html" "scribble" "mys!
 terx" "redex" "rnrs" "teachpack" "tex2page" "schemeunit"))
Computer Language: (("Module") (#(#t write mixed-fraction-e #f #t none) (default) #() "#lang scheme\n" #t))
>Description:
#lang scheme
(define/contract (f l) (vector? . -> . vector?) l)
(f 1 2)

produces 

procedure f: expects 1 argument, given 2: 1 2

instead of a contract error.

[Stevie wanted this reported.]
>How-To-Repeat:
>Fix:
>Audit-Trail:
Responsible changed from "nobody" to "sstrickl" by sstrickl at Tue, 24 Nov 2009 11:41:39 -0500
Reason>>> Picking this up until I decide what to do about it

State changed from "open" to "analyzed" by sstrickl at Tue, 24 Nov 2009 11:41:39 -0500
Reason>>> I know why this happens, the question is whether it's the right thing or not.

From: Matthias Felleisen <matthias@ccs.neu.edu>
To: bugs@plt-scheme.org
Cc: sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org, samth@ccs.neu.edu
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract errors on wrong arity
Date: Tue, 24 Nov 2009 11:49:42 -0500

 That's an old request. Can't do w/o Matthew
 
 
 
 On Nov 24, 2009, at 11:41 AM, sstrickl@plt-scheme.org wrote:
 
 >
 > Responsible changed from "nobody" to "sstrickl" by sstrickl at Tue,  
 > 24 Nov 2009 11:41:39 -0500
 > Reason>>> Picking this up until I decide what to do about it
 >
 > State changed from "open" to "analyzed" by sstrickl at Tue, 24 Nov  
 > 2009 11:41:39 -0500
 > Reason>>> I know why this happens, the question is whether it's the  
 > right thing or not.
 >
 >
 > View:
 >  http://bugs.plt-scheme.org/query/?cmd=view&pr=10612
 >
 
From: Carl Eastlund <cce@plt-scheme.org>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: bugs@plt-scheme.org, sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org, samth@ccs.neu.edu
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 11:54:23 -0500

 On Tue, Nov 24, 2009 at 11:49 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > That's an old request. Can't do w/o Matthew
 
 You mean efficiently.  Because it's really easy to do it with
 case-lambda and/or make-keyword-procedure.
 
 --Carl
From: Stevie Strickland <sstrickl@plt-scheme.org>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org, samth@ccs.neu.edu
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract errors on wrong arity
Date: Tue, 24 Nov 2009 11:57:04 -0500

 I don't think that's quite correct -- we can always have contracted =
 lambdas basically accept all arguments, keyword or no, and then do the =
 parsing and detection inside the lambda.  Inefficient, yes, but =
 possible.
 
 However, after asking Sam to submit this, I've given it some further =
 thought and I'm not sure that it would be correct to report it as a =
 contract error, since it's an error at the level of the operation, not =
 inside the operand.  I will explain further in a future followup.
 
 Stevie
 
 On Nov 24, 2009, at 11:49 AM, Matthias Felleisen wrote:
 >=20
 > That's an old request. Can't do w/o Matthew
 >=20
 >=20
 >=20
 > On Nov 24, 2009, at 11:41 AM, sstrickl@plt-scheme.org wrote:
 >=20
 >>=20
 >> Responsible changed from "nobody" to "sstrickl" by sstrickl at Tue, =
 24 Nov 2009 11:41:39 -0500
 >> Reason>>> Picking this up until I decide what to do about it
 >>=20
 >> State changed from "open" to "analyzed" by sstrickl at Tue, 24 Nov =
 2009 11:41:39 -0500
 >> Reason>>> I know why this happens, the question is whether it's the =
 right thing or not.
 >>=20
 >>=20
 >> View:
 >> http://bugs.plt-scheme.org/query/?cmd=3Dview&pr=3D10612
 >>=20
 >=20
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Carl Eastlund <cce@plt-scheme.org>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>, bugs@plt-scheme.org,
        sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org, samth@ccs.neu.edu
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 10:59:29 -0600

 I thought I had convinced Matthias that the current behavior was
 correct some time ago. (Water flowing in jugs and all that... probably
 he recalls convincing me the other way :)
 
 Anyways, I believe that this is not a contract violation of the
 function, but of the application operator. It has a contract saying
 that the number of arguments it gets matches the number of arguments
 desired by the procedure. And it is correctly reporting that failure.
 
 Robby
 
 On Tue, Nov 24, 2009 at 10:54 AM, Carl Eastlund <cce@plt-scheme.org> wrote:
 > On Tue, Nov 24, 2009 at 11:49 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >>
 >> That's an old request. Can't do w/o Matthew
 >
 > You mean efficiently. =C2=A0Because it's really easy to do it with
 > case-lambda and/or make-keyword-procedure.
 >
 > --Carl
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Stevie Strickland <sstrickl@plt-scheme.org>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org, samth@ccs.neu.edu
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract errors on wrong arity
Date: Tue, 24 Nov 2009 11:59:49 -0500

 That'll kill our performance.
 
 
 On Nov 24, 2009, at 11:57 AM, Stevie Strickland wrote:
 
 > I don't think that's quite correct -- we can always have contracted  
 > lambdas basically accept all arguments, keyword or no, and then do  
 > the parsing and detection inside the lambda.  Inefficient, yes, but  
 > possible.
 >
 > However, after asking Sam to submit this, I've given it some further  
 > thought and I'm not sure that it would be correct to report it as a  
 > contract error, since it's an error at the level of the operation,  
 > not inside the operand.  I will explain further in a future followup.
 >
 > Stevie
 >
 > On Nov 24, 2009, at 11:49 AM, Matthias Felleisen wrote:
 >>
 >> That's an old request. Can't do w/o Matthew
 >>
 >>
 >>
 >> On Nov 24, 2009, at 11:41 AM, sstrickl@plt-scheme.org wrote:
 >>
 >>>
 >>> Responsible changed from "nobody" to "sstrickl" by sstrickl at  
 >>> Tue, 24 Nov 2009 11:41:39 -0500
 >>> Reason>>> Picking this up until I decide what to do about it
 >>>
 >>> State changed from "open" to "analyzed" by sstrickl at Tue, 24 Nov  
 >>> 2009 11:41:39 -0500
 >>> Reason>>> I know why this happens, the question is whether it's  
 >>> the right thing or not.
 >>>
 >>>
 >>> View:
 >>> http://bugs.plt-scheme.org/query/?cmd=view&pr=10612
 >>>
 >>
 >
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Carl Eastlund <cce@plt-scheme.org>, bugs@plt-scheme.org,
        sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org, samth@ccs.neu.edu
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 11:02:26 -0600

 On Tue, Nov 24, 2009 at 11:01 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > Oh man, I can never keep straight what you are convincing me of.
 
 :)
 
 > You may have for some 10 mins while you were around, but I always think o=
 f
 > this as a first-order property that is checkable.
 
 But what you write here is not in contradiction with what I wrote!!
 
 I'm merely claiming it is _apply_'s contract, (#%app technically), NOT
 the function's contract that is being violated here.
 
 Robby
 
 > On Nov 24, 2009, at 11:59 AM, Robby Findler wrote:
 >
 >> I thought I had convinced Matthias that the current behavior was
 >> correct some time ago. (Water flowing in jugs and all that... probably
 >> he recalls convincing me the other way :)
 >>
 >> Anyways, I believe that this is not a contract violation of the
 >> function, but of the application operator. It has a contract saying
 >> that the number of arguments it gets matches the number of arguments
 >> desired by the procedure. And it is correctly reporting that failure.
 >>
 >> Robby
 >>
 >> On Tue, Nov 24, 2009 at 10:54 AM, Carl Eastlund <cce@plt-scheme.org>
 >> wrote:
 >>>
 >>> On Tue, Nov 24, 2009 at 11:49 AM, Matthias Felleisen
 >>> <matthias@ccs.neu.edu> wrote:
 >>>>
 >>>> That's an old request. Can't do w/o Matthew
 >>>
 >>> You mean efficiently. =C2=A0Because it's really easy to do it with
 >>> case-lambda and/or make-keyword-procedure.
 >>>
 >>> --Carl
 >>>
 >
 >
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Carl Eastlund <cce@plt-scheme.org>, bugs@plt-scheme.org,
        sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org, samth@ccs.neu.edu
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract  errors on wrong arity
Date: Tue, 24 Nov 2009 12:01:24 -0500

 Oh man, I can never keep straight what you are convincing me of.
 
 You may have for some 10 mins while you were around, but I always  
 think of this as a first-order property that is checkable.
 
 
 On Nov 24, 2009, at 11:59 AM, Robby Findler wrote:
 
 > I thought I had convinced Matthias that the current behavior was
 > correct some time ago. (Water flowing in jugs and all that... probably
 > he recalls convincing me the other way :)
 >
 > Anyways, I believe that this is not a contract violation of the
 > function, but of the application operator. It has a contract saying
 > that the number of arguments it gets matches the number of arguments
 > desired by the procedure. And it is correctly reporting that failure.
 >
 > Robby
 >
 > On Tue, Nov 24, 2009 at 10:54 AM, Carl Eastlund <cce@plt-scheme.org>  
 > wrote:
 >> On Tue, Nov 24, 2009 at 11:49 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> That's an old request. Can't do w/o Matthew
 >>
 >> You mean efficiently.  Because it's really easy to do it with
 >> case-lambda and/or make-keyword-procedure.
 >>
 >> --Carl
 >>
 
From: Sam TH <samth@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs@plt-scheme.org,
        sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 12:07:30 -0500

 On Tue, Nov 24, 2009 at 12:02 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > On Tue, Nov 24, 2009 at 11:01 AM, Matthias Felleisen
 > <matthias@ccs.neu.edu> wrote:
 >>
 >> Oh man, I can never keep straight what you are convincing me of.
 >
 > :)
 >
 >> You may have for some 10 mins while you were around, but I always think =
 of
 >> this as a first-order property that is checkable.
 >
 > But what you write here is not in contradiction with what I wrote!!
 >
 > I'm merely claiming it is _apply_'s contract, (#%app technically), NOT
 > the function's contract that is being violated here.
 
 How would you characterize this contract?  Who is it between?  It
 seems to involve 3 parties, unlike all of our other contracts.  It
 also seems hard to specify - it's parameterized over something
 dynamically determined about the function.
 
 I definitely have the intuition that you promise to provide this
 function with precisely 1 argument.  For example:
 
 (define/contract (f x [internal-only 0]) (-> number? number?)
    (if (zero? internal-only) (f x (add1 internal-only)) ...))
 
 (f 1 7)
 
 Now it really looks (to me) like it's the contract that's being violated.
 
 >
 > Robby
 >
 >> On Nov 24, 2009, at 11:59 AM, Robby Findler wrote:
 >>
 >>> I thought I had convinced Matthias that the current behavior was
 >>> correct some time ago. (Water flowing in jugs and all that... probably
 >>> he recalls convincing me the other way :)
 >>>
 >>> Anyways, I believe that this is not a contract violation of the
 >>> function, but of the application operator. It has a contract saying
 >>> that the number of arguments it gets matches the number of arguments
 >>> desired by the procedure. And it is correctly reporting that failure.
 >>>
 >>> Robby
 >>>
 >>> On Tue, Nov 24, 2009 at 10:54 AM, Carl Eastlund <cce@plt-scheme.org>
 >>> wrote:
 >>>>
 >>>> On Tue, Nov 24, 2009 at 11:49 AM, Matthias Felleisen
 >>>> <matthias@ccs.neu.edu> wrote:
 >>>>>
 >>>>> That's an old request. Can't do w/o Matthew
 >>>>
 >>>> You mean efficiently. =A0Because it's really easy to do it with
 >>>> case-lambda and/or make-keyword-procedure.
 >>>>
 >>>> --Carl
 >>>>
 >>
 >>
 >
 
 
 
 --=20
 sam th
 samth@ccs.neu.edu
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam TH <samth@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs@plt-scheme.org,
        sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 11:17:40 -0600

 On Tue, Nov 24, 2009 at 11:07 AM, Sam TH <samth@ccs.neu.edu> wrote:
 > On Tue, Nov 24, 2009 at 12:02 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> On Tue, Nov 24, 2009 at 11:01 AM, Matthias Felleisen
 >> <matthias@ccs.neu.edu> wrote:
 >>>
 >>> Oh man, I can never keep straight what you are convincing me of.
 >>
 >> :)
 >>
 >>> You may have for some 10 mins while you were around, but I always think=
  of
 >>> this as a first-order property that is checkable.
 >>
 >> But what you write here is not in contradiction with what I wrote!!
 >>
 >> I'm merely claiming it is _apply_'s contract, (#%app technically), NOT
 >> the function's contract that is being violated here.
 >
 > How would you characterize this contract? =C2=A0Who is it between? It
 > seems to involve 3 parties, unlike all of our other contracts. =C2=A0It
 
 It is a pre-condition contract on the apply operator. blame falls on
 the user of apply.
 
 (The two parties are the user of apply and apply itself.)
 
 > also seems hard to specify - it's parameterized over something
 > dynamically determined about the function.
 
 You can write it in terms of the number of arguments appearing in the
 application expression and "procedure-arity-includes?".
 
 > I definitely have the intuition that you promise to provide this
 > function with precisely 1 argument. =C2=A0For example:
 >
 > (define/contract (f x [internal-only 0]) (-> number? number?)
 > =C2=A0 (if (zero? internal-only) (f x (add1 internal-only)) ...))
 >
 > (f 1 7)
 >
 > Now it really looks (to me) like it's the contract that's being violated.
 
 Thinking at the define/contract level is going to confuse things (at
 least for me). Lets start with just 'contract' which, as Stevie agrees
 (for one anyways), is the core feature.
 
 Here is what I think you mean:
 
 ((contract (-> number? number?)
            (letrec ([f (=CE=BB (x [internal-only 0])
                          (if (zero? internal-only)
                              (f x (add1 internal-only))
                              1))])
              f)
            'pos
            'neg)
  1 2)
 
 In this case, #%app is getting a procedure that only accepts one
 argument, as well as two arugments. And it lets you know.
 
 (of course, primitives in mzscheme don't supply blame information, but
 that's a separate story).
 
 Robby
 
 Robby
From: Sam TH <samth@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs@plt-scheme.org,
        sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 12:34:58 -0500

 On Tue, Nov 24, 2009 at 12:17 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 >> I definitely have the intuition that you promise to provide this
 >> function with precisely 1 argument. =A0For example:
 >>
 >> (define/contract (f x [internal-only 0]) (-> number? number?)
 >> =A0 (if (zero? internal-only) (f x (add1 internal-only)) ...))
 >>
 >> (f 1 7)
 >>
 >> Now it really looks (to me) like it's the contract that's being violated=
 .
 >
 > Thinking at the define/contract level is going to confuse things (at
 > least for me). Lets start with just 'contract' which, as Stevie agrees
 > (for one anyways), is the core feature.
 >
 > Here is what I think you mean:
 >
 > ((contract (-> number? number?)
 > =A0 =A0 =A0 =A0 =A0 (letrec ([f (=EB (x [internal-only 0])
 > =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 (if (zero? internal-only)
 > =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 (f x (add1 intern=
 al-only))
 > =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 1))])
 > =A0 =A0 =A0 =A0 =A0 =A0 f)
 > =A0 =A0 =A0 =A0 =A0 'pos
 > =A0 =A0 =A0 =A0 =A0 'neg)
 > =A01 2)
 >
 > In this case, #%app is getting a procedure that only accepts one
 > argument, as well as two arugments. And it lets you know.
 
 I have the same intuition for this case as with `define/contract'.
 
 How about this contract for `f'
 (case-> (-> number? number? number?)
               (-> string? number?))
 
 Then we have two applications:
 
 (f 1)
 (f 3 3 3)
 
 In the current contract system, the first is a contract error, the
 second is not.  That seems inconsistent to me.
 
 > (of course, primitives in mzscheme don't supply blame information, but
 > that's a separate story).
 
 As long as that's the case (which seems like it will be for a while),
 there's a software engineering argument for providing this blame via
 the contract system.
 --=20
 sam th
 samth@ccs.neu.edu
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam TH <samth@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs@plt-scheme.org,
        sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 11:40:27 -0600

 2009/11/24 Sam TH <samth@ccs.neu.edu>:
 > On Tue, Nov 24, 2009 at 12:17 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >>> I definitely have the intuition that you promise to provide this
 >>> function with precisely 1 argument. =C2=A0For example:
 >>>
 >>> (define/contract (f x [internal-only 0]) (-> number? number?)
 >>> =C2=A0 (if (zero? internal-only) (f x (add1 internal-only)) ...))
 >>>
 >>> (f 1 7)
 >>>
 >>> Now it really looks (to me) like it's the contract that's being violate=
 d.
 >>
 >> Thinking at the define/contract level is going to confuse things (at
 >> least for me). Lets start with just 'contract' which, as Stevie agrees
 >> (for one anyways), is the core feature.
 >>
 >> Here is what I think you mean:
 >>
 >> ((contract (-> number? number?)
 >> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (letrec ([f (=CE=BB (x [internal-only=
  0])
 >> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 (if (zero? internal-only)
 >> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (f x (add1 internal-only))
 >> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 1))])
 >> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 f)
 >> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 'pos
 >> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 'neg)
 >> =C2=A01 2)
 >>
 >> In this case, #%app is getting a procedure that only accepts one
 >> argument, as well as two arugments. And it lets you know.
 >
 > I have the same intuition for this case as with `define/contract'.
 >
 > How about this contract for `f'
 > (case-> (-> number? number? number?)
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(-> string? number?))
 >
 > Then we have two applications:
 >
 > (f 1)
 > (f 3 3 3)
 >
 > In the current contract system, the first is a contract error, the
 > second is not. =C2=A0That seems inconsistent to me.
 
 Seems consistent to me, if you think of #%app as its own operator,
 with a separate contract.
 
 >> (of course, primitives in mzscheme don't supply blame information, but
 >> that's a separate story).
 >
 > As long as that's the case (which seems like it will be for a while),
 > there's a software engineering argument for providing this blame via
 > the contract system.
 
 But the contract system doesn't know who to blame if you take my
 worldview. It is the guy who calls apply, not the producer or consumer
 of the function.
 
 Robby
From: Sam TH <samth@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs@plt-scheme.org,
        sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 12:45:05 -0500

 On Tue, Nov 24, 2009 at 12:40 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > 2009/11/24 Sam TH <samth@ccs.neu.edu>:
 >> On Tue, Nov 24, 2009 at 12:17 PM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >>>> I definitely have the intuition that you promise to provide this
 >>>> function with precisely 1 argument. =A0For example:
 >>>>
 >>>> (define/contract (f x [internal-only 0]) (-> number? number?)
 >>>> =A0 (if (zero? internal-only) (f x (add1 internal-only)) ...))
 >>>>
 >>>> (f 1 7)
 >>>>
 >>>> Now it really looks (to me) like it's the contract that's being violat=
 ed.
 >>>
 >>> Thinking at the define/contract level is going to confuse things (at
 >>> least for me). Lets start with just 'contract' which, as Stevie agrees
 >>> (for one anyways), is the core feature.
 >>>
 >>> Here is what I think you mean:
 >>>
 >>> ((contract (-> number? number?)
 >>> =A0 =A0 =A0 =A0 =A0 (letrec ([f (=EB (x [internal-only 0])
 >>> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 (if (zero? internal-onl=
 y)
 >>> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 (f x (add1 inte=
 rnal-only))
 >>> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 1))])
 >>> =A0 =A0 =A0 =A0 =A0 =A0 f)
 >>> =A0 =A0 =A0 =A0 =A0 'pos
 >>> =A0 =A0 =A0 =A0 =A0 'neg)
 >>> =A01 2)
 >>>
 >>> In this case, #%app is getting a procedure that only accepts one
 >>> argument, as well as two arugments. And it lets you know.
 >>
 >> I have the same intuition for this case as with `define/contract'.
 >>
 >> How about this contract for `f'
 >> (case-> (-> number? number? number?)
 >> =A0 =A0 =A0 =A0 =A0 =A0 =A0(-> string? number?))
 >>
 >> Then we have two applications:
 >>
 >> (f 1)
 >> (f 3 3 3)
 >>
 >> In the current contract system, the first is a contract error, the
 >> second is not. =A0That seems inconsistent to me.
 >
 > Seems consistent to me, if you think of #%app as its own operator,
 > with a separate contract.
 
 But they're both arity errors, so how can that be consistent?
 
 >>> (of course, primitives in mzscheme don't supply blame information, but
 >>> that's a separate story).
 >>
 >> As long as that's the case (which seems like it will be for a while),
 >> there's a software engineering argument for providing this blame via
 >> the contract system.
 >
 > But the contract system doesn't know who to blame if you take my
 > worldview. It is the guy who calls apply, not the producer or consumer
 > of the function.
 
 Isn't the guy who calls apply the consumer of the function by
 definition?  That's what it means to consume a function.
 
 --=20
 sam th
 samth@ccs.neu.edu
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>, bugs@plt-scheme.org
Cc: nobody@plt-scheme.org
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract errors on wrong arity
Date: Tue, 24 Nov 2009 12:45:21 -0500

 On Nov 24, 2009, at 11:20 AM, samth@ccs.neu.edu wrote:
 > #lang scheme
 > (define/contract (f l) (vector? . -> . vector?) l)
 > (f 1 2)
 >=20
 > produces=20
 >=20
 > procedure f: expects 1 argument, given 2: 1 2
 >=20
 > instead of a contract error.
 >=20
 > [Stevie wanted this reported.]
 
 I did, and am glad I did, even if I'm on the opposite side of the =
 discussion now.
 
 However, I do believe the below _is_ an error, and should have reported =
 a contract error instead of an arity error:
 
 -----
 
 #lang scheme
 
 (define/contract f
   (-> number? number?)
   (case-lambda
     [(x) x]
     [(x y) x]))
 
 (f 3 4)
 
 -----
 
 The reason for this is because the value that is resulting from the =
 "projection" is not semantically equivalent modulo contract errors.  The =
 lambda resulting from the application of an arrow contract should always =
 accept the same arities as the original.
 
 Stevie=
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam TH <samth@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs@plt-scheme.org,
        sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 11:50:40 -0600

 2009/11/24 Sam TH <samth@ccs.neu.edu>:
 > On Tue, Nov 24, 2009 at 12:40 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> 2009/11/24 Sam TH <samth@ccs.neu.edu>:
 >>> On Tue, Nov 24, 2009 at 12:17 PM, Robby Findler
 >>> <robby@eecs.northwestern.edu> wrote:
 >>>>> I definitely have the intuition that you promise to provide this
 >>>>> function with precisely 1 argument. =C2=A0For example:
 >>>>>
 >>>>> (define/contract (f x [internal-only 0]) (-> number? number?)
 >>>>> =C2=A0 (if (zero? internal-only) (f x (add1 internal-only)) ...))
 >>>>>
 >>>>> (f 1 7)
 >>>>>
 >>>>> Now it really looks (to me) like it's the contract that's being viola=
 ted.
 >>>>
 >>>> Thinking at the define/contract level is going to confuse things (at
 >>>> least for me). Lets start with just 'contract' which, as Stevie agrees
 >>>> (for one anyways), is the core feature.
 >>>>
 >>>> Here is what I think you mean:
 >>>>
 >>>> ((contract (-> number? number?)
 >>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (letrec ([f (=CE=BB (x [internal-on=
 ly 0])
 >>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 (if (zero? internal-only)
 >>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (f x (add1 internal-only))
 >>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 1))])
 >>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 f)
 >>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 'pos
 >>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 'neg)
 >>>> =C2=A01 2)
 >>>>
 >>>> In this case, #%app is getting a procedure that only accepts one
 >>>> argument, as well as two arugments. And it lets you know.
 >>>
 >>> I have the same intuition for this case as with `define/contract'.
 >>>
 >>> How about this contract for `f'
 >>> (case-> (-> number? number? number?)
 >>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(-> string? number?))
 >>>
 >>> Then we have two applications:
 >>>
 >>> (f 1)
 >>> (f 3 3 3)
 >>>
 >>> In the current contract system, the first is a contract error, the
 >>> second is not. =C2=A0That seems inconsistent to me.
 >>
 >> Seems consistent to me, if you think of #%app as its own operator,
 >> with a separate contract.
 >
 > But they're both arity errors, so how can that be consistent?
 
 the first one is "number given, expected string", no?
 
 >>>> (of course, primitives in mzscheme don't supply blame information, but
 >>>> that's a separate story).
 >>>
 >>> As long as that's the case (which seems like it will be for a while),
 >>> there's a software engineering argument for providing this blame via
 >>> the contract system.
 >>
 >> But the contract system doesn't know who to blame if you take my
 >> worldview. It is the guy who calls apply, not the producer or consumer
 >> of the function.
 >
 > Isn't the guy who calls apply the consumer of the function by
 > definition? =C2=A0That's what it means to consume a function.
 
 No.... I can pass functions around. Even in C you can do that ;)
 
 Robby
From: Robby Findler <robby@eecs.northwestern.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 11:49:45 -0600

 Oh, I see. Instead of writing
 
   (f 3 4)
 
 at the end there, we shoudl really be considering writing:
 
   (procedure-arity-includes? f 2)
 
 right?
 
 hm. good point! But this has some far-reaching consequences.....
 
 Robby
 
 On Tue, Nov 24, 2009 at 11:45 AM, Stevie Strickland
 <sstrickl@ccs.neu.edu> wrote:
 > On Nov 24, 2009, at 11:20 AM, samth@ccs.neu.edu wrote:
 >> #lang scheme
 >> (define/contract (f l) (vector? . -> . vector?) l)
 >> (f 1 2)
 >>
 >> produces
 >>
 >> procedure f: expects 1 argument, given 2: 1 2
 >>
 >> instead of a contract error.
 >>
 >> [Stevie wanted this reported.]
 >
 > I did, and am glad I did, even if I'm on the opposite side of the discuss=
 ion now.
 >
 > However, I do believe the below _is_ an error, and should have reported a=
  contract error instead of an arity error:
 >
 > -----
 >
 > #lang scheme
 >
 > (define/contract f
 > =C2=A0(-> number? number?)
 > =C2=A0(case-lambda
 > =C2=A0 =C2=A0[(x) x]
 > =C2=A0 =C2=A0[(x y) x]))
 >
 > (f 3 4)
 >
 > -----
 >
 > The reason for this is because the value that is resulting from the "proj=
 ection" is not semantically equivalent modulo contract errors. =C2=A0The la=
 mbda resulting from the application of an arrow contract should always acce=
 pt the same arities as the original.
 >
 > Stevie
From: Sam TH <samth@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs@plt-scheme.org,
        sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 12:54:02 -0500

 On Tue, Nov 24, 2009 at 12:50 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > 2009/11/24 Sam TH <samth@ccs.neu.edu>:
 >> On Tue, Nov 24, 2009 at 12:40 PM, Robby Findler
 >> <robby@eecs.northwestern.edu> wrote:
 >>> 2009/11/24 Sam TH <samth@ccs.neu.edu>:
 >>>> On Tue, Nov 24, 2009 at 12:17 PM, Robby Findler
 >>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>> I definitely have the intuition that you promise to provide this
 >>>>>> function with precisely 1 argument. =A0For example:
 >>>>>>
 >>>>>> (define/contract (f x [internal-only 0]) (-> number? number?)
 >>>>>> =A0 (if (zero? internal-only) (f x (add1 internal-only)) ...))
 >>>>>>
 >>>>>> (f 1 7)
 >>>>>>
 >>>>>> Now it really looks (to me) like it's the contract that's being viol=
 ated.
 >>>>>
 >>>>> Thinking at the define/contract level is going to confuse things (at
 >>>>> least for me). Lets start with just 'contract' which, as Stevie agree=
 s
 >>>>> (for one anyways), is the core feature.
 >>>>>
 >>>>> Here is what I think you mean:
 >>>>>
 >>>>> ((contract (-> number? number?)
 >>>>> =A0 =A0 =A0 =A0 =A0 (letrec ([f (=EB (x [internal-only 0])
 >>>>> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 (if (zero? internal-o=
 nly)
 >>>>> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 (f x (add1 in=
 ternal-only))
 >>>>> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 1))])
 >>>>> =A0 =A0 =A0 =A0 =A0 =A0 f)
 >>>>> =A0 =A0 =A0 =A0 =A0 'pos
 >>>>> =A0 =A0 =A0 =A0 =A0 'neg)
 >>>>> =A01 2)
 >>>>>
 >>>>> In this case, #%app is getting a procedure that only accepts one
 >>>>> argument, as well as two arugments. And it lets you know.
 >>>>
 >>>> I have the same intuition for this case as with `define/contract'.
 >>>>
 >>>> How about this contract for `f'
 >>>> (case-> (-> number? number? number?)
 >>>> =A0 =A0 =A0 =A0 =A0 =A0 =A0(-> string? number?))
 >>>>
 >>>> Then we have two applications:
 >>>>
 >>>> (f 1)
 >>>> (f 3 3 3)
 >>>>
 >>>> In the current contract system, the first is a contract error, the
 >>>> second is not. =A0That seems inconsistent to me.
 >>>
 >>> Seems consistent to me, if you think of #%app as its own operator,
 >>> with a separate contract.
 >>
 >> But they're both arity errors, so how can that be consistent?
 >
 > the first one is "number given, expected string", no?
 
 Why not "expected two numbers, got one"?  Why is number of arguments
 privileged over the values of the arguments?
 
 --=20
 sam th
 samth@ccs.neu.edu
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract  errors on wrong arity
Date: Tue, 24 Nov 2009 12:54:47 -0500

 No, I think that the result of the projection in this case should be =
 something approximating:
 
 (case-lambda
   [(x) (p_r (p_x x))]
   [(x y) (raise-contract-error ...)])
 
 where p_x is the projection for the argument contract and p_r is the =
 projection for the result contract.
 
 On Nov 24, 2009, at 12:49 PM, Robby Findler wrote:
 
 > Oh, I see. Instead of writing
 >=20
 >  (f 3 4)
 >=20
 > at the end there, we shoudl really be considering writing:
 >=20
 >  (procedure-arity-includes? f 2)
 >=20
 > right?
 >=20
 > hm. good point! But this has some far-reaching consequences.....
 >=20
 > Robby
 >=20
 > On Tue, Nov 24, 2009 at 11:45 AM, Stevie Strickland
 > <sstrickl@ccs.neu.edu> wrote:
 >> On Nov 24, 2009, at 11:20 AM, samth@ccs.neu.edu wrote:
 >>> #lang scheme
 >>> (define/contract (f l) (vector? . -> . vector?) l)
 >>> (f 1 2)
 >>>=20
 >>> produces
 >>>=20
 >>> procedure f: expects 1 argument, given 2: 1 2
 >>>=20
 >>> instead of a contract error.
 >>>=20
 >>> [Stevie wanted this reported.]
 >>=20
 >> I did, and am glad I did, even if I'm on the opposite side of the =
 discussion now.
 >>=20
 >> However, I do believe the below _is_ an error, and should have =
 reported a contract error instead of an arity error:
 >>=20
 >> -----
 >>=20
 >> #lang scheme
 >>=20
 >> (define/contract f
 >>  (-> number? number?)
 >>  (case-lambda
 >>    [(x) x]
 >>    [(x y) x]))
 >>=20
 >> (f 3 4)
 >>=20
 >> -----
 >>=20
 >> The reason for this is because the value that is resulting from the =
 "projection" is not semantically equivalent modulo contract errors.  The =
 lambda resulting from the application of an arrow contract should always =
 accept the same arities as the original.
 >>=20
 >> Stevie
 
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract  errors on wrong arity
Date: Tue, 24 Nov 2009 12:56:21 -0500

 And by "no", I mean "yes".  Sorry, I don't know how I misread what you =
 meant.
 
 Stevie
 
 On Nov 24, 2009, at 12:54 PM, Stevie Strickland wrote:
 
 > No, I think that the result of the projection in this case should be =
 something approximating:
 >=20
 > (case-lambda
 >  [(x) (p_r (p_x x))]
 >  [(x y) (raise-contract-error ...)])
 >=20
 > where p_x is the projection for the argument contract and p_r is the =
 projection for the result contract.
 >=20
 > On Nov 24, 2009, at 12:49 PM, Robby Findler wrote:
 >=20
 >> Oh, I see. Instead of writing
 >>=20
 >> (f 3 4)
 >>=20
 >> at the end there, we shoudl really be considering writing:
 >>=20
 >> (procedure-arity-includes? f 2)
 >>=20
 >> right?
 >>=20
 >> hm. good point! But this has some far-reaching consequences.....
 >>=20
 >> Robby
 >>=20
 >> On Tue, Nov 24, 2009 at 11:45 AM, Stevie Strickland
 >> <sstrickl@ccs.neu.edu> wrote:
 >>> On Nov 24, 2009, at 11:20 AM, samth@ccs.neu.edu wrote:
 >>>> #lang scheme
 >>>> (define/contract (f l) (vector? . -> . vector?) l)
 >>>> (f 1 2)
 >>>>=20
 >>>> produces
 >>>>=20
 >>>> procedure f: expects 1 argument, given 2: 1 2
 >>>>=20
 >>>> instead of a contract error.
 >>>>=20
 >>>> [Stevie wanted this reported.]
 >>>=20
 >>> I did, and am glad I did, even if I'm on the opposite side of the =
 discussion now.
 >>>=20
 >>> However, I do believe the below _is_ an error, and should have =
 reported a contract error instead of an arity error:
 >>>=20
 >>> -----
 >>>=20
 >>> #lang scheme
 >>>=20
 >>> (define/contract f
 >>> (-> number? number?)
 >>> (case-lambda
 >>>   [(x) x]
 >>>   [(x y) x]))
 >>>=20
 >>> (f 3 4)
 >>>=20
 >>> -----
 >>>=20
 >>> The reason for this is because the value that is resulting from the =
 "projection" is not semantically equivalent modulo contract errors.  The =
 lambda resulting from the application of an arrow contract should always =
 accept the same arities as the original.
 >>>=20
 >>> Stevie
 >=20
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 11:56:34 -0600

 If you replace the first two letters of your message with "Yes" then I
 think we're in agreement.
 
 But I'm still not sure, as this is pretty fundamental.
 
 And without procedure-arity-includes? (or similar things) then we
 wouldn't have to take this step.
 
 Wow.
 
 Robby
 
 On Tue, Nov 24, 2009 at 11:54 AM, Stevie Strickland
 <sstrickl@ccs.neu.edu> wrote:
 > No, I think that the result of the projection in this case should be some=
 thing approximating:
 >
 > (case-lambda
 > =C2=A0[(x) (p_r (p_x x))]
 > =C2=A0[(x y) (raise-contract-error ...)])
 >
 > where p_x is the projection for the argument contract and p_r is the proj=
 ection for the result contract.
 >
 > On Nov 24, 2009, at 12:49 PM, Robby Findler wrote:
 >
 >> Oh, I see. Instead of writing
 >>
 >> =C2=A0(f 3 4)
 >>
 >> at the end there, we shoudl really be considering writing:
 >>
 >> =C2=A0(procedure-arity-includes? f 2)
 >>
 >> right?
 >>
 >> hm. good point! But this has some far-reaching consequences.....
 >>
 >> Robby
 >>
 >> On Tue, Nov 24, 2009 at 11:45 AM, Stevie Strickland
 >> <sstrickl@ccs.neu.edu> wrote:
 >>> On Nov 24, 2009, at 11:20 AM, samth@ccs.neu.edu wrote:
 >>>> #lang scheme
 >>>> (define/contract (f l) (vector? . -> . vector?) l)
 >>>> (f 1 2)
 >>>>
 >>>> produces
 >>>>
 >>>> procedure f: expects 1 argument, given 2: 1 2
 >>>>
 >>>> instead of a contract error.
 >>>>
 >>>> [Stevie wanted this reported.]
 >>>
 >>> I did, and am glad I did, even if I'm on the opposite side of the discu=
 ssion now.
 >>>
 >>> However, I do believe the below _is_ an error, and should have reported=
  a contract error instead of an arity error:
 >>>
 >>> -----
 >>>
 >>> #lang scheme
 >>>
 >>> (define/contract f
 >>> =C2=A0(-> number? number?)
 >>> =C2=A0(case-lambda
 >>> =C2=A0 =C2=A0[(x) x]
 >>> =C2=A0 =C2=A0[(x y) x]))
 >>>
 >>> (f 3 4)
 >>>
 >>> -----
 >>>
 >>> The reason for this is because the value that is resulting from the "pr=
 ojection" is not semantically equivalent modulo contract errors. =C2=A0The =
 lambda resulting from the application of an arrow contract should always ac=
 cept the same arities as the original.
 >>>
 >>> Stevie
 >
 >
From: Robby Findler <robby@eecs.northwestern.edu>
To: Sam TH <samth@ccs.neu.edu>
Cc: Matthias Felleisen <matthias@ccs.neu.edu>,
        Carl Eastlund <cce@plt-scheme.org>, bugs@plt-scheme.org,
        sstrickl@plt-scheme.org, nobody@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 11:59:37 -0600

 That's just the same question as what began this thread, iiuc. I think
 of apply as having a contract that depends on its arguments instead
 of, as you seem to, think of apply as having the contract (any (listof
 any) *-> (values any)) in Cormac's old notation.
 
 My view is somehwat pragmatic, since ... uhh ... apply actually does
 that check and signals that error.
 
 2009/11/24 Sam TH <samth@ccs.neu.edu>:
 > On Tue, Nov 24, 2009 at 12:50 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> 2009/11/24 Sam TH <samth@ccs.neu.edu>:
 >>> On Tue, Nov 24, 2009 at 12:40 PM, Robby Findler
 >>> <robby@eecs.northwestern.edu> wrote:
 >>>> 2009/11/24 Sam TH <samth@ccs.neu.edu>:
 >>>>> On Tue, Nov 24, 2009 at 12:17 PM, Robby Findler
 >>>>> <robby@eecs.northwestern.edu> wrote:
 >>>>>>> I definitely have the intuition that you promise to provide this
 >>>>>>> function with precisely 1 argument. =C2=A0For example:
 >>>>>>>
 >>>>>>> (define/contract (f x [internal-only 0]) (-> number? number?)
 >>>>>>> =C2=A0 (if (zero? internal-only) (f x (add1 internal-only)) ...))
 >>>>>>>
 >>>>>>> (f 1 7)
 >>>>>>>
 >>>>>>> Now it really looks (to me) like it's the contract that's being vio=
 lated.
 >>>>>>
 >>>>>> Thinking at the define/contract level is going to confuse things (at
 >>>>>> least for me). Lets start with just 'contract' which, as Stevie agre=
 es
 >>>>>> (for one anyways), is the core feature.
 >>>>>>
 >>>>>> Here is what I think you mean:
 >>>>>>
 >>>>>> ((contract (-> number? number?)
 >>>>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (letrec ([f (=CE=BB (x [internal-=
 only 0])
 >>>>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 (if (zero? internal-only)
 >>>>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (f x (add1 internal-only))
 >>>>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 1))])
 >>>>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 f)
 >>>>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 'pos
 >>>>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 'neg)
 >>>>>> =C2=A01 2)
 >>>>>>
 >>>>>> In this case, #%app is getting a procedure that only accepts one
 >>>>>> argument, as well as two arugments. And it lets you know.
 >>>>>
 >>>>> I have the same intuition for this case as with `define/contract'.
 >>>>>
 >>>>> How about this contract for `f'
 >>>>> (case-> (-> number? number? number?)
 >>>>> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(-> string? number?))
 >>>>>
 >>>>> Then we have two applications:
 >>>>>
 >>>>> (f 1)
 >>>>> (f 3 3 3)
 >>>>>
 >>>>> In the current contract system, the first is a contract error, the
 >>>>> second is not. =C2=A0That seems inconsistent to me.
 >>>>
 >>>> Seems consistent to me, if you think of #%app as its own operator,
 >>>> with a separate contract.
 >>>
 >>> But they're both arity errors, so how can that be consistent?
 >>
 >> the first one is "number given, expected string", no?
 >
 > Why not "expected two numbers, got one"? =C2=A0Why is number of arguments
 > privileged over the values of the arguments?
 >
 > --
 > sam th
 > samth@ccs.neu.edu
 >
From: Robby Findler <robby@eecs.northwestern.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 12:02:36 -0600

 On Tue, Nov 24, 2009 at 12:01 PM, Stevie Strickland
 <sstrickl@ccs.neu.edu> wrote:
 > On Nov 24, 2009, at 12:56 PM, Robby Findler wrote:
 >> If you replace the first two letters of your message with "Yes" then I
 >> think we're in agreement.
 >>
 >> But I'm still not sure, as this is pretty fundamental.
 >>
 >> And without procedure-arity-includes? (or similar things) then we
 >> wouldn't have to take this step.
 >>
 >> Wow.
 >
 > Well, the existence of those functions sure doesn't help things, but even=
  in the example I wrote, you're getting an error at the level of apply, whi=
 ch shows that the result of the projection is not semantically equivalent t=
 o the original modulo contract errors. =C2=A0We're getting a runtime error =
 instead of a contract error.
 
 No no, apply _is_ a contract error. It just comes from a part of the
 system that, for efficiency reasons, doesn't include blame information
 (Sadly).
 
 Similarly (+ #f #t) is a contract violation of the same ilk.
 
 Robby
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract  errors on wrong arity
Date: Tue, 24 Nov 2009 13:01:35 -0500

 On Nov 24, 2009, at 12:56 PM, Robby Findler wrote:
 > If you replace the first two letters of your message with "Yes" then I
 > think we're in agreement.
 >=20
 > But I'm still not sure, as this is pretty fundamental.
 >=20
 > And without procedure-arity-includes? (or similar things) then we
 > wouldn't have to take this step.
 >=20
 > Wow.
 
 Well, the existence of those functions sure doesn't help things, but =
 even in the example I wrote, you're getting an error at the level of =
 apply, which shows that the result of the projection is not semantically =
 equivalent to the original modulo contract errors.  We're getting a =
 runtime error instead of a contract error.
 
 Stevie=
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract  errors on wrong arity
Date: Tue, 24 Nov 2009 13:09:43 -0500

 On Nov 24, 2009, at 1:02 PM, Robby Findler wrote:
 > No no, apply _is_ a contract error. It just comes from a part of the
 > system that, for efficiency reasons, doesn't include blame information
 > (Sadly).
 >=20
 > Similarly (+ #f #t) is a contract violation of the same ilk.
 
 Wrong contract error, though, because it's resulting from a different =
 contract than the one I wrote down.  The adding of the contract to a =
 function value should not change its arity -- that's changing behavior =
 in a distinctly non-projection-like way.
 
 That is,
 
 (define/contract (f x) (-> number? number?) x)
 (define/contract g
   (-> number? number?)
   (case-lambda [(x) x] [(x y) x]))
 
 ;; can be considered either a contract error at the apply level
 ;; or just a runtime error at the apply level, but in either case,
 ;; is at the apply level
 (f 1 2)=20
 ;; should not be considered a contract or runtime error at the
 ;; apply level, since the original function allowed this arity
 (g 1 2)=20=
From: Robby Findler <robby@eecs.northwestern.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 12:13:45 -0600

 On Tue, Nov 24, 2009 at 12:09 PM, Stevie Strickland
 <sstrickl@ccs.neu.edu> wrote:
 > On Nov 24, 2009, at 1:02 PM, Robby Findler wrote:
 >> No no, apply _is_ a contract error. It just comes from a part of the
 >> system that, for efficiency reasons, doesn't include blame information
 >> (Sadly).
 >>
 >> Similarly (+ #f #t) is a contract violation of the same ilk.
 >
 > Wrong contract error, though, because it's resulting from a different con=
 tract than the one I wrote down. =C2=A0The adding of the contract to a func=
 tion value should not change its arity -- that's changing behavior in a dis=
 tinctly non-projection-like way.
 
 Yes, agreed on that point. (Sadly.)
 
 > That is,
 >
 > (define/contract (f x) (-> number? number?) x)
 > (define/contract g
 > =C2=A0(-> number? number?)
 > =C2=A0(case-lambda [(x) x] [(x y) x]))
 >
 > ;; can be considered either a contract error at the apply level
 > ;; or just a runtime error at the apply level, but in either case,
 > ;; is at the apply level
 > (f 1 2)
 > ;; should not be considered a contract or runtime error at the
 > ;; apply level, since the original function allowed this arity
 > (g 1 2)
 
 But this is not the right reason.
 
 Instead, you have to say that this program:
 
 (procedure-arity-includes?
   (contract (-> number? number?) (case-lambda [(x) x][(x y) x]) 'pos 'neg)
   2)
 
 and this program:
 
 (procedure-arity-includes?
   (case-lambda [(x) x][(x y) x])
   2)
 
 should produce the same results, since one is simply the removal of a
 well-behaved contract from the other.
 
 Robby
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract  errors on wrong arity
Date: Tue, 24 Nov 2009 13:25:20 -0500

 On Nov 24, 2009, at 1:13 PM, Robby Findler wrote:
 >> That is,
 >>=20
 >> (define/contract (f x) (-> number? number?) x)
 >> (define/contract g
 >>  (-> number? number?)
 >>  (case-lambda [(x) x] [(x y) x]))
 >>=20
 >> ;; can be considered either a contract error at the apply level
 >> ;; or just a runtime error at the apply level, but in either case,
 >> ;; is at the apply level
 >> (f 1 2)
 >> ;; should not be considered a contract or runtime error at the
 >> ;; apply level, since the original function allowed this arity
 >> (g 1 2)
 >=20
 > But this is not the right reason.
 >=20
 > Instead, you have to say that this program:
 >=20
 > (procedure-arity-includes?
 >  (contract (-> number? number?) (case-lambda [(x) x][(x y) x]) 'pos =
 'neg)
 >  2)
 >=20
 > and this program:
 >=20
 > (procedure-arity-includes?
 >  (case-lambda [(x) x][(x y) x])
 >  2)
 >=20
 > should produce the same results, since one is simply the removal of a
 > well-behaved contract from the other.
 
 So, we're violently agreeing, but disagreeing on the utility of the =
 examples.  Let me make sure I have this clear:
 
 Your example is a case where we should have
 
 contracted program --> v =3D=3D> uncontracted program --> v
 
 but right now we don't have the first side, because of the bogus =
 transformation.
 
 I've been trying to show an example of the case
 
 uncontracted program --> v =3D=3D>
   contracted program --> v \/ contracted program --> contract error
 
 but you're saying since you consider the apply error a contract error of =
 sorts, that my example doesn't show a problem (since we usually aren't =
 talking about _which_ contract triggered the error in the latter case, =
 but just that the only change in behavior are contract errors).
 
 Stevie=
From: Robby Findler <robby@eecs.northwestern.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 12:37:28 -0600

 On Tue, Nov 24, 2009 at 12:25 PM, Stevie Strickland
 <sstrickl@ccs.neu.edu> wrote:
 > On Nov 24, 2009, at 1:13 PM, Robby Findler wrote:
 >>> That is,
 >>>
 >>> (define/contract (f x) (-> number? number?) x)
 >>> (define/contract g
 >>> =C2=A0(-> number? number?)
 >>> =C2=A0(case-lambda [(x) x] [(x y) x]))
 >>>
 >>> ;; can be considered either a contract error at the apply level
 >>> ;; or just a runtime error at the apply level, but in either case,
 >>> ;; is at the apply level
 >>> (f 1 2)
 >>> ;; should not be considered a contract or runtime error at the
 >>> ;; apply level, since the original function allowed this arity
 >>> (g 1 2)
 >>
 >> But this is not the right reason.
 >>
 >> Instead, you have to say that this program:
 >>
 >> (procedure-arity-includes?
 >> =C2=A0(contract (-> number? number?) (case-lambda [(x) x][(x y) x]) 'pos=
  'neg)
 >> =C2=A02)
 >>
 >> and this program:
 >>
 >> (procedure-arity-includes?
 >> =C2=A0(case-lambda [(x) x][(x y) x])
 >> =C2=A02)
 >>
 >> should produce the same results, since one is simply the removal of a
 >> well-behaved contract from the other.
 >
 > So, we're violently agreeing, but disagreeing on the utility of the examp=
 les.
 
 Yes.
 
 > Let me make sure I have this clear:
 >
 > Your example is a case where we should have
 >
 > contracted program --> v =3D=3D> uncontracted program --> v
 >
 > but right now we don't have the first side, because of the bogus transfor=
 mation.
 >
 > I've been trying to show an example of the case
 >
 > uncontracted program --> v =3D=3D>
 > =C2=A0contracted program --> v \/ contracted program --> contract error
 >
 > but you're saying since you consider the apply error a contract error of =
 sorts, that my example doesn't show a problem (since we usually aren't talk=
 ing about _which_ contract triggered the error in the latter case, but just=
  that the only change in behavior are contract errors).
 
 Yes, exactly.
 
 Well, except I don't quite follow what is happening after the
 implication in the second logical formula above. Is that the same
 contracted program exhibiting two different behaviors?
 
 Robby
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract  errors on wrong arity
Date: Tue, 24 Nov 2009 13:40:09 -0500

 On Nov 24, 2009, at 1:37 PM, Robby Findler wrote:
 ...
 >> I've been trying to show an example of the case
 >>=20
 >> uncontracted program --> v =3D=3D>
 >>  contracted program --> v \/ contracted program --> contract error
 ...
 >=20
 > Well, except I don't quite follow what is happening after the
 > implication in the second logical formula above. Is that the same
 > contracted program exhibiting two different behaviors?
 
 No, I meant that the contracted program either goes to the same value as =
 the contracted one (I left off the "exists v in Value such that" in =
 both) or results in a contract error.
 
 Stevie=
From: Sam TH <samth@ccs.neu.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: Stevie Strickland <sstrickl@plt-scheme.org>, bugs@plt-scheme.org,
        nobody@plt-scheme.org, bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10612 contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 13:44:25 -0500

 On Tue, Nov 24, 2009 at 11:59 AM, Matthias Felleisen
 <matthias@ccs.neu.edu> wrote:
 >
 > That'll kill our performance
 
 Leaving aside the semantics, this isn't true:
 
 #lang scheme
 
 (define (f1 x) (add1 x))
 
 (define f2
   (case-lambda [(x) (add1 x)]
                [_ (error 'bad)]))
 
 (time (for ([i (in-range 10000000)]) (f1 i)))
 cpu time: 248 real time: 248 gc time: 0
 
 (time (for ([i (in-range 10000000)]) (f2 i)))
 cpu time: 252 real time: 255 gc time: 0
 
 Branch prediction is pretty good these days.
 -- 
 sam th
 samth@ccs.neu.edu
From: Robby Findler <robby@eecs.northwestern.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 12:46:20 -0600

 On Tue, Nov 24, 2009 at 12:40 PM, Stevie Strickland
 <sstrickl@ccs.neu.edu> wrote:
 > On Nov 24, 2009, at 1:37 PM, Robby Findler wrote:
 > ...
 >>> I've been trying to show an example of the case
 >>>
 >>> uncontracted program --> v =3D=3D>
 >>> =C2=A0contracted program --> v \/ contracted program --> contract error
 > ...
 >>
 >> Well, except I don't quite follow what is happening after the
 >> implication in the second logical formula above. Is that the same
 >> contracted program exhibiting two different behaviors?
 >
 > No, I meant that the contracted program either goes to the same value as =
 the contracted one (I left off the "exists v in Value such that" in both) o=
 r results in a contract error.
 
 Oh, right. You can use the same procedure-arity-includes example to
 break that implication, too.
 
 Robby
From: Stevie Strickland <sstrickl@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract  errors on wrong arity
Date: Tue, 24 Nov 2009 13:48:21 -0500

 On Nov 24, 2009, at 1:46 PM, Robby Findler wrote:
 > Oh, right. You can use the same procedure-arity-includes example to
 > break that implication, too.
 
 Yes, exactly.
 
 With mine, I was just trying to show that you don't get the "right" =
 contract error with my example, but of course, we never prove in all =
 these papers that you get the "right" contract error, just _a_ contract =
 error.  That's why yours is more clearly an example of the broken =
 behavior.
 
 Stevie=
From: Robby Findler <robby@eecs.northwestern.edu>
To: Stevie Strickland <sstrickl@ccs.neu.edu>
Cc: bugs@plt-scheme.org, nobody@plt-scheme.org, Sam TH <samth@ccs.neu.edu>,
        Matthias Felleisen <matthias@ccs.neu.edu>
Subject: Re: [plt-bug] all/10612: contracted procedures should report contract 
	errors on wrong arity
Date: Tue, 24 Nov 2009 13:04:10 -0600

 I'm just glad we agree :)
 
 On Tue, Nov 24, 2009 at 12:48 PM, Stevie Strickland
 <sstrickl@ccs.neu.edu> wrote:
 > On Nov 24, 2009, at 1:46 PM, Robby Findler wrote:
 >> Oh, right. You can use the same procedure-arity-includes example to
 >> break that implication, too.
 >
 > Yes, exactly.
 >
 > With mine, I was just trying to show that you don't get the "right" contr=
 act error with my example, but of course, we never prove in all these paper=
 s that you get the "right" contract error, just _a_ contract error. =C2=A0T=
 hat's why yours is more clearly an example of the broken behavior.
 >
 > Stevie


State changed from "analyzed" to "closed" by sstrickl at Mon, 01 Oct 2012 09:59:58 -0400
Reason>>> At this point, I'm pretty sure this is always going to be the way it works, 
especially after the addition of chaperones/impersonators.  If the function never 
took a given arity to begin with, the runtime will report the mismatch.  If the 
function did, and a contract is restricting that arity, then the contract will report 
the error.

