From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Sun Jan 16 16:22:59 2011
Received: from mail-fx0-f44.google.com (mail-fx0-f44.google.com [209.85.161.44])
	by champlain.ccs.neu.edu (8.14.3/8.14.3) with ESMTP id p0GLMuS0025955
	for <bugs@bugs.plt-scheme.org>; Sun, 16 Jan 2011 16:22:57 -0500
Message-Id: <201101162122.p0GLMqdE025947@champlain.ccs.neu.edu>
Date: Sun, 16 Jan 2011 16:22:52 -0500
From: endobson@cs.brown.edu
To: bugs@racket-lang.org
Subject: Error escape handler can kill process

>Number:         11630
>Category:       drscheme
>Synopsis:       Error escape handler can kill process
>Class:          sw-bug
>Responsible:    mflatt
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Sun Jan 16 16:24:01 -0500 2011
>Closed-Date:    Thu Jan 20 16:22:49 -0500 2011
>Last-Modified:  Fri Jan 21 06:04:01 -0500 2011
>Originator:     Eric Dobson
>Organization:
plt
>Submitter-Id:   unknown
>Release:        5.0.2
>Environment:
macosx "Darwin eric-dobsons-macbook.local 10.6.0 Darwin Kernel Version 10.6.0: Wed Nov 10 18:13:17 PST 2010; root:xnu-1504.9.26~3/RELEASE_I386 i386 i386" (i386-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 165105440

Collections:
(("/Users/eric/Library/Racket/5.0.2/collects" non-existent-path) ("/Applications/Racket v5.0.2/collects" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compiler" "config" "data" "datalog" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "games" "graphics" "gui-debugger" "help" "hierlist" "htdp" "html" "icons" "info-domain" "lang" "launcher" "lazy" "macro-debugger" "make" "mred" "mrlib" "mysterx" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raco" "reader" "readline" "redex" "rnrs" "s-exp" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "slatex" "slideshow" "srfi" "stepper" "string-constants" "swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engine" "tex2page" "texpict" "trace" "typed" "typed-scheme" "unstable" "version" "web-server" "!
 wxme" "xml"))
Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t))
>Description:
If an error escape handler returns, bad things happen. In DrRacket it hangs the interactions window and in racket it exits the process.
>How-To-Repeat:
In the repl enter


(parameterize ((error-escape-handler (lambda () (printf "bad escape handler~n") 'return)))
  (call-with-exception-handler (lambda (x) (raise 'again))
                               (lambda () (raise 'original))))
>Fix:
>Audit-Trail:
From: Robby Findler <robby@eecs.northwestern.edu>
To: endobson@cs.brown.edu, bugs@racket-lang.org
Cc: nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/11630: Error escape handler can kill process
Date: Sun, 16 Jan 2011 15:31:58 -0600

 What do you propose should happen?
 
 Robby
 
 On Sun, Jan 16, 2011 at 3:24 PM,  <endobson@cs.brown.edu> wrote:
 > A new problem report is waiting at
 > =C2=A0http://bugs.racket-lang.org/query/?cmd=3Dview&pr=3D11630
 >
 > Reported by Eric Dobson for release: 5.0.2
 >
 > *** Description:
 > If an error escape handler returns, bad things happen. In DrRacket it han=
 gs the interactions window and in racket it exits the process.
 >
 > *** How to repeat:
 > In the repl enter
 >
 >
 > (parameterize ((error-escape-handler (lambda () (printf "bad escape handl=
 er~n") 'return)))
 > =C2=A0(call-with-exception-handler (lambda (x) (raise 'again))
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (lambda () (raise 'original))))
 >
 > *** Environment:
 > macosx "Darwin eric-dobsons-macbook.local 10.6.0 Darwin Kernel Version 10=
 .6.0: Wed Nov 10 18:13:17 PST 2010; root:xnu-1504.9.26~3/RELEASE_I386 i386 =
 i386" (i386-macosx/3m) (get-display-depth) =3D 32
 > Human Language: english
 > (current-memory-use) 165105440
 >
 > Collections:
 > (("/Users/eric/Library/Racket/5.0.2/collects" non-existent-path) ("/Appli=
 cations/Racket v5.0.2/collects" "2htdp" "afm" "algol60" "at-exp" "browser" =
 "combinator-parser" "compiler" "config" "data" "datalog" "defaults" "deinpr=
 ogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "=
 ffi" "file" "framework" "frtime" "games" "graphics" "gui-debugger" "help" "=
 hierlist" "htdp" "html" "icons" "info-domain" "lang" "launcher" "lazy" "mac=
 ro-debugger" "make" "mred" "mrlib" "mysterx" "mzcom" "mzlib" "mzscheme" "ne=
 t" "openssl" "parser-tools" "plai" "planet" "plot" "preprocessor" "profile"=
  "r5rs" "r6rs" "racket" "racklog" "rackunit" "raco" "reader" "readline" "re=
 dex" "rnrs" "s-exp" "scheme" "schemeunit" "scribble" "scribblings" "scribli=
 b" "setup" "sgl" "slatex" "slideshow" "srfi" "stepper" "string-constants" "=
 swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engi=
 ne" "tex2page" "texpict" "trace" "typed" "typed-scheme" "unstable" "version=
 " "web-server" "!
 > =C2=A0wxme" "xml"))
 > Computer Language: (("Determine language from source") (#(#t print mixed-=
 fraction-e #f #t debug) (default) #() "#lang racket\n" #t))
 >
 >
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: endobson@cs.brown.edu, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/11630: Error escape handler can kill process
Date: Sun, 16 Jan 2011 16:44:19 -0500

 I think the thread that was running should at least die, and =
 interactions be disabled. The following program shows that the repl =
 thread doesn't die, while another thread does.=20
 
 #lang racket
 
 
 (define (buggy)
   (parameterize ((error-escape-handler (lambda () (printf "bad escape =
 handler~n") 'return)))
     (call-with-exception-handler (lambda (x) (raise 'again))
                                  (lambda () (raise 'original)))))
 
 (define original-thread (current-thread))
 (define second-thread (thread buggy))
                       =20
                       =20
 (define (loop)
   (printf "status orig: ~a ~n" (thread-dead? original-thread))
   (printf "status second: ~a ~n" (thread-dead? second-thread))
   (sleep 1)
   (loop))
 
 (thread loop)
 
 (buggy)
 
 -Eric
 
 On Jan 16, 2011, at 4:31 PM, Robby Findler wrote:
 
 > What do you propose should happen?
 >=20
 > Robby
 >=20
 > On Sun, Jan 16, 2011 at 3:24 PM,  <endobson@cs.brown.edu> wrote:
 >> A new problem report is waiting at
 >>  http://bugs.racket-lang.org/query/?cmd=3Dview&pr=3D11630
 >>=20
 >> Reported by Eric Dobson for release: 5.0.2
 >>=20
 >> *** Description:
 >> If an error escape handler returns, bad things happen. In DrRacket it =
 hangs the interactions window and in racket it exits the process.
 >>=20
 >> *** How to repeat:
 >> In the repl enter
 >>=20
 >>=20
 >> (parameterize ((error-escape-handler (lambda () (printf "bad escape =
 handler~n") 'return)))
 >>  (call-with-exception-handler (lambda (x) (raise 'again))
 >>                               (lambda () (raise 'original))))
 >>=20
 >> *** Environment:
 >> macosx "Darwin eric-dobsons-macbook.local 10.6.0 Darwin Kernel =
 Version 10.6.0: Wed Nov 10 18:13:17 PST 2010; =
 root:xnu-1504.9.26~3/RELEASE_I386 i386 i386" (i386-macosx/3m) =
 (get-display-depth) =3D 32
 >> Human Language: english
 >> (current-memory-use) 165105440
 >>=20
 >> Collections:
 >> (("/Users/eric/Library/Racket/5.0.2/collects" non-existent-path) =
 ("/Applications/Racket v5.0.2/collects" "2htdp" "afm" "algol60" "at-exp" =
 "browser" "combinator-parser" "compiler" "config" "data" "datalog" =
 "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" =
 "eopl" "errortrace" "ffi" "file" "framework" "frtime" "games" "graphics" =
 "gui-debugger" "help" "hierlist" "htdp" "html" "icons" "info-domain" =
 "lang" "launcher" "lazy" "macro-debugger" "make" "mred" "mrlib" =
 "mysterx" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" =
 "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" =
 "racklog" "rackunit" "raco" "reader" "readline" "redex" "rnrs" "s-exp" =
 "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" =
 "slatex" "slideshow" "srfi" "stepper" "string-constants" "swindle" =
 "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engine" =
 "tex2page" "texpict" "trace" "typed" "typed-scheme" "unstable" "version" =
 "web-server" "!
 >>  wxme" "xml"))
 >> Computer Language: (("Determine language from source") (#(#t print =
 mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t))
 >>=20
 >>=20
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: endobson@cs.brown.edu, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/11630: Error escape handler can kill process
Date: Sun, 16 Jan 2011 17:14:34 -0600

 I like the spirit of this test! But, I think that the current behavior
 actually matches what you're seeing. Let me explain.
 
 One subtlety is that the thread doing repl evaluations in drracket is
 defined to be an eventspace-handler-thread, not a thread created by
 'thread' (one created by 'make-eventspace', that is). So, if I extend
 your test to test that, I see the same behavior in drracket's repl
 thread and another eventspace main thread.
 
 Also, when I run (kill-thread (current-thread)) in the racket REPL, it
 exits the process, which also seems consistent with your test.
 
 Robby
 
 #lang racket/gui
 
 (define (buggy)
   (parameterize ((error-escape-handler (lambda () (printf "bad escape
 handler~n") 'return)))
     (call-with-exception-handler (lambda (x) (raise 'again))
                                  (lambda () (raise 'original)))))
 
 (define original-thread (current-thread))
 (define second-thread (thread buggy))
 
 (define evt-space (make-eventspace))
 (define third-thread (eventspace-handler-thread evt-space))
 
 (parameterize ([current-eventspace evt-space])
   (queue-callback buggy))
 
 (define (loop)
   (printf "status orig:   ~a \n" (thread-dead? original-thread))
   (printf "status second: ~a \n" (thread-dead? second-thread))
   (printf "status third:  ~a \n\n" (thread-dead? third-thread))
   (sleep 1)
   (loop))
 
 (thread loop)
 
 (buggy)
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: endobson@cs.brown.edu, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/11630: Error escape handler can kill process
Date: Sun, 16 Jan 2011 17:21:15 -0600

 One other thought I had to beef up your test. If you create a frame like th=
 is:
 
 (define f (new (class frame%
                  (define/override (on-size w h)
                    (printf "resized to ~sx~s\n" w h))
                  (super-new [label ""]
                             [width 100]
                             [height 100]))))
 (send f show #t)
 
 
 and then run buggy (in the drracket repl), events are still being
 handled in the frame, which also matches the behavior in a new
 eventspace.
 
 That said, I think that probably we don't really have any evidence
 that the drracket REPL *has* to get stuck ....
 
 Robby
 
 On Sun, Jan 16, 2011 at 5:14 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > I like the spirit of this test! But, I think that the current behavior
 > actually matches what you're seeing. Let me explain.
 >
 > One subtlety is that the thread doing repl evaluations in drracket is
 > defined to be an eventspace-handler-thread, not a thread created by
 > 'thread' (one created by 'make-eventspace', that is). So, if I extend
 > your test to test that, I see the same behavior in drracket's repl
 > thread and another eventspace main thread.
 >
 > Also, when I run (kill-thread (current-thread)) in the racket REPL, it
 > exits the process, which also seems consistent with your test.
 >
 > Robby
 >
 > #lang racket/gui
 >
 > (define (buggy)
 > =C2=A0(parameterize ((error-escape-handler (lambda () (printf "bad escape
 > handler~n") 'return)))
 > =C2=A0 =C2=A0(call-with-exception-handler (lambda (x) (raise 'again))
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (lambda () (raise 'original)))))
 >
 > (define original-thread (current-thread))
 > (define second-thread (thread buggy))
 >
 > (define evt-space (make-eventspace))
 > (define third-thread (eventspace-handler-thread evt-space))
 >
 > (parameterize ([current-eventspace evt-space])
 > =C2=A0(queue-callback buggy))
 >
 > (define (loop)
 > =C2=A0(printf "status orig: =C2=A0 ~a \n" (thread-dead? original-thread))
 > =C2=A0(printf "status second: ~a \n" (thread-dead? second-thread))
 > =C2=A0(printf "status third: =C2=A0~a \n\n" (thread-dead? third-thread))
 > =C2=A0(sleep 1)
 > =C2=A0(loop))
 >
 > (thread loop)
 >
 > (buggy)
 >
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: endobson@cs.brown.edu, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/11630: Error escape handler can kill process
Date: Sun, 16 Jan 2011 18:59:17 -0500

 Ok looking at the GUI system, it seems that all calls are wrapped in a =
 dynamic wind that prevents escapes by turning them in to void returns to =
 the event loop.
 
 This program implements the behavior that I believe the =
 eventspace-handler-threads have, because the repl continues functioning =
 after the escape.
 
 #lang racket
 
 
 (define (buggy)
   (with-continuation-mark 'key 'value
     (parameterize ((error-escape-handler
                     (lambda ()
                       (printf "bad escape handler~n")
                      ; (raise 'bad)
                       'return)))
       (call-with-exception-handler (lambda (x) (raise 'again))
                                    (lambda () (raise 'original))))))
 
 (let/cc esc
   (dynamic-wind
    (lambda () (printf "before~n"))
    (lambda () (call-with-continuation-prompt
                buggy
                (default-continuation-prompt-tag)
                (lambda () (printf "abort~n") 'abort)))
    (lambda () (printf "after~n") (esc 'escaping))))
 =20
  So my question is now, what is the target of this escape? The normal =
 error-escape-handler aborts to a prompt tagged with the =
 default-continuation-prompt-tag. This program shows that this behavior =
 is not what is happening, it is somehow skipping this.=20
 
 -Eric
 
 
 On Jan 16, 2011, at 6:21 PM, Robby Findler wrote:
 
 > One other thought I had to beef up your test. If you create a frame =
 like this:
 >=20
 > (define f (new (class frame%
 >                 (define/override (on-size w h)
 >                   (printf "resized to ~sx~s\n" w h))
 >                 (super-new [label ""]
 >                            [width 100]
 >                            [height 100]))))
 > (send f show #t)
 >=20
 >=20
 > and then run buggy (in the drracket repl), events are still being
 > handled in the frame, which also matches the behavior in a new
 > eventspace.
 >=20
 > That said, I think that probably we don't really have any evidence
 > that the drracket REPL *has* to get stuck ....
 >=20
 > Robby
 >=20
 > On Sun, Jan 16, 2011 at 5:14 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> I like the spirit of this test! But, I think that the current =
 behavior
 >> actually matches what you're seeing. Let me explain.
 >>=20
 >> One subtlety is that the thread doing repl evaluations in drracket is
 >> defined to be an eventspace-handler-thread, not a thread created by
 >> 'thread' (one created by 'make-eventspace', that is). So, if I extend
 >> your test to test that, I see the same behavior in drracket's repl
 >> thread and another eventspace main thread.
 >>=20
 >> Also, when I run (kill-thread (current-thread)) in the racket REPL, =
 it
 >> exits the process, which also seems consistent with your test.
 >>=20
 >> Robby
 >>=20
 >> #lang racket/gui
 >>=20
 >> (define (buggy)
 >>  (parameterize ((error-escape-handler (lambda () (printf "bad escape
 >> handler~n") 'return)))
 >>    (call-with-exception-handler (lambda (x) (raise 'again))
 >>                                 (lambda () (raise 'original)))))
 >>=20
 >> (define original-thread (current-thread))
 >> (define second-thread (thread buggy))
 >>=20
 >> (define evt-space (make-eventspace))
 >> (define third-thread (eventspace-handler-thread evt-space))
 >>=20
 >> (parameterize ([current-eventspace evt-space])
 >>  (queue-callback buggy))
 >>=20
 >> (define (loop)
 >>  (printf "status orig:   ~a \n" (thread-dead? original-thread))
 >>  (printf "status second: ~a \n" (thread-dead? second-thread))
 >>  (printf "status third:  ~a \n\n" (thread-dead? third-thread))
 >>  (sleep 1)
 >>  (loop))
 >>=20
 >> (thread loop)
 >>=20
 >> (buggy)
 >>=20
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: endobson@cs.brown.edu, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/11630: Error escape handler can kill process
Date: Tue, 18 Jan 2011 14:26:33 -0600

 I'm not super clear on what you're getting at below (more comments
 below), but the behavior of this program seems wrong:
 
 -------
 #lang racket
 (define (buggy)
   (with-continuation-mark 'key 'value
     (parameterize ((error-escape-handler
                     (lambda ()
                       'return)))
       (raise 'again))))
 (list (call-with-continuation-prompt
        buggy
        (default-continuation-prompt-tag)
        (lambda x (printf "abort\n") 'abort)))
 -------
 
 I would have expected it to print "abort" but it doesn't. The program
 notices that the error-escape-handler doesn't escape and then claims
 to be calling the default one, which should invoke the abort-printing
 handler, but that doesn't seem to happen.
 
 This looks like the abort is happening via a setjmp in
 src/racket/src/error.c, but I didn't try to figure out where that
 goes.
 
 
 On Sun, Jan 16, 2011 at 5:59 PM, Eric Dobson <eric.n.dobson@gmail.com> wrot=
 e:
 > Ok looking at the GUI system, it seems that all calls are wrapped in a dy=
 namic wind that prevents escapes by turning them in to void returns to the =
 event loop.
 >
 > This program implements the behavior that I believe the eventspace-handle=
 r-threads have, because the repl continues functioning after the escape.
 
 I'm not seeing the connection to eventspace handler threads.
 
 FWIW, they listen to some connection to the GUI and then run event
 callbacks. The REPL (in drracket) is implemented by creating one of
 those and running a callback that either calls 'yield' (to get such
 events in) or by pulling thunks off of an internal queue that end up
 evaluating the text at a REPL prompt.
 
 > #lang racket
 >
 >
 > (define (buggy)
 > =C2=A0(with-continuation-mark 'key 'value
 > =C2=A0 =C2=A0(parameterize ((error-escape-handler
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(lam=
 bda ()
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0(printf "bad escape handler~n")
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ; (=
 raise 'bad)
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0'return)))
 > =C2=A0 =C2=A0 =C2=A0(call-with-exception-handler (lambda (x) (raise 'agai=
 n))
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (lambda () (raise 'original))=
 ))))
 >
 > (let/cc esc
 > =C2=A0(dynamic-wind
 > =C2=A0 (lambda () (printf "before~n"))
 > =C2=A0 (lambda () (call-with-continuation-prompt
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 buggy
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (default-continuation-pr=
 ompt-tag)
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (lambda () (printf "abor=
 t~n") 'abort)))
 > =C2=A0 (lambda () (printf "after~n") (esc 'escaping))))
 >
 > =C2=A0So my question is now, what is the target of this escape? The norma=
 l error-escape-handler aborts to a prompt tagged with the default-continuat=
 ion-prompt-tag. This program shows that this behavior is not what is happen=
 ing, it is somehow skipping this.
 
 This doesn't seem to be a counter example to the documented behavior
 of the default error-escape-handler, since the default-error-escape
 handler doesn't seem to be being invoked in this program. The only
 error-escape-handler that is invoked seems to be the one you've
 written there in the parameterize.
 
 The printout says that it is invoking the default one, but as I noted
 above, I don't think that it really is (and whether it should or not
 is unclear to me -- in any case you've written a buggy
 error-escape-handler and that's not a good thing to do).
 
 Robby
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: endobson@cs.brown.edu, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/11630: Error escape handler can kill process
Date: Tue, 18 Jan 2011 16:05:23 -0500

 --Apple-Mail-12--750056141
 Content-Transfer-Encoding: quoted-printable
 Content-Type: text/plain;
 	charset=us-ascii
 
 The real point of this bug report I feel is to figure out what the =
 correct behavior is when the error-escape-handler returns, and to have =
 it documented.
 
 The current behavior as I conceptualize it is an abort to a prompt at =
 the beginning of the thread's continuation, which if it succeeds =
 terminates the thread. This does not happen in an =
 eventspace-handler-thread, because the abort is cancelled by a =
 continuation jump during the post thunk of a dynamic wind. I think all =
 of the programs we have constructed are consistent with this. The =
 program I sent in my last message was to show the differences between =
 the threads we had seen was this dynamic wind post thunk.
 
 I don't think that this is the desired behavior, I think that the =
 default error-escape-handler should be invoked if the current =
 error-escape-handler returns, and the current behavior is an artifact of =
 the implementation.
 
 With regards to your program, I don't see where it claims to call the =
 default error-escape-handler. It calls the default =
 uncaught-exception-handler which then calls the current =
 error-escape-handler which then returns, thus there is no abort to your =
 prompt.
 
 -Eric
 
 
 On Jan 18, 2011, at 3:26 PM, Robby Findler wrote:
 
 > I'm not super clear on what you're getting at below (more comments
 > below), but the behavior of this program seems wrong:
 >=20
 > -------
 > #lang racket
 > (define (buggy)
 >  (with-continuation-mark 'key 'value
 >    (parameterize ((error-escape-handler
 >                    (lambda ()
 >                      'return)))
 >      (raise 'again))))
 > (list (call-with-continuation-prompt
 >       buggy
 >       (default-continuation-prompt-tag)
 >       (lambda x (printf "abort\n") 'abort)))
 > -------
 >=20
 > I would have expected it to print "abort" but it doesn't. The program
 > notices that the error-escape-handler doesn't escape and then claims
 > to be calling the default one, which should invoke the abort-printing
 > handler, but that doesn't seem to happen.
 >=20
 > This looks like the abort is happening via a setjmp in
 > src/racket/src/error.c, but I didn't try to figure out where that
 > goes.
 >=20
 >=20
 > On Sun, Jan 16, 2011 at 5:59 PM, Eric Dobson <eric.n.dobson@gmail.com> =
 wrote:
 >> Ok looking at the GUI system, it seems that all calls are wrapped in =
 a dynamic wind that prevents escapes by turning them in to void returns =
 to the event loop.
 >>=20
 >> This program implements the behavior that I believe the =
 eventspace-handler-threads have, because the repl continues functioning =
 after the escape.
 >=20
 > I'm not seeing the connection to eventspace handler threads.
 >=20
 > FWIW, they listen to some connection to the GUI and then run event
 > callbacks. The REPL (in drracket) is implemented by creating one of
 > those and running a callback that either calls 'yield' (to get such
 > events in) or by pulling thunks off of an internal queue that end up
 > evaluating the text at a REPL prompt.
 >=20
 >> #lang racket
 >>=20
 >>=20
 >> (define (buggy)
 >>  (with-continuation-mark 'key 'value
 >>    (parameterize ((error-escape-handler
 >>                    (lambda ()
 >>                      (printf "bad escape handler~n")
 >>                     ; (raise 'bad)
 >>                      'return)))
 >>      (call-with-exception-handler (lambda (x) (raise 'again))
 >>                                   (lambda () (raise 'original))))))
 >>=20
 >> (let/cc esc
 >>  (dynamic-wind
 >>   (lambda () (printf "before~n"))
 >>   (lambda () (call-with-continuation-prompt
 >>               buggy
 >>               (default-continuation-prompt-tag)
 >>               (lambda () (printf "abort~n") 'abort)))
 >>   (lambda () (printf "after~n") (esc 'escaping))))
 >>=20
 >>  So my question is now, what is the target of this escape? The normal =
 error-escape-handler aborts to a prompt tagged with the =
 default-continuation-prompt-tag. This program shows that this behavior =
 is not what is happening, it is somehow skipping this.
 >=20
 > This doesn't seem to be a counter example to the documented behavior
 > of the default error-escape-handler, since the default-error-escape
 > handler doesn't seem to be being invoked in this program. The only
 > error-escape-handler that is invoked seems to be the one you've
 > written there in the parameterize.
 >=20
 > The printout says that it is invoking the default one, but as I noted
 > above, I don't think that it really is (and whether it should or not
 > is unclear to me -- in any case you've written a buggy
 > error-escape-handler and that's not a good thing to do).
 >=20
 > Robby
 
 
 --Apple-Mail-12--750056141
 Content-Transfer-Encoding: quoted-printable
 Content-Type: text/html;
 	charset=us-ascii
 
 <html><head></head><body style=3D"word-wrap: break-word; =
 -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; =
 "><div>The real point of this bug report I feel is to figure out what =
 the correct behavior is when the error-escape-handler returns, and to =
 have it documented.</div><div><br></div><div>The current behavior as I =
 conceptualize it is an abort to a prompt at the beginning of the =
 thread's continuation, which if it succeeds terminates the thread. This =
 does not happen in an eventspace-handler-thread, because the abort is =
 cancelled by a continuation jump during the post thunk of a dynamic =
 wind. I think all of the programs we have constructed are consistent =
 with this. The program I sent in my last message was to show the =
 differences between the threads we had seen was this dynamic wind post =
 thunk.</div><div><br></div><div>I don't think that this is the desired =
 behavior, I think that the default error-escape-handler should be =
 invoked if the current error-escape-handler returns, and the current =
 behavior is an artifact of the =
 implementation.</div><div><br></div><div>With regards to your program, I =
 don't see where it claims to call the default error-escape-handler. It =
 calls the default uncaught-exception-handler which then calls the =
 current error-escape-handler which then returns, thus there is no abort =
 to your =
 prompt.</div><div><br></div><div>-Eric</div><div><br></div><br><div><div>O=
 n Jan 18, 2011, at 3:26 PM, Robby Findler wrote:</div><br =
 class=3D"Apple-interchange-newline"><blockquote type=3D"cite"><div>I'm =
 not super clear on what you're getting at below (more =
 comments<br>below), but the behavior of this program seems =
 wrong:<br><font class=3D"Apple-style-span" color=3D"#000000"><font =
 class=3D"Apple-style-span" =
 color=3D"#144FAE"><br></font></font></div></blockquote><blockquote =
 type=3D"cite"><div>-------<br>#lang racket<br>(define (buggy)<br> =
 &nbsp;(with-continuation-mark 'key 'value<br> =
 &nbsp;&nbsp;&nbsp;(parameterize ((error-escape-handler<br> =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
 bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda ()<br> =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
 bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'return)))<br> =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(raise 'again))))<br>(list =
 (call-with-continuation-prompt<br> =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buggy<br> =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(default-continuation-prompt-tag)<br> =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda x (printf "abort\n") =
 'abort)))<br>-------<br><br>I would have expected it to print "abort" =
 but it doesn't. The program<br>notices that the error-escape-handler =
 doesn't escape and then claims<br>to be calling the default one, which =
 should invoke the abort-printing<br>handler, but that doesn't seem to =
 happen.<br><br>This looks like the abort is happening via a setjmp =
 in<br>src/racket/src/error.c, but I didn't try to figure out where =
 that<br>goes.<br><br><br>On Sun, Jan 16, 2011 at 5:59 PM, Eric Dobson =
 &lt;<a =
 href=3D"mailto:eric.n.dobson@gmail.com">eric.n.dobson@gmail.com</a>&gt; =
 wrote:<br><blockquote type=3D"cite">Ok looking at the GUI system, it =
 seems that all calls are wrapped in a dynamic wind that prevents escapes =
 by turning them in to void returns to the event =
 loop.<br></blockquote><blockquote =
 type=3D"cite"><br></blockquote><blockquote type=3D"cite">This program =
 implements the behavior that I believe the eventspace-handler-threads =
 have, because the repl continues functioning after the =
 escape.<br></blockquote><br>I'm not seeing the connection to eventspace =
 handler threads.<br><br>FWIW, they listen to some connection to the GUI =
 and then run event<br>callbacks. The REPL (in drracket) is implemented =
 by creating one of<br>those and running a callback that either calls =
 'yield' (to get such<br>events in) or by pulling thunks off of an =
 internal queue that end up<br>evaluating the text at a REPL =
 prompt.<br><br><blockquote type=3D"cite">#lang =
 racket<br></blockquote><blockquote =
 type=3D"cite"><br></blockquote><blockquote =
 type=3D"cite"><br></blockquote><blockquote type=3D"cite">(define =
 (buggy)<br></blockquote><blockquote =
 type=3D"cite">&nbsp;(with-continuation-mark 'key =
 'value<br></blockquote><blockquote type=3D"cite">&nbsp; =
 &nbsp;(parameterize ((error-escape-handler<br></blockquote><blockquote =
 type=3D"cite">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
 &nbsp; &nbsp;(lambda ()<br></blockquote><blockquote type=3D"cite">&nbsp; =
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
 &nbsp;(printf "bad escape handler~n")<br></blockquote><blockquote =
 type=3D"cite">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
 &nbsp; &nbsp; ; (raise 'bad)<br></blockquote><blockquote =
 type=3D"cite">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
 &nbsp; &nbsp; &nbsp;'return)))<br></blockquote><blockquote =
 type=3D"cite">&nbsp; &nbsp; &nbsp;(call-with-exception-handler (lambda =
 (x) (raise 'again))<br></blockquote><blockquote type=3D"cite">&nbsp; =
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda () (raise =
 'original))))))<br></blockquote><blockquote =
 type=3D"cite"><br></blockquote><blockquote type=3D"cite">(let/cc =
 esc<br></blockquote><blockquote =
 type=3D"cite">&nbsp;(dynamic-wind<br></blockquote><blockquote =
 type=3D"cite">&nbsp; (lambda () (printf =
 "before~n"))<br></blockquote><blockquote type=3D"cite">&nbsp; (lambda () =
 (call-with-continuation-prompt<br></blockquote><blockquote =
 type=3D"cite">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
 buggy<br></blockquote><blockquote type=3D"cite">&nbsp; &nbsp; &nbsp; =
 &nbsp; &nbsp; &nbsp; &nbsp; =
 (default-continuation-prompt-tag)<br></blockquote><blockquote =
 type=3D"cite">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda =
 () (printf "abort~n") 'abort)))<br></blockquote><blockquote =
 type=3D"cite">&nbsp; (lambda () (printf "after~n") (esc =
 'escaping))))<br></blockquote><blockquote =
 type=3D"cite"><br></blockquote><blockquote type=3D"cite">&nbsp;So my =
 question is now, what is the target of this escape? The normal =
 error-escape-handler aborts to a prompt tagged with the =
 default-continuation-prompt-tag. This program shows that this behavior =
 is not what is happening, it is somehow skipping =
 this.<br></blockquote><br>This doesn't seem to be a counter example to =
 the documented behavior<br>of the default error-escape-handler, since =
 the default-error-escape<br>handler doesn't seem to be being invoked in =
 this program. The only<br>error-escape-handler that is invoked seems to =
 be the one you've<br>written there in the parameterize.<br><br>The =
 printout says that it is invoking the default one, but as I =
 noted<br>above, I don't think that it really is (and whether it should =
 or not<br>is unclear to me -- in any case you've written a =
 buggy<br>error-escape-handler and that's not a good thing to =
 do).<br><br>Robby<br></div></blockquote></div><br></body></html>=
 
 --Apple-Mail-12--750056141--
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: endobson@cs.brown.edu, bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/11630: Error escape handler can kill process
Date: Tue, 18 Jan 2011 15:18:50 -0600

 On Tue, Jan 18, 2011 at 3:05 PM, Eric Dobson <eric.n.dobson@gmail.com> wrot=
 e:
 > The real point of this bug report I feel is to figure out what the correc=
 t
 > behavior is when the error-escape-handler returns, and to have it
 > documented.
 > The current behavior as I conceptualize it is an abort to a prompt at the
 > beginning of the thread's continuation, which if it succeeds terminates t=
 he
 > thread. This does not happen in an eventspace-handler-thread, because the
 > abort is cancelled by a continuation jump during the post thunk of a dyna=
 mic
 > wind. I think all of the programs we have constructed are consistent with
 > this. The program I sent in my last message was to show the differences
 > between the threads we had seen was this dynamic wind post thunk.
 > I don't think that this is the desired behavior, I think that the default
 > error-escape-handler should be invoked if the current error-escape-handle=
 r
 > returns, and the current behavior is an artifact of the implementation.
 
 Thank you for this clarification. I think that I'll have to now leave
 this to Matthew.
 
 > With regards to your program, I don't see where it claims to call the
 > default error-escape-handler. It calls the default
 > uncaught-exception-handler which then calls the current error-escape-hand=
 ler
 > which then returns, thus there is no abort to your prompt.
 
 Well, from what I can tell, 'raise' invokes the error-escape-handler
 which then returns back to 'raise'. Raise notices this, complains, and
 then claims that it invokes the default error-escape-handler (this
 claim comes in the form of a printout to the original processes
 stderr, so you might not see it under mac os x unless you start
 drracket from a terminal window), but it isn't clear that it is really
 invoking that default error-escape-handler; instead I think it is
 doing what the default error-escape-handler used to do before we had
 prompts.
 
 Robby
 
 > -Eric
 >
 > On Jan 18, 2011, at 3:26 PM, Robby Findler wrote:
 >
 > I'm not super clear on what you're getting at below (more comments
 > below), but the behavior of this program seems wrong:
 >
 > -------
 > #lang racket
 > (define (buggy)
 > =C2=A0(with-continuation-mark 'key 'value
 > =C2=A0=C2=A0=C2=A0(parameterize ((error-escape-handler
 > =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
 =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0(lambda ()
 > =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
 =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0'return)))
 > =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0(raise 'again))))
 > (list (call-with-continuation-prompt
 > =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0buggy
 > =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0(default-continuation-prompt-tag)
 > =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0(lambda x (printf "abort\n") 'abort))=
 )
 > -------
 >
 > I would have expected it to print "abort" but it doesn't. The program
 > notices that the error-escape-handler doesn't escape and then claims
 > to be calling the default one, which should invoke the abort-printing
 > handler, but that doesn't seem to happen.
 >
 > This looks like the abort is happening via a setjmp in
 > src/racket/src/error.c, but I didn't try to figure out where that
 > goes.
 >
 >
 > On Sun, Jan 16, 2011 at 5:59 PM, Eric Dobson <eric.n.dobson@gmail.com>
 > wrote:
 >
 > Ok looking at the GUI system, it seems that all calls are wrapped in a
 > dynamic wind that prevents escapes by turning them in to void returns to =
 the
 > event loop.
 >
 > This program implements the behavior that I believe the
 > eventspace-handler-threads have, because the repl continues functioning
 > after the escape.
 >
 > I'm not seeing the connection to eventspace handler threads.
 >
 > FWIW, they listen to some connection to the GUI and then run event
 > callbacks. The REPL (in drracket) is implemented by creating one of
 > those and running a callback that either calls 'yield' (to get such
 > events in) or by pulling thunks off of an internal queue that end up
 > evaluating the text at a REPL prompt.
 >
 > #lang racket
 >
 >
 > (define (buggy)
 >
 > =C2=A0(with-continuation-mark 'key 'value
 >
 > =C2=A0 =C2=A0(parameterize ((error-escape-handler
 >
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0(lam=
 bda ()
 >
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0(printf "bad escape handler~n")
 >
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 ; (=
 raise 'bad)
 >
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0'return)))
 >
 > =C2=A0 =C2=A0 =C2=A0(call-with-exception-handler (lambda (x) (raise 'agai=
 n))
 >
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
 =A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (lambda () (raise 'original))=
 ))))
 >
 > (let/cc esc
 >
 > =C2=A0(dynamic-wind
 >
 > =C2=A0 (lambda () (printf "before~n"))
 >
 > =C2=A0 (lambda () (call-with-continuation-prompt
 >
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 buggy
 >
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (default-continuation-pr=
 ompt-tag)
 >
 > =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 (lambda () (printf "abor=
 t~n") 'abort)))
 >
 > =C2=A0 (lambda () (printf "after~n") (esc 'escaping))))
 >
 > =C2=A0So my question is now, what is the target of this escape? The norma=
 l
 > error-escape-handler aborts to a prompt tagged with the
 > default-continuation-prompt-tag. This program shows that this behavior is
 > not what is happening, it is somehow skipping this.
 >
 > This doesn't seem to be a counter example to the documented behavior
 > of the default error-escape-handler, since the default-error-escape
 > handler doesn't seem to be being invoked in this program. The only
 > error-escape-handler that is invoked seems to be the one you've
 > written there in the parameterize.
 >
 > The printout says that it is invoking the default one, but as I noted
 > above, I don't think that it really is (and whether it should or not
 > is unclear to me -- in any case you've written a buggy
 > error-escape-handler and that's not a good thing to do).
 >
 > Robby
 >
 >

Responsible changed from "robby" to "mflatt" by mflatt@racket-lang.org at Thu, 20 Jan 2011 16:22:49 -0500
Reason>>> A commit by mflatt@racket-lang.org has resolved this report
  http://git.racket-lang.org/plt/commit/0c193a599a
State changed from "open" to "closed" by mflatt@racket-lang.org at Thu, 20 Jan 2011 16:22:49 -0500
Reason>>> A commit by mflatt@racket-lang.org has resolved this report
  http://git.racket-lang.org/plt/commit/0c193a599a
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, endobson@cs.brown.edu,
        bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/11630: Error escape handler can kill process
Date: Thu, 20 Jan 2011 14:03:54 -0700

 At Tue, 18 Jan 2011 15:18:50 -0600, Robby Findler wrote:
 > Well, from what I can tell, 'raise' invokes the error-escape-handler
 > which then returns back to 'raise'. Raise notices this, complains, and
 > then claims that it invokes the default error-escape-handler (this
 > claim comes in the form of a printout to the original processes
 > stderr, so you might not see it under mac os x unless you start
 > drracket from a terminal window), but it isn't clear that it is really
 > invoking that default error-escape-handler; instead I think it is
 > doing what the default error-escape-handler used to do before we had
 > prompts.
 
 Yep. I'm fixing that and documented the default uncaught exception
 handler's use of the default error escape handler when the current one
 doesn't escape.
 
 Also, I'm changing the emergency error display handler (used when the
 default error display handler fails) to log an error instead of writing
 to the console.
 
