From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Sun Apr 11 16:21:05 2010
Received: from mail-gw0-f44.google.com (mail-gw0-f44.google.com [74.125.83.44])
	by champlain.ccs.neu.edu (8.14.3/8.14.3) with ESMTP id o3BKL3IY015201
	for <bugs@bugs.plt-scheme.org>; Sun, 11 Apr 2010 16:21:03 -0400
Message-Id: <201004112020.o3BKKvkr015193@champlain.ccs.neu.edu>
Date: Sun, 11 Apr 2010 16:20:57 -0400
From: cce@ccs.neu.edu
To: bugs@plt-scheme.org
Subject: regexp-replace* does strange things with the "^" pattern

>Number:         10855
>Category:       mzscheme
>Synopsis:       regexp-replace* does strange things with the "^" pattern
>Class:          sw-bug
>Responsible:    mflatt
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Sun Apr 11 16:24:01 -0400 2010
>Closed-Date:    Wed Apr 14 22:53:28 -0400 2010
>Last-Modified:  Thu Apr 15 11:32:01 -0400 2010
>Originator:     Carl Eastlund
>Organization:
plt
>Submitter-Id:   unknown
>Release:        4.2.5.8-svn11apr2010
>Environment:
macosx "Darwin Arkham.ccs.neu.edu 10.2.0 Darwin Kernel Version 10.2.0: Tue Nov  3 23:08:29 PST 2009; root:xnu-1486.2.11~3/RELEASE_I386 i386" (i386-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 206500852

Collections:
(("/Users/cce/svn/2010-04-11/dist/add-on/4.2.5.8/collects" non-existent-path) ("/Users/cce/svn/2010-04-11/dist/collects" ".svn" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compiler" "config" "defaults" "deinprogramm" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "games" "graphics" "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" "hierlist" "honu" "htdp" "html" "icons" "info-domain" "lang" "launcher" "lazy" "macro-debugger" "make" "meta" "mred" "mrlib" "mysterx" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "reader" "readline" "redex" "repos-time-stamp" "rico" "rnrs" "s-exp" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" "string-constants" "swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engine" "tests" "tex2!
 page" "texpict" "trace" "typed" "typed-scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml"))
Computer Language: (("Determine language from source") (#(#t write mixed-fraction-e #f #t debug) (default) #() "#lang scheme\n" #t))
>Description:
Instead of replacing the start of a string (or of a line in multi-mode), regexp-replace* replaces every position but the start and end of a string when given "^" as a pattern.
>How-To-Repeat:
> (regexp-replace* "^" "Scheme" "Racket")
"SRacketcRackethRacketeRacketmRackete"
>Fix:
>Audit-Trail:
From: Eli Barzilay <eli@barzilay.org>
To: cce@ccs.neu.edu, bugs@plt-scheme.org
Cc: bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the "^" pattern
Date: Sun, 11 Apr 2010 17:25:56 -0400

 On Apr 11, cce@ccs.neu.edu wrote:
 > *** Description:
 > Instead of replacing the start of a string (or of a line in
 > multi-mode), regexp-replace* replaces every position but the start
 > and end of a string when given "^" as a pattern.
 > 
 > *** How to repeat:
 > > (regexp-replace* "^" "Scheme" "Racket")
 > "SRacketcRackethRacketeRacketmRackete"
 
 It's a(n inconvenient) corollary of
 -> (regexp-match #rx"^x." "x1x2" 2)
 ("x2")
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Carl Eastlund <cce@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: bugs@plt-scheme.org, bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 17:31:07 -0400

 On Sun, Apr 11, 2010 at 5:25 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > On Apr 11, cce@ccs.neu.edu wrote:
 >> *** Description:
 >> Instead of replacing the start of a string (or of a line in
 >> multi-mode), regexp-replace* replaces every position but the start
 >> and end of a string when given "^" as a pattern.
 >>
 >> *** How to repeat:
 >> > (regexp-replace* "^" "Scheme" "Racket")
 >> "SRacketcRackethRacketeRacketmRackete"
 >
 > It's a(n inconvenient) corollary of
 > -> (regexp-match #rx"^x." "x1x2" 2)
 > ("x2")
 
 That sounds like a bug in the implementation; I don't see where
 regexp-replace* is specified in terms of regexp-match's start-pos
 argument.
 
 --Carl
From: Eli Barzilay <eli@barzilay.org>
To: Carl Eastlund <cce@ccs.neu.edu>
Cc: bugs@plt-scheme.org, bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 17:46:24 -0400

 On Apr 11, Carl Eastlund wrote:
 > On Sun, Apr 11, 2010 at 5:25 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > > On Apr 11, cce@ccs.neu.edu wrote:
 > >> *** Description:
 > >> Instead of replacing the start of a string (or of a line in
 > >> multi-mode), regexp-replace* replaces every position but the start
 > >> and end of a string when given "^" as a pattern.
 > >>
 > >> *** How to repeat:
 > >> > (regexp-replace* "^" "Scheme" "Racket")
 > >> "SRacketcRackethRacketeRacketmRackete"
 > >
 > > It's a(n inconvenient) corollary of
 > > -> (regexp-match #rx"^x." "x1x2" 2)
 > > ("x2")
 > 
 > That sounds like a bug in the implementation; I don't see where
 > regexp-replace* is specified in terms of regexp-match's start-pos
 > argument.
 
 It's specified in terms of "regexp matches" so it obeys the semantics
 of regexp patterns.  The "^" pattern is documented as "Match start",
 so it matches any point you start searching from.  This applies to all
 regexp functions, as in the above example, or:
 
   -> (regexp-match* #rx"^." "foo")
   ("f" "o" "o")
 
 It is particularly inconvenient with the family of the latter, since
 it makes "^" patterns useless.
 
 The best approximation for something more usable that I had is to
 define "^" and "$" as the beginning/end of the string being matched,
 but carrying this over to ports will make many uses of "^" for
 anchored searches broken.
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Carl Eastlund <cce@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: bugs@plt-scheme.org, bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 17:59:27 -0400

 On Sun, Apr 11, 2010 at 5:46 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > On Apr 11, Carl Eastlund wrote:
 >> On Sun, Apr 11, 2010 at 5:25 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> > On Apr 11, cce@ccs.neu.edu wrote:
 >> >> *** Description:
 >> >> Instead of replacing the start of a string (or of a line in
 >> >> multi-mode), regexp-replace* replaces every position but the start
 >> >> and end of a string when given "^" as a pattern.
 >> >>
 >> >> *** How to repeat:
 >> >> > (regexp-replace* "^" "Scheme" "Racket")
 >> >> "SRacketcRackethRacketeRacketmRackete"
 >> >
 >> > It's a(n inconvenient) corollary of
 >> > -> (regexp-match #rx"^x." "x1x2" 2)
 >> > ("x2")
 >>
 >> That sounds like a bug in the implementation; I don't see where
 >> regexp-replace* is specified in terms of regexp-match's start-pos
 >> argument.
 >
 > It's specified in terms of "regexp matches" so it obeys the semantics
 > of regexp patterns. =A0The "^" pattern is documented as "Match start",
 > so it matches any point you start searching from. =A0This applies to all
 > regexp functions, as in the above example, or:
 >
 > =A0-> (regexp-match* #rx"^." "foo")
 > =A0("f" "o" "o")
 >
 > It is particularly inconvenient with the family of the latter, since
 > it makes "^" patterns useless.
 >
 > The best approximation for something more usable that I had is to
 > define "^" and "$" as the beginning/end of the string being matched,
 > but carrying this over to ports will make many uses of "^" for
 > anchored searches broken.
 
 This still seems like an implementation-oriented interpretation of the
 documentation.  I didn't start matching from anywhere but the start of
 the string.  I matched against the whole string, and said "replace all
 occurrences".  It seems like regexp-match*'s and regexp-replace*'s
 problem if they decide to do that by recursively matching smaller
 parts of the input.  Our regexp machinery needs to keep better track
 of what "^" and "$" mean to the end user.
 
 --Carl
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Carl Eastlund <cce@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 16:30:29 -0600

 What do other regexp packages (e.g., Perl) do in this case?
 
From: Carl Eastlund <cce@ccs.neu.edu>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: Eli Barzilay <eli@barzilay.org>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 18:35:09 -0400

 On Sun, Apr 11, 2010 at 6:30 PM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > What do other regexp packages (e.g., Perl) do in this case?
 
 It does what I wanted (not what Scheme did).  Here's output of two
 runs, one in single-line mode and one in multi-line mode, with
 separators added to clarify where I was giving Perl input and where it
 was giving me output:
 
 [cce@Arkham:~] perl
 
 ----- START INPUT -----
 my $a = "Foo\nBar";
 $a =~ s/^/CARAT/g;
 print "$a\n";
 
 ----- START OUTPU -----
 CARATFoo
 Bar
 
 [cce@Arkham:~] perl
 
 ----- START INPUT -----
 my $a = "Foo\nBar";
 $a =~ s/^/CARAT/mg;
 print "$a\n";
 
 ----- START OUTPUT -----
 CARATFoo
 CARATBar
 
 
 --Carl
From: Eli Barzilay <eli@barzilay.org>
To: Matthew Flatt <mflatt@cs.utah.edu>, Carl Eastlund <cce@ccs.neu.edu>
Cc: bugs@plt-scheme.org, bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 20:09:02 -0400

 On Apr 11, Carl Eastlund wrote:
 > On Sun, Apr 11, 2010 at 5:46 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > > The best approximation for something more usable that I had is to
 > > define "^" and "$" as the beginning/end of the string being
 > > matched, but carrying this over to ports will make many uses of
 > > "^" for anchored searches broken.
 > 
 > This still seems like an implementation-oriented interpretation of
 > the documentation.
 
 The issue is specification -- what does "^" match.
 
 
 > I didn't start matching from anywhere but the start of the string.
 
 You did, by using `regexp-replace*'.
 
 
 > I matched against the whole string, and said "replace all
 > occurrences".  It seems like regexp-match*'s and regexp-replace*'s
 > problem if they decide to do that by recursively matching smaller
 > parts of the input.  Our regexp machinery needs to keep better track
 > of what "^" and "$" mean to the end user.
 
 Close -- what's missing is a specification for them that is not as
 surprising as what it currently does.
 
 
 On Apr 11, Matthew Flatt wrote:
 > What do other regexp packages (e.g., Perl) do in this case?
 
 I tried to get some sense from Perl and Emacs in the past.
 
 In Emacs there is no issue since there are no regexp operations on
 ports -- only on strings (or buffers, which is essentially the same).
 (And FWIW, Emacs has line-oriented "^" and "$", and "\\`" "\\'" for
 the beginning/end of the string/buffer).
 
 In Perl I don't remember whether it is possible to do regexp
 operations on a port, but just trying to make sense of it is asking
 for trouble.  The best example of this is the meaning of "^" in
 `split' (from http://perldoc.perl.org/functions/split.html):
 
   A PATTERN of /^/ is treated as if it were /^/m , since it isn't much
   use otherwise.
 
 So I think that there is no way to avoid coming up with an answer.
 
 The obvious thing of making "^" match only on the actual beginning of
 the string will break working on ports.  Trying to make it depend on
 strings (do it) and on ports (do what it does now) will break code
 that matches on strings that it reads from a file.
 
 My best guess for a way out is related to Carl's "keep better track":
 make "^" match what it does now except for recursive calls that are
 needed to implement a regexp operation -- or in other words, the
 "beginning of the match" which is what "^" is supposed to match on, is
 interpreted in relation to the topmost string operation.  Something
 like:
 
   (define (regexp-replace* rx str sub [start 0])
     (parameterize ([match-beginning (or (match-beginning) start)])
       ...work...))
 
 This means that `regexp-replace*' will do the reasonable thing, since
 the beginning will be only where it started working on rather than the
 nested matches.  It will also get rid of a considerable amount of hair
 in the * operations in "scheme/private/string.ss".  (The question is
 what to do with new user defined functions that want to do the same;
 perhaps there shouldn't be any besides the few known "primitives".)
 
 But in any case doing the above will make regexps considerabely slower
 (and they're expected to be fast).  There's probably a way to do that
 efficiently for `regexp-replace*' because it's in C, but that means
 moving the rest of them into C too.  (And I think that moving
 `regexp-replace*' out of C is a much better direction.)
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Carl Eastlund <cce@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 20:22:51 -0400

 On Sun, Apr 11, 2010 at 8:09 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > On Apr 11, Carl Eastlund wrote:
 >> On Sun, Apr 11, 2010 at 5:46 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> > The best approximation for something more usable that I had is to
 >> > define "^" and "$" as the beginning/end of the string being
 >> > matched, but carrying this over to ports will make many uses of
 >> > "^" for anchored searches broken.
 >>
 >> This still seems like an implementation-oriented interpretation of
 >> the documentation.
 >
 > The issue is specification -- what does "^" match.
 >
 >
 >> I didn't start matching from anywhere but the start of the string.
 >
 > You did, by using `regexp-replace*'.
 
 I guess I disagree with your interpretation of regexp-replace*, then.
 I take it as replacing every match of <pattern> in <input> -- not
 every match of <pattern> in every suffix or substring of <input>.  For
 each match, I still consider the regexp's input to be the full string.
 
 --Carl
From: Robby Findler <robby@eecs.northwestern.edu>
To: Carl Eastlund <cce@ccs.neu.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Matthew Flatt <mflatt@cs.utah.edu>,
        bugs@plt-scheme.org, bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 19:25:13 -0500

 That doesn't seem to be what you want; won't that either just always
 replace once or, if you do the matching after replacing, something
 strange?
 
 Robby
 
 On Sun, Apr 11, 2010 at 7:22 PM, Carl Eastlund <cce@ccs.neu.edu> wrote:
 > On Sun, Apr 11, 2010 at 8:09 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> On Apr 11, Carl Eastlund wrote:
 >>> On Sun, Apr 11, 2010 at 5:46 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >>> > The best approximation for something more usable that I had is to
 >>> > define "^" and "$" as the beginning/end of the string being
 >>> > matched, but carrying this over to ports will make many uses of
 >>> > "^" for anchored searches broken.
 >>>
 >>> This still seems like an implementation-oriented interpretation of
 >>> the documentation.
 >>
 >> The issue is specification -- what does "^" match.
 >>
 >>
 >>> I didn't start matching from anywhere but the start of the string.
 >>
 >> You did, by using `regexp-replace*'.
 >
 > I guess I disagree with your interpretation of regexp-replace*, then.
 > I take it as replacing every match of <pattern> in <input> -- not
 > every match of <pattern> in every suffix or substring of <input>. =C2=A0F=
 or
 > each match, I still consider the regexp's input to be the full string.
 >
 > --Carl
 >
From: Eli Barzilay <eli@barzilay.org>
To: Carl Eastlund <cce@ccs.neu.edu>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 20:37:39 -0400

 On Apr 11, Carl Eastlund wrote:
 > On Sun, Apr 11, 2010 at 8:09 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > >
 > > You did, by using `regexp-replace*'.
 > 
 > I guess I disagree with your interpretation of regexp-replace*,
 > then.  I take it as replacing every match of <pattern> in <input>
 > [...]
 
 (*sigh*.  If you *read* what I wrote later, it's an attempt to get
 exactly that.)
 
 
 On Apr 11, Eli Barzilay wrote:
 > [...]  But in any case doing the above will make regexps
 > considerabely slower (and they're expected to be fast).  [...]
 
 I should have mentioned the attempt to deal with this in the scheme
 functions -- there is a `no-empty-edge-matches' function which is
 trying to use a modified version of the input regexp that doesn't
 match on the edges.  The problem with that is that it does both sides,
 and that the code needs to manually track whether matching on the
 edges should be forbidden or not.
 
 So here's an alternative suggestion:
 
 * Drop `regexp-replace*' from the C code and add it to the Scheme
   code.  (Should be easy to implement it in scheme, and will probably
   the same speed.)
 
 * The only primitive functions that are left in C are the ones that do
   the matching work.
 
 * Add two arguments: `effective-start' and `effective-end' that
   determine where "^" and "$" are allowed to match.  The C side will
   use these instead of the given beginning/end.  (In the case of
   matching on ports the effective start can be negative, I think,
   which means that a "^" will never match.)
 
 * The scheme side passes along the initial begin/start values it
   receives for these values.
 
 Is this (turning `regexp-match' into a 2-7 argument function) going to
 lead to a considerable speed penalty?
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Eli Barzilay <eli@barzilay.org>
To: Matthew Flatt <mflatt@cs.utah.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Cc: 
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 20:47:32 -0400

 On Apr 11, Eli Barzilay wrote:
 > 
 > Is this (turning `regexp-match' into a 2-7 argument function) going
 > to lead to a considerable speed penalty?
 
 Actually, here's an alternative for two more arguments -- add a new
 type:
 
   (make-limited-regexp rx start end)
 
 where `rx' is a "raw" regexp.
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Carl Eastlund <cce@ccs.neu.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eli Barzilay <eli@barzilay.org>, Matthew Flatt <mflatt@cs.utah.edu>,
        bugs@plt-scheme.org, bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 20:56:35 -0400

 In mult-line mode, "^" also matches at newlines.
 
 Carl Eastlund
 
 On Sun, Apr 11, 2010 at 8:25 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > That doesn't seem to be what you want; won't that either just always
 > replace once or, if you do the matching after replacing, something
 > strange?
 >
 > Robby
From: Carl Eastlund <cce@ccs.neu.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 22:17:40 -0400

 On Sun, Apr 11, 2010 at 8:37 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > On Apr 11, Carl Eastlund wrote:
 >> On Sun, Apr 11, 2010 at 8:09 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> >
 >> > You did, by using `regexp-replace*'.
 >>
 >> I guess I disagree with your interpretation of regexp-replace*,
 >> then. =A0I take it as replacing every match of <pattern> in <input>
 >> [...]
 >
 > (*sigh*. =A0If you *read* what I wrote later, it's an attempt to get
 > exactly that.)
 
 I read it, but was confused by it, since it seemed the top part was
 saying regexp-replace* should consider each subsequent part as a new
 "start of match", and the bottom was trying to implement the opposite.
  I thought the best way to sort it out was to respond to the top part,
 since it was simpler, and see if I got it right.
 
 I didn't get it right, so now I see where you're going with it.
 Thanks for clarifying.
 
 --Carl
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Carl Eastlund <cce@ccs.neu.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 20:29:41 -0600

 At Sun, 11 Apr 2010 20:37:39 -0400, Eli Barzilay wrote:
 > * Add two arguments: `effective-start' and `effective-end' that
 >   determine where "^" and "$" are allowed to match.  The C side will
 >   use these instead of the given beginning/end.  (In the case of
 >   matching on ports the effective start can be negative, I think,
 >   which means that a "^" will never match.)
 
 Why not two booleans, which indicate whether the start and end match ^
 and $, respectively? That would avoid various checks/specifications on
 how the numbers must relate to other numbers, but maybe you have in
 mind some use for the generality.
 
 > Is this (turning `regexp-match' into a 2-7 argument function) going to
 > lead to a considerable speed penalty?
 
 No, that seems fine.
 
 
 One point I didn't quite follow: `regexp-match*' is currently defined
 to ignore empty matches at the start and end of the input; how are you
 planning to change that?
 
From: Eli Barzilay <eli@barzilay.org>
To: Carl Eastlund <cce@ccs.neu.edu>
Cc: Matthew Flatt <mflatt@cs.utah.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 22:28:23 -0400

 On Apr 11, Carl Eastlund wrote:
 > I read it, but was confused by it, since it seemed the top part was
 > saying regexp-replace* should consider each subsequent part as a new
 > "start of match", and the bottom was trying to implement the
 > opposite.  I thought the best way to sort it out was to respond to
 > the top part, since it was simpler, and see if I got it right.
 > 
 > I didn't get it right, so now I see where you're going with it.
 > Thanks for clarifying.
 
 (That's why I initially added "(inconvenient)" -- I know why it
 happens, but it *is* something that *really* bugged me in the past.
 The code that is currently in "scheme/private/string.ss" is a second
 rewrite where the main headaches are due to the current setup, and
 I've been through 2-3 rounds of trying to resolve it with Matthew.)
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Eli Barzilay <eli@barzilay.org>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: Carl Eastlund <cce@ccs.neu.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Sun, 11 Apr 2010 23:02:06 -0400

 On Apr 11, Matthew Flatt wrote:
 > At Sun, 11 Apr 2010 20:37:39 -0400, Eli Barzilay wrote:
 > > * Add two arguments: `effective-start' and `effective-end' that
 > >   determine where "^" and "$" are allowed to match.  The C side
 > >   will use these instead of the given beginning/end.  (In the case
 > >   of matching on ports the effective start can be negative, I
 > >   think, which means that a "^" will never match.)
 > 
 > Why not two booleans, which indicate whether the start and end match
 > ^ and $, respectively?  That would avoid various
 > checks/specifications on how the numbers must relate to other
 > numbers, but maybe you have in mind some use for the generality.
 
 If I get to specify two integers, then things are a little simpler: I
 only need to send the original values in.  If I only get two booleans,
 then I need to keep track of where I am in my scan -- and forbid the
 start edge only if I actually made an advancement.  (But perhaps a
 second match should avoid the edge in any case to avoid an infinite
 empty-match loop?  I don't remember all the details.)
 
 This is in some sense close to what the regexp tweaker is trying to do
 now (except -- IIRC -- it only has a version that doesn't match either
 edge).
 
 
 > One point I didn't quite follow: `regexp-match*' is currently
 > defined to ignore empty matches at the start and end of the input;
 > how are you planning to change that?
 
 I think that this was a separate issue -- whether you get this
 
    > (regexp-split #rx"" "foo")
    ("" "f" "o" "o" "")
 
 or
 
   ("f" "o" "o")
 
 with the latter happenning now.
 
 
 BTW, and FWIW, I've also tried some python games, and it looks like
 it's doing something different -- it looks like it forbids empty
 matches, and it doesn't drop empty edge matches, which means:
 
   > (regexp-split #rx" *" "foo  bar ")
   ("foo" "bar" "") ; advantage
   > (regexp-split #rx"\\b" "foo bar")
   ("foo bar")      ; disadvantage
 
 And they also splice in grouped matches:
 
   > (regexp-split #rx" *" "foo  bar ")
   ("foo" "bar" "")
   > (regexp-split #rx"( *)" "foo  bar ")
   ("foo" "  " "bar" " " "")
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Carl Eastlund <cce@ccs.neu.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Mon, 12 Apr 2010 07:31:47 -0600

 At Sun, 11 Apr 2010 23:02:06 -0400, Eli Barzilay wrote:
 > On Apr 11, Matthew Flatt wrote:
 > > At Sun, 11 Apr 2010 20:37:39 -0400, Eli Barzilay wrote:
 > > > * Add two arguments: `effective-start' and `effective-end' that
 > > >   determine where "^" and "$" are allowed to match.  The C side
 > > >   will use these instead of the given beginning/end.  (In the case
 > > >   of matching on ports the effective start can be negative, I
 > > >   think, which means that a "^" will never match.)
 > > 
 > > Why not two booleans, which indicate whether the start and end match
 > > ^ and $, respectively?  That would avoid various
 > > checks/specifications on how the numbers must relate to other
 > > numbers, but maybe you have in mind some use for the generality.
 > 
 > If I get to specify two integers, then things are a little simpler: I
 > only need to send the original values in.  If I only get two booleans,
 > then I need to keep track of where I am in my scan -- and forbid the
 > start edge only if I actually made an advancement.  (But perhaps a
 > second match should avoid the edge in any case to avoid an infinite
 > empty-match loop?  I don't remember all the details.)
 
 I still don't understand. Maybe I should ask more specific questions:
 What would the numbers mean in the case of an input port? What number
 would I use to say that the end of the port's streams should not match
 $ if I don't know how much data the port will deliver?
 
 > > One point I didn't quite follow: `regexp-match*' is currently
 > > defined to ignore empty matches at the start and end of the input;
 > > how are you planning to change that?
 > 
 > I think that this was a separate issue
 
 Right. My question is really: What's the plan for this separate issue,
 since it affects the original report?
 
From: Eli Barzilay <eli@barzilay.org>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: Carl Eastlund <cce@ccs.neu.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Mon, 12 Apr 2010 10:40:26 -0400

 On Apr 12, Matthew Flatt wrote:
 > At Sun, 11 Apr 2010 23:02:06 -0400, Eli Barzilay wrote:
 > > On Apr 11, Matthew Flatt wrote:
 > > > At Sun, 11 Apr 2010 20:37:39 -0400, Eli Barzilay wrote:
 > > > > * Add two arguments: `effective-start' and `effective-end' that
 > > > >   determine where "^" and "$" are allowed to match.  The C side
 > > > >   will use these instead of the given beginning/end.  (In the case
 > > > >   of matching on ports the effective start can be negative, I
 > > > >   think, which means that a "^" will never match.)
 > > > 
 > > > Why not two booleans, which indicate whether the start and end match
 > > > ^ and $, respectively?  That would avoid various
 > > > checks/specifications on how the numbers must relate to other
 > > > numbers, but maybe you have in mind some use for the generality.
 > > 
 > > If I get to specify two integers, then things are a little simpler: I
 > > only need to send the original values in.  If I only get two booleans,
 > > then I need to keep track of where I am in my scan -- and forbid the
 > > start edge only if I actually made an advancement.  (But perhaps a
 > > second match should avoid the edge in any case to avoid an infinite
 > > empty-match loop?  I don't remember all the details.)
 > 
 > I still don't understand. Maybe I should ask more specific questions:
 > What would the numbers mean in the case of an input port?
 
 Yes -- if they mean the same, then the start could be negative (I
 mentioned that above), I said that I think that it means that "^" will
 never match -- and that probably means that either with booleans or
 with integers the caller still needs to do some bookkeeping so perhaps
 the difference is cosmetic.
 
 
 > What number would I use to say that the end of the port's streams
 > should not match $ if I don't know how much data the port will
 > deliver?
 
 I don't think that this should happen.  Can you see a case where you'd
 want to forbid "$" at the end when you don't know where the end is?
 
 
 BTW, another pattern that should be affected by this is "\\b":
 
   -> (regexp-match #px"\\b.*" "foo bar" 1)
   ("oo bar")
 
 but if empty matches for "^" at the beginning are forbidden, then that
 should match the next point instead and return (" bar").
 
 (And this would simplify the hacks that make this happen now:
 
   -> (regexp-split #px"\\b" " foo bar ")
   (" " "foo" " " "bar" " ")
 
 )
 
 
 > > > One point I didn't quite follow: `regexp-match*' is currently
 > > > defined to ignore empty matches at the start and end of the input;
 > > > how are you planning to change that?
 > > 
 > > I think that this was a separate issue
 > 
 > Right. My question is really: What's the plan for this separate
 > issue, since it affects the original report?
 
 I think that once the first issue is resolved, deciding what to do
 with this one would be easier because it would be a separate decision.
 Wrt the original report `regexp-replace*' I think that it's reasonable
 to expect:
 
   > (regexp-replace* "^" "Scheme" "Racket")
   "RacketScheme"
 
 And the options I see are:
 
 * Python: *all* empty matches are forbidden in the * functions.
 
 * Perl: do whatever "feels better" on a case by case basis.
 
 * Emacs: `split-string' has an `omit-nulls' optional argument, other
   *-like functions keep them -- so
     (replace-regexp-in-string "^" "Racket" "Scheme")
     => "RacketScheme"
 
 It looks to me like doing what Emacs is doing, with a default #t for
 the omit argument might be the best way to go.  (Perhaps that *is*
 what perl is doing too.)
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Carl Eastlund <cce@ccs.neu.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Tue, 13 Apr 2010 20:39:41 -0600

 After experimenting with ways to tackle this problem, I'm planning to
 extend `regexp-match' et al. to accept a prefix byte string that the
 matcher pretends exists before the start of the input.
 
 The default (and current) behavior is an empty prefix. A prefix #"x"
 would prevent a "^" pattern from matching the start of the input. A
 #"\n" prefix would prevent a start-of-string "^" from matching the
 beginning of the input, while a start-of-line "^" could still match the
 beginning of the input. More generally, a lookbehind pattern at the
 start of a regexp might use more of the prefix.
 
 A new `regexp-max-lookbehind' function will report the maximum number
 of prefix characters that a regexp might inspect. Then, the
 implementation of functions like `regexp-match*' can use the lookbehind
 count to know how many bytes to carry forward as a prefix as it looks
 for another match.
 
 There are some more details, but that's the basic idea.
 
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Eli Barzilay <eli@barzilay.org>, Carl Eastlund <cce@ccs.neu.edu>,
        bugs@plt-scheme.org, bug-notification@plt-scheme.org
Cc: 
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Wed, 14 Apr 2010 16:41:45 -0600

 At Tue, 13 Apr 2010 20:39:41 -0600, Matthew Flatt wrote:
 > After experimenting with ways to tackle this problem, I'm planning to
 > extend `regexp-match' et al. to accept a prefix byte string that the
 > matcher pretends exists before the start of the input.
 
 Done.
 
 The original example still doesn't produce a Perl-like result, though
 it's now somewhat less weird:
 
  > (regexp-replace* "^" "Scheme" "Racket")
  "Scheme"
 
 Since I've blown a whole day on this already and I have it all paged
 in, I'm going to keep working on the empty-match rule that prevents the
 above result from being "RacketScheme".
 
 
 Here's one idea: The Perl example
 
   my $a = "Foo\nBar";
   $a =~ s/o??/Z/g;
   print "$a\n";
  =>
   ZFZZZZZ
   ZBZaZrZ
 
 suggests that Perl allows an empty match, but if it gets one, then it
 disallows an immediate empty match for the next attempt. At least, that
 rule sounds plausible to me, and it would produce the result that Carl
 wanted.
 
 
 Also, it turns out that the current `regexp-replace*' does not
 implement the same rule as `regexp-match*' and other `*' functions. The
 former throws out an immediate empty match and then try again starting
 with the next byte. The latter constrain the pattern to not match an
 immediate empty sequence, backtracking more locally to let a non-empty
 match from the beginning proceed. The latter is what Perl seems to do,
 and it seems more right. As Eli suggests, ditching the C implementation
 of `regexp-replace*' is on the path to fixing that problem.
 

State changed from "open" to "closed" by mflatt at Wed, 14 Apr 2010 22:53:28 -0400
Reason>>> The empty-match plan worked, I think.

Results are now very Perl-like as far as I can tell, 
except that Perl's `regexp-split' seems to drop any
empty string that isn't the first one, while ours
leaves all empty strings.

From: Eli Barzilay <eli@barzilay.org>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: Carl Eastlund <cce@ccs.neu.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Thu, 15 Apr 2010 11:09:25 -0400

 On Apr 13, Matthew Flatt wrote:
 > After experimenting with ways to tackle this problem, I'm planning
 > to extend `regexp-match' et al. to accept a prefix byte string that
 > the matcher pretends exists before the start of the input.
 > 
 > The default (and current) behavior is an empty prefix. A prefix #"x"
 > would prevent a "^" pattern from matching the start of the input. A
 > #"\n" prefix would prevent a start-of-string "^" from matching the
 > beginning of the input, while a start-of-line "^" could still match the
 > beginning of the input. More generally, a lookbehind pattern at the
 > start of a regexp might use more of the prefix.
 
 (I didn't even look at the details since I was completely inside the
 conversion thing, so this might be completely off.)
 
 This definitely sounds like it can express more than just a boolean,
 but how is it handled with strings?  Does it require allocating a
 string and keeping it uptodate with a scan like the one `regexp-split'
 is doing?  If so then it seems like it would make things much slower,
 but maybe there's some obious trick to avoid such costs?
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: Carl Eastlund <cce@ccs.neu.edu>, bugs@plt-scheme.org,
        bug-notification@plt-scheme.org
Subject: Re: [plt-bug] all/10855: regexp-replace* does strange things with the 
	"^" pattern
Date: Thu, 15 Apr 2010 09:31:00 -0600

 At Thu, 15 Apr 2010 11:09:25 -0400, Eli Barzilay wrote:
 > On Apr 13, Matthew Flatt wrote:
 > > After experimenting with ways to tackle this problem, I'm planning
 > > to extend `regexp-match' et al. to accept a prefix byte string that
 > > the matcher pretends exists before the start of the input.
 > > 
 > > The default (and current) behavior is an empty prefix. A prefix #"x"
 > > would prevent a "^" pattern from matching the start of the input. A
 > > #"\n" prefix would prevent a start-of-string "^" from matching the
 > > beginning of the input, while a start-of-line "^" could still match the
 > > beginning of the input. More generally, a lookbehind pattern at the
 > > start of a regexp might use more of the prefix.
 > 
 > (I didn't even look at the details since I was completely inside the
 > conversion thing, so this might be completely off.)
 > 
 > This definitely sounds like it can express more than just a boolean,
 > but how is it handled with strings?  Does it require allocating a
 > string and keeping it uptodate with a scan like the one `regexp-split'
 > is doing?  If so then it seems like it would make things much slower,
 > but maybe there's some obious trick to avoid such costs?
 
 Yes, currently you have to allocate a byte string to supply the prior
 context. I can imagine allowing a fragment of the input string to be
 identified as the prefix, too, which would avoid allocation in some
 cases, but it would be messier to use in `regexp-match*', etc.
 
 Overall, I don't expect this allocation to be much of an issue because
 it's only needed when a pattern has some amount of lookbehind --- not
 the common case.
 
 Along similar lines, the new rules for empty matches mean that a
 pattern doesn't have to be padded with "(?=.)" and "(?<=.)" unless an
 empty match is found. Since empty matches are not common, that can
 speed things up a little.
 
 As an example, both of the timed examples in
 
  #lang scheme
 
  (define f (make-bytes 1024 (char->integer #\x)))
  (define g (make-bytes 12 (char->integer #\x)))
 
  (collect-garbage)
 
  (time (for ([i (in-range 100)])
          (regexp-match* #rx#"xxxxxxxxx" f)))
 
  (time (for ([i (in-range 10000)])
          (regexp-match* #rx#"xxxxxxxxx" g)))
 
 run slightly faster on my machine with the latest compared to 4.2.5.
 
