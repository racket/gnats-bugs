From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Sun Oct 20 21:11:51 2013
Received: from mail-oa0-f51.google.com (mail-oa0-f51.google.com [209.85.219.51])
	by winooski.ccs.neu.edu (8.14.7/8.14.7) with ESMTP id r9L1BoMS000507
	for <bugs@bugs.plt-scheme.org>; Sun, 20 Oct 2013 21:11:50 -0400
Message-Id: <201310210111.r9L1BlFR000500@winooski.ccs.neu.edu>
Date: Sun, 20 Oct 2013 21:11:47 -0400
From: eric.n.dobson@gmail.com
To: bugs@racket-lang.org
Subject: It is too easy to hit the maximum number of files open in Racket

>Number:         14111
>Category:       mzscheme
>Synopsis:       It is too easy to hit the maximum number of files open in Racket
>Class:          not-a-bug
>Responsible:    mflatt
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Sun Oct 20 21:12:01 -0400 2013
>Closed-Date:    Thu Oct 24 20:55:41 -0400 2013
>Last-Modified:  Thu Oct 24 20:55:41 -0400 2013
>Originator:     Eric Dobson
>Organization:
plt
>Submitter-Id:   unknown
>Release:        HEAD
>Environment:
MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2 Safari/537.28
>Description:
During testing TR we want to run multiple programs at once, which we do using places. The issue is that this means that each place must reopen files that the other places have open leading to hitting the limit of racket. Most of these files are zo files and other racket implementation details.

OS: OSX 10.8.5
Machine: MacProRetina with 4 hyperthreaded cores.

>How-To-Repeat:
Edit transform.rkt in pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer, and add the line "(places 20)" above start workers, and then run "racket transform.rkt" from that directory.
>Fix:
>Audit-Trail:
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>
Cc: nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Sun, 20 Oct 2013 20:21:27 -0500

 --047d7b33cd7463a6c604e9361a28
 Content-Type: text/plain; charset=UTF-8
 
 Something seems fishy: when you have 4 places running doing lots of zo file
 reading, won't they have at most 4 files open at once? Or is it that you're
 using threads too?
 
 Robby
 
 
 On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 
 > A new problem report is waiting at
 >   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 >
 > Reported by Eric Dobson for release: HEAD
 >
 > *** Description:
 > During testing TR we want to run multiple programs at once, which we do
 > using places. The issue is that this means that each place must reopen
 > files that the other places have open leading to hitting the limit of
 > racket. Most of these files are zo files and other racket implementation
 > details.
 >
 > OS: OSX 10.8.5
 > Machine: MacProRetina with 4 hyperthreaded cores.
 >
 >
 > *** How to repeat:
 > Edit transform.rkt in
 > pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer, and
 > add the line "(places 20)" above start workers, and then run "racket
 > transform.rkt" from that directory.
 >
 > *** Environment:
 > MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 > AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2 Safari/537.28
 >
 >
 
 --047d7b33cd7463a6c604e9361a28
 Content-Type: text/html; charset=UTF-8
 Content-Transfer-Encoding: quoted-printable
 
 <div dir=3D"ltr">Something seems fishy: when you have 4 places running doin=
 g lots of zo file reading, won&#39;t they have at most 4 files open at once=
 ? Or is it that you&#39;re using threads too?<div><br></div><div>Robby</div=
 >
 </div><div class=3D"gmail_extra"><br><br><div class=3D"gmail_quote">On Sun,=
  Oct 20, 2013 at 8:12 PM,  <span dir=3D"ltr">&lt;<a href=3D"mailto:eric.n.d=
 obson@gmail.com" target=3D"_blank">eric.n.dobson@gmail.com</a>&gt;</span> w=
 rote:<br>
 <blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
 x #ccc solid;padding-left:1ex">A new problem report is waiting at<br>
 =C2=A0 <a href=3D"http://bugs.racket-lang.org/query/?cmd=3Dview&amp;pr=3D14=
 111" target=3D"_blank">http://bugs.racket-lang.org/query/?cmd=3Dview&amp;pr=
 =3D14111</a><br>
 <br>
 Reported by Eric Dobson for release: HEAD<br>
 <br>
 *** Description:<br>
 During testing TR we want to run multiple programs at once, which we do usi=
 ng places. The issue is that this means that each place must reopen files t=
 hat the other places have open leading to hitting the limit of racket. Most=
  of these files are zo files and other racket implementation details.<br>
 
 <br>
 OS: OSX 10.8.5<br>
 Machine: MacProRetina with 4 hyperthreaded cores.<br>
 <br>
 <br>
 *** How to repeat:<br>
 Edit transform.rkt in pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-=
 racket/optimizer, and add the line &quot;(places 20)&quot; above start work=
 ers, and then run &quot;racket transform.rkt&quot; from that directory.<br>
 
 <br>
 *** Environment:<br>
 MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.2=
 8 (KHTML, like Gecko) Chrome/26.0.1397.2 Safari/537.28<br>
 <br>
 </blockquote></div><br></div>
 
 --047d7b33cd7463a6c604e9361a28--

From: Eric Dobson <eric.n.dobson@gmail.com>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Sun, 20 Oct 2013 18:33:24 -0700

 Yes, something seemed fishy. The number of threads should be
 irrelevant since the places are what actually run the code, and the
 threads are just for making things work concurrently (not in
 parallel). The file limit on OS X is ~10000, so it looked like files
 were not getting closed.
 
 I noticed this because I changed the code under test in TR and this
 started breaking, but if I lowered the number of places it continues
 to work.
 
 I'll try to reduce the test case, and post back in a day or two when I
 get the time.
 
 On Sun, Oct 20, 2013 at 6:21 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > Something seems fishy: when you have 4 places running doing lots of zo file
 > reading, won't they have at most 4 files open at once? Or is it that you're
 > using threads too?
 >
 > Robby
 >
 >
 > On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 >>
 >> A new problem report is waiting at
 >>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 >>
 >> Reported by Eric Dobson for release: HEAD
 >>
 >> *** Description:
 >> During testing TR we want to run multiple programs at once, which we do
 >> using places. The issue is that this means that each place must reopen files
 >> that the other places have open leading to hitting the limit of racket. Most
 >> of these files are zo files and other racket implementation details.
 >>
 >> OS: OSX 10.8.5
 >> Machine: MacProRetina with 4 hyperthreaded cores.
 >>
 >>
 >> *** How to repeat:
 >> Edit transform.rkt in
 >> pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer, and
 >> add the line "(places 20)" above start workers, and then run "racket
 >> transform.rkt" from that directory.
 >>
 >> *** Environment:
 >> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 >> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2 Safari/537.28
 >>
 >
From: Sam Tobin-Hochstadt <samth@cs.indiana.edu>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eric Dobson <eric.n.dobson@gmail.com>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Sun, 20 Oct 2013 20:32:30 -0500

 Yes, this program uses thread to queue work, and then places to
 consume the work.  But the number of threads is the same, regardless
 of the number of places.
 
 Sam
 
 On Sun, Oct 20, 2013 at 8:21 PM, Robby Findler
 <robby@eecs.northwestern.edu> wrote:
 > Something seems fishy: when you have 4 places running doing lots of zo file
 > reading, won't they have at most 4 files open at once? Or is it that you're
 > using threads too?
 >
 > Robby
 >
 >
 > On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 >>
 >> A new problem report is waiting at
 >>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 >>
 >> Reported by Eric Dobson for release: HEAD
 >>
 >> *** Description:
 >> During testing TR we want to run multiple programs at once, which we do
 >> using places. The issue is that this means that each place must reopen files
 >> that the other places have open leading to hitting the limit of racket. Most
 >> of these files are zo files and other racket implementation details.
 >>
 >> OS: OSX 10.8.5
 >> Machine: MacProRetina with 4 hyperthreaded cores.
 >>
 >>
 >> *** How to repeat:
 >> Edit transform.rkt in
 >> pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer, and
 >> add the line "(places 20)" above start workers, and then run "racket
 >> transform.rkt" from that directory.
 >>
 >> *** Environment:
 >> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 >> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2 Safari/537.28
 >>
 >
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: bugs <bugs@racket-lang.org>, nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Sun, 20 Oct 2013 23:59:33 -0700

 Replicated with a small example. I once got a malloc error, but
 couldn't replicate that.
 
 tmp.rkt:
 #lang racket
 
 (provide run)
 
 (define (run chan)
   (let loop ()
     (eval-syntax
       #'(module x racket))
     (loop)))
 
 tmp2.rkt:
 #lang racket
 
 (require "tmp.rkt")
 
 (for ((i 1))
   (place chan (run chan)))
 (sync never-evt)
 
 
 Then "racket tmp2.rkt", and wait about 15-30 seconds, till it hits the
 error. Increasing the number of places makes it faster.
 
 
 On Sun, Oct 20, 2013 at 6:33 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > Yes, something seemed fishy. The number of threads should be
 > irrelevant since the places are what actually run the code, and the
 > threads are just for making things work concurrently (not in
 > parallel). The file limit on OS X is ~10000, so it looked like files
 > were not getting closed.
 >
 > I noticed this because I changed the code under test in TR and this
 > started breaking, but if I lowered the number of places it continues
 > to work.
 >
 > I'll try to reduce the test case, and post back in a day or two when I
 > get the time.
 >
 > On Sun, Oct 20, 2013 at 6:21 PM, Robby Findler
 > <robby@eecs.northwestern.edu> wrote:
 >> Something seems fishy: when you have 4 places running doing lots of zo file
 >> reading, won't they have at most 4 files open at once? Or is it that you're
 >> using threads too?
 >>
 >> Robby
 >>
 >>
 >> On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 >>>
 >>> A new problem report is waiting at
 >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 >>>
 >>> Reported by Eric Dobson for release: HEAD
 >>>
 >>> *** Description:
 >>> During testing TR we want to run multiple programs at once, which we do
 >>> using places. The issue is that this means that each place must reopen files
 >>> that the other places have open leading to hitting the limit of racket. Most
 >>> of these files are zo files and other racket implementation details.
 >>>
 >>> OS: OSX 10.8.5
 >>> Machine: MacProRetina with 4 hyperthreaded cores.
 >>>
 >>>
 >>> *** How to repeat:
 >>> Edit transform.rkt in
 >>> pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer, and
 >>> add the line "(places 20)" above start workers, and then run "racket
 >>> transform.rkt" from that directory.
 >>>
 >>> *** Environment:
 >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 >>> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2 Safari/537.28
 >>>
 >>
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Mon, 21 Oct 2013 06:14:06 -0600

 Unless I'm confused about the example, the report is really "it's too
 easy to request an infinite number of places".
 
 Here's an even simpler variant:
 
  #lang racket
  (place p 1)
  (sync never-evt)
 
 The `place` form runs the enclosing module in the next place, which
 runs the enclosing module in another new place, and so on. I believe
 the same thing happens with "tmp2.rkt" below.
 
 The usual solution is to put `place` inside a function that is called
 from a `main` submodule. That way, the surrounding module for `place`
 doesn't call the function that contains `place`.
 
  #lang racket
 
  (require "tmp.rkt")
 
  (define (go)
    (for ((i 1))
      (place chan (run chan)))
    (sync never-evt))
 
  (module+ main
    (go))
 
 
 
 At Sun, 20 Oct 2013 23:59:33 -0700, Eric Dobson wrote:
 > Replicated with a small example. I once got a malloc error, but
 > couldn't replicate that.
 > 
 > tmp.rkt:
 > #lang racket
 > 
 > (provide run)
 > 
 > (define (run chan)
 >   (let loop ()
 >     (eval-syntax
 >       #'(module x racket))
 >     (loop)))
 > 
 > tmp2.rkt:
 > #lang racket
 > 
 > (require "tmp.rkt")
 > 
 > (for ((i 1))
 >   (place chan (run chan)))
 > (sync never-evt)
 > 
 > 
 > Then "racket tmp2.rkt", and wait about 15-30 seconds, till it hits the
 > error. Increasing the number of places makes it faster.
 > 
 > 
 > On Sun, Oct 20, 2013 at 6:33 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > > Yes, something seemed fishy. The number of threads should be
 > > irrelevant since the places are what actually run the code, and the
 > > threads are just for making things work concurrently (not in
 > > parallel). The file limit on OS X is ~10000, so it looked like files
 > > were not getting closed.
 > >
 > > I noticed this because I changed the code under test in TR and this
 > > started breaking, but if I lowered the number of places it continues
 > > to work.
 > >
 > > I'll try to reduce the test case, and post back in a day or two when I
 > > get the time.
 > >
 > > On Sun, Oct 20, 2013 at 6:21 PM, Robby Findler
 > > <robby@eecs.northwestern.edu> wrote:
 > >> Something seems fishy: when you have 4 places running doing lots of zo file
 > >> reading, won't they have at most 4 files open at once? Or is it that you're
 > >> using threads too?
 > >>
 > >> Robby
 > >>
 > >>
 > >> On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 > >>>
 > >>> A new problem report is waiting at
 > >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 > >>>
 > >>> Reported by Eric Dobson for release: HEAD
 > >>>
 > >>> *** Description:
 > >>> During testing TR we want to run multiple programs at once, which we do
 > >>> using places. The issue is that this means that each place must reopen 
 > files
 > >>> that the other places have open leading to hitting the limit of racket. 
 > Most
 > >>> of these files are zo files and other racket implementation details.
 > >>>
 > >>> OS: OSX 10.8.5
 > >>> Machine: MacProRetina with 4 hyperthreaded cores.
 > >>>
 > >>>
 > >>> *** How to repeat:
 > >>> Edit transform.rkt in
 > >>> pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer, and
 > >>> add the line "(places 20)" above start workers, and then run "racket
 > >>> transform.rkt" from that directory.
 > >>>
 > >>> *** Environment:
 > >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 > >>> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2 Safari/537.28
 > >>>
 > >>
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Mon, 21 Oct 2013 09:32:13 -0700

 Well, I messed up the example so it did have that issue, but shouldn't
 create an infinite number of places. I knew that was an issue which is
 why I used the two files, but still didn't actually avoid the issue.
 Here is a simpler one that uses submodules and still has the bug:
 
 #lang racket
 
 
 (define (run chan)
   (let loop ()
     (eval-syntax
       #'(module x racket))
     (loop)))
 
 (define (go)
   (place chan (run chan)))
 
 (module+ main
   (for ((i 100))
     (go))
   (sync never-evt))
 
 
 On Mon, Oct 21, 2013 at 5:14 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > Unless I'm confused about the example, the report is really "it's too
 > easy to request an infinite number of places".
 >
 > Here's an even simpler variant:
 >
 >  #lang racket
 >  (place p 1)
 >  (sync never-evt)
 >
 > The `place` form runs the enclosing module in the next place, which
 > runs the enclosing module in another new place, and so on. I believe
 > the same thing happens with "tmp2.rkt" below.
 >
 > The usual solution is to put `place` inside a function that is called
 > from a `main` submodule. That way, the surrounding module for `place`
 > doesn't call the function that contains `place`.
 >
 >  #lang racket
 >
 >  (require "tmp.rkt")
 >
 >  (define (go)
 >    (for ((i 1))
 >      (place chan (run chan)))
 >    (sync never-evt))
 >
 >  (module+ main
 >    (go))
 >
 >
 >
 > At Sun, 20 Oct 2013 23:59:33 -0700, Eric Dobson wrote:
 >> Replicated with a small example. I once got a malloc error, but
 >> couldn't replicate that.
 >>
 >> tmp.rkt:
 >> #lang racket
 >>
 >> (provide run)
 >>
 >> (define (run chan)
 >>   (let loop ()
 >>     (eval-syntax
 >>       #'(module x racket))
 >>     (loop)))
 >>
 >> tmp2.rkt:
 >> #lang racket
 >>
 >> (require "tmp.rkt")
 >>
 >> (for ((i 1))
 >>   (place chan (run chan)))
 >> (sync never-evt)
 >>
 >>
 >> Then "racket tmp2.rkt", and wait about 15-30 seconds, till it hits the
 >> error. Increasing the number of places makes it faster.
 >>
 >>
 >> On Sun, Oct 20, 2013 at 6:33 PM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 >> > Yes, something seemed fishy. The number of threads should be
 >> > irrelevant since the places are what actually run the code, and the
 >> > threads are just for making things work concurrently (not in
 >> > parallel). The file limit on OS X is ~10000, so it looked like files
 >> > were not getting closed.
 >> >
 >> > I noticed this because I changed the code under test in TR and this
 >> > started breaking, but if I lowered the number of places it continues
 >> > to work.
 >> >
 >> > I'll try to reduce the test case, and post back in a day or two when I
 >> > get the time.
 >> >
 >> > On Sun, Oct 20, 2013 at 6:21 PM, Robby Findler
 >> > <robby@eecs.northwestern.edu> wrote:
 >> >> Something seems fishy: when you have 4 places running doing lots of zo file
 >> >> reading, won't they have at most 4 files open at once? Or is it that you're
 >> >> using threads too?
 >> >>
 >> >> Robby
 >> >>
 >> >>
 >> >> On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 >> >>>
 >> >>> A new problem report is waiting at
 >> >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 >> >>>
 >> >>> Reported by Eric Dobson for release: HEAD
 >> >>>
 >> >>> *** Description:
 >> >>> During testing TR we want to run multiple programs at once, which we do
 >> >>> using places. The issue is that this means that each place must reopen
 >> files
 >> >>> that the other places have open leading to hitting the limit of racket.
 >> Most
 >> >>> of these files are zo files and other racket implementation details.
 >> >>>
 >> >>> OS: OSX 10.8.5
 >> >>> Machine: MacProRetina with 4 hyperthreaded cores.
 >> >>>
 >> >>>
 >> >>> *** How to repeat:
 >> >>> Edit transform.rkt in
 >> >>> pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer, and
 >> >>> add the line "(places 20)" above start workers, and then run "racket
 >> >>> transform.rkt" from that directory.
 >> >>>
 >> >>> *** Environment:
 >> >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 >> >>> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2 Safari/537.28
 >> >>>
 >> >>
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Mon, 21 Oct 2013 10:45:12 -0600

 And, just to be sure, you've set your descriptors limit on Mac OS X to
 10000s?
 
 The default setting is normally 256 or so, which would be reached
 easily with 100 places running at the same time. I get a "Too many open
 files" error quickly when I try the program on my machine. When I raise
 the descriptors limit to 10000, then Racket hits an uncomfortable
 amount of memory (so that I kill it) before a "Too many open files"
 error.
 
 At Mon, 21 Oct 2013 09:32:13 -0700, Eric Dobson wrote:
 > Well, I messed up the example so it did have that issue, but shouldn't
 > create an infinite number of places. I knew that was an issue which is
 > why I used the two files, but still didn't actually avoid the issue.
 > Here is a simpler one that uses submodules and still has the bug:
 > 
 > #lang racket
 > 
 > 
 > (define (run chan)
 >   (let loop ()
 >     (eval-syntax
 >       #'(module x racket))
 >     (loop)))
 > 
 > (define (go)
 >   (place chan (run chan)))
 > 
 > (module+ main
 >   (for ((i 100))
 >     (go))
 >   (sync never-evt))
 > 
 > 
 > On Mon, Oct 21, 2013 at 5:14 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > > Unless I'm confused about the example, the report is really "it's too
 > > easy to request an infinite number of places".
 > >
 > > Here's an even simpler variant:
 > >
 > >  #lang racket
 > >  (place p 1)
 > >  (sync never-evt)
 > >
 > > The `place` form runs the enclosing module in the next place, which
 > > runs the enclosing module in another new place, and so on. I believe
 > > the same thing happens with "tmp2.rkt" below.
 > >
 > > The usual solution is to put `place` inside a function that is called
 > > from a `main` submodule. That way, the surrounding module for `place`
 > > doesn't call the function that contains `place`.
 > >
 > >  #lang racket
 > >
 > >  (require "tmp.rkt")
 > >
 > >  (define (go)
 > >    (for ((i 1))
 > >      (place chan (run chan)))
 > >    (sync never-evt))
 > >
 > >  (module+ main
 > >    (go))
 > >
 > >
 > >
 > > At Sun, 20 Oct 2013 23:59:33 -0700, Eric Dobson wrote:
 > >> Replicated with a small example. I once got a malloc error, but
 > >> couldn't replicate that.
 > >>
 > >> tmp.rkt:
 > >> #lang racket
 > >>
 > >> (provide run)
 > >>
 > >> (define (run chan)
 > >>   (let loop ()
 > >>     (eval-syntax
 > >>       #'(module x racket))
 > >>     (loop)))
 > >>
 > >> tmp2.rkt:
 > >> #lang racket
 > >>
 > >> (require "tmp.rkt")
 > >>
 > >> (for ((i 1))
 > >>   (place chan (run chan)))
 > >> (sync never-evt)
 > >>
 > >>
 > >> Then "racket tmp2.rkt", and wait about 15-30 seconds, till it hits the
 > >> error. Increasing the number of places makes it faster.
 > >>
 > >>
 > >> On Sun, Oct 20, 2013 at 6:33 PM, Eric Dobson <eric.n.dobson@gmail.com> 
 > wrote:
 > >> > Yes, something seemed fishy. The number of threads should be
 > >> > irrelevant since the places are what actually run the code, and the
 > >> > threads are just for making things work concurrently (not in
 > >> > parallel). The file limit on OS X is ~10000, so it looked like files
 > >> > were not getting closed.
 > >> >
 > >> > I noticed this because I changed the code under test in TR and this
 > >> > started breaking, but if I lowered the number of places it continues
 > >> > to work.
 > >> >
 > >> > I'll try to reduce the test case, and post back in a day or two when I
 > >> > get the time.
 > >> >
 > >> > On Sun, Oct 20, 2013 at 6:21 PM, Robby Findler
 > >> > <robby@eecs.northwestern.edu> wrote:
 > >> >> Something seems fishy: when you have 4 places running doing lots of zo 
 > file
 > >> >> reading, won't they have at most 4 files open at once? Or is it that 
 > you're
 > >> >> using threads too?
 > >> >>
 > >> >> Robby
 > >> >>
 > >> >>
 > >> >> On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 > >> >>>
 > >> >>> A new problem report is waiting at
 > >> >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 > >> >>>
 > >> >>> Reported by Eric Dobson for release: HEAD
 > >> >>>
 > >> >>> *** Description:
 > >> >>> During testing TR we want to run multiple programs at once, which we do
 > >> >>> using places. The issue is that this means that each place must reopen
 > >> files
 > >> >>> that the other places have open leading to hitting the limit of racket.
 > >> Most
 > >> >>> of these files are zo files and other racket implementation details.
 > >> >>>
 > >> >>> OS: OSX 10.8.5
 > >> >>> Machine: MacProRetina with 4 hyperthreaded cores.
 > >> >>>
 > >> >>>
 > >> >>> *** How to repeat:
 > >> >>> Edit transform.rkt in
 > >> >>> pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer, 
 > and
 > >> >>> add the line "(places 20)" above start workers, and then run "racket
 > >> >>> transform.rkt" from that directory.
 > >> >>>
 > >> >>> *** Environment:
 > >> >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 > >> >>> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2 Safari/537.28
 > >> >>>
 > >> >>
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Mon, 21 Oct 2013 09:55:48 -0700

 No. 10000 is the default.
 
 endobson@yggdrasil () ~ % sysctl -A | grep kern.maxfiles
 
 
                      (0)
 Use pstat to view kern.vnode information
 Use ps to view kern.proc information
 Use pstat to view kern.file information
 kernel is not compiled for profiling
 kern.maxpartitions: no such MIB
 kern.kdebug: value is not available
 kern.update: no such MIB
 kern.osreldate: no such MIB
 kern.ntp_pll: no such MIB
 kern.bootfile: no such MIB
 kern.dumpdev: no such MIB
 kern.ipc: no such MIB
 kern.dummy: no such MIB
 kern.dummy: no such MIB
 kern.logsigexit: no such MIB
 kern.symfile: Input/output error
 kern.procargs: Invalid argument
 kern.dummy: no such MIB
 kern.panicinfo: no such MIB
 kern.sysv: no such MIB
 kern.dummy: no such MIB
 kern.dummy: no such MIB
 kern.procargs2: Invalid argument
 kern.proc_low_pri_io: no such MIB
 kern.low_pri_window: no such MIB
 kern.low_pri_delay: no such MIB
 kern.posix: no such MIB
 kern.tfp: no such MIB
 kern.threadsigaltstack: no such MIB
 kern.lctx: no such MIB
 kern.tty: no such MIB
 kern.check_openevt: Invalid argument
 vm.vmmeter: no such MIB
 vm.dummy: no such MIB
 hw.disknames: no such MIB
 hw.diskstats: no such MIB
 hw.floatingpoint: no such MIB
 hw.machinearch: no such MIB
 kern.maxfiles = 12288
 kern.maxfilesperproc = 10240
 kern.maxfiles: 12288
 kern.maxfilesperproc: 10240
 
 On Mon, Oct 21, 2013 at 9:45 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > And, just to be sure, you've set your descriptors limit on Mac OS X to
 > 10000s?
 >
 > The default setting is normally 256 or so, which would be reached
 > easily with 100 places running at the same time. I get a "Too many open
 > files" error quickly when I try the program on my machine. When I raise
 > the descriptors limit to 10000, then Racket hits an uncomfortable
 > amount of memory (so that I kill it) before a "Too many open files"
 > error.
 >
 > At Mon, 21 Oct 2013 09:32:13 -0700, Eric Dobson wrote:
 >> Well, I messed up the example so it did have that issue, but shouldn't
 >> create an infinite number of places. I knew that was an issue which is
 >> why I used the two files, but still didn't actually avoid the issue.
 >> Here is a simpler one that uses submodules and still has the bug:
 >>
 >> #lang racket
 >>
 >>
 >> (define (run chan)
 >>   (let loop ()
 >>     (eval-syntax
 >>       #'(module x racket))
 >>     (loop)))
 >>
 >> (define (go)
 >>   (place chan (run chan)))
 >>
 >> (module+ main
 >>   (for ((i 100))
 >>     (go))
 >>   (sync never-evt))
 >>
 >>
 >> On Mon, Oct 21, 2013 at 5:14 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >> > Unless I'm confused about the example, the report is really "it's too
 >> > easy to request an infinite number of places".
 >> >
 >> > Here's an even simpler variant:
 >> >
 >> >  #lang racket
 >> >  (place p 1)
 >> >  (sync never-evt)
 >> >
 >> > The `place` form runs the enclosing module in the next place, which
 >> > runs the enclosing module in another new place, and so on. I believe
 >> > the same thing happens with "tmp2.rkt" below.
 >> >
 >> > The usual solution is to put `place` inside a function that is called
 >> > from a `main` submodule. That way, the surrounding module for `place`
 >> > doesn't call the function that contains `place`.
 >> >
 >> >  #lang racket
 >> >
 >> >  (require "tmp.rkt")
 >> >
 >> >  (define (go)
 >> >    (for ((i 1))
 >> >      (place chan (run chan)))
 >> >    (sync never-evt))
 >> >
 >> >  (module+ main
 >> >    (go))
 >> >
 >> >
 >> >
 >> > At Sun, 20 Oct 2013 23:59:33 -0700, Eric Dobson wrote:
 >> >> Replicated with a small example. I once got a malloc error, but
 >> >> couldn't replicate that.
 >> >>
 >> >> tmp.rkt:
 >> >> #lang racket
 >> >>
 >> >> (provide run)
 >> >>
 >> >> (define (run chan)
 >> >>   (let loop ()
 >> >>     (eval-syntax
 >> >>       #'(module x racket))
 >> >>     (loop)))
 >> >>
 >> >> tmp2.rkt:
 >> >> #lang racket
 >> >>
 >> >> (require "tmp.rkt")
 >> >>
 >> >> (for ((i 1))
 >> >>   (place chan (run chan)))
 >> >> (sync never-evt)
 >> >>
 >> >>
 >> >> Then "racket tmp2.rkt", and wait about 15-30 seconds, till it hits the
 >> >> error. Increasing the number of places makes it faster.
 >> >>
 >> >>
 >> >> On Sun, Oct 20, 2013 at 6:33 PM, Eric Dobson <eric.n.dobson@gmail.com>
 >> wrote:
 >> >> > Yes, something seemed fishy. The number of threads should be
 >> >> > irrelevant since the places are what actually run the code, and the
 >> >> > threads are just for making things work concurrently (not in
 >> >> > parallel). The file limit on OS X is ~10000, so it looked like files
 >> >> > were not getting closed.
 >> >> >
 >> >> > I noticed this because I changed the code under test in TR and this
 >> >> > started breaking, but if I lowered the number of places it continues
 >> >> > to work.
 >> >> >
 >> >> > I'll try to reduce the test case, and post back in a day or two when I
 >> >> > get the time.
 >> >> >
 >> >> > On Sun, Oct 20, 2013 at 6:21 PM, Robby Findler
 >> >> > <robby@eecs.northwestern.edu> wrote:
 >> >> >> Something seems fishy: when you have 4 places running doing lots of zo
 >> file
 >> >> >> reading, won't they have at most 4 files open at once? Or is it that
 >> you're
 >> >> >> using threads too?
 >> >> >>
 >> >> >> Robby
 >> >> >>
 >> >> >>
 >> >> >> On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 >> >> >>>
 >> >> >>> A new problem report is waiting at
 >> >> >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 >> >> >>>
 >> >> >>> Reported by Eric Dobson for release: HEAD
 >> >> >>>
 >> >> >>> *** Description:
 >> >> >>> During testing TR we want to run multiple programs at once, which we do
 >> >> >>> using places. The issue is that this means that each place must reopen
 >> >> files
 >> >> >>> that the other places have open leading to hitting the limit of racket.
 >> >> Most
 >> >> >>> of these files are zo files and other racket implementation details.
 >> >> >>>
 >> >> >>> OS: OSX 10.8.5
 >> >> >>> Machine: MacProRetina with 4 hyperthreaded cores.
 >> >> >>>
 >> >> >>>
 >> >> >>> *** How to repeat:
 >> >> >>> Edit transform.rkt in
 >> >> >>> pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer,
 >> and
 >> >> >>> add the line "(places 20)" above start workers, and then run "racket
 >> >> >>> transform.rkt" from that directory.
 >> >> >>>
 >> >> >>> *** Environment:
 >> >> >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 >> >> >>> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2 Safari/537.28
 >> >> >>>
 >> >> >>
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Mon, 21 Oct 2013 11:01:39 -0600

 The system-wide hard limit is probably not as relevant as the
 process-inherited current limit.
 
 What do you get for `ulimit -n`? I get 256 by default:
 
  laptop% ulimit -n
  256
 
 
 At Mon, 21 Oct 2013 09:55:48 -0700, Eric Dobson wrote:
 > No. 10000 is the default.
 > 
 > endobson@yggdrasil () ~ % sysctl -A | grep kern.maxfiles
 > 
 > 
 >                      (0)
 > Use pstat to view kern.vnode information
 > Use ps to view kern.proc information
 > Use pstat to view kern.file information
 > kernel is not compiled for profiling
 > kern.maxpartitions: no such MIB
 > kern.kdebug: value is not available
 > kern.update: no such MIB
 > kern.osreldate: no such MIB
 > kern.ntp_pll: no such MIB
 > kern.bootfile: no such MIB
 > kern.dumpdev: no such MIB
 > kern.ipc: no such MIB
 > kern.dummy: no such MIB
 > kern.dummy: no such MIB
 > kern.logsigexit: no such MIB
 > kern.symfile: Input/output error
 > kern.procargs: Invalid argument
 > kern.dummy: no such MIB
 > kern.panicinfo: no such MIB
 > kern.sysv: no such MIB
 > kern.dummy: no such MIB
 > kern.dummy: no such MIB
 > kern.procargs2: Invalid argument
 > kern.proc_low_pri_io: no such MIB
 > kern.low_pri_window: no such MIB
 > kern.low_pri_delay: no such MIB
 > kern.posix: no such MIB
 > kern.tfp: no such MIB
 > kern.threadsigaltstack: no such MIB
 > kern.lctx: no such MIB
 > kern.tty: no such MIB
 > kern.check_openevt: Invalid argument
 > vm.vmmeter: no such MIB
 > vm.dummy: no such MIB
 > hw.disknames: no such MIB
 > hw.diskstats: no such MIB
 > hw.floatingpoint: no such MIB
 > hw.machinearch: no such MIB
 > kern.maxfiles = 12288
 > kern.maxfilesperproc = 10240
 > kern.maxfiles: 12288
 > kern.maxfilesperproc: 10240
 > 
 > On Mon, Oct 21, 2013 at 9:45 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > > And, just to be sure, you've set your descriptors limit on Mac OS X to
 > > 10000s?
 > >
 > > The default setting is normally 256 or so, which would be reached
 > > easily with 100 places running at the same time. I get a "Too many open
 > > files" error quickly when I try the program on my machine. When I raise
 > > the descriptors limit to 10000, then Racket hits an uncomfortable
 > > amount of memory (so that I kill it) before a "Too many open files"
 > > error.
 > >
 > > At Mon, 21 Oct 2013 09:32:13 -0700, Eric Dobson wrote:
 > >> Well, I messed up the example so it did have that issue, but shouldn't
 > >> create an infinite number of places. I knew that was an issue which is
 > >> why I used the two files, but still didn't actually avoid the issue.
 > >> Here is a simpler one that uses submodules and still has the bug:
 > >>
 > >> #lang racket
 > >>
 > >>
 > >> (define (run chan)
 > >>   (let loop ()
 > >>     (eval-syntax
 > >>       #'(module x racket))
 > >>     (loop)))
 > >>
 > >> (define (go)
 > >>   (place chan (run chan)))
 > >>
 > >> (module+ main
 > >>   (for ((i 100))
 > >>     (go))
 > >>   (sync never-evt))
 > >>
 > >>
 > >> On Mon, Oct 21, 2013 at 5:14 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > >> > Unless I'm confused about the example, the report is really "it's too
 > >> > easy to request an infinite number of places".
 > >> >
 > >> > Here's an even simpler variant:
 > >> >
 > >> >  #lang racket
 > >> >  (place p 1)
 > >> >  (sync never-evt)
 > >> >
 > >> > The `place` form runs the enclosing module in the next place, which
 > >> > runs the enclosing module in another new place, and so on. I believe
 > >> > the same thing happens with "tmp2.rkt" below.
 > >> >
 > >> > The usual solution is to put `place` inside a function that is called
 > >> > from a `main` submodule. That way, the surrounding module for `place`
 > >> > doesn't call the function that contains `place`.
 > >> >
 > >> >  #lang racket
 > >> >
 > >> >  (require "tmp.rkt")
 > >> >
 > >> >  (define (go)
 > >> >    (for ((i 1))
 > >> >      (place chan (run chan)))
 > >> >    (sync never-evt))
 > >> >
 > >> >  (module+ main
 > >> >    (go))
 > >> >
 > >> >
 > >> >
 > >> > At Sun, 20 Oct 2013 23:59:33 -0700, Eric Dobson wrote:
 > >> >> Replicated with a small example. I once got a malloc error, but
 > >> >> couldn't replicate that.
 > >> >>
 > >> >> tmp.rkt:
 > >> >> #lang racket
 > >> >>
 > >> >> (provide run)
 > >> >>
 > >> >> (define (run chan)
 > >> >>   (let loop ()
 > >> >>     (eval-syntax
 > >> >>       #'(module x racket))
 > >> >>     (loop)))
 > >> >>
 > >> >> tmp2.rkt:
 > >> >> #lang racket
 > >> >>
 > >> >> (require "tmp.rkt")
 > >> >>
 > >> >> (for ((i 1))
 > >> >>   (place chan (run chan)))
 > >> >> (sync never-evt)
 > >> >>
 > >> >>
 > >> >> Then "racket tmp2.rkt", and wait about 15-30 seconds, till it hits the
 > >> >> error. Increasing the number of places makes it faster.
 > >> >>
 > >> >>
 > >> >> On Sun, Oct 20, 2013 at 6:33 PM, Eric Dobson <eric.n.dobson@gmail.com>
 > >> wrote:
 > >> >> > Yes, something seemed fishy. The number of threads should be
 > >> >> > irrelevant since the places are what actually run the code, and the
 > >> >> > threads are just for making things work concurrently (not in
 > >> >> > parallel). The file limit on OS X is ~10000, so it looked like files
 > >> >> > were not getting closed.
 > >> >> >
 > >> >> > I noticed this because I changed the code under test in TR and this
 > >> >> > started breaking, but if I lowered the number of places it continues
 > >> >> > to work.
 > >> >> >
 > >> >> > I'll try to reduce the test case, and post back in a day or two when I
 > >> >> > get the time.
 > >> >> >
 > >> >> > On Sun, Oct 20, 2013 at 6:21 PM, Robby Findler
 > >> >> > <robby@eecs.northwestern.edu> wrote:
 > >> >> >> Something seems fishy: when you have 4 places running doing lots of zo
 > >> file
 > >> >> >> reading, won't they have at most 4 files open at once? Or is it that
 > >> you're
 > >> >> >> using threads too?
 > >> >> >>
 > >> >> >> Robby
 > >> >> >>
 > >> >> >>
 > >> >> >> On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 > >> >> >>>
 > >> >> >>> A new problem report is waiting at
 > >> >> >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 > >> >> >>>
 > >> >> >>> Reported by Eric Dobson for release: HEAD
 > >> >> >>>
 > >> >> >>> *** Description:
 > >> >> >>> During testing TR we want to run multiple programs at once, which we 
 > do
 > >> >> >>> using places. The issue is that this means that each place must 
 > reopen
 > >> >> files
 > >> >> >>> that the other places have open leading to hitting the limit of 
 > racket.
 > >> >> Most
 > >> >> >>> of these files are zo files and other racket implementation details.
 > >> >> >>>
 > >> >> >>> OS: OSX 10.8.5
 > >> >> >>> Machine: MacProRetina with 4 hyperthreaded cores.
 > >> >> >>>
 > >> >> >>>
 > >> >> >>> *** How to repeat:
 > >> >> >>> Edit transform.rkt in
 > >> >> >>> 
 > pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer,
 > >> and
 > >> >> >>> add the line "(places 20)" above start workers, and then run "racket
 > >> >> >>> transform.rkt" from that directory.
 > >> >> >>>
 > >> >> >>> *** Environment:
 > >> >> >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 > >> >> >>> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2 
 > Safari/537.28
 > >> >> >>>
 > >> >> >>
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Mon, 21 Oct 2013 10:10:40 -0700

 Ok, yes that is still at 256. Testing with changing the numbers I see
 that it runs at 20 for a reasonable amount of time without erroring
 and 21 fails almost instantly. Thus it is not a leak as I suspected,
 Does 12 files open per place seem like a reasonable number?
 
 On Mon, Oct 21, 2013 at 10:01 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > The system-wide hard limit is probably not as relevant as the
 > process-inherited current limit.
 >
 > What do you get for `ulimit -n`? I get 256 by default:
 >
 >  laptop% ulimit -n
 >  256
 >
 >
 > At Mon, 21 Oct 2013 09:55:48 -0700, Eric Dobson wrote:
 >> No. 10000 is the default.
 >>
 >> endobson@yggdrasil () ~ % sysctl -A | grep kern.maxfiles
 >>
 >>
 >>                      (0)
 >> Use pstat to view kern.vnode information
 >> Use ps to view kern.proc information
 >> Use pstat to view kern.file information
 >> kernel is not compiled for profiling
 >> kern.maxpartitions: no such MIB
 >> kern.kdebug: value is not available
 >> kern.update: no such MIB
 >> kern.osreldate: no such MIB
 >> kern.ntp_pll: no such MIB
 >> kern.bootfile: no such MIB
 >> kern.dumpdev: no such MIB
 >> kern.ipc: no such MIB
 >> kern.dummy: no such MIB
 >> kern.dummy: no such MIB
 >> kern.logsigexit: no such MIB
 >> kern.symfile: Input/output error
 >> kern.procargs: Invalid argument
 >> kern.dummy: no such MIB
 >> kern.panicinfo: no such MIB
 >> kern.sysv: no such MIB
 >> kern.dummy: no such MIB
 >> kern.dummy: no such MIB
 >> kern.procargs2: Invalid argument
 >> kern.proc_low_pri_io: no such MIB
 >> kern.low_pri_window: no such MIB
 >> kern.low_pri_delay: no such MIB
 >> kern.posix: no such MIB
 >> kern.tfp: no such MIB
 >> kern.threadsigaltstack: no such MIB
 >> kern.lctx: no such MIB
 >> kern.tty: no such MIB
 >> kern.check_openevt: Invalid argument
 >> vm.vmmeter: no such MIB
 >> vm.dummy: no such MIB
 >> hw.disknames: no such MIB
 >> hw.diskstats: no such MIB
 >> hw.floatingpoint: no such MIB
 >> hw.machinearch: no such MIB
 >> kern.maxfiles = 12288
 >> kern.maxfilesperproc = 10240
 >> kern.maxfiles: 12288
 >> kern.maxfilesperproc: 10240
 >>
 >> On Mon, Oct 21, 2013 at 9:45 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >> > And, just to be sure, you've set your descriptors limit on Mac OS X to
 >> > 10000s?
 >> >
 >> > The default setting is normally 256 or so, which would be reached
 >> > easily with 100 places running at the same time. I get a "Too many open
 >> > files" error quickly when I try the program on my machine. When I raise
 >> > the descriptors limit to 10000, then Racket hits an uncomfortable
 >> > amount of memory (so that I kill it) before a "Too many open files"
 >> > error.
 >> >
 >> > At Mon, 21 Oct 2013 09:32:13 -0700, Eric Dobson wrote:
 >> >> Well, I messed up the example so it did have that issue, but shouldn't
 >> >> create an infinite number of places. I knew that was an issue which is
 >> >> why I used the two files, but still didn't actually avoid the issue.
 >> >> Here is a simpler one that uses submodules and still has the bug:
 >> >>
 >> >> #lang racket
 >> >>
 >> >>
 >> >> (define (run chan)
 >> >>   (let loop ()
 >> >>     (eval-syntax
 >> >>       #'(module x racket))
 >> >>     (loop)))
 >> >>
 >> >> (define (go)
 >> >>   (place chan (run chan)))
 >> >>
 >> >> (module+ main
 >> >>   (for ((i 100))
 >> >>     (go))
 >> >>   (sync never-evt))
 >> >>
 >> >>
 >> >> On Mon, Oct 21, 2013 at 5:14 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >> >> > Unless I'm confused about the example, the report is really "it's too
 >> >> > easy to request an infinite number of places".
 >> >> >
 >> >> > Here's an even simpler variant:
 >> >> >
 >> >> >  #lang racket
 >> >> >  (place p 1)
 >> >> >  (sync never-evt)
 >> >> >
 >> >> > The `place` form runs the enclosing module in the next place, which
 >> >> > runs the enclosing module in another new place, and so on. I believe
 >> >> > the same thing happens with "tmp2.rkt" below.
 >> >> >
 >> >> > The usual solution is to put `place` inside a function that is called
 >> >> > from a `main` submodule. That way, the surrounding module for `place`
 >> >> > doesn't call the function that contains `place`.
 >> >> >
 >> >> >  #lang racket
 >> >> >
 >> >> >  (require "tmp.rkt")
 >> >> >
 >> >> >  (define (go)
 >> >> >    (for ((i 1))
 >> >> >      (place chan (run chan)))
 >> >> >    (sync never-evt))
 >> >> >
 >> >> >  (module+ main
 >> >> >    (go))
 >> >> >
 >> >> >
 >> >> >
 >> >> > At Sun, 20 Oct 2013 23:59:33 -0700, Eric Dobson wrote:
 >> >> >> Replicated with a small example. I once got a malloc error, but
 >> >> >> couldn't replicate that.
 >> >> >>
 >> >> >> tmp.rkt:
 >> >> >> #lang racket
 >> >> >>
 >> >> >> (provide run)
 >> >> >>
 >> >> >> (define (run chan)
 >> >> >>   (let loop ()
 >> >> >>     (eval-syntax
 >> >> >>       #'(module x racket))
 >> >> >>     (loop)))
 >> >> >>
 >> >> >> tmp2.rkt:
 >> >> >> #lang racket
 >> >> >>
 >> >> >> (require "tmp.rkt")
 >> >> >>
 >> >> >> (for ((i 1))
 >> >> >>   (place chan (run chan)))
 >> >> >> (sync never-evt)
 >> >> >>
 >> >> >>
 >> >> >> Then "racket tmp2.rkt", and wait about 15-30 seconds, till it hits the
 >> >> >> error. Increasing the number of places makes it faster.
 >> >> >>
 >> >> >>
 >> >> >> On Sun, Oct 20, 2013 at 6:33 PM, Eric Dobson <eric.n.dobson@gmail.com>
 >> >> wrote:
 >> >> >> > Yes, something seemed fishy. The number of threads should be
 >> >> >> > irrelevant since the places are what actually run the code, and the
 >> >> >> > threads are just for making things work concurrently (not in
 >> >> >> > parallel). The file limit on OS X is ~10000, so it looked like files
 >> >> >> > were not getting closed.
 >> >> >> >
 >> >> >> > I noticed this because I changed the code under test in TR and this
 >> >> >> > started breaking, but if I lowered the number of places it continues
 >> >> >> > to work.
 >> >> >> >
 >> >> >> > I'll try to reduce the test case, and post back in a day or two when I
 >> >> >> > get the time.
 >> >> >> >
 >> >> >> > On Sun, Oct 20, 2013 at 6:21 PM, Robby Findler
 >> >> >> > <robby@eecs.northwestern.edu> wrote:
 >> >> >> >> Something seems fishy: when you have 4 places running doing lots of zo
 >> >> file
 >> >> >> >> reading, won't they have at most 4 files open at once? Or is it that
 >> >> you're
 >> >> >> >> using threads too?
 >> >> >> >>
 >> >> >> >> Robby
 >> >> >> >>
 >> >> >> >>
 >> >> >> >> On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 >> >> >> >>>
 >> >> >> >>> A new problem report is waiting at
 >> >> >> >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 >> >> >> >>>
 >> >> >> >>> Reported by Eric Dobson for release: HEAD
 >> >> >> >>>
 >> >> >> >>> *** Description:
 >> >> >> >>> During testing TR we want to run multiple programs at once, which we
 >> do
 >> >> >> >>> using places. The issue is that this means that each place must
 >> reopen
 >> >> >> files
 >> >> >> >>> that the other places have open leading to hitting the limit of
 >> racket.
 >> >> >> Most
 >> >> >> >>> of these files are zo files and other racket implementation details.
 >> >> >> >>>
 >> >> >> >>> OS: OSX 10.8.5
 >> >> >> >>> Machine: MacProRetina with 4 hyperthreaded cores.
 >> >> >> >>>
 >> >> >> >>>
 >> >> >> >>> *** How to repeat:
 >> >> >> >>> Edit transform.rkt in
 >> >> >> >>>
 >> pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer,
 >> >> and
 >> >> >> >>> add the line "(places 20)" above start workers, and then run "racket
 >> >> >> >>> transform.rkt" from that directory.
 >> >> >> >>>
 >> >> >> >>> *** Environment:
 >> >> >> >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 >> >> >> >>> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2
 >> Safari/537.28
 >> >> >> >>>
 >> >> >> >>
From: Matthew Flatt <mflatt@cs.utah.edu>
To: Eric Dobson <eric.n.dobson@gmail.com>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Mon, 21 Oct 2013 11:16:30 -0600

 I'd have trouble tracking them all down. There will be 3 for stdio, and
 1-2 for basic scheduling tasks, and I think 2-3 for filesystem-change
 events, but that's only half-way to 12.
 
 Even though I don't know offhand what would use all 12 descriptors,
 it's the right order of magnitude, so it seems ok as long as there's no
 a leak (i.e., you should be able to create and end places all day).
 
 At Mon, 21 Oct 2013 10:10:40 -0700, Eric Dobson wrote:
 > Ok, yes that is still at 256. Testing with changing the numbers I see
 > that it runs at 20 for a reasonable amount of time without erroring
 > and 21 fails almost instantly. Thus it is not a leak as I suspected,
 > Does 12 files open per place seem like a reasonable number?
 > 
 > On Mon, Oct 21, 2013 at 10:01 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > > The system-wide hard limit is probably not as relevant as the
 > > process-inherited current limit.
 > >
 > > What do you get for `ulimit -n`? I get 256 by default:
 > >
 > >  laptop% ulimit -n
 > >  256
 > >
 > >
 > > At Mon, 21 Oct 2013 09:55:48 -0700, Eric Dobson wrote:
 > >> No. 10000 is the default.
 > >>
 > >> endobson@yggdrasil () ~ % sysctl -A | grep kern.maxfiles
 > >>
 > >>
 > >>                      (0)
 > >> Use pstat to view kern.vnode information
 > >> Use ps to view kern.proc information
 > >> Use pstat to view kern.file information
 > >> kernel is not compiled for profiling
 > >> kern.maxpartitions: no such MIB
 > >> kern.kdebug: value is not available
 > >> kern.update: no such MIB
 > >> kern.osreldate: no such MIB
 > >> kern.ntp_pll: no such MIB
 > >> kern.bootfile: no such MIB
 > >> kern.dumpdev: no such MIB
 > >> kern.ipc: no such MIB
 > >> kern.dummy: no such MIB
 > >> kern.dummy: no such MIB
 > >> kern.logsigexit: no such MIB
 > >> kern.symfile: Input/output error
 > >> kern.procargs: Invalid argument
 > >> kern.dummy: no such MIB
 > >> kern.panicinfo: no such MIB
 > >> kern.sysv: no such MIB
 > >> kern.dummy: no such MIB
 > >> kern.dummy: no such MIB
 > >> kern.procargs2: Invalid argument
 > >> kern.proc_low_pri_io: no such MIB
 > >> kern.low_pri_window: no such MIB
 > >> kern.low_pri_delay: no such MIB
 > >> kern.posix: no such MIB
 > >> kern.tfp: no such MIB
 > >> kern.threadsigaltstack: no such MIB
 > >> kern.lctx: no such MIB
 > >> kern.tty: no such MIB
 > >> kern.check_openevt: Invalid argument
 > >> vm.vmmeter: no such MIB
 > >> vm.dummy: no such MIB
 > >> hw.disknames: no such MIB
 > >> hw.diskstats: no such MIB
 > >> hw.floatingpoint: no such MIB
 > >> hw.machinearch: no such MIB
 > >> kern.maxfiles = 12288
 > >> kern.maxfilesperproc = 10240
 > >> kern.maxfiles: 12288
 > >> kern.maxfilesperproc: 10240
 > >>
 > >> On Mon, Oct 21, 2013 at 9:45 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > >> > And, just to be sure, you've set your descriptors limit on Mac OS X to
 > >> > 10000s?
 > >> >
 > >> > The default setting is normally 256 or so, which would be reached
 > >> > easily with 100 places running at the same time. I get a "Too many open
 > >> > files" error quickly when I try the program on my machine. When I raise
 > >> > the descriptors limit to 10000, then Racket hits an uncomfortable
 > >> > amount of memory (so that I kill it) before a "Too many open files"
 > >> > error.
 > >> >
 > >> > At Mon, 21 Oct 2013 09:32:13 -0700, Eric Dobson wrote:
 > >> >> Well, I messed up the example so it did have that issue, but shouldn't
 > >> >> create an infinite number of places. I knew that was an issue which is
 > >> >> why I used the two files, but still didn't actually avoid the issue.
 > >> >> Here is a simpler one that uses submodules and still has the bug:
 > >> >>
 > >> >> #lang racket
 > >> >>
 > >> >>
 > >> >> (define (run chan)
 > >> >>   (let loop ()
 > >> >>     (eval-syntax
 > >> >>       #'(module x racket))
 > >> >>     (loop)))
 > >> >>
 > >> >> (define (go)
 > >> >>   (place chan (run chan)))
 > >> >>
 > >> >> (module+ main
 > >> >>   (for ((i 100))
 > >> >>     (go))
 > >> >>   (sync never-evt))
 > >> >>
 > >> >>
 > >> >> On Mon, Oct 21, 2013 at 5:14 AM, Matthew Flatt <mflatt@cs.utah.edu> 
 > wrote:
 > >> >> > Unless I'm confused about the example, the report is really "it's too
 > >> >> > easy to request an infinite number of places".
 > >> >> >
 > >> >> > Here's an even simpler variant:
 > >> >> >
 > >> >> >  #lang racket
 > >> >> >  (place p 1)
 > >> >> >  (sync never-evt)
 > >> >> >
 > >> >> > The `place` form runs the enclosing module in the next place, which
 > >> >> > runs the enclosing module in another new place, and so on. I believe
 > >> >> > the same thing happens with "tmp2.rkt" below.
 > >> >> >
 > >> >> > The usual solution is to put `place` inside a function that is called
 > >> >> > from a `main` submodule. That way, the surrounding module for `place`
 > >> >> > doesn't call the function that contains `place`.
 > >> >> >
 > >> >> >  #lang racket
 > >> >> >
 > >> >> >  (require "tmp.rkt")
 > >> >> >
 > >> >> >  (define (go)
 > >> >> >    (for ((i 1))
 > >> >> >      (place chan (run chan)))
 > >> >> >    (sync never-evt))
 > >> >> >
 > >> >> >  (module+ main
 > >> >> >    (go))
 > >> >> >
 > >> >> >
 > >> >> >
 > >> >> > At Sun, 20 Oct 2013 23:59:33 -0700, Eric Dobson wrote:
 > >> >> >> Replicated with a small example. I once got a malloc error, but
 > >> >> >> couldn't replicate that.
 > >> >> >>
 > >> >> >> tmp.rkt:
 > >> >> >> #lang racket
 > >> >> >>
 > >> >> >> (provide run)
 > >> >> >>
 > >> >> >> (define (run chan)
 > >> >> >>   (let loop ()
 > >> >> >>     (eval-syntax
 > >> >> >>       #'(module x racket))
 > >> >> >>     (loop)))
 > >> >> >>
 > >> >> >> tmp2.rkt:
 > >> >> >> #lang racket
 > >> >> >>
 > >> >> >> (require "tmp.rkt")
 > >> >> >>
 > >> >> >> (for ((i 1))
 > >> >> >>   (place chan (run chan)))
 > >> >> >> (sync never-evt)
 > >> >> >>
 > >> >> >>
 > >> >> >> Then "racket tmp2.rkt", and wait about 15-30 seconds, till it hits the
 > >> >> >> error. Increasing the number of places makes it faster.
 > >> >> >>
 > >> >> >>
 > >> >> >> On Sun, Oct 20, 2013 at 6:33 PM, Eric Dobson <eric.n.dobson@gmail.com>
 > >> >> wrote:
 > >> >> >> > Yes, something seemed fishy. The number of threads should be
 > >> >> >> > irrelevant since the places are what actually run the code, and the
 > >> >> >> > threads are just for making things work concurrently (not in
 > >> >> >> > parallel). The file limit on OS X is ~10000, so it looked like files
 > >> >> >> > were not getting closed.
 > >> >> >> >
 > >> >> >> > I noticed this because I changed the code under test in TR and this
 > >> >> >> > started breaking, but if I lowered the number of places it continues
 > >> >> >> > to work.
 > >> >> >> >
 > >> >> >> > I'll try to reduce the test case, and post back in a day or two 
 > when I
 > >> >> >> > get the time.
 > >> >> >> >
 > >> >> >> > On Sun, Oct 20, 2013 at 6:21 PM, Robby Findler
 > >> >> >> > <robby@eecs.northwestern.edu> wrote:
 > >> >> >> >> Something seems fishy: when you have 4 places running doing lots 
 > of zo
 > >> >> file
 > >> >> >> >> reading, won't they have at most 4 files open at once? Or is it 
 > that
 > >> >> you're
 > >> >> >> >> using threads too?
 > >> >> >> >>
 > >> >> >> >> Robby
 > >> >> >> >>
 > >> >> >> >>
 > >> >> >> >> On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 > >> >> >> >>>
 > >> >> >> >>> A new problem report is waiting at
 > >> >> >> >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 > >> >> >> >>>
 > >> >> >> >>> Reported by Eric Dobson for release: HEAD
 > >> >> >> >>>
 > >> >> >> >>> *** Description:
 > >> >> >> >>> During testing TR we want to run multiple programs at once, which 
 > we
 > >> do
 > >> >> >> >>> using places. The issue is that this means that each place must
 > >> reopen
 > >> >> >> files
 > >> >> >> >>> that the other places have open leading to hitting the limit of
 > >> racket.
 > >> >> >> Most
 > >> >> >> >>> of these files are zo files and other racket implementation 
 > details.
 > >> >> >> >>>
 > >> >> >> >>> OS: OSX 10.8.5
 > >> >> >> >>> Machine: MacProRetina with 4 hyperthreaded cores.
 > >> >> >> >>>
 > >> >> >> >>>
 > >> >> >> >>> *** How to repeat:
 > >> >> >> >>> Edit transform.rkt in
 > >> >> >> >>>
 > >> pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer,
 > >> >> and
 > >> >> >> >>> add the line "(places 20)" above start workers, and then run 
 > "racket
 > >> >> >> >>> transform.rkt" from that directory.
 > >> >> >> >>>
 > >> >> >> >>> *** Environment:
 > >> >> >> >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 > >> >> >> >>> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2
 > >> Safari/537.28
 > >> >> >> >>>
 > >> >> >> >>
From: Eric Dobson <eric.n.dobson@gmail.com>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Mon, 21 Oct 2013 10:31:16 -0700

 Ok, so this doesn't explain why the original program is seeing the
 issue though because in that there are just 9 places (8 for tasks and
 1 main one for scheduling), and that shouldn't have the issue of
 opening infinite places. I'll try to investigate and see what I find.
 
 On Mon, Oct 21, 2013 at 10:16 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 > I'd have trouble tracking them all down. There will be 3 for stdio, and
 > 1-2 for basic scheduling tasks, and I think 2-3 for filesystem-change
 > events, but that's only half-way to 12.
 >
 > Even though I don't know offhand what would use all 12 descriptors,
 > it's the right order of magnitude, so it seems ok as long as there's no
 > a leak (i.e., you should be able to create and end places all day).
 >
 > At Mon, 21 Oct 2013 10:10:40 -0700, Eric Dobson wrote:
 >> Ok, yes that is still at 256. Testing with changing the numbers I see
 >> that it runs at 20 for a reasonable amount of time without erroring
 >> and 21 fails almost instantly. Thus it is not a leak as I suspected,
 >> Does 12 files open per place seem like a reasonable number?
 >>
 >> On Mon, Oct 21, 2013 at 10:01 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >> > The system-wide hard limit is probably not as relevant as the
 >> > process-inherited current limit.
 >> >
 >> > What do you get for `ulimit -n`? I get 256 by default:
 >> >
 >> >  laptop% ulimit -n
 >> >  256
 >> >
 >> >
 >> > At Mon, 21 Oct 2013 09:55:48 -0700, Eric Dobson wrote:
 >> >> No. 10000 is the default.
 >> >>
 >> >> endobson@yggdrasil () ~ % sysctl -A | grep kern.maxfiles
 >> >>
 >> >>
 >> >>                      (0)
 >> >> Use pstat to view kern.vnode information
 >> >> Use ps to view kern.proc information
 >> >> Use pstat to view kern.file information
 >> >> kernel is not compiled for profiling
 >> >> kern.maxpartitions: no such MIB
 >> >> kern.kdebug: value is not available
 >> >> kern.update: no such MIB
 >> >> kern.osreldate: no such MIB
 >> >> kern.ntp_pll: no such MIB
 >> >> kern.bootfile: no such MIB
 >> >> kern.dumpdev: no such MIB
 >> >> kern.ipc: no such MIB
 >> >> kern.dummy: no such MIB
 >> >> kern.dummy: no such MIB
 >> >> kern.logsigexit: no such MIB
 >> >> kern.symfile: Input/output error
 >> >> kern.procargs: Invalid argument
 >> >> kern.dummy: no such MIB
 >> >> kern.panicinfo: no such MIB
 >> >> kern.sysv: no such MIB
 >> >> kern.dummy: no such MIB
 >> >> kern.dummy: no such MIB
 >> >> kern.procargs2: Invalid argument
 >> >> kern.proc_low_pri_io: no such MIB
 >> >> kern.low_pri_window: no such MIB
 >> >> kern.low_pri_delay: no such MIB
 >> >> kern.posix: no such MIB
 >> >> kern.tfp: no such MIB
 >> >> kern.threadsigaltstack: no such MIB
 >> >> kern.lctx: no such MIB
 >> >> kern.tty: no such MIB
 >> >> kern.check_openevt: Invalid argument
 >> >> vm.vmmeter: no such MIB
 >> >> vm.dummy: no such MIB
 >> >> hw.disknames: no such MIB
 >> >> hw.diskstats: no such MIB
 >> >> hw.floatingpoint: no such MIB
 >> >> hw.machinearch: no such MIB
 >> >> kern.maxfiles = 12288
 >> >> kern.maxfilesperproc = 10240
 >> >> kern.maxfiles: 12288
 >> >> kern.maxfilesperproc: 10240
 >> >>
 >> >> On Mon, Oct 21, 2013 at 9:45 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >> >> > And, just to be sure, you've set your descriptors limit on Mac OS X to
 >> >> > 10000s?
 >> >> >
 >> >> > The default setting is normally 256 or so, which would be reached
 >> >> > easily with 100 places running at the same time. I get a "Too many open
 >> >> > files" error quickly when I try the program on my machine. When I raise
 >> >> > the descriptors limit to 10000, then Racket hits an uncomfortable
 >> >> > amount of memory (so that I kill it) before a "Too many open files"
 >> >> > error.
 >> >> >
 >> >> > At Mon, 21 Oct 2013 09:32:13 -0700, Eric Dobson wrote:
 >> >> >> Well, I messed up the example so it did have that issue, but shouldn't
 >> >> >> create an infinite number of places. I knew that was an issue which is
 >> >> >> why I used the two files, but still didn't actually avoid the issue.
 >> >> >> Here is a simpler one that uses submodules and still has the bug:
 >> >> >>
 >> >> >> #lang racket
 >> >> >>
 >> >> >>
 >> >> >> (define (run chan)
 >> >> >>   (let loop ()
 >> >> >>     (eval-syntax
 >> >> >>       #'(module x racket))
 >> >> >>     (loop)))
 >> >> >>
 >> >> >> (define (go)
 >> >> >>   (place chan (run chan)))
 >> >> >>
 >> >> >> (module+ main
 >> >> >>   (for ((i 100))
 >> >> >>     (go))
 >> >> >>   (sync never-evt))
 >> >> >>
 >> >> >>
 >> >> >> On Mon, Oct 21, 2013 at 5:14 AM, Matthew Flatt <mflatt@cs.utah.edu>
 >> wrote:
 >> >> >> > Unless I'm confused about the example, the report is really "it's too
 >> >> >> > easy to request an infinite number of places".
 >> >> >> >
 >> >> >> > Here's an even simpler variant:
 >> >> >> >
 >> >> >> >  #lang racket
 >> >> >> >  (place p 1)
 >> >> >> >  (sync never-evt)
 >> >> >> >
 >> >> >> > The `place` form runs the enclosing module in the next place, which
 >> >> >> > runs the enclosing module in another new place, and so on. I believe
 >> >> >> > the same thing happens with "tmp2.rkt" below.
 >> >> >> >
 >> >> >> > The usual solution is to put `place` inside a function that is called
 >> >> >> > from a `main` submodule. That way, the surrounding module for `place`
 >> >> >> > doesn't call the function that contains `place`.
 >> >> >> >
 >> >> >> >  #lang racket
 >> >> >> >
 >> >> >> >  (require "tmp.rkt")
 >> >> >> >
 >> >> >> >  (define (go)
 >> >> >> >    (for ((i 1))
 >> >> >> >      (place chan (run chan)))
 >> >> >> >    (sync never-evt))
 >> >> >> >
 >> >> >> >  (module+ main
 >> >> >> >    (go))
 >> >> >> >
 >> >> >> >
 >> >> >> >
 >> >> >> > At Sun, 20 Oct 2013 23:59:33 -0700, Eric Dobson wrote:
 >> >> >> >> Replicated with a small example. I once got a malloc error, but
 >> >> >> >> couldn't replicate that.
 >> >> >> >>
 >> >> >> >> tmp.rkt:
 >> >> >> >> #lang racket
 >> >> >> >>
 >> >> >> >> (provide run)
 >> >> >> >>
 >> >> >> >> (define (run chan)
 >> >> >> >>   (let loop ()
 >> >> >> >>     (eval-syntax
 >> >> >> >>       #'(module x racket))
 >> >> >> >>     (loop)))
 >> >> >> >>
 >> >> >> >> tmp2.rkt:
 >> >> >> >> #lang racket
 >> >> >> >>
 >> >> >> >> (require "tmp.rkt")
 >> >> >> >>
 >> >> >> >> (for ((i 1))
 >> >> >> >>   (place chan (run chan)))
 >> >> >> >> (sync never-evt)
 >> >> >> >>
 >> >> >> >>
 >> >> >> >> Then "racket tmp2.rkt", and wait about 15-30 seconds, till it hits the
 >> >> >> >> error. Increasing the number of places makes it faster.
 >> >> >> >>
 >> >> >> >>
 >> >> >> >> On Sun, Oct 20, 2013 at 6:33 PM, Eric Dobson <eric.n.dobson@gmail.com>
 >> >> >> wrote:
 >> >> >> >> > Yes, something seemed fishy. The number of threads should be
 >> >> >> >> > irrelevant since the places are what actually run the code, and the
 >> >> >> >> > threads are just for making things work concurrently (not in
 >> >> >> >> > parallel). The file limit on OS X is ~10000, so it looked like files
 >> >> >> >> > were not getting closed.
 >> >> >> >> >
 >> >> >> >> > I noticed this because I changed the code under test in TR and this
 >> >> >> >> > started breaking, but if I lowered the number of places it continues
 >> >> >> >> > to work.
 >> >> >> >> >
 >> >> >> >> > I'll try to reduce the test case, and post back in a day or two
 >> when I
 >> >> >> >> > get the time.
 >> >> >> >> >
 >> >> >> >> > On Sun, Oct 20, 2013 at 6:21 PM, Robby Findler
 >> >> >> >> > <robby@eecs.northwestern.edu> wrote:
 >> >> >> >> >> Something seems fishy: when you have 4 places running doing lots
 >> of zo
 >> >> >> file
 >> >> >> >> >> reading, won't they have at most 4 files open at once? Or is it
 >> that
 >> >> >> you're
 >> >> >> >> >> using threads too?
 >> >> >> >> >>
 >> >> >> >> >> Robby
 >> >> >> >> >>
 >> >> >> >> >>
 >> >> >> >> >> On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 >> >> >> >> >>>
 >> >> >> >> >>> A new problem report is waiting at
 >> >> >> >> >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 >> >> >> >> >>>
 >> >> >> >> >>> Reported by Eric Dobson for release: HEAD
 >> >> >> >> >>>
 >> >> >> >> >>> *** Description:
 >> >> >> >> >>> During testing TR we want to run multiple programs at once, which
 >> we
 >> >> do
 >> >> >> >> >>> using places. The issue is that this means that each place must
 >> >> reopen
 >> >> >> >> files
 >> >> >> >> >>> that the other places have open leading to hitting the limit of
 >> >> racket.
 >> >> >> >> Most
 >> >> >> >> >>> of these files are zo files and other racket implementation
 >> details.
 >> >> >> >> >>>
 >> >> >> >> >>> OS: OSX 10.8.5
 >> >> >> >> >>> Machine: MacProRetina with 4 hyperthreaded cores.
 >> >> >> >> >>>
 >> >> >> >> >>>
 >> >> >> >> >>> *** How to repeat:
 >> >> >> >> >>> Edit transform.rkt in
 >> >> >> >> >>>
 >> >> pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer,
 >> >> >> and
 >> >> >> >> >>> add the line "(places 20)" above start workers, and then run
 >> "racket
 >> >> >> >> >>> transform.rkt" from that directory.
 >> >> >> >> >>>
 >> >> >> >> >>> *** Environment:
 >> >> >> >> >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 >> >> >> >> >>> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2
 >> >> Safari/537.28
 >> >> >> >> >>>
 >> >> >> >> >>

Class changed from "sw-bug" to "not-a-bug" by endobson at Tue, 22 Oct 2013 00:14:53 -0400
Reason>>> User error.

From: Eric Dobson <eric.n.dobson@gmail.com>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs <bugs@racket-lang.org>,
        nobody <nobody@racket-lang.org>,
        bug-notification <bug-notification@racket-lang.org>
Subject: Re: [racket-bug] all/14111: It is too easy to hit the maximum number
 of files open in Racket
Date: Mon, 21 Oct 2013 21:14:19 -0700

 The original problem was programmer error. While garbage collection
 will collect open files, it shouldn't be relied upon because it cleans
 up when there is memory pressure not presure on file descriptors.
 
 On Mon, Oct 21, 2013 at 10:31 AM, Eric Dobson <eric.n.dobson@gmail.com> wrote:
 > Ok, so this doesn't explain why the original program is seeing the
 > issue though because in that there are just 9 places (8 for tasks and
 > 1 main one for scheduling), and that shouldn't have the issue of
 > opening infinite places. I'll try to investigate and see what I find.
 >
 > On Mon, Oct 21, 2013 at 10:16 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >> I'd have trouble tracking them all down. There will be 3 for stdio, and
 >> 1-2 for basic scheduling tasks, and I think 2-3 for filesystem-change
 >> events, but that's only half-way to 12.
 >>
 >> Even though I don't know offhand what would use all 12 descriptors,
 >> it's the right order of magnitude, so it seems ok as long as there's no
 >> a leak (i.e., you should be able to create and end places all day).
 >>
 >> At Mon, 21 Oct 2013 10:10:40 -0700, Eric Dobson wrote:
 >>> Ok, yes that is still at 256. Testing with changing the numbers I see
 >>> that it runs at 20 for a reasonable amount of time without erroring
 >>> and 21 fails almost instantly. Thus it is not a leak as I suspected,
 >>> Does 12 files open per place seem like a reasonable number?
 >>>
 >>> On Mon, Oct 21, 2013 at 10:01 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>> > The system-wide hard limit is probably not as relevant as the
 >>> > process-inherited current limit.
 >>> >
 >>> > What do you get for `ulimit -n`? I get 256 by default:
 >>> >
 >>> >  laptop% ulimit -n
 >>> >  256
 >>> >
 >>> >
 >>> > At Mon, 21 Oct 2013 09:55:48 -0700, Eric Dobson wrote:
 >>> >> No. 10000 is the default.
 >>> >>
 >>> >> endobson@yggdrasil () ~ % sysctl -A | grep kern.maxfiles
 >>> >>
 >>> >>
 >>> >>                      (0)
 >>> >> Use pstat to view kern.vnode information
 >>> >> Use ps to view kern.proc information
 >>> >> Use pstat to view kern.file information
 >>> >> kernel is not compiled for profiling
 >>> >> kern.maxpartitions: no such MIB
 >>> >> kern.kdebug: value is not available
 >>> >> kern.update: no such MIB
 >>> >> kern.osreldate: no such MIB
 >>> >> kern.ntp_pll: no such MIB
 >>> >> kern.bootfile: no such MIB
 >>> >> kern.dumpdev: no such MIB
 >>> >> kern.ipc: no such MIB
 >>> >> kern.dummy: no such MIB
 >>> >> kern.dummy: no such MIB
 >>> >> kern.logsigexit: no such MIB
 >>> >> kern.symfile: Input/output error
 >>> >> kern.procargs: Invalid argument
 >>> >> kern.dummy: no such MIB
 >>> >> kern.panicinfo: no such MIB
 >>> >> kern.sysv: no such MIB
 >>> >> kern.dummy: no such MIB
 >>> >> kern.dummy: no such MIB
 >>> >> kern.procargs2: Invalid argument
 >>> >> kern.proc_low_pri_io: no such MIB
 >>> >> kern.low_pri_window: no such MIB
 >>> >> kern.low_pri_delay: no such MIB
 >>> >> kern.posix: no such MIB
 >>> >> kern.tfp: no such MIB
 >>> >> kern.threadsigaltstack: no such MIB
 >>> >> kern.lctx: no such MIB
 >>> >> kern.tty: no such MIB
 >>> >> kern.check_openevt: Invalid argument
 >>> >> vm.vmmeter: no such MIB
 >>> >> vm.dummy: no such MIB
 >>> >> hw.disknames: no such MIB
 >>> >> hw.diskstats: no such MIB
 >>> >> hw.floatingpoint: no such MIB
 >>> >> hw.machinearch: no such MIB
 >>> >> kern.maxfiles = 12288
 >>> >> kern.maxfilesperproc = 10240
 >>> >> kern.maxfiles: 12288
 >>> >> kern.maxfilesperproc: 10240
 >>> >>
 >>> >> On Mon, Oct 21, 2013 at 9:45 AM, Matthew Flatt <mflatt@cs.utah.edu> wrote:
 >>> >> > And, just to be sure, you've set your descriptors limit on Mac OS X to
 >>> >> > 10000s?
 >>> >> >
 >>> >> > The default setting is normally 256 or so, which would be reached
 >>> >> > easily with 100 places running at the same time. I get a "Too many open
 >>> >> > files" error quickly when I try the program on my machine. When I raise
 >>> >> > the descriptors limit to 10000, then Racket hits an uncomfortable
 >>> >> > amount of memory (so that I kill it) before a "Too many open files"
 >>> >> > error.
 >>> >> >
 >>> >> > At Mon, 21 Oct 2013 09:32:13 -0700, Eric Dobson wrote:
 >>> >> >> Well, I messed up the example so it did have that issue, but shouldn't
 >>> >> >> create an infinite number of places. I knew that was an issue which is
 >>> >> >> why I used the two files, but still didn't actually avoid the issue.
 >>> >> >> Here is a simpler one that uses submodules and still has the bug:
 >>> >> >>
 >>> >> >> #lang racket
 >>> >> >>
 >>> >> >>
 >>> >> >> (define (run chan)
 >>> >> >>   (let loop ()
 >>> >> >>     (eval-syntax
 >>> >> >>       #'(module x racket))
 >>> >> >>     (loop)))
 >>> >> >>
 >>> >> >> (define (go)
 >>> >> >>   (place chan (run chan)))
 >>> >> >>
 >>> >> >> (module+ main
 >>> >> >>   (for ((i 100))
 >>> >> >>     (go))
 >>> >> >>   (sync never-evt))
 >>> >> >>
 >>> >> >>
 >>> >> >> On Mon, Oct 21, 2013 at 5:14 AM, Matthew Flatt <mflatt@cs.utah.edu>
 >>> wrote:
 >>> >> >> > Unless I'm confused about the example, the report is really "it's too
 >>> >> >> > easy to request an infinite number of places".
 >>> >> >> >
 >>> >> >> > Here's an even simpler variant:
 >>> >> >> >
 >>> >> >> >  #lang racket
 >>> >> >> >  (place p 1)
 >>> >> >> >  (sync never-evt)
 >>> >> >> >
 >>> >> >> > The `place` form runs the enclosing module in the next place, which
 >>> >> >> > runs the enclosing module in another new place, and so on. I believe
 >>> >> >> > the same thing happens with "tmp2.rkt" below.
 >>> >> >> >
 >>> >> >> > The usual solution is to put `place` inside a function that is called
 >>> >> >> > from a `main` submodule. That way, the surrounding module for `place`
 >>> >> >> > doesn't call the function that contains `place`.
 >>> >> >> >
 >>> >> >> >  #lang racket
 >>> >> >> >
 >>> >> >> >  (require "tmp.rkt")
 >>> >> >> >
 >>> >> >> >  (define (go)
 >>> >> >> >    (for ((i 1))
 >>> >> >> >      (place chan (run chan)))
 >>> >> >> >    (sync never-evt))
 >>> >> >> >
 >>> >> >> >  (module+ main
 >>> >> >> >    (go))
 >>> >> >> >
 >>> >> >> >
 >>> >> >> >
 >>> >> >> > At Sun, 20 Oct 2013 23:59:33 -0700, Eric Dobson wrote:
 >>> >> >> >> Replicated with a small example. I once got a malloc error, but
 >>> >> >> >> couldn't replicate that.
 >>> >> >> >>
 >>> >> >> >> tmp.rkt:
 >>> >> >> >> #lang racket
 >>> >> >> >>
 >>> >> >> >> (provide run)
 >>> >> >> >>
 >>> >> >> >> (define (run chan)
 >>> >> >> >>   (let loop ()
 >>> >> >> >>     (eval-syntax
 >>> >> >> >>       #'(module x racket))
 >>> >> >> >>     (loop)))
 >>> >> >> >>
 >>> >> >> >> tmp2.rkt:
 >>> >> >> >> #lang racket
 >>> >> >> >>
 >>> >> >> >> (require "tmp.rkt")
 >>> >> >> >>
 >>> >> >> >> (for ((i 1))
 >>> >> >> >>   (place chan (run chan)))
 >>> >> >> >> (sync never-evt)
 >>> >> >> >>
 >>> >> >> >>
 >>> >> >> >> Then "racket tmp2.rkt", and wait about 15-30 seconds, till it hits the
 >>> >> >> >> error. Increasing the number of places makes it faster.
 >>> >> >> >>
 >>> >> >> >>
 >>> >> >> >> On Sun, Oct 20, 2013 at 6:33 PM, Eric Dobson <eric.n.dobson@gmail.com>
 >>> >> >> wrote:
 >>> >> >> >> > Yes, something seemed fishy. The number of threads should be
 >>> >> >> >> > irrelevant since the places are what actually run the code, and the
 >>> >> >> >> > threads are just for making things work concurrently (not in
 >>> >> >> >> > parallel). The file limit on OS X is ~10000, so it looked like files
 >>> >> >> >> > were not getting closed.
 >>> >> >> >> >
 >>> >> >> >> > I noticed this because I changed the code under test in TR and this
 >>> >> >> >> > started breaking, but if I lowered the number of places it continues
 >>> >> >> >> > to work.
 >>> >> >> >> >
 >>> >> >> >> > I'll try to reduce the test case, and post back in a day or two
 >>> when I
 >>> >> >> >> > get the time.
 >>> >> >> >> >
 >>> >> >> >> > On Sun, Oct 20, 2013 at 6:21 PM, Robby Findler
 >>> >> >> >> > <robby@eecs.northwestern.edu> wrote:
 >>> >> >> >> >> Something seems fishy: when you have 4 places running doing lots
 >>> of zo
 >>> >> >> file
 >>> >> >> >> >> reading, won't they have at most 4 files open at once? Or is it
 >>> that
 >>> >> >> you're
 >>> >> >> >> >> using threads too?
 >>> >> >> >> >>
 >>> >> >> >> >> Robby
 >>> >> >> >> >>
 >>> >> >> >> >>
 >>> >> >> >> >> On Sun, Oct 20, 2013 at 8:12 PM, <eric.n.dobson@gmail.com> wrote:
 >>> >> >> >> >>>
 >>> >> >> >> >>> A new problem report is waiting at
 >>> >> >> >> >>>   http://bugs.racket-lang.org/query/?cmd=view&pr=14111
 >>> >> >> >> >>>
 >>> >> >> >> >>> Reported by Eric Dobson for release: HEAD
 >>> >> >> >> >>>
 >>> >> >> >> >>> *** Description:
 >>> >> >> >> >>> During testing TR we want to run multiple programs at once, which
 >>> we
 >>> >> do
 >>> >> >> >> >>> using places. The issue is that this means that each place must
 >>> >> reopen
 >>> >> >> >> files
 >>> >> >> >> >>> that the other places have open leading to hitting the limit of
 >>> >> racket.
 >>> >> >> >> Most
 >>> >> >> >> >>> of these files are zo files and other racket implementation
 >>> details.
 >>> >> >> >> >>>
 >>> >> >> >> >>> OS: OSX 10.8.5
 >>> >> >> >> >>> Machine: MacProRetina with 4 hyperthreaded cores.
 >>> >> >> >> >>>
 >>> >> >> >> >>>
 >>> >> >> >> >>> *** How to repeat:
 >>> >> >> >> >>> Edit transform.rkt in
 >>> >> >> >> >>>
 >>> >> pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/optimizer,
 >>> >> >> and
 >>> >> >> >> >>> add the line "(places 20)" above start workers, and then run
 >>> "racket
 >>> >> >> >> >>> transform.rkt" from that directory.
 >>> >> >> >> >>>
 >>> >> >> >> >>> *** Environment:
 >>> >> >> >> >>> MacIntel / Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2)
 >>> >> >> >> >>> AppleWebKit/537.28 (KHTML, like Gecko) Chrome/26.0.1397.2
 >>> >> Safari/537.28
 >>> >> >> >> >>>
 >>> >> >> >> >>

State changed from "open" to "closed" by asumu at Thu, 24 Oct 2013 20:55:41 -0400
Reason>>> not a bug

