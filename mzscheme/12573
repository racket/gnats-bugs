From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Tue Feb 14 19:44:25 2012
Received: from mail-vw0-f44.google.com (mail-vw0-f44.google.com [209.85.212.44])
	by champlain.ccs.neu.edu (8.14.4/8.14.4) with ESMTP id q1F0iLYS021649
	for <bugs@bugs.plt-scheme.org>; Tue, 14 Feb 2012 19:44:21 -0500
Message-Id: <201202150044.q1F0iGB6021630@champlain.ccs.neu.edu>
Date: Tue, 14 Feb 2012 19:44:16 -0500
From: clements@brinckerhoff.org
To: bugs@racket-lang.org
Subject: coverage testing fails for identifier bound to application of function with keyword args

>Number:         12573
>Category:       mzscheme
>Synopsis:       coverage testing fails for identifier bound to application of function with keyword args
>Class:          sw-bug
>Responsible:    mflatt
>Severity:       serious
>Priority:       medium
>State:          open
>Confidential:   no
>Arrival-Date:   Tue Feb 14 19:48:01 -0500 2012
>Last-Modified:  Tue Feb 21 15:00:01 -0500 2012
>Originator:     John Clements
>Organization:
plt
>Submitter-Id:   unknown
>Release:        5.2.1.5--2012-02-14(f895039/g)
>Environment:
macosx "Darwin pcp074319pcs.wireless.calpoly.edu 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7 16:33:36 PDT 2011; root:xnu-1504.15.3~1/RELEASE_I386 i386" (x86_64-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 460605536
Links: (links) = (); (links #:user? #f) = (); (links #:root? #t) = (); (links #:user? #f #:root? #t) = ()


Collections:
("/Users/clements/git-clements/clements/collects"
 (".gitignore" "badger" "clements-lib" "contour-letters" "file-size-checker" "gradeserver" "info-domain" "iTunes-helper" "java-helpers" "jbc-gnucash" "matrix-arithmetic" "mboxrd-read" "midi" "mnemisis" "profj-auto-runner" "projector" "shelly" "smootxes" "template-tester" "txomp" "web-utilities"))
("/Users/clements/clements/matthias/collects"
 ("info-domain" "web"))
("/Users/clements/Library/Racket/5.2.1.5/collects"
 ("cp-csc430" "info-domain"))
("/Users/clements/plt/collects"
 (".gitignore" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compiler" "config" "data" "datalog" "db" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "games" "graphics" "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" "hierlist" "honu" "htdp" "html" "icons" "images" "info-domain" "lang" "launcher" "lazy" "macro-debugger" "make" "meta" "mred" "mrlib" "mysterx" "mz" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "picturing-programs" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raclog" "raco" "racunit" "reader" "readline" "redex" "repo-time-stamp" "repos-time-stamp" "rnrs" "s-exp" "schelog" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" "string-constants" "swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "tes!
 t-engine" "tests" "tex2page" "texpict" "trace" "typed" "typed-racket" "typed-scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml" "xrepl"))

Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t test-coverage) (default) #() "#lang racket\n" #f #t))
>Description:
Coverage testing fails for programs that give
names to the results of calls to functions 
that have keyword arguments, indicating that 
those names are unused even when they are.
>How-To-Repeat:
In Choose Language..., enable syntactic coverag testing, and run this program:

#lang racket

(define (takes-kwd-arg #:kwd-arg opt)
  (not opt))

(let ([named-val (takes-kwd-arg #:kwd-arg #t)])
  named-val)

See that the binding instance for "named-val" 
is red. Remove keyword in definition, see 
fully green program.
>Fix:
>Audit-Trail:
From: John Clements <clements@brinckerhoff.org>
To: John Clements <clements@brinckerhoff.org>
Cc: bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier bound to application of function with keyword args
Date: Tue, 14 Feb 2012 17:07:44 -0800

 On Feb 14, 2012, at 5:06 PM, John Clements wrote:
 
 >=20
 > On Feb 14, 2012, at 4:48 PM, clements@brinckerhoff.org wrote:
 >=20
 >> A new problem report is waiting at
 >> http://bugs.racket-lang.org/query/?cmd=3Dview&pr=3D12573
 >>=20
 >> Reported by John Clements for release: 5.2.1.5--2012-02-14(f895039/g)
 >>=20
 >> *** Description:
 >> Coverage testing fails for programs that give
 >> names to the results of calls to functions=20
 >> that have keyword arguments, indicating that=20
 >> those names are unused even when they are.
 >>=20
 >> *** How to repeat:
 >> In Choose Language..., enable syntactic coverag testing, and run this =
 program:
 >>=20
 >> #lang racket
 >>=20
 >> (define (takes-kwd-arg #:kwd-arg opt)
 >> (not opt))
 >>=20
 >> (let ([named-val (takes-kwd-arg #:kwd-arg #t)])
 >> named-val)
 
 One other thing; I should record for posterity that there's a simple =
 workaround: wrap the expression in an application of the identity =
 function.
 
 John
 
From: John Clements <clements@brinckerhoff.org>
To: clements@brinckerhoff.org, bugs@racket-lang.org
Cc: nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier bound to application of function with keyword args
Date: Tue, 14 Feb 2012 17:06:24 -0800

 On Feb 14, 2012, at 4:48 PM, clements@brinckerhoff.org wrote:
 
 > A new problem report is waiting at
 >  http://bugs.racket-lang.org/query/?cmd=3Dview&pr=3D12573
 >=20
 > Reported by John Clements for release: 5.2.1.5--2012-02-14(f895039/g)
 >=20
 > *** Description:
 > Coverage testing fails for programs that give
 > names to the results of calls to functions=20
 > that have keyword arguments, indicating that=20
 > those names are unused even when they are.
 >=20
 > *** How to repeat:
 > In Choose Language..., enable syntactic coverag testing, and run this =
 program:
 >=20
 > #lang racket
 >=20
 > (define (takes-kwd-arg #:kwd-arg opt)
 >  (not opt))
 >=20
 > (let ([named-val (takes-kwd-arg #:kwd-arg #t)])
 >  named-val)
 >=20
 > See that the binding instance for "named-val"=20
 > is red. Remove keyword in definition, see=20
 > fully green program.
 
 I took a look at the expansion of this--thanks for the awesome macro =
 stepper!---and observed that the expansion of this looks like this =
 (pardon lots of code below):
 
 (module anonymous-module racket
   (#%module-begin
    (define-values (lifted.0) (#%app make-required 'takes-kwd-arg =
 (case-lambda ((self) (#%app apply missing-kw self null))) '#f '#f))
    (define-syntaxes (takes-kwd-arg)
      (#%app
       make-keyword-syntax
       (lambda () (#%app values (quote-syntax takes-kwd-arg3) =
 (quote-syntax takes-kwd-arg5)))
       '0
       '0
       '#f
       '(#:kwd-arg)
       '(#:kwd-arg)))
    (define-values (takes-kwd-arg3) (lambda (kwd-arg1) (let-values =
 (((opt) kwd-arg1)) (let-values:18 () (#%app:19 not opt)))))
    (define-values:20 (unpack4:21)
      (lambda (given-kws given-args) (let-values:22 (((kwd-arg1) =
 (#%app:23 car:23 given-args))) (#%app takes-kwd-arg3 kwd-arg1))))
    (define-values:24 (takes-kwd-arg5)
      (#%app
       lifted.0
       (lambda (given-kws given-argc)
         (if:25 (#%app:26 =3D:26 given-argc '2)
           (let-values:27 (((l2:28) given-kws))
             (if:29 (#%app:28 pair?:28 l2:28)
               (if:30 (#%app:28 eq?:28 (#%app:28 car:28 l2:28) =
 '#:kwd-arg) (#%app:31 null?:31 (#%app:28 cdr:28 l2:28)) '#f)
               '#f))
           '#f))
       (case-lambda:32 ((given-kws given-args) (#%app:32 unpack4:21 =
 given-kws given-args)))
       '(#:kwd-arg)
       '(#:kwd-arg)))
    (#%app:33
     call-with-values:33
     (lambda:33 ()
       (let-values:34 (((named-val)
                        (let-values:35 (((named-val) takes-kwd-arg5:36) =
 ((temp6) (quote #t)))
                          (if (#%app variable-reference-constant? =
 (#%variable-reference takes-kwd-arg5))
                            (#%app takes-kwd-arg3 temp6)
                            (#%app
                             (#%app
                              checked-procedure-check-and-extract
                              struct:keyword-procedure
                              named-val
                              keyword-procedure-extract
                              '(#:kwd-arg)
                              '2)
                             '(#:kwd-arg)
                             (#%app list temp6))))))
         named-val))
     print-values:33)))
 
 
 Examining this, I think I see why the coverage tester gets confused.  In =
 particular, the name 'named-val' is reused in an inner let to refer to a =
 thunk that will produce the value that later gets associated with the =
 desired name.  This thunk is only evaluated along one possible chain of =
 conrol flow, though. =20
 
 I conjecture that coverage testing is seeing that the inner definition =
 is unused, and coloring the outer one red, presumably because they both =
 point to the same source position.
 
 In this case, though, I don't see why it's a good idea to re-use this =
 name or to set its source position to refer to the outer use. I've been =
 through the "gets-the-right-name" and "highlights-the-right-location" =
 arguments, and I can't see how either of them would apply, here.
 
 I therefore believe that it would suffice simply to not use the same =
 name and/or source position for this inner identifier.
 
 Does this make sense?
 
 John
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: John Clements <clements@brinckerhoff.org>
Cc: bugs@racket-lang.org, nobody@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier
 bound to application of function with keyword args
Date: Wed, 15 Feb 2012 07:56:43 -0600

 On Tue, Feb 14, 2012 at 7:06 PM, John Clements
 <clements@brinckerhoff.org> wrote:
 >
 > On Feb 14, 2012, at 4:48 PM, clements@brinckerhoff.org wrote:
 >
 >> A new problem report is waiting at
 >>  http://bugs.racket-lang.org/query/?cmd=view&pr=12573
 
 I believe the syntax checker counts things that appear multiple times
 as "run" when at least one of them runs. For example, this program
 doesn't show any red.
 
 #lang racket
 
 (define-syntax (m stx)
   (syntax-case stx ()
     [(_ a)
      #'(begin a (λ () a))]))
 
 (m (+ 1 2))
 
 
 Or am I misunderstanding?
 
 Robby
 
From: Eli Barzilay <eli@barzilay.org>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: John Clements <clements@brinckerhoff.org>, bugs@racket-lang.org,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier
 bound to application of function with keyword args
Date: Wed, 15 Feb 2012 09:14:14 -0500

 20 minutes ago, Robby Findler wrote:
 > On Tue, Feb 14, 2012 at 7:06 PM, John Clements
 > <clements@brinckerhoff.org> wrote:
 > >
 > > On Feb 14, 2012, at 4:48 PM, clements@brinckerhoff.org wrote:
 > >
 > >> A new problem report is waiting at
 > >>  http://bugs.racket-lang.org/query/?cmd=view&pr=12573
 > 
 > I believe the syntax checker counts things that appear multiple times
 > as "run" when at least one of them runs. For example, this program
 > doesn't show any red.
 
 Yes, if it uses errortrace -- maybe there's some missing source
 information on some parts of the application expansion?
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
 
From: John Clements <clements@brinckerhoff.org>
To: Eli Barzilay <eli@barzilay.org>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs@racket-lang.org,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier bound to application of function with keyword args
Date: Wed, 15 Feb 2012 14:58:50 -0800

 On Feb 15, 2012, at 6:14 AM, Eli Barzilay wrote:
 
 > 20 minutes ago, Robby Findler wrote:
 >> On Tue, Feb 14, 2012 at 7:06 PM, John Clements
 >> <clements@brinckerhoff.org> wrote:
 >>>=20
 >>> On Feb 14, 2012, at 4:48 PM, clements@brinckerhoff.org wrote:
 >>>=20
 >>>> A new problem report is waiting at
 >>>>  http://bugs.racket-lang.org/query/?cmd=3Dview&pr=3D12573
 >>=20
 >> I believe the syntax checker counts things that appear multiple times
 >> as "run" when at least one of them runs. For example, this program
 >> doesn't show any red.
 >=20
 > Yes, if it uses errortrace -- maybe there's some missing source
 > information on some parts of the application expansion?
 
 That doesn't quite make sense: in particular, wrapping the RHS with =
 ((lambda (x) x) RHS) fixes the problem. This suggests to me that the =
 solution isn't going to be as simple as adding source information =
 somewhere. =20
 
 John
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: John Clements <clements@brinckerhoff.org>
Cc: Eli Barzilay <eli@barzilay.org>, bugs@racket-lang.org,
        nobody@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier
 bound to application of function with keyword args
Date: Wed, 15 Feb 2012 17:05:03 -0600

 On Wed, Feb 15, 2012 at 4:58 PM, John Clements
 <clements@brinckerhoff.org> wrote:
 >
 > On Feb 15, 2012, at 6:14 AM, Eli Barzilay wrote:
 >
 >> 20 minutes ago, Robby Findler wrote:
 >>> On Tue, Feb 14, 2012 at 7:06 PM, John Clements
 >>> <clements@brinckerhoff.org> wrote:
 >>>>
 >>>> On Feb 14, 2012, at 4:48 PM, clements@brinckerhoff.org wrote:
 >>>>
 >>>>> A new problem report is waiting at
 >>>>>  http://bugs.racket-lang.org/query/?cmd=view&pr=12573
 >>>
 >>> I believe the syntax checker counts things that appear multiple times
 >>> as "run" when at least one of them runs. For example, this program
 >>> doesn't show any red.
 >>
 >> Yes, if it uses errortrace -- maybe there's some missing source
 >> information on some parts of the application expansion?
 >
 > That doesn't quite make sense: in particular, wrapping the RHS with ((lambda (x) x) RHS) fixes the problem. This suggests to me that the solution isn't going to be as simple as adding source information somewhere.
 
 That change may fix the problem because it triggers a different (less
 optimized) expansion of the use of the keyword function. There are
 some special cases in the keyword expansion to support optimizations.
 
 Robby
 

From: Eli Barzilay <eli@barzilay.org>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: John Clements <clements@brinckerhoff.org>, bugs@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier
 bound to application of function with keyword args
Date: Fri, 17 Feb 2012 07:08:57 -0500

 Two days ago, Robby Findler wrote:
 > On Wed, Feb 15, 2012 at 4:58 PM, John Clements
 > <clements@brinckerhoff.org> wrote:
 > >
 > > That doesn't quite make sense: in particular, wrapping the RHS
 > > with ((lambda (x) x) RHS) fixes the problem. This suggests to me
 > > that the solution isn't going to be as simple as adding source
 > > information somewhere.
 > 
 > That change may fix the problem because it triggers a different
 > (less optimized) expansion of the use of the keyword function. There
 > are some special cases in the keyword expansion to support
 > optimizations.
 
 Yes, the problem is in optimized application code, and such a wrapping
 will kill it.
 
 Looking again at John's earlier conjecture, I think that I found the
 problem.  (The cojecture there not correct, but it's in the right
 direction.)  It also looks like it'll be easy to fix it.  And it also
 looks like a good case for "macros are hard"...  (Potentially with an
 interesting moral that duplicating input code can be bad even if the
 duplication is just of an identifier--?)
 
 I'll start with the "macros are hard" point which demonstrates the
 problem.  Try this code:
 
   | #lang racket
   | (define debug? #f)
   | (define-syntax-rule (bind (x V) E)
   |   (let ([x V]) (if debug? x E)))
   | (bind (y 10) (+ y 1))
 
 and you'll see the LHS `y' as uncovered.  The thing is that the
 bindings in a `let' are never colored as uncovered since they're not
 expressions.  But the problem here is that the macro takes the LHS `y'
 and uses it directly as an expression -- and since that expression is
 uncovered it is colored as such, no matter where it is in the source.
 The way to fix this is to create a new identifier instead of using the
 one from the input, even though it looks redundant:
 
   | #lang racket
   | (define debug? #f)
   | (define-syntax-rule (bind (x V) E)
   |   (let* ([x V] [x2 x]) (if debug? x2 E)))
   | (bind (y 10) (+ y 1))
 
 Now the `y' identifier is not duplicated, and the uncovered expression
 is marked correctly.
 
 
 Going back to the PR code, I started from this exact code:
 
   | #lang racket
   | (define (foo #:x x) x)
   | (let ([y (foo #:x 3)])
   |   y)
 
 and using the macro stepper I get this expansion after one step with
 standard hiding (which is actually a bug):
 
   (module anonymous-module racket
     (#%module-begin
      (define (foo #:x x) x)
      (let ((y
             (let ((y foo) (temp6 3))
               (if (variable-reference-constant? (#%variable-reference foo5))
                 (foo3 temp6)
                 ((checked-procedure-check-and-extract
                   struct:keyword-procedure
                   y
                   keyword-procedure-extract
                   '(#:x)
                   2)
                  '(#:x)
                  (list temp6))))))
        y)))
 
 My guess is that the "constant?" check is true, and therefore the
 else branch is not taken, and the problem is there.
 Using the "syntax object" panel, you can see that the `y' in that
 branch is the same as the original one (same meaning same source
 info).  The fact that it's bound in a local `let' is irrelevant, since
 bindings are ignored.  It's using it as an expression that makes it
 possible to highlight it as unused.
 
 (And that's why it seems easy to fix.)
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: John Clements <clements@brinckerhoff.org>
To: Eli Barzilay <eli@barzilay.org>
Cc: Robby Findler <robby@eecs.northwestern.edu>, bugs@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier bound to application of function with keyword args
Date: Tue, 21 Feb 2012 10:53:21 -0800

 On Feb 17, 2012, at 4:08 AM, Eli Barzilay wrote:
 
 > Two days ago, Robby Findler wrote:
 >> On Wed, Feb 15, 2012 at 4:58 PM, John Clements
 >> <clements@brinckerhoff.org> wrote:
 >>> 
 >>> That doesn't quite make sense: in particular, wrapping the RHS
 >>> with ((lambda (x) x) RHS) fixes the problem. This suggests to me
 >>> that the solution isn't going to be as simple as adding source
 >>> information somewhere.
 >> 
 >> That change may fix the problem because it triggers a different
 >> (less optimized) expansion of the use of the keyword function. There
 >> are some special cases in the keyword expansion to support
 >> optimizations.
 > 
 > Yes, the problem is in optimized application code, and such a wrapping
 > will kill it.
 > 
 > Looking again at John's earlier conjecture, I think that I found the
 > problem.  (The cojecture there not correct, but it's in the right
 > direction.)  It also looks like it'll be easy to fix it.  And it also
 > looks like a good case for "macros are hard"...  (Potentially with an
 > interesting moral that duplicating input code can be bad even if the
 > duplication is just of an identifier--?)
 > 
 > I'll start with the "macros are hard" point which demonstrates the
 > problem.  Try this code:
 > 
 >  | #lang racket
 >  | (define debug? #f)
 >  | (define-syntax-rule (bind (x V) E)
 >  |   (let ([x V]) (if debug? x E)))
 >  | (bind (y 10) (+ y 1))
 > 
 > and you'll see the LHS `y' as uncovered.  The thing is that the
 > bindings in a `let' are never colored as uncovered since they're not
 > expressions.  But the problem here is that the macro takes the LHS `y'
 > and uses it directly as an expression -- and since that expression is
 > uncovered it is colored as such, no matter where it is in the source.
 
 Ah! this makes sense.
 
 How much would you charge to fix this bug? :)
 
 John
 
 > The way to fix this is to create a new identifier instead of using the
 > one from the input, even though it looks redundant:
 > 
 >  | #lang racket
 >  | (define debug? #f)
 >  | (define-syntax-rule (bind (x V) E)
 >  |   (let* ([x V] [x2 x]) (if debug? x2 E)))
 >  | (bind (y 10) (+ y 1))
 > 
 > Now the `y' identifier is not duplicated, and the uncovered expression
 > is marked correctly.
 > 
 > 
 > Going back to the PR code, I started from this exact code:
 > 
 >  | #lang racket
 >  | (define (foo #:x x) x)
 >  | (let ([y (foo #:x 3)])
 >  |   y)
 > 
 > and using the macro stepper I get this expansion after one step with
 > standard hiding (which is actually a bug):
 > 
 >  (module anonymous-module racket
 >    (#%module-begin
 >     (define (foo #:x x) x)
 >     (let ((y
 >            (let ((y foo) (temp6 3))
 >              (if (variable-reference-constant? (#%variable-reference foo5))
 >                (foo3 temp6)
 >                ((checked-procedure-check-and-extract
 >                  struct:keyword-procedure
 >                  y
 >                  keyword-procedure-extract
 >                  '(#:x)
 >                  2)
 >                 '(#:x)
 >                 (list temp6))))))
 >       y)))
 > 
 > My guess is that the "constant?" check is true, and therefore the
 > else branch is not taken, and the problem is there.
 > Using the "syntax object" panel, you can see that the `y' in that
 > branch is the same as the original one (same meaning same source
 > info).  The fact that it's bound in a local `let' is irrelevant, since
 > bindings are ignored.  It's using it as an expression that makes it
 > possible to highlight it as unused.
 > 
 > (And that's why it seems easy to fix.)
 > 
 > -- 
 >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                    http://barzilay.org/                   Maze is Life!
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: John Clements <clements@brinckerhoff.org>
Cc: Eli Barzilay <eli@barzilay.org>, bugs@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier
 bound to application of function with keyword args
Date: Tue, 21 Feb 2012 12:56:46 -0600

 FWIW, I think the fix here is to make the test coverage annotations
 color/track bound variables (if they are original & whatnot).
 
 Robby
 
 On Tue, Feb 21, 2012 at 12:53 PM, John Clements
 <clements@brinckerhoff.org> wrote:
 >
 > On Feb 17, 2012, at 4:08 AM, Eli Barzilay wrote:
 >
 >> Two days ago, Robby Findler wrote:
 >>> On Wed, Feb 15, 2012 at 4:58 PM, John Clements
 >>> <clements@brinckerhoff.org> wrote:
 >>>>
 >>>> That doesn't quite make sense: in particular, wrapping the RHS
 >>>> with ((lambda (x) x) RHS) fixes the problem. This suggests to me
 >>>> that the solution isn't going to be as simple as adding source
 >>>> information somewhere.
 >>>
 >>> That change may fix the problem because it triggers a different
 >>> (less optimized) expansion of the use of the keyword function. There
 >>> are some special cases in the keyword expansion to support
 >>> optimizations.
 >>
 >> Yes, the problem is in optimized application code, and such a wrapping
 >> will kill it.
 >>
 >> Looking again at John's earlier conjecture, I think that I found the
 >> problem.  (The cojecture there not correct, but it's in the right
 >> direction.)  It also looks like it'll be easy to fix it.  And it also
 >> looks like a good case for "macros are hard"...  (Potentially with an
 >> interesting moral that duplicating input code can be bad even if the
 >> duplication is just of an identifier--?)
 >>
 >> I'll start with the "macros are hard" point which demonstrates the
 >> problem.  Try this code:
 >>
 >>  | #lang racket
 >>  | (define debug? #f)
 >>  | (define-syntax-rule (bind (x V) E)
 >>  |   (let ([x V]) (if debug? x E)))
 >>  | (bind (y 10) (+ y 1))
 >>
 >> and you'll see the LHS `y' as uncovered.  The thing is that the
 >> bindings in a `let' are never colored as uncovered since they're not
 >> expressions.  But the problem here is that the macro takes the LHS `y'
 >> and uses it directly as an expression -- and since that expression is
 >> uncovered it is colored as such, no matter where it is in the source.
 >
 > Ah! this makes sense.
 >
 > How much would you charge to fix this bug? :)
 >
 > John
 >
 >> The way to fix this is to create a new identifier instead of using the
 >> one from the input, even though it looks redundant:
 >>
 >>  | #lang racket
 >>  | (define debug? #f)
 >>  | (define-syntax-rule (bind (x V) E)
 >>  |   (let* ([x V] [x2 x]) (if debug? x2 E)))
 >>  | (bind (y 10) (+ y 1))
 >>
 >> Now the `y' identifier is not duplicated, and the uncovered expression
 >> is marked correctly.
 >>
 >>
 >> Going back to the PR code, I started from this exact code:
 >>
 >>  | #lang racket
 >>  | (define (foo #:x x) x)
 >>  | (let ([y (foo #:x 3)])
 >>  |   y)
 >>
 >> and using the macro stepper I get this expansion after one step with
 >> standard hiding (which is actually a bug):
 >>
 >>  (module anonymous-module racket
 >>    (#%module-begin
 >>     (define (foo #:x x) x)
 >>     (let ((y
 >>            (let ((y foo) (temp6 3))
 >>              (if (variable-reference-constant? (#%variable-reference foo5))
 >>                (foo3 temp6)
 >>                ((checked-procedure-check-and-extract
 >>                  struct:keyword-procedure
 >>                  y
 >>                  keyword-procedure-extract
 >>                  '(#:x)
 >>                  2)
 >>                 '(#:x)
 >>                 (list temp6))))))
 >>       y)))
 >>
 >> My guess is that the "constant?" check is true, and therefore the
 >> else branch is not taken, and the problem is there.
 >> Using the "syntax object" panel, you can see that the `y' in that
 >> branch is the same as the original one (same meaning same source
 >> info).  The fact that it's bound in a local `let' is irrelevant, since
 >> bindings are ignored.  It's using it as an expression that makes it
 >> possible to highlight it as unused.
 >>
 >> (And that's why it seems easy to fix.)
 >>
 >> --
 >>          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >>                    http://barzilay.org/                   Maze is Life!
 >
 
From: John Clements <clements@brinckerhoff.org>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: Eli Barzilay <eli@barzilay.org>, bugs@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier bound to application of function with keyword args
Date: Tue, 21 Feb 2012 11:00:45 -0800

 On Feb 21, 2012, at 10:56 AM, Robby Findler wrote:
 
 > FWIW, I think the fix here is to make the test coverage annotations
 > color/track bound variables (if they are original & whatnot).
 
 I don't understand this suggestion; my understanding is that the binding =
 instance is being incorrectly treated as an expression, and not as a =
 binding instance, and therefore getting "has this expression been =
 evaluated" logic rather than "has this binding been used" logic.  =
 Wouldn't the right fix be to rectify this as Eli suggests?
 
 I'm about 75% sure that I'm just misunderstanding you, so I'm politely =
 asking for clarification, here.
 
 John
 
 
 
 
 
 >=20
 > Robby
 >=20
 > On Tue, Feb 21, 2012 at 12:53 PM, John Clements
 > <clements@brinckerhoff.org> wrote:
 >>=20
 >> On Feb 17, 2012, at 4:08 AM, Eli Barzilay wrote:
 >>=20
 >>> Two days ago, Robby Findler wrote:
 >>>> On Wed, Feb 15, 2012 at 4:58 PM, John Clements
 >>>> <clements@brinckerhoff.org> wrote:
 >>>>>=20
 >>>>> That doesn't quite make sense: in particular, wrapping the RHS
 >>>>> with ((lambda (x) x) RHS) fixes the problem. This suggests to me
 >>>>> that the solution isn't going to be as simple as adding source
 >>>>> information somewhere.
 >>>>=20
 >>>> That change may fix the problem because it triggers a different
 >>>> (less optimized) expansion of the use of the keyword function. =
 There
 >>>> are some special cases in the keyword expansion to support
 >>>> optimizations.
 >>>=20
 >>> Yes, the problem is in optimized application code, and such a =
 wrapping
 >>> will kill it.
 >>>=20
 >>> Looking again at John's earlier conjecture, I think that I found the
 >>> problem.  (The cojecture there not correct, but it's in the right
 >>> direction.)  It also looks like it'll be easy to fix it.  And it =
 also
 >>> looks like a good case for "macros are hard"...  (Potentially with =
 an
 >>> interesting moral that duplicating input code can be bad even if the
 >>> duplication is just of an identifier--?)
 >>>=20
 >>> I'll start with the "macros are hard" point which demonstrates the
 >>> problem.  Try this code:
 >>>=20
 >>>  | #lang racket
 >>>  | (define debug? #f)
 >>>  | (define-syntax-rule (bind (x V) E)
 >>>  |   (let ([x V]) (if debug? x E)))
 >>>  | (bind (y 10) (+ y 1))
 >>>=20
 >>> and you'll see the LHS `y' as uncovered.  The thing is that the
 >>> bindings in a `let' are never colored as uncovered since they're not
 >>> expressions.  But the problem here is that the macro takes the LHS =
 `y'
 >>> and uses it directly as an expression -- and since that expression =
 is
 >>> uncovered it is colored as such, no matter where it is in the =
 source.
 >>=20
 >> Ah! this makes sense.
 >>=20
 >> How much would you charge to fix this bug? :)
 >>=20
 >> John
 >>=20
 >>> The way to fix this is to create a new identifier instead of using =
 the
 >>> one from the input, even though it looks redundant:
 >>>=20
 >>>  | #lang racket
 >>>  | (define debug? #f)
 >>>  | (define-syntax-rule (bind (x V) E)
 >>>  |   (let* ([x V] [x2 x]) (if debug? x2 E)))
 >>>  | (bind (y 10) (+ y 1))
 >>>=20
 >>> Now the `y' identifier is not duplicated, and the uncovered =
 expression
 >>> is marked correctly.
 >>>=20
 >>>=20
 >>> Going back to the PR code, I started from this exact code:
 >>>=20
 >>>  | #lang racket
 >>>  | (define (foo #:x x) x)
 >>>  | (let ([y (foo #:x 3)])
 >>>  |   y)
 >>>=20
 >>> and using the macro stepper I get this expansion after one step with
 >>> standard hiding (which is actually a bug):
 >>>=20
 >>>  (module anonymous-module racket
 >>>    (#%module-begin
 >>>     (define (foo #:x x) x)
 >>>     (let ((y
 >>>            (let ((y foo) (temp6 3))
 >>>              (if (variable-reference-constant? (#%variable-reference =
 foo5))
 >>>                (foo3 temp6)
 >>>                ((checked-procedure-check-and-extract
 >>>                  struct:keyword-procedure
 >>>                  y
 >>>                  keyword-procedure-extract
 >>>                  '(#:x)
 >>>                  2)
 >>>                 '(#:x)
 >>>                 (list temp6))))))
 >>>       y)))
 >>>=20
 >>> My guess is that the "constant?" check is true, and therefore the
 >>> else branch is not taken, and the problem is there.
 >>> Using the "syntax object" panel, you can see that the `y' in that
 >>> branch is the same as the original one (same meaning same source
 >>> info).  The fact that it's bound in a local `let' is irrelevant, =
 since
 >>> bindings are ignored.  It's using it as an expression that makes it
 >>> possible to highlight it as unused.
 >>>=20
 >>> (And that's why it seems easy to fix.)
 >>>=20
 >>> --
 >>>          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli =
 Barzilay:
 >>>                    http://barzilay.org/                   Maze is =
 Life!
 >>=20
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: John Clements <clements@brinckerhoff.org>
Cc: Eli Barzilay <eli@barzilay.org>, bugs@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier
 bound to application of function with keyword args
Date: Tue, 21 Feb 2012 13:22:37 -0600

 If I understand what's been said correctly, then the variables in
 binding expressions are not, themselves, individually considered for
 coloration (in the fully expanded form). If we were to change the
 output of the test coverage annotation so that, when a let expression
 were evaluated, it would color the syntax objects in the binding
 positions of the let, then this bug would be fixed.
 
 Robby
 
 On Tue, Feb 21, 2012 at 1:00 PM, John Clements
 <clements@brinckerhoff.org> wrote:
 >
 > On Feb 21, 2012, at 10:56 AM, Robby Findler wrote:
 >
 >> FWIW, I think the fix here is to make the test coverage annotations
 >> color/track bound variables (if they are original & whatnot).
 >
 > I don't understand this suggestion; my understanding is that the binding instance is being incorrectly treated as an expression, and not as a binding instance, and therefore getting "has this expression been evaluated" logic rather than "has this binding been used" logic.  Wouldn't the right fix be to rectify this as Eli suggests?
 >
 > I'm about 75% sure that I'm just misunderstanding you, so I'm politely asking for clarification, here.
 >
 > John
 >
 >
 >
 >
 >
 >>
 >> Robby
 >>
 >> On Tue, Feb 21, 2012 at 12:53 PM, John Clements
 >> <clements@brinckerhoff.org> wrote:
 >>>
 >>> On Feb 17, 2012, at 4:08 AM, Eli Barzilay wrote:
 >>>
 >>>> Two days ago, Robby Findler wrote:
 >>>>> On Wed, Feb 15, 2012 at 4:58 PM, John Clements
 >>>>> <clements@brinckerhoff.org> wrote:
 >>>>>>
 >>>>>> That doesn't quite make sense: in particular, wrapping the RHS
 >>>>>> with ((lambda (x) x) RHS) fixes the problem. This suggests to me
 >>>>>> that the solution isn't going to be as simple as adding source
 >>>>>> information somewhere.
 >>>>>
 >>>>> That change may fix the problem because it triggers a different
 >>>>> (less optimized) expansion of the use of the keyword function. There
 >>>>> are some special cases in the keyword expansion to support
 >>>>> optimizations.
 >>>>
 >>>> Yes, the problem is in optimized application code, and such a wrapping
 >>>> will kill it.
 >>>>
 >>>> Looking again at John's earlier conjecture, I think that I found the
 >>>> problem.  (The cojecture there not correct, but it's in the right
 >>>> direction.)  It also looks like it'll be easy to fix it.  And it also
 >>>> looks like a good case for "macros are hard"...  (Potentially with an
 >>>> interesting moral that duplicating input code can be bad even if the
 >>>> duplication is just of an identifier--?)
 >>>>
 >>>> I'll start with the "macros are hard" point which demonstrates the
 >>>> problem.  Try this code:
 >>>>
 >>>>  | #lang racket
 >>>>  | (define debug? #f)
 >>>>  | (define-syntax-rule (bind (x V) E)
 >>>>  |   (let ([x V]) (if debug? x E)))
 >>>>  | (bind (y 10) (+ y 1))
 >>>>
 >>>> and you'll see the LHS `y' as uncovered.  The thing is that the
 >>>> bindings in a `let' are never colored as uncovered since they're not
 >>>> expressions.  But the problem here is that the macro takes the LHS `y'
 >>>> and uses it directly as an expression -- and since that expression is
 >>>> uncovered it is colored as such, no matter where it is in the source.
 >>>
 >>> Ah! this makes sense.
 >>>
 >>> How much would you charge to fix this bug? :)
 >>>
 >>> John
 >>>
 >>>> The way to fix this is to create a new identifier instead of using the
 >>>> one from the input, even though it looks redundant:
 >>>>
 >>>>  | #lang racket
 >>>>  | (define debug? #f)
 >>>>  | (define-syntax-rule (bind (x V) E)
 >>>>  |   (let* ([x V] [x2 x]) (if debug? x2 E)))
 >>>>  | (bind (y 10) (+ y 1))
 >>>>
 >>>> Now the `y' identifier is not duplicated, and the uncovered expression
 >>>> is marked correctly.
 >>>>
 >>>>
 >>>> Going back to the PR code, I started from this exact code:
 >>>>
 >>>>  | #lang racket
 >>>>  | (define (foo #:x x) x)
 >>>>  | (let ([y (foo #:x 3)])
 >>>>  |   y)
 >>>>
 >>>> and using the macro stepper I get this expansion after one step with
 >>>> standard hiding (which is actually a bug):
 >>>>
 >>>>  (module anonymous-module racket
 >>>>    (#%module-begin
 >>>>     (define (foo #:x x) x)
 >>>>     (let ((y
 >>>>            (let ((y foo) (temp6 3))
 >>>>              (if (variable-reference-constant? (#%variable-reference foo5))
 >>>>                (foo3 temp6)
 >>>>                ((checked-procedure-check-and-extract
 >>>>                  struct:keyword-procedure
 >>>>                  y
 >>>>                  keyword-procedure-extract
 >>>>                  '(#:x)
 >>>>                  2)
 >>>>                 '(#:x)
 >>>>                 (list temp6))))))
 >>>>       y)))
 >>>>
 >>>> My guess is that the "constant?" check is true, and therefore the
 >>>> else branch is not taken, and the problem is there.
 >>>> Using the "syntax object" panel, you can see that the `y' in that
 >>>> branch is the same as the original one (same meaning same source
 >>>> info).  The fact that it's bound in a local `let' is irrelevant, since
 >>>> bindings are ignored.  It's using it as an expression that makes it
 >>>> possible to highlight it as unused.
 >>>>
 >>>> (And that's why it seems easy to fix.)
 >>>>
 >>>> --
 >>>>          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >>>>                    http://barzilay.org/                   Maze is Life!
 >>>
 >
 
From: Eli Barzilay <eli@barzilay.org>
To: Robby Findler <robby@eecs.northwestern.edu>,
        John Clements <clements@brinckerhoff.org>
Cc: bugs@racket-lang.org, bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier bound to application of function with keyword args
Date: Tue, 21 Feb 2012 14:31:34 -0500

 30 minutes ago, John Clements wrote:
 > 
 > On Feb 17, 2012, at 4:08 AM, Eli Barzilay wrote:
 > > 
 > > I'll start with the "macros are hard" point which demonstrates the
 > > problem.  Try this code:
 > > 
 > >  | #lang racket
 > >  | (define debug? #f)
 > >  | (define-syntax-rule (bind (x V) E)
 > >  |   (let ([x V]) (if debug? x E)))
 > >  | (bind (y 10) (+ y 1))
 > > 
 > > and you'll see the LHS `y' as uncovered.  The thing is that the
 > > bindings in a `let' are never colored as uncovered since they're
 > > not expressions.  But the problem here is that the macro takes the
 > > LHS `y' and uses it directly as an expression -- and since that
 > > expression is uncovered it is colored as such, no matter where it
 > > is in the source.
 > 
 > Ah! this makes sense.
 > 
 > How much would you charge to fix this bug? :)
 
 I did look at the code, and it seems like there's a lot of room for
 making mistakes, so I didn't try to fix it.
 
 
 A few minutes ago, Robby Findler wrote:
 > If I understand what's been said correctly, then the variables in
 > binding expressions are not, themselves, individually considered for
 > coloration (in the fully expanded form). If we were to change the
 > output of the test coverage annotation so that, when a let
 > expression were evaluated, it would color the syntax objects in the
 > binding positions of the let, then this bug would be fixed.
 
 I don't follow this either.  I think that a simpler version of it is
 to simply never color binders as uncovered, but that just solves it
 for things like `let' where you know where they are -- but macros that
 expand to them can have an identifier get used as both so it doesn't
 help.
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: John Clements <clements@brinckerhoff.org>, bugs@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier
 bound to application of function with keyword args
Date: Tue, 21 Feb 2012 13:39:34 -0600

 I'm saying to color binders as *covered* (when the let expression is evaluated).
 
 Wouldn't that solve the problem here?
 
 Robby
 
 On Tue, Feb 21, 2012 at 1:31 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > 30 minutes ago, John Clements wrote:
 >>
 >> On Feb 17, 2012, at 4:08 AM, Eli Barzilay wrote:
 >> >
 >> > I'll start with the "macros are hard" point which demonstrates the
 >> > problem.  Try this code:
 >> >
 >> >  | #lang racket
 >> >  | (define debug? #f)
 >> >  | (define-syntax-rule (bind (x V) E)
 >> >  |   (let ([x V]) (if debug? x E)))
 >> >  | (bind (y 10) (+ y 1))
 >> >
 >> > and you'll see the LHS `y' as uncovered.  The thing is that the
 >> > bindings in a `let' are never colored as uncovered since they're
 >> > not expressions.  But the problem here is that the macro takes the
 >> > LHS `y' and uses it directly as an expression -- and since that
 >> > expression is uncovered it is colored as such, no matter where it
 >> > is in the source.
 >>
 >> Ah! this makes sense.
 >>
 >> How much would you charge to fix this bug? :)
 >
 > I did look at the code, and it seems like there's a lot of room for
 > making mistakes, so I didn't try to fix it.
 >
 >
 > A few minutes ago, Robby Findler wrote:
 >> If I understand what's been said correctly, then the variables in
 >> binding expressions are not, themselves, individually considered for
 >> coloration (in the fully expanded form). If we were to change the
 >> output of the test coverage annotation so that, when a let
 >> expression were evaluated, it would color the syntax objects in the
 >> binding positions of the let, then this bug would be fixed.
 >
 > I don't follow this either.  I think that a simpler version of it is
 > to simply never color binders as uncovered, but that just solves it
 > for things like `let' where you know where they are -- but macros that
 > expand to them can have an identifier get used as both so it doesn't
 > help.
 >
 > --
 >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                    http://barzilay.org/                   Maze is Life!
 
From: Eli Barzilay <eli@barzilay.org>
To: Robby Findler <robby@eecs.northwestern.edu>
Cc: John Clements <clements@brinckerhoff.org>, bugs@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier
 bound to application of function with keyword args
Date: Tue, 21 Feb 2012 14:52:09 -0500

 A few minutes ago, Robby Findler wrote:
 > I'm saying to color binders as *covered* (when the let expression is
 > evaluated).
 > 
 > Wouldn't that solve the problem here?
 
 I think that this is what I thought is the "simpler version", and I
 don't think that it will work exactly because of macros like the one
 below where `x' is both a binder and an expression.
 
 But I think that I see what you said earlier now -- you want to use
 the extra information to know what is a binder, and a macro like the
 below is therefore broken because it doesn't provide the extra
 information?  That would be a major change to the errortrace code that
 produces the coverage information since there's nothing about the
 actual source expressions at that point.  So that kind of a fix should
 go into the annotator, maybe just plant an expression in the result
 that marks binders as covered.
 
 Actually, maybe that (adding that to the annotator) can work without
 any extra information -- it works on expanded code so it knows about
 the bindings, and it can just be conservative to one side and always
 add those coverages.  But this conservativeness would make the below
 example colored bogusly.
 
 
 > On Tue, Feb 21, 2012 at 1:31 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > > 30 minutes ago, John Clements wrote:
 > >>
 > >> On Feb 17, 2012, at 4:08 AM, Eli Barzilay wrote:
 > >> >
 > >> > I'll start with the "macros are hard" point which demonstrates the
 > >> > problem.  Try this code:
 > >> >
 > >> >  | #lang racket
 > >> >  | (define debug? #f)
 > >> >  | (define-syntax-rule (bind (x V) E)
 > >> >  |   (let ([x V]) (if debug? x E)))
 > >> >  | (bind (y 10) (+ y 1))
 > >> >
 > >> > and you'll see the LHS `y' as uncovered.  The thing is that the
 > >> > bindings in a `let' are never colored as uncovered since they're
 > >> > not expressions.  But the problem here is that the macro takes the
 > >> > LHS `y' and uses it directly as an expression -- and since that
 > >> > expression is uncovered it is colored as such, no matter where it
 > >> > is in the source.
 > >>
 > >> Ah! this makes sense.
 > >>
 > >> How much would you charge to fix this bug? :)
 > >
 > > I did look at the code, and it seems like there's a lot of room for
 > > making mistakes, so I didn't try to fix it.
 > >
 > >
 > > A few minutes ago, Robby Findler wrote:
 > >> If I understand what's been said correctly, then the variables in
 > >> binding expressions are not, themselves, individually considered for
 > >> coloration (in the fully expanded form). If we were to change the
 > >> output of the test coverage annotation so that, when a let
 > >> expression were evaluated, it would color the syntax objects in the
 > >> binding positions of the let, then this bug would be fixed.
 > >
 > > I don't follow this either.  I think that a simpler version of it is
 > > to simply never color binders as uncovered, but that just solves it
 > > for things like `let' where you know where they are -- but macros that
 > > expand to them can have an identifier get used as both so it doesn't
 > > help.
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                     http://barzilay.org/                   Maze is Life!
 
From: Robby Findler <robby@eecs.northwestern.edu>
To: Eli Barzilay <eli@barzilay.org>
Cc: John Clements <clements@brinckerhoff.org>, bugs@racket-lang.org,
        bug-notification@racket-lang.org
Subject: Re: [racket-bug] all/12573: coverage testing fails for identifier
 bound to application of function with keyword args
Date: Tue, 21 Feb 2012 13:59:01 -0600

 On Tue, Feb 21, 2012 at 1:52 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > A few minutes ago, Robby Findler wrote:
 >> I'm saying to color binders as *covered* (when the let expression is
 >> evaluated).
 >>
 >> Wouldn't that solve the problem here?
 >
 > I think that this is what I thought is the "simpler version", and I
 > don't think that it will work exactly because of macros like the one
 > below where `x' is both a binder and an expression.
 
 Why does it matter that it be both?
 
 I'm saying just change the errortrace annotation to insert calls that
 says "this expression is colorerd": when encountering a let
 expression, color not only the let, but also color the bindings.
 
 That will work when an expression is used in two places, just like
 things currently work when an expression is duplicated.
 
 Robby
