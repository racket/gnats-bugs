From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Tue Sep 28 17:04:40 2010
Received: from mail-gy0-f172.google.com (mail-gy0-f172.google.com [209.85.160.172])
	by champlain.ccs.neu.edu (8.14.3/8.14.3) with ESMTP id o8SL4cxc005897
	for <bugs@bugs.plt-scheme.org>; Tue, 28 Sep 2010 17:04:38 -0400
Message-Id: <201009282104.o8SL4ZPU005890@champlain.ccs.neu.edu>
Date: Tue, 28 Sep 2010 17:04:35 -0400
From: clements@brinckerhoff.org
To: bugs@racket-lang.org
Subject: Another very similar JIT bug

>Number:         11264
>Category:       mzscheme
>Synopsis:       Another very similar JIT bug
>Class:          sw-bug
>Responsible:    mflatt
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Tue Sep 28 17:08:01 -0400 2010
>Closed-Date:    Sat Jan 08 10:09:15 -0500 2011
>Last-Modified:  Sat Jan 08 10:09:15 -0500 2011
>Originator:     John Clements
>Organization:
plt
>Submitter-Id:   unknown
>Release:        5.0.1.7--2010-09-28(202af50/g)
>Environment:
macosx "Darwin john-clementss-macbook-pro.local 10.4.0 Darwin Kernel Version 10.4.0: Fri Apr 23 18:28:53 PDT 2010; root:xnu-1504.7.4~1/RELEASE_I386 i386" (i386-macosx/3m) (get-display-depth) = 32
Human Language: english
(current-memory-use) 374470584

Collections:
(("/Users/clements/git-clements/clements/collects" ".gitignore" "badger" "clements-lib" "contour-letters" "file-size-checker" "info-domain" "iTunes-helper" "java-helpers" "jbc-gnucash" "matrix-arithmetic" "mboxrd-read" "midi" "mnemisis" "profj-auto-runner" "projector" "rsound" "shelly" "single-stepper" "smootxes" "template-tester" "txomp" "web-utilities") ("/Users/clements/clements/matthias/collects" "info-domain" "web") ("/Users/clements/Library/Racket/5.0.1.7/collects" non-existent-path) ("/Users/clements/plt/collects" ".gitignore" "2htdp" "afm" "algol60" "at-exp" "browser" "combinator-parser" "compiler" "config" "data" "datalog" "defaults" "deinprogramm" "drracket" "drscheme" "dynext" "embedded-gui" "eopl" "errortrace" "ffi" "file" "framework" "frtime" "games" "graphics" "gui-debugger" "guibuilder" "handin-client" "handin-server" "help" "hierlist" "honu" "htdp" "html" "icons" "info-domain" "lang" "launcher" "lazy" "macro-debugger" "make" "meta" "mred" "mrlib" "mysterx" "m!
 z" "mzcom" "mzlib" "mzscheme" "net" "openssl" "parser-tools" "plai" "planet" "plot" "preprocessor" "profile" "r5rs" "r6rs" "racket" "racklog" "rackunit" "raclog" "raco" "racunit" "reader" "readline" "redex" "repo-time-stamp" "repos-time-stamp" "rico" "rnrs" "s-exp" "schelog" "scheme" "schemeunit" "scribble" "scribblings" "scriblib" "setup" "sgl" "sirmail" "slatex" "slideshow" "srfi" "srpersist" "stepper" "string-constants" "swindle" "syntax" "syntax-color" "teachpack" "test-box-recovery" "test-engine" "tests" "tex2page" "texpict" "trace" "typed" "typed-scheme" "unstable" "version" "waterworld" "web-server" "wxme" "xml"))
Computer Language: (("Determine language from source") (#(#t print mixed-fraction-e #f #t debug) (default) #() "#lang racket\n" #t))
>Description:
This seems *very* closely related to the earlier JIT bug;
the difference is that now it only happens with the 
unsafe operations enabled.

I'll respond to the auto-generated e-mail with the 
content of fft.rkt
>How-To-Repeat:
In the presence of fft.rkt, run this program:

#lang racket

(require "fft.rkt")

(fft-complex-forward (make-vector 4096 0.0))
>Fix:
>Audit-Trail:
From: John Clements <clements@brinckerhoff.org>
To: John Clements <clements@brinckerhoff.org>, bugs@racket-lang.org,
        Matthew Flatt <mflatt@cs.utah.edu>
Cc: 
Subject: Re: [racket-bug] all/11264: Another very similar JIT bug
Date: Tue, 28 Sep 2010 14:16:21 -0700

 On Sep 28, 2010, at 2:08 PM, clements@brinckerhoff.org wrote:
 
 > A new problem report is waiting at
 >  http://bugs.racket-lang.org/query/?cmd=3Dview&pr=3D11264
 >=20
 > Reported by John Clements for release: 5.0.1.7--2010-09-28(202af50/g)
 >=20
 > *** Description:
 > This seems *very* closely related to the earlier JIT bug;
 > the difference is that now it only happens with the=20
 > unsafe operations enabled.
 >=20
 > I'll respond to the auto-generated e-mail with the=20
 > content of fft.rkt
 
 ... and here it is:
 
 #lang racket
 
 (require racket/unsafe/ops
          #;(prefix-in unsafe- racket/fixnum)
          #;(prefix-in unsafe- racket/flonum))
 
 #|
 (define unsafe-vector-length vector-length)
 (define unsafe-vector-ref vector-ref)
 (define unsafe-vector-set! vector-set!)
 |#
 (define 2*pi (* 2.0 pi))
 
 ;;; fft-forward : real? =3D -1.0
 ;;; fft-backward : real? =3D +1.0
 (define fft-forward -1.0)
 (define fft-backward +1.0)
 
 ;;; Radix 2 Complex FFT
 
 ;;; (fft-bitreverse-order data) -> void?
 ;;;   data : (vectorof complex?)
 ;;; Implements the Gold-Rader bit-reversal algorithm. Note that this is =
 an
 ;;; internal routine and all operations are unsafe.
 (define (fft-bitreverse-order data)
   (let ((n (unsafe-vector-length data)))
     (for/fold ((j 0))
               ((i (in-range (unsafe-fx- n 1))))
       (let ((k (unsafe-fxquotient n 2)))
         (when (unsafe-fx< i j)
           (let ((tmp (unsafe-vector-ref data i)))
             (unsafe-vector-set! data i (unsafe-vector-ref data j))
             (unsafe-vector-set! data j tmp)))
         (let loop ()
           (when (unsafe-fx<=3D k j)
             (set! j (unsafe-fx- j k))
             (set! k (unsafe-fxquotient k 2))
             (loop)))
         (unsafe-fx+ j k)))
     (void)))
 
 ;;; (fft-binary-logn n) -> (or/c exact-nonnegative-integer? false/c)
 ;;;   n : exact-nonegative-integer?
 ;;; If n is a power of 2, returns the base 2 log of n (i.e.,
 ;;; (expt (fft-binary-logn n) 2) =3D n), otherwise #f is returned. Note =
 that this
 ;;; is an internal routine and all operations are unsafe.
 (define (fft-binary-logn n)
   (with-fixed (n)
     (let ((binary-logn
            (let loop ((k 1)
                       (l 0))
              (if (unsafe-fx>=3D k n)
                  l
                  (loop (unsafe-fx* k 2) (unsafe-fx+ l 1))))))
       (if (unsafe-fx=3D n (unsafe-fxlshift 1 binary-logn))
           binary-logn
           #f))))
 
 ;;; Decimation in Time
 
 
 ;;; Decimation in Frequency
 
 
 ;;; Multi-Radix Complex FFT
 
 ;;; (fft-complex-factorize n)
 ;;; -> (listof fixnum?)
 ;;;   n : fixnum?
 (define (fft-complex-factorize n)
   (fft-factorize n '(5 4 3 2)))
 
 ;;; (fft-factorize n implemented-subtransforms) -> (listof fixnum?)
 ;;;   n : fixnum?
 ;;;   implemented-subtransforms : (listof fixnum?)
 (define (fft-factorize n implemented-subtransforms)
   (with-fixed (n)
     (if (unsafe-fx=3D n 1)
         '(1)
         (let ((ntest n)
               (factors '()))
           ;; Deal with implemented factors first.
           (let outer-loop ()
             (unless (or (null? implemented-subtransforms)
                         (unsafe-fx=3D ntest 0))
               (let ((factor (car implemented-subtransforms)))
                 (let inner-loop ()
                   (when (unsafe-fx=3D (unsafe-fxmodulo ntest factor) 0)
                     (set! factors (append factors (list factor)))
                     (set! ntest (unsafe-fxquotient ntest factor))
                     (inner-loop)))
                 (set! implemented-subtransforms
                       (cdr implemented-subtransforms)))
               (outer-loop)))
           ;; Deal with any other even prime factors (there is only one).
           (let ((factor 2))
             (let loop ()
               (when (and (not (unsafe-fx=3D ntest 1))
                          (unsafe-fx=3D (unsafe-fxmodulo ntest factor) =
 0))
                 (set! factors (append factors (list factor)))
                 (set! ntest (unsafe-fxquotient ntest factor))
                 (loop))))
           ;; Deal with any other odd prime factors.
           (let ((factor 3))
             (let outer-loop ()
               (unless (unsafe-fx=3D ntest 1)
                 (let inner-loop ()
                   (unless (unsafe-fx=3D (unsafe-fxmodulo ntest factor) =
 0)
                     (set! factor (unsafe-fx+ factor 2))
                     (inner-loop)))
                 (set! factors (append factors (list factor)))
                 (set! ntest (unsafe-fxquotient ntest factor))
                 (outer-loop))))
           factors))))
 
 ;;; (struct fft-complex-wavetable (n
 ;;;                                nf
 ;;;                                factors
 ;;;                                twiddle
 ;;;                                trig))
 ;;;   n : (and/c exact-positive-integer? fixnum?)
 ;;;   nf : (and/c exact-positive-integer? fixnum?)
 ;;;   factors : (listof (and/c exact-positive-integer? fixnum?))
 ;;;   twiddle : (vectorof fixnum?)
 ;;;   trig : (vectorof complex?)
 (struct fft-complex-wavetable
   (n
    nf
    factors
    twiddle
    trig))
 
 ;;; fft-complex-wavetable-hash : hash-eq?
 (define fft-complex-wavetable-hash (make-hasheq))
 
 ;;; (get-fft-complex-wavetable n) -> fft-complex-wavetable?
 ;;;   n : (and/c exact-positive-integer? fixnum?)
 (define (get-fft-complex-wavetable n)
   (with-fixed (n)
     (hash-ref! fft-complex-wavetable-hash n
                (make-fft-complex-wavetable n))))
 
 ;;; (make-fft-complex-wavetable n) -> fft-complex-wavetable?
 ;;;   n : (and/c exact-positive-integer? fixnum?)
 ;;; Creates a new wavetable for vectors of length n.
 (define (make-fft-complex-wavetable n)
   (let* ((factors (fft-complex-factorize n))
          (nf (length factors))
          (twiddle (make-vector nf))
          (trig (make-vector n)))
     (let ((d-theta (unsafe-fl/ (unsafe-fl- 0.0 2*pi)
                                (unsafe-fx->fl n)))
           (t 0)
           (product 1)
           (product-1 0)
           (q 0))
       (for ((factor (in-list factors))
             (i (in-naturals)))
         (unsafe-vector-set! twiddle i t)
         (set! product-1 product) ; product-1 =3D p_(i-1)
         (set! product (unsafe-fx* product factor))
         (set! q (unsafe-fxquotient n product))
         (for ((j (in-range 1 factor)))
           (let ((m 0))
             (for ((k (in-range 1 (unsafe-fx+ q 1))))
               (set! m (unsafe-fx+ m (unsafe-fx* j product-1)))
               (set! m (unsafe-fxmodulo m n))
               (let ((theta
                      (unsafe-fl* d-theta
                                  (unsafe-fx->fl m)))) ; =
 d-theta*j*k*p_(i-1)
                 (unsafe-vector-set!
                  trig t (make-rectangular
                          (unsafe-flcos theta) (unsafe-flsin theta))))
               (set! t (unsafe-fx+ t 1)))))))
     (fft-complex-wavetable
      n nf factors twiddle trig)))
 
 ;;; (struct fft-complex-workspace (n
 ;;;                                scratch))
 ;;;   n : (and/c exact-positive-integer? fixnum?)
 ;;;   scratch : (vectorof complex?)
 (struct fft-complex-workspace
   (n
    scratch))
 
 ;;; (make-fft-complex-workspace n)
 ;;;   n : (and/c exact-positive-integer? fixnum?)
 (define (make-fft-complex-workspace n)
   (fft-complex-workspace n (make-vector n)))
 
 ;;; (fft-complex-forward data #:workspace workspace) -> void?
 ;;;   data : (vectorof complex?)
 ;;;   workspace : fft-complex-workspace
 ;;;     =3D (make-fft-complex-workspace (vector-length data))
 (define (fft-complex-forward
          data
          #:workspace
          (workspace (make-fft-complex-workspace (vector-length data))))
   (fft-complex-transform data fft-forward #:workspace workspace))
 
 
 
 ;;; (fft-complex-transform data sign #:workspace workspace) -> void?
 ;;;   data : (vectorof complex?)
 ;;;   sign : (or/c -1.0 1.0)
 ;;;   workspace : fft-complex-workspace
 ;;;     =3D (make-fft-complex-workspace (vector-length data))
 (define (fft-complex-transform
          data sign
          #:workspace
          (workspace (make-fft-complex-workspace (vector-length data))))
   (let ((n (vector-length data)))
     (unless (unsafe-fx=3D n (fft-complex-workspace-n workspace))
       (error 'fft-complex-transform
              "workspace does not match length of data, ~a"
              n))
     (let* ((wavetable (get-fft-complex-wavetable n))
            (nf (fft-complex-wavetable-nf wavetable))
            (factors (fft-complex-wavetable-factors wavetable))
            (twiddle (fft-complex-wavetable-twiddle wavetable))
            (trig (fft-complex-wavetable-trig wavetable))
            (scratch (fft-complex-workspace-scratch workspace))
            (state 0)
            (in data)
            (out scratch)
            (product 1)
            (q 0))
       (unless (unsafe-fx=3D n 1)
         (for ((factor (in-list factors))
               (i (in-naturals)))
           (set! product (unsafe-fx* product factor))
           (set! q (unsafe-fxquotient n product))
           (if (unsafe-fx=3D state 0)
               (begin
                 (set! in data)
                 (set! out scratch)
                 (set! state 1))
               (begin
                 (set! in scratch)
                 (set! out data)
                 (set! state 0)))
           (cond ((unsafe-fx=3D factor 4)
                  (let* ((twiddle1 (unsafe-vector-ref twiddle i))
                         (twiddle2 (unsafe-fx+ twiddle1 q))
                         (twiddle3 (unsafe-fx+ twiddle2 q)))
                    (fft-complex-pass-4
                     in out sign product n
                     trig twiddle1 twiddle2 twiddle3)))
                 (else
                  (error 'foo "ffo"))))
         (when (unsafe-fx=3D state 1)
           (for ((i (in-range n)))
             (unsafe-vector-set! data i (unsafe-vector-ref scratch =
 i))))))))
 
 
 ;;; (fft-complex-pass-4 in out sign product n trig
 ;;;                     twiddle1 twiddle2 twiddle3) -> void
 ;;;   in : (vectorof complex?)
 ;;;   out : (vectorof complex?)
 ;;;   sign : (one-of/c -1.0 1.0)
 ;;;   product : (and/c exact-positive-integer? fixnum?)
 ;;;   n : (and/c exact-positive-integer? fixnum?)
 ;;;   trig : (vectorof complex?)
 ;;;   twiddle1 : (and/c exact-nonnegative-integer? fixnum?)
 ;;;   twiddle2 : (and/c exact-nonnegative-integer? fixnum?)
 ;;;   twiddle3 : (and/c exact-nonnegative-integer? fixnum?)
 (define (fft-complex-pass-4 in out sign product n
                             trig twiddle1 twiddle2 twiddle3)
   (let* ((i 0)
          (j 0)
          (factor 4)
          (m (unsafe-fxquotient n factor))
          (q (unsafe-fxquotient n product))
          (p-1 (unsafe-fxquotient product factor))
          (jump (unsafe-fx* (unsafe-fx- factor 1) p-1)))
     (for ((k (in-range q)))
       (let ((w1-real 1.0)
             (w1-imag 0.0)
             (w2-real 1.0)
             (w2-imag 0.0)
             (w3-real 1.0)
             (w3-imag 0.0))
         (unless (unsafe-fx=3D k 0)
           (let ((tw1 (unsafe-vector-ref trig (unsafe-fx+ twiddle1 =
 (unsafe-fx- k 1))))
                 (tw2 (unsafe-vector-ref trig (unsafe-fx+ twiddle2 =
 (unsafe-fx- k 1))))
                 (tw3 (unsafe-vector-ref trig (unsafe-fx+ twiddle3 =
 (unsafe-fx- k 1)))))
             (if (=3D sign fft-forward)
                 (begin
                   ;; Forward transrofm
                   (set! w1-real (real-part tw1))
                   (set! w1-imag (imag-part tw1))
                   (set! w2-real (real-part tw2))
                   (set! w2-imag (imag-part tw2))
                   (set! w3-real (real-part tw3))
                   (set! w3-imag (imag-part tw3)))
                 (begin
                   ;; Backward transform : w -> conjugate(w)
                   (set! w1-real (real-part tw1))
                   (set! w1-imag (- (imag-part tw1)))
                   (set! w2-real (real-part tw2))
                   (set! w2-imag (- (imag-part tw2)))
                   (set! w3-real (real-part tw3))
                   (set! w3-imag (- (imag-part tw3)))))))
         (for ((k1 (in-range p-1)))
           (unless (andmap number? (vector->list in))
             (error 'uh-oh "expected a vector of numbers..."))
           (let* ((z0 (vector-ref in i))
                  (z0-real (real-part z0))
                  (z0-imag (imag-part z0))
                  (z1 (unsafe-vector-ref in (unsafe-fx+ i m)))
                  (z1-real (real-part z1))
                  (z1-imag (imag-part z1))
                  (z2 (unsafe-vector-ref in (unsafe-fx+ i (unsafe-fx* 2 =
 m))))
                  (z2-real (real-part z2))
                  (z2-imag (imag-part z2))
                  (z3 (unsafe-vector-ref in (unsafe-fx+ i (unsafe-fx* 3 =
 m))))
                  (z3-real (real-part z3))
                  (z3-imag (imag-part z3)))
             (with-float (z0-real z0-imag z1-real z1-imag
                          z2-real z2-imag z3-real z3-imag)
               ;; Compute x =3D W(4) z         =20
               (let* (;; t1 =3D z0 + z2
                      (t1-real (unsafe-fl+ z0-real z2-real))
                      (t1-imag (unsafe-fl+ z0-imag z2-imag))
                      ;; t2 =3D z1 + z3
                      (t2-real (unsafe-fl+ z1-real z3-real))
                      (t2-imag (unsafe-fl+ z1-imag z3-imag))
                      ;; t3 =3D z0 - z2
                      (t3-real (unsafe-fl- z0-real z2-real))
                      (t3-imag (unsafe-fl- z0-imag z2-imag))
                      ;; t4 =3D (+/-) (z1 - z3)
                      (t4-real (* sign (unsafe-fl- z1-real z3-real)))
                      (t4-imag (* sign (unsafe-fl- z1-imag z3-imag)))
                      ;; x0 =3D t1 + t2
                      (x0-real (unsafe-fl+ t1-real t2-real))
                      (x0-imag (unsafe-fl+ t1-imag t2-imag))
                      ;; x1 =3D t3 + i t4
                      (x1-real (unsafe-fl- t3-real t4-imag))
                      (x1-imag (unsafe-fl+ t3-imag t4-real))
                      ;; x2 =3D t1 - t2
                      (x2-real (unsafe-fl- t1-real t2-real))
                      (x2-imag (unsafe-fl- t1-imag t2-imag))
                      ;; x3 =3D t3 - i t4
                      (x3-real (unsafe-fl+ t3-real t4-imag))
                      (x3-imag (unsafe-fl- t3-imag t4-real)))
                 ;; Apply twiddle factors
                 ;; to0 =3D 1 * x0
                 (vector-set!
                  out j (make-rectangular x0-real x0-imag))
                 ;; to1 =3D w1 * x1
                 #;(vector-set!
                  out (unsafe-fx+ j p-1)
                  (make-rectangular
                   (unsafe-fl- (unsafe-fl* w1-real x1-real)
                               (unsafe-fl* w1-imag x1-imag))
                   (unsafe-fl+ (unsafe-fl* w1-real x1-imag)
                               (unsafe-fl* w1-imag x1-real))))
                 ;; to2 =3D w2 * x2
                 #;(vector-set!
                  out (unsafe-fx+ j (unsafe-fx* 2 p-1))
                  (make-rectangular
                   (unsafe-fl- (unsafe-fl* w2-real x2-real)
                               (unsafe-fl* w2-imag x2-imag))
                   (unsafe-fl+ (unsafe-fl* w2-real x2-imag)
                               (unsafe-fl* w2-imag x2-real))))
                 ;; to3 =3D w3 * x3
                 #;(vector-set!
                  out (unsafe-fx+ j (unsafe-fx* 3 p-1))
                  (make-rectangular
                   (unsafe-fl- (unsafe-fl* w3-real x3-real)
                               (unsafe-fl* w3-imag x3-imag))
                   (unsafe-fl+ (unsafe-fl* w3-real x3-imag)
                               (unsafe-fl* w3-imag x3-real))))
                 #;(set! i (unsafe-fx+ i 1))
                 #;(set! j (unsafe-fx+ j 1))))))
         (set! j (unsafe-fx+ j jump))))))
 
 
 ;;; Generic DFT
 
 
 ;;; Module Contracts
 
 (provide
  (rename-out
   (fft-complex-forward unchecked-fft-complex-forward)))
 
 (provide/contract
  (fft-complex-workspace?
   (-> any/c boolean?))
  (make-fft-complex-workspace
   (-> exact-positive-integer? fft-complex-workspace?))
  (fft-complex-forward
   (->* ((vectorof complex?))
        (#:workspace fft-complex-workspace?)
        void?)))
 
 
 
 
 
 ;;; (with-fixed (x ...)
 ;;;  expr ...)
 ;;; Executes the expr's with the x's guaranteed to be fixnums. All of =
 the x's
 ;;; must be identifiers. Note that this does not attempt to coerce =
 anything to a
 ;;; fixnum, just assure that they are.
 (define-syntax (with-fixed stx)
   (syntax-case stx ()
     ((with-fized (x ...) expr ...)
      (for ((id (in-list (syntax->list #'(x ...)))))
        (unless (identifier? id)
          (raise-syntax-error #f
                              "not an identifier"
                              stx
                              id)))
      #`(let ((x (if (fixnum? x)
                     x
                     (error "expected fixed integer, given" x)))
              ...)
          expr ...))))
 
 ;;; (with-float (x ...)
 ;;;   expr ...)
 ;;; Executes the expr's with the x's guaranteed to be floats. All of the =
 x's
 ;;; must be identifiers.
 (define-syntax (with-float stx)
   (syntax-case stx ()
     ((with-float (x ...) expr ...)
      (for ((id (in-list (syntax->list #'(x ...)))))
        (unless (identifier? id)
          (raise-syntax-error #f
                              "not an identifier"
                              stx
                              id)))
      #`(let ((x (if (real? x)
                     (exact->inexact x)
                     (error "expected real, given" x)))
              ...)
          expr ...))))
 
 ;;; Module Contracts
 
From: Matthew Flatt <mflatt@cs.utah.edu>
To: John Clements <clements@brinckerhoff.org>
Cc: John Clements <clements@brinckerhoff.org>,
        "bugs@racket-lang.org" <bugs@racket-lang.org>
Subject: Re: [racket-bug] all/11264: Another very similar JIT bug
Date: Tue, 28 Sep 2010 18:10:10 -0400

 Do you need to use 'unsafe-vector*' operations? If I remember  
 correctly, those are the ones that work with proxies (and the fact  
 that the vector contract now uses a proxy was relevant to the earlier  
 bug).
 
 
 
 On Sep 28, 2010, at 5:16 PM, John Clements <clements@brinckerhoff.org>  
 wrote:
 
 >
 > On Sep 28, 2010, at 2:08 PM, clements@brinckerhoff.org wrote:
 >
 >> A new problem report is waiting at
 >> http://bugs.racket-lang.org/query/?cmd=view&pr=11264
 >>
 >> Reported by John Clements for release: 5.0.1.7--2010-09-28(202af50/g)
 >>
 >> *** Description:
 >> This seems *very* closely related to the earlier JIT bug;
 >> the difference is that now it only happens with the
 >> unsafe operations enabled.
 >>
 >> I'll respond to the auto-generated e-mail with the
 >> content of fft.rkt
 >
 > ... and here it is:
 >
 > #lang racket
 >
 > (require racket/unsafe/ops
 >         #;(prefix-in unsafe- racket/fixnum)
 >         #;(prefix-in unsafe- racket/flonum))
 >
 > #|
 > (define unsafe-vector-length vector-length)
 > (define unsafe-vector-ref vector-ref)
 > (define unsafe-vector-set! vector-set!)
 > |#
 > (define 2*pi (* 2.0 pi))
 >
 > ;;; fft-forward : real? = -1.0
 > ;;; fft-backward : real? = +1.0
 > (define fft-forward -1.0)
 > (define fft-backward +1.0)
 >
 > ;;; Radix 2 Complex FFT
 >
 > ;;; (fft-bitreverse-order data) -> void?
 > ;;;   data : (vectorof complex?)
 > ;;; Implements the Gold-Rader bit-reversal algorithm. Note that this  
 > is an
 > ;;; internal routine and all operations are unsafe.
 > (define (fft-bitreverse-order data)
 >  (let ((n (unsafe-vector-length data)))
 >    (for/fold ((j 0))
 >              ((i (in-range (unsafe-fx- n 1))))
 >      (let ((k (unsafe-fxquotient n 2)))
 >        (when (unsafe-fx< i j)
 >          (let ((tmp (unsafe-vector-ref data i)))
 >            (unsafe-vector-set! data i (unsafe-vector-ref data j))
 >            (unsafe-vector-set! data j tmp)))
 >        (let loop ()
 >          (when (unsafe-fx<= k j)
 >            (set! j (unsafe-fx- j k))
 >            (set! k (unsafe-fxquotient k 2))
 >            (loop)))
 >        (unsafe-fx+ j k)))
 >    (void)))
 >
 > ;;; (fft-binary-logn n) -> (or/c exact-nonnegative-integer? false/c)
 > ;;;   n : exact-nonegative-integer?
 > ;;; If n is a power of 2, returns the base 2 log of n (i.e.,
 > ;;; (expt (fft-binary-logn n) 2) = n), otherwise #f is returned.  
 > Note that this
 > ;;; is an internal routine and all operations are unsafe.
 > (define (fft-binary-logn n)
 >  (with-fixed (n)
 >    (let ((binary-logn
 >           (let loop ((k 1)
 >                      (l 0))
 >             (if (unsafe-fx>= k n)
 >                 l
 >                 (loop (unsafe-fx* k 2) (unsafe-fx+ l 1))))))
 >      (if (unsafe-fx= n (unsafe-fxlshift 1 binary-logn))
 >          binary-logn
 >          #f))))
 >
 > ;;; Decimation in Time
 >
 >
 > ;;; Decimation in Frequency
 >
 >
 > ;;; Multi-Radix Complex FFT
 >
 > ;;; (fft-complex-factorize n)
 > ;;; -> (listof fixnum?)
 > ;;;   n : fixnum?
 > (define (fft-complex-factorize n)
 >  (fft-factorize n '(5 4 3 2)))
 >
 > ;;; (fft-factorize n implemented-subtransforms) -> (listof fixnum?)
 > ;;;   n : fixnum?
 > ;;;   implemented-subtransforms : (listof fixnum?)
 > (define (fft-factorize n implemented-subtransforms)
 >  (with-fixed (n)
 >    (if (unsafe-fx= n 1)
 >        '(1)
 >        (let ((ntest n)
 >              (factors '()))
 >          ;; Deal with implemented factors first.
 >          (let outer-loop ()
 >            (unless (or (null? implemented-subtransforms)
 >                        (unsafe-fx= ntest 0))
 >              (let ((factor (car implemented-subtransforms)))
 >                (let inner-loop ()
 >                  (when (unsafe-fx= (unsafe-fxmodulo ntest factor) 0)
 >                    (set! factors (append factors (list factor)))
 >                    (set! ntest (unsafe-fxquotient ntest factor))
 >                    (inner-loop)))
 >                (set! implemented-subtransforms
 >                      (cdr implemented-subtransforms)))
 >              (outer-loop)))
 >          ;; Deal with any other even prime factors (there is only  
 > one).
 >          (let ((factor 2))
 >            (let loop ()
 >              (when (and (not (unsafe-fx= ntest 1))
 >                         (unsafe-fx= (unsafe-fxmodulo ntest factor) 0))
 >                (set! factors (append factors (list factor)))
 >                (set! ntest (unsafe-fxquotient ntest factor))
 >                (loop))))
 >          ;; Deal with any other odd prime factors.
 >          (let ((factor 3))
 >            (let outer-loop ()
 >              (unless (unsafe-fx= ntest 1)
 >                (let inner-loop ()
 >                  (unless (unsafe-fx= (unsafe-fxmodulo ntest factor) 0)
 >                    (set! factor (unsafe-fx+ factor 2))
 >                    (inner-loop)))
 >                (set! factors (append factors (list factor)))
 >                (set! ntest (unsafe-fxquotient ntest factor))
 >                (outer-loop))))
 >          factors))))
 >
 > ;;; (struct fft-complex-wavetable (n
 > ;;;                                nf
 > ;;;                                factors
 > ;;;                                twiddle
 > ;;;                                trig))
 > ;;;   n : (and/c exact-positive-integer? fixnum?)
 > ;;;   nf : (and/c exact-positive-integer? fixnum?)
 > ;;;   factors : (listof (and/c exact-positive-integer? fixnum?))
 > ;;;   twiddle : (vectorof fixnum?)
 > ;;;   trig : (vectorof complex?)
 > (struct fft-complex-wavetable
 >  (n
 >   nf
 >   factors
 >   twiddle
 >   trig))
 >
 > ;;; fft-complex-wavetable-hash : hash-eq?
 > (define fft-complex-wavetable-hash (make-hasheq))
 >
 > ;;; (get-fft-complex-wavetable n) -> fft-complex-wavetable?
 > ;;;   n : (and/c exact-positive-integer? fixnum?)
 > (define (get-fft-complex-wavetable n)
 >  (with-fixed (n)
 >    (hash-ref! fft-complex-wavetable-hash n
 >               (make-fft-complex-wavetable n))))
 >
 > ;;; (make-fft-complex-wavetable n) -> fft-complex-wavetable?
 > ;;;   n : (and/c exact-positive-integer? fixnum?)
 > ;;; Creates a new wavetable for vectors of length n.
 > (define (make-fft-complex-wavetable n)
 >  (let* ((factors (fft-complex-factorize n))
 >         (nf (length factors))
 >         (twiddle (make-vector nf))
 >         (trig (make-vector n)))
 >    (let ((d-theta (unsafe-fl/ (unsafe-fl- 0.0 2*pi)
 >                               (unsafe-fx->fl n)))
 >          (t 0)
 >          (product 1)
 >          (product-1 0)
 >          (q 0))
 >      (for ((factor (in-list factors))
 >            (i (in-naturals)))
 >        (unsafe-vector-set! twiddle i t)
 >        (set! product-1 product) ; product-1 = p_(i-1)
 >        (set! product (unsafe-fx* product factor))
 >        (set! q (unsafe-fxquotient n product))
 >        (for ((j (in-range 1 factor)))
 >          (let ((m 0))
 >            (for ((k (in-range 1 (unsafe-fx+ q 1))))
 >              (set! m (unsafe-fx+ m (unsafe-fx* j product-1)))
 >              (set! m (unsafe-fxmodulo m n))
 >              (let ((theta
 >                     (unsafe-fl* d-theta
 >                                 (unsafe-fx->fl m)))) ; d-theta*j*k*p_ 
 > (i-1)
 >                (unsafe-vector-set!
 >                 trig t (make-rectangular
 >                         (unsafe-flcos theta) (unsafe-flsin theta))))
 >              (set! t (unsafe-fx+ t 1)))))))
 >    (fft-complex-wavetable
 >     n nf factors twiddle trig)))
 >
 > ;;; (struct fft-complex-workspace (n
 > ;;;                                scratch))
 > ;;;   n : (and/c exact-positive-integer? fixnum?)
 > ;;;   scratch : (vectorof complex?)
 > (struct fft-complex-workspace
 >  (n
 >   scratch))
 >
 > ;;; (make-fft-complex-workspace n)
 > ;;;   n : (and/c exact-positive-integer? fixnum?)
 > (define (make-fft-complex-workspace n)
 >  (fft-complex-workspace n (make-vector n)))
 >
 > ;;; (fft-complex-forward data #:workspace workspace) -> void?
 > ;;;   data : (vectorof complex?)
 > ;;;   workspace : fft-complex-workspace
 > ;;;     = (make-fft-complex-workspace (vector-length data))
 > (define (fft-complex-forward
 >         data
 >         #:workspace
 >         (workspace (make-fft-complex-workspace (vector-length data))))
 >  (fft-complex-transform data fft-forward #:workspace workspace))
 >
 >
 >
 > ;;; (fft-complex-transform data sign #:workspace workspace) -> void?
 > ;;;   data : (vectorof complex?)
 > ;;;   sign : (or/c -1.0 1.0)
 > ;;;   workspace : fft-complex-workspace
 > ;;;     = (make-fft-complex-workspace (vector-length data))
 > (define (fft-complex-transform
 >         data sign
 >         #:workspace
 >         (workspace (make-fft-complex-workspace (vector-length data))))
 >  (let ((n (vector-length data)))
 >    (unless (unsafe-fx= n (fft-complex-workspace-n workspace))
 >      (error 'fft-complex-transform
 >             "workspace does not match length of data, ~a"
 >             n))
 >    (let* ((wavetable (get-fft-complex-wavetable n))
 >           (nf (fft-complex-wavetable-nf wavetable))
 >           (factors (fft-complex-wavetable-factors wavetable))
 >           (twiddle (fft-complex-wavetable-twiddle wavetable))
 >           (trig (fft-complex-wavetable-trig wavetable))
 >           (scratch (fft-complex-workspace-scratch workspace))
 >           (state 0)
 >           (in data)
 >           (out scratch)
 >           (product 1)
 >           (q 0))
 >      (unless (unsafe-fx= n 1)
 >        (for ((factor (in-list factors))
 >              (i (in-naturals)))
 >          (set! product (unsafe-fx* product factor))
 >          (set! q (unsafe-fxquotient n product))
 >          (if (unsafe-fx= state 0)
 >              (begin
 >                (set! in data)
 >                (set! out scratch)
 >                (set! state 1))
 >              (begin
 >                (set! in scratch)
 >                (set! out data)
 >                (set! state 0)))
 >          (cond ((unsafe-fx= factor 4)
 >                 (let* ((twiddle1 (unsafe-vector-ref twiddle i))
 >                        (twiddle2 (unsafe-fx+ twiddle1 q))
 >                        (twiddle3 (unsafe-fx+ twiddle2 q)))
 >                   (fft-complex-pass-4
 >                    in out sign product n
 >                    trig twiddle1 twiddle2 twiddle3)))
 >                (else
 >                 (error 'foo "ffo"))))
 >        (when (unsafe-fx= state 1)
 >          (for ((i (in-range n)))
 >            (unsafe-vector-set! data i (unsafe-vector-ref scratch  
 > i))))))))
 >
 >
 > ;;; (fft-complex-pass-4 in out sign product n trig
 > ;;;                     twiddle1 twiddle2 twiddle3) -> void
 > ;;;   in : (vectorof complex?)
 > ;;;   out : (vectorof complex?)
 > ;;;   sign : (one-of/c -1.0 1.0)
 > ;;;   product : (and/c exact-positive-integer? fixnum?)
 > ;;;   n : (and/c exact-positive-integer? fixnum?)
 > ;;;   trig : (vectorof complex?)
 > ;;;   twiddle1 : (and/c exact-nonnegative-integer? fixnum?)
 > ;;;   twiddle2 : (and/c exact-nonnegative-integer? fixnum?)
 > ;;;   twiddle3 : (and/c exact-nonnegative-integer? fixnum?)
 > (define (fft-complex-pass-4 in out sign product n
 >                            trig twiddle1 twiddle2 twiddle3)
 >  (let* ((i 0)
 >         (j 0)
 >         (factor 4)
 >         (m (unsafe-fxquotient n factor))
 >         (q (unsafe-fxquotient n product))
 >         (p-1 (unsafe-fxquotient product factor))
 >         (jump (unsafe-fx* (unsafe-fx- factor 1) p-1)))
 >    (for ((k (in-range q)))
 >      (let ((w1-real 1.0)
 >            (w1-imag 0.0)
 >            (w2-real 1.0)
 >            (w2-imag 0.0)
 >            (w3-real 1.0)
 >            (w3-imag 0.0))
 >        (unless (unsafe-fx= k 0)
 >          (let ((tw1 (unsafe-vector-ref trig (unsafe-fx+ twiddle1  
 > (unsafe-fx- k 1))))
 >                (tw2 (unsafe-vector-ref trig (unsafe-fx+ twiddle2  
 > (unsafe-fx- k 1))))
 >                (tw3 (unsafe-vector-ref trig (unsafe-fx+ twiddle3  
 > (unsafe-fx- k 1)))))
 >            (if (= sign fft-forward)
 >                (begin
 >                  ;; Forward transrofm
 >                  (set! w1-real (real-part tw1))
 >                  (set! w1-imag (imag-part tw1))
 >                  (set! w2-real (real-part tw2))
 >                  (set! w2-imag (imag-part tw2))
 >                  (set! w3-real (real-part tw3))
 >                  (set! w3-imag (imag-part tw3)))
 >                (begin
 >                  ;; Backward transform : w -> conjugate(w)
 >                  (set! w1-real (real-part tw1))
 >                  (set! w1-imag (- (imag-part tw1)))
 >                  (set! w2-real (real-part tw2))
 >                  (set! w2-imag (- (imag-part tw2)))
 >                  (set! w3-real (real-part tw3))
 >                  (set! w3-imag (- (imag-part tw3)))))))
 >        (for ((k1 (in-range p-1)))
 >          (unless (andmap number? (vector->list in))
 >            (error 'uh-oh "expected a vector of numbers..."))
 >          (let* ((z0 (vector-ref in i))
 >                 (z0-real (real-part z0))
 >                 (z0-imag (imag-part z0))
 >                 (z1 (unsafe-vector-ref in (unsafe-fx+ i m)))
 >                 (z1-real (real-part z1))
 >                 (z1-imag (imag-part z1))
 >                 (z2 (unsafe-vector-ref in (unsafe-fx+ i (unsafe-fx*  
 > 2 m))))
 >                 (z2-real (real-part z2))
 >                 (z2-imag (imag-part z2))
 >                 (z3 (unsafe-vector-ref in (unsafe-fx+ i (unsafe-fx*  
 > 3 m))))
 >                 (z3-real (real-part z3))
 >                 (z3-imag (imag-part z3)))
 >            (with-float (z0-real z0-imag z1-real z1-imag
 >                         z2-real z2-imag z3-real z3-imag)
 >              ;; Compute x = W(4) z
 >              (let* (;; t1 = z0 + z2
 >                     (t1-real (unsafe-fl+ z0-real z2-real))
 >                     (t1-imag (unsafe-fl+ z0-imag z2-imag))
 >                     ;; t2 = z1 + z3
 >                     (t2-real (unsafe-fl+ z1-real z3-real))
 >                     (t2-imag (unsafe-fl+ z1-imag z3-imag))
 >                     ;; t3 = z0 - z2
 >                     (t3-real (unsafe-fl- z0-real z2-real))
 >                     (t3-imag (unsafe-fl- z0-imag z2-imag))
 >                     ;; t4 = (+/-) (z1 - z3)
 >                     (t4-real (* sign (unsafe-fl- z1-real z3-real)))
 >                     (t4-imag (* sign (unsafe-fl- z1-imag z3-imag)))
 >                     ;; x0 = t1 + t2
 >                     (x0-real (unsafe-fl+ t1-real t2-real))
 >                     (x0-imag (unsafe-fl+ t1-imag t2-imag))
 >                     ;; x1 = t3 + i t4
 >                     (x1-real (unsafe-fl- t3-real t4-imag))
 >                     (x1-imag (unsafe-fl+ t3-imag t4-real))
 >                     ;; x2 = t1 - t2
 >                     (x2-real (unsafe-fl- t1-real t2-real))
 >                     (x2-imag (unsafe-fl- t1-imag t2-imag))
 >                     ;; x3 = t3 - i t4
 >                     (x3-real (unsafe-fl+ t3-real t4-imag))
 >                     (x3-imag (unsafe-fl- t3-imag t4-real)))
 >                ;; Apply twiddle factors
 >                ;; to0 = 1 * x0
 >                (vector-set!
 >                 out j (make-rectangular x0-real x0-imag))
 >                ;; to1 = w1 * x1
 >                #;(vector-set!
 >                 out (unsafe-fx+ j p-1)
 >                 (make-rectangular
 >                  (unsafe-fl- (unsafe-fl* w1-real x1-real)
 >                              (unsafe-fl* w1-imag x1-imag))
 >                  (unsafe-fl+ (unsafe-fl* w1-real x1-imag)
 >                              (unsafe-fl* w1-imag x1-real))))
 >                ;; to2 = w2 * x2
 >                #;(vector-set!
 >                 out (unsafe-fx+ j (unsafe-fx* 2 p-1))
 >                 (make-rectangular
 >                  (unsafe-fl- (unsafe-fl* w2-real x2-real)
 >                              (unsafe-fl* w2-imag x2-imag))
 >                  (unsafe-fl+ (unsafe-fl* w2-real x2-imag)
 >                              (unsafe-fl* w2-imag x2-real))))
 >                ;; to3 = w3 * x3
 >                #;(vector-set!
 >                 out (unsafe-fx+ j (unsafe-fx* 3 p-1))
 >                 (make-rectangular
 >                  (unsafe-fl- (unsafe-fl* w3-real x3-real)
 >                              (unsafe-fl* w3-imag x3-imag))
 >                  (unsafe-fl+ (unsafe-fl* w3-real x3-imag)
 >                              (unsafe-fl* w3-imag x3-real))))
 >                #;(set! i (unsafe-fx+ i 1))
 >                #;(set! j (unsafe-fx+ j 1))))))
 >        (set! j (unsafe-fx+ j jump))))))
 >
 >
 > ;;; Generic DFT
 >
 >
 > ;;; Module Contracts
 >
 > (provide
 > (rename-out
 >  (fft-complex-forward unchecked-fft-complex-forward)))
 >
 > (provide/contract
 > (fft-complex-workspace?
 >  (-> any/c boolean?))
 > (make-fft-complex-workspace
 >  (-> exact-positive-integer? fft-complex-workspace?))
 > (fft-complex-forward
 >  (->* ((vectorof complex?))
 >       (#:workspace fft-complex-workspace?)
 >       void?)))
 >
 >
 >
 >
 >
 > ;;; (with-fixed (x ...)
 > ;;;  expr ...)
 > ;;; Executes the expr's with the x's guaranteed to be fixnums. All  
 > of the x's
 > ;;; must be identifiers. Note that this does not attempt to coerce  
 > anything to a
 > ;;; fixnum, just assure that they are.
 > (define-syntax (with-fixed stx)
 >  (syntax-case stx ()
 >    ((with-fized (x ...) expr ...)
 >     (for ((id (in-list (syntax->list #'(x ...)))))
 >       (unless (identifier? id)
 >         (raise-syntax-error #f
 >                             "not an identifier"
 >                             stx
 >                             id)))
 >     #`(let ((x (if (fixnum? x)
 >                    x
 >                    (error "expected fixed integer, given" x)))
 >             ...)
 >         expr ...))))
 >
 > ;;; (with-float (x ...)
 > ;;;   expr ...)
 > ;;; Executes the expr's with the x's guaranteed to be floats. All of  
 > the x's
 > ;;; must be identifiers.
 > (define-syntax (with-float stx)
 >  (syntax-case stx ()
 >    ((with-float (x ...) expr ...)
 >     (for ((id (in-list (syntax->list #'(x ...)))))
 >       (unless (identifier? id)
 >         (raise-syntax-error #f
 >                             "not an identifier"
 >                             stx
 >                             id)))
 >     #`(let ((x (if (real? x)
 >                    (exact->inexact x)
 >                    (error "expected real, given" x)))
 >             ...)
 >         expr ...))))
 >
 > ;;; Module Contracts
 >
From: John Clements <clements@brinckerhoff.org>
To: Matthew Flatt <mflatt@cs.utah.edu>
Cc: "bugs@racket-lang.org" <bugs@racket-lang.org>
Subject: Re: [racket-bug] all/11264: Another very similar JIT bug
Date: Tue, 28 Sep 2010 16:19:52 -0700

 On Sep 28, 2010, at 3:10 PM, Matthew Flatt wrote:
 
 > Do you need to use 'unsafe-vector*' operations? If I remember =
 correctly, those are the ones that work with proxies (and the fact that =
 the vector contract now uses a proxy was relevant to the earlier bug).
 
 That fixes it just fine.  This is Doug Williams' FFT code; I have no =
 idea how much faster it would be with the unsafe operations. =20
 
 Thanks for the pointer,
 
 John


State changed from "open" to "closed" by mflatt at Sat, 08 Jan 2011 10:09:15 -0500
Reason>>> `unsafe-vector*-...' became `unsafe-vector-...'

