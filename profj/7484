From apache@plt-scheme.org Mon Jul  4 12:40:59 2005
Received: from champlain.ccs.neu.edu (champlain.ccs.neu.edu [127.0.0.1])
	by champlain.ccs.neu.edu (8.12.10/8.12.10) with ESMTP id j64GeuZS028057
	for <bugs@plt-scheme.org>; Mon, 4 Jul 2005 12:40:56 -0400
Message-Id: <200507041640.j64GeuPQ028055@champlain.ccs.neu.edu>
Date: Mon, 4 Jul 2005 12:40:56 -0400
From: matthias@ccs.neu.edu
To: bugs@plt-scheme.org
Subject: professorJ mentions guard-convert-Color in strange error report

>Number:         7484
>Category:       profj
>Synopsis:       professorJ mentions guard-convert-Color in strange error report
>Class:          sw-bug
>Responsible:    kathyg
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Mon Jul 04 12:45:00 -0400 2005
>Last-Modified:  Mon Jul 04 18:00:01 -0400 2005
>Originator:     matthias
>Organization:
plt
>Submitter-Id:   unknown
>Release:        299.107-svn4jul2005
>Environment:
macosx "Darwin europe.local 7.9.0 Darwin Kernel Version 7.9.0: Wed Mar 30 20:11:17 PST 2005; root:xnu/xnu-517.12.7.obj~1/RELEASE_PPC  Power Macintosh powerpc" (ppc-macosx) (get-display-depth) = 32
Docs Installed:
(#<path:/Users/matthias/plt/collects/doc/help>)
Collections:
((#<path:/Users/matthias/Library/PLT Scheme/299.107/collects> "non-existent path") (#<path:/Users/matthias/plt/collects> (#<path:.svn> #<path:afm> #<path:algol60> #<path:browser> #<path:compiler> #<path:defaults> #<path:doc> #<path:drscheme> #<path:dynext> #<path:embedded-gui> #<path:eopl> #<path:errortrace> #<path:ffi> #<path:finish-install> #<path:framework> #<path:frtime> #<path:games> #<path:graphics> #<path:guibuilder> #<path:handin-client> #<path:handin-server> #<path:help> #<path:hierlist> #<path:honu> #<path:honu-module> #<path:htdch> #<path:htdp> #<path:html> #<path:icons> #<path:info-domain> #<path:lang> #<path:launcher> #<path:make> #<path:mred> #<path:mrflow> #<path:mrlib> #<path:mysterx> #<path:mzcom> #<path:mzlib> #<path:mzscheme> #<path:mztake> #<path:net> #<path:openssl> #<path:parser-tools> #<path:planet> #<path:plot> #<path:preprocessor> #<path:profj> #<path:profjBoxes> #<path:profjWizard> #<path:readline> #<path:reduction-semantics> #<path:repos-time-stamp> #<path:setup> #<path:sgl> #<path:sirmail> #<path:skipper> #<path:slatex> #<path:slibinit> #<path:slideshow> #<path:srfi> #<path:srpersist> #<path:ssax> #<path:stepper> #<path:string-constants> #<path:swindle> #<path:syntax> #<path:syntax-color> #<path:test-suite> #<path:tests> #<path:tex2page> #<path:texpict> #<path:trace> #<path:version> #<path:waterworld> #<path:web-server> #<path:xelda> #<path:xml>)))
Human Language: english
Teachpack filenames: ()
Computer Language: (("Experimental Languages" "ProfessorJ" "Intermediate") ((field) (#f)))
>Description:
I ran the program in "steps to reproduce" just fine for an hour.
After deleting some comments I get this: 

Welcome to DrScheme, version 299.107-svn4jul2005.
Language: ProfessorJ: Intermediate.
expand: unbound variable in module in: guard-convert-Color
> 

I can't get it to work anymore either. ARGH! 
>How-To-Repeat:
excuse the indentation but see previous bug report 

import draw.*;

import java.util.Random;

class Game {
  WormWorld w;

  Game() {
   this.w = new WormWorld(
		new Worm(new Segment(100,100,"left"),new MtSegment()),
	        new Food(100,100),
	        new Box(300,300));
  }

  // set up the world, draw it, and go
  boolean go(double speed) {
    return (this.w.start(300,300) && this.w.bigBang(speed) && this.w.draw());
   }
}

// ------------------------------------------------------------------------------
// represent the world of a Worm Game: Worm, Food, and the Bounding Box
class WormWorld extends World {

   Worm w;
   Food f;
   Box  b;

   WormWorld(Worm w, Food f, Box b) {
     this.w = w;
     this.f = f;
     this.b = b;
   }

   // what happens when the clock ticks
   World onTick() {
     return this.move(this.w.step());
   }

   // what happens when the palyer presses a key
   World onKeyEvent(String ke) {
     return this.move(this.w.move(ke));
   }

   // move the world 
   WormWorld move(Worm newWorm) {
     if (newWorm.ateItself() 
         && this.finish("Your worm ate itself: ".concat(String.valueOf(newWorm.length()))))
        return this;
     else if (newWorm.ranIntoWall(this.b)
	      && this.finish("Your worm ran into a wall: ".concat(String.valueOf(newWorm.length()))))
	return this;
     else if (newWorm.canEat(this.f)
	      && this.announce("Your worm just ate: ".concat(String.valueOf(newWorm.length()))))
        return new WormWorld(newWorm.eat(this.f),this.f.create(this.b),this.b);		
     else // move the worm
        return new WormWorld(newWorm,this.f,this.b);
   }

   // announce something and stop this world
   boolean finish(String s) {
     return this.write(s) && this.endOfTime();
   }

   // announce something and stop this world
   boolean announce(String s) {
     return this.write(s);
   }

   // write a string to this worm world
   boolean write(String s) {
     return (   this.drawRect(new Posn(10,280),150,20,new White())
	     && this.drawString(new Posn(10,290),s));
   }

   // draw this world
   boolean draw() { return this.w.draw(this) && this.f.draw(this); }

   // erase this world
   boolean erase() { return this.w.erase(this) && this.f.erase(this); }
}

// -----------------------------------------------------------------------------
// Box: represents the playing field for the worm game

class Box {
    int width;
    int height;

    Box(int width, int height) {
	this.width = width;
	this.height = height; 	
    }

    // is p inside of _this_ box?
    boolean inside(Posn p) {
	return
	    (0 <= p.x && p.x <= this.width) &&
	    (0 <= p.y && p.y <= this.height);
    }
}


// -----------------------------------------------------------------------------
// represents a piece of food as a solid rectangle with northwest corner at (x,y)
class Food {
    int x;
    int y;

    int width = 20;
    int height = 10;
    Color color = new Green();

    Random foodPlace = new Random();

    Food(int x, int y) {
   	this.x = x;
	   this.y = y;
    }

    // is p inside of this Food shape
    boolean inside(Posn p) {
   	return
	    (this.x <= p.x && p.x <= this.x+this.width) &&
	    (this.y <= p.y && p.y <= this.y+this.width);
    }

    // create a food pile that is at a different location than this 
    // use trial and error
    Food create(Box b) {
	   int x = new Random().nextInt(b.width-1); // -1 to stay within boundaries
    	int y = new Random().nextInt(b.height-1);

    	if ((this.x != x) && this.y != y)
	    return new Food(x,y);
   	else
	    return this.create(b);
    }

    boolean draw(World w) {
   	return w.drawRect(new Posn(this.x,this.y),this.width,this.height,this.color);
    }
	
    boolean erase(World w) {
	   return w.clearRect(new Posn(this.x,this.y),this.width,this.height,this.color);
    }
}


// -----------------------------------------------------------------------------
// Worm is a head segment plus a potentially empty sequence of segments

class Worm {
    Segment head;
    ListSegment body;
    Worm(Segment head, ListSegment body) {
   	this.head = head;
	   this.body = body;
    }

    // where is the head of the worm?
    Posn posn() {
   	return new Posn(this.head.x,this.head.y);
    }

    // where is this going?
    String whereTo() {
        return this.head.whereTo();
    }

    // did this worm run into the wall?
    boolean ranIntoWall(Box b) {
      return !b.inside(this.posn());
    }

    // move this worm in the direction of the keyevent
    //   if ke is in left, right, up, down
    // head moves in the direction of the predecessor
    // body element n+1 moves into the position of element n
    // body element 0 moves into the position of head
    Worm move(String ke) {
	if (this.head.move(ke).equal(this.head))
	   return this; // the key was not a directional change
        else
	   return new Worm(this.head.move(ke),this.body.move(this.head));
    }

    Worm step() { 
      return new Worm(this.head.move(this.whereTo()),this.body.move(this.head));
    }

    // did this worm run into itself after a move?
    boolean ateItself() {
	return this.body.overlap(this.head);
    }

    // can the head of this worm eat the food?
    boolean canEat(Food f) {
	return this.head.canEat(f);
    }

    // move the head into the direction into which it is going already
    // the old head becomes part of the body
    // @pre: canEat(f)
    // @post: !ateItself()
    Worm eat(Food f) {
	return new Worm(this.head.move(this.whereTo()),
			new ConsSegment(this.head,this.body));
    }

    // how long is the worm 
    int length() { 
	return 1 + this.body.length();
    }

    // draw this worm into c
    boolean draw(World c) {
	return this.head.draw(c) && this.body.draw(c);
    }

    // erase this worm from c
    boolean erase(World c) {
	return this.head.erase(c) && this.body.erase(c);
    }
}

// -----------------------------------------------------------------------------
// a list of worm segments that represent the worm's body
// composite pattern: it is a composite because every segment behaves the same way
abstract class ListSegment {
    // does s overlap with any of the segments in _this_ body
    abstract boolean overlap(Segment s);

    // move each segment in this list of segments into the position of its
    // predecessor, given the new position for the predecessor (head originally)
    abstract ListSegment move(Segment pred);

    // count the number of segments 
    abstract int length();
	
    // draw the list of segments on c
    abstract boolean draw(World c);

    // erase the list of segments from c
    abstract boolean erase(World c);
}

class MtSegment extends ListSegment {
    MtSegment() {}
	
    boolean overlap(Segment s) { return false; }

    ListSegment move(Segment pred) { return new MtSegment(); }

    int length() { return 0; }

    boolean draw(World c) { return true; }

    boolean erase(World c) { return true; }
}

class ConsSegment extends ListSegment {
    Segment first;
    ListSegment rest;
    ConsSegment(Segment first, ListSegment rest) {
	this.first = first;
	this.rest = rest;
    }

    boolean overlap(Segment s) {
	return this.first.overlap(s) || this.rest.overlap(s);
    }

    ListSegment move(Segment pred) {
	return new ConsSegment(pred,this.rest.move(this.first));
    }

    int length() { 
	return 1 + this.rest.length();
    }

    boolean draw(World c) {
	return this.first.draw(c) && this.rest.draw(c);
    }

    boolean erase(World c) {
	return this.first.erase(c) && this.rest.erase(c);
    }
}

// -----------------------------------------------------------------------------
// represents a segment of the worm, represented as solid disk located at (x,y)	
class Segment {
    int x;
    int y;
    String direction;

    int radius;
    Color color;
    int DX;
    int DY;
	
    Segment(int x, int y, String d) {
	this.x = x;
	this.y = y;
        this.radius = 5;
        this.color = new Red();
        this.DX = 2 * this.radius;
        this.DY = 2 * this.radius;
        this.direction = d;
    }

    // where is it?
    Posn posn() {
	return new Posn(this.x,this.y);
    }

    // where is it going?
    String whereTo() {
      return this.direction;
    }

    // is this segment equal to that?
    boolean equal(Segment that) {
       return this.x == that.x && this.y == that.y && this.direction == that.direction;
    }

    // move in the direction of ke as specified if ke is in left, right, up, down
    Segment move(String ke) {
	if (ke.equals("left"))
	    return new Segment(this.x-this.DX,this.y,ke);
	else if (ke.equals("right"))
	    return new Segment(this.x+this.DX,this.y,ke);
	else if (ke.equals("up"))
	    return new Segment(this.x,this.y-this.DY,ke);
	else if (ke.equals("down"))
	    return new Segment(this.x,this.y+this.DY,ke);
	else // don't move
	    return this;
    }

    // does _this_ segment overlap with segment s
    boolean overlap(Segment s) {
	return this.distance(this.x-s.x,this.y-s.y) < 2 * this.radius;
    }

    // can this (head) segment eat the food if it moves in the direction of ke
    boolean canEat(Food f) {
	// is there an overlap of the two geometric shapes
	// approximation: is any of the four corners of the food inside s?
	return f.inside(this.posn());
    }

    // draw a worm segment
    boolean draw(World c) {
	return c.drawDisk(new Posn(this.x,this.y),this.radius,this.color);
    }

    // erase a worm segment
    boolean erase(World c) {
	return c.clearDisk(new Posn(this.x,this.y),this.radius,this.color);
    }

    // --- auxiliaries that are only needed for this class: motivate private ---

    // is the Posn inside the disk represented by this segment
    boolean inside(Posn p) {
	return this.distance(this.x-p.x,this.y-p.y) <= this.radius;
    }

    // how far is (x,y) from the origin
    double distance(int x, int y) {
	return Math.sqrt(x*x+y*y);
    }
}


class Examples {
  Segment h;
  Worm w;
  Food f;
  Box b;

  Examples() {
    this.h = new Segment(30,10,"left");
    this.w = new Worm(this.h,new ConsSegment(new Segment(40,10,"left"),new MtSegment()));
    this.f = new Food(0,0);
    this.b = new Box(300,300);
  }

  boolean test() {
    // return this.h.canEat(this.f);
    // return !this.w.eat(this.f).body.isMt();
    // return this.w.eat(this.f).move("left").move("up").move("down").ateItself();
    return this.w.move("left").eat(this.f).ranIntoWall(this.b);
  }
}
>Fix:
>Audit-Trail:
From: Kathy Gray <kathyg@cs.utah.edu>
To: matthias@ccs.neu.edu, bugs@plt-scheme.org
Cc: 
Subject: Re: all/7484: professorJ mentions guard-convert-Color in strange error report
Date: Mon, 4 Jul 2005 14:23:09 -0500

 I see what's wrong, but the fix isn't a quick one.
 
 Putting a temporary additional Color field into WormWorld gets the  
 program working for me.
 
 -Kathy
 
 
 On Jul 4, 2005, at 11:45 AM, matthias@ccs.neu.edu wrote:
 
 > A new problem report is waiting at
 >   http://bugs.plt-scheme.org/query/?cmd=view&pr=7484
 >
 > Reported by matthias for release: 299.107-svn4jul2005
 >
 > *** Description:
 > I ran the program in "steps to reproduce" just fine for an hour.
 > After deleting some comments I get this:
 >
 > Welcome to DrScheme, version 299.107-svn4jul2005.
 > Language: ProfessorJ: Intermediate.
 > expand: unbound variable in module in: guard-convert-Color
 >
 >>
 >>
 >
 > I can't get it to work anymore either. ARGH!
 >
 > *** How to repeat:
 > excuse the indentation but see previous bug report
 >
 > import draw.*;
 >
 > import java.util.Random;
 >
 > class Game {
 >   WormWorld w;
 >
 >   Game() {
 >    this.w = new WormWorld(
 >         new Worm(new Segment(100,100,"left"),new MtSegment()),
 >             new Food(100,100),
 >             new Box(300,300));
 >   }
 >
 >   // set up the world, draw it, and go
 >   boolean go(double speed) {
 >     return (this.w.start(300,300) && this.w.bigBang(speed) &&  
 > this.w.draw());
 >    }
 > }
 >
 > //  
 > ---------------------------------------------------------------------- 
 > --------
 > // represent the world of a Worm Game: Worm, Food, and the Bounding  
 > Box
 > class WormWorld extends World {
 >
 >    Worm w;
 >    Food f;
 >    Box  b;
 >
 >    WormWorld(Worm w, Food f, Box b) {
 >      this.w = w;
 >      this.f = f;
 >      this.b = b;
 >    }
 >
 >    // what happens when the clock ticks
 >    World onTick() {
 >      return this.move(this.w.step());
 >    }
 >
 >    // what happens when the palyer presses a key
 >    World onKeyEvent(String ke) {
 >      return this.move(this.w.move(ke));
 >    }
 >
 >    // move the world
 >    WormWorld move(Worm newWorm) {
 >      if (newWorm.ateItself()
 >          && this.finish("Your worm ate itself: ".concat 
 > (String.valueOf(newWorm.length()))))
 >         return this;
 >      else if (newWorm.ranIntoWall(this.b)
 >           && this.finish("Your worm ran into a wall: ".concat 
 > (String.valueOf(newWorm.length()))))
 >     return this;
 >      else if (newWorm.canEat(this.f)
 >           && this.announce("Your worm just ate: ".concat 
 > (String.valueOf(newWorm.length()))))
 >         return new WormWorld(newWorm.eat(this.f),this.f.create 
 > (this.b),this.b);
 >      else // move the worm
 >         return new WormWorld(newWorm,this.f,this.b);
 >    }
 >
 >    // announce something and stop this world
 >    boolean finish(String s) {
 >      return this.write(s) && this.endOfTime();
 >    }
 >
 >    // announce something and stop this world
 >    boolean announce(String s) {
 >      return this.write(s);
 >    }
 >
 >    // write a string to this worm world
 >    boolean write(String s) {
 >      return (   this.drawRect(new Posn(10,280),150,20,new White())
 >          && this.drawString(new Posn(10,290),s));
 >    }
 >
 >    // draw this world
 >    boolean draw() { return this.w.draw(this) && this.f.draw(this); }
 >
 >    // erase this world
 >    boolean erase() { return this.w.erase(this) && this.f.erase 
 > (this); }
 > }
 >
 > //  
 > ---------------------------------------------------------------------- 
 > -------
 > // Box: represents the playing field for the worm game
 >
 > class Box {
 >     int width;
 >     int height;
 >
 >     Box(int width, int height) {
 >     this.width = width;
 >     this.height = height;
 >     }
 >
 >     // is p inside of _this_ box?
 >     boolean inside(Posn p) {
 >     return
 >         (0 <= p.x && p.x <= this.width) &&
 >         (0 <= p.y && p.y <= this.height);
 >     }
 > }
 >
 >
 > //  
 > ---------------------------------------------------------------------- 
 > -------
 > // represents a piece of food as a solid rectangle with northwest  
 > corner at (x,y)
 > class Food {
 >     int x;
 >     int y;
 >
 >     int width = 20;
 >     int height = 10;
 >     Color color = new Green();
 >
 >     Random foodPlace = new Random();
 >
 >     Food(int x, int y) {
 >        this.x = x;
 >        this.y = y;
 >     }
 >
 >     // is p inside of this Food shape
 >     boolean inside(Posn p) {
 >        return
 >         (this.x <= p.x && p.x <= this.x+this.width) &&
 >         (this.y <= p.y && p.y <= this.y+this.width);
 >     }
 >
 >     // create a food pile that is at a different location than this
 >     // use trial and error
 >     Food create(Box b) {
 >        int x = new Random().nextInt(b.width-1); // -1 to stay  
 > within boundaries
 >         int y = new Random().nextInt(b.height-1);
 >
 >         if ((this.x != x) && this.y != y)
 >         return new Food(x,y);
 >        else
 >         return this.create(b);
 >     }
 >
 >     boolean draw(World w) {
 >        return w.drawRect(new Posn 
 > (this.x,this.y),this.width,this.height,this.color);
 >     }
 >
 >     boolean erase(World w) {
 >        return w.clearRect(new Posn 
 > (this.x,this.y),this.width,this.height,this.color);
 >     }
 > }
 >
 >
 > //  
 > ---------------------------------------------------------------------- 
 > -------
 > // Worm is a head segment plus a potentially empty sequence of  
 > segments
 >
 > class Worm {
 >     Segment head;
 >     ListSegment body;
 >     Worm(Segment head, ListSegment body) {
 >        this.head = head;
 >        this.body = body;
 >     }
 >
 >     // where is the head of the worm?
 >     Posn posn() {
 >        return new Posn(this.head.x,this.head.y);
 >     }
 >
 >     // where is this going?
 >     String whereTo() {
 >         return this.head.whereTo();
 >     }
 >
 >     // did this worm run into the wall?
 >     boolean ranIntoWall(Box b) {
 >       return !b.inside(this.posn());
 >     }
 >
 >     // move this worm in the direction of the keyevent
 >     //   if ke is in left, right, up, down
 >     // head moves in the direction of the predecessor
 >     // body element n+1 moves into the position of element n
 >     // body element 0 moves into the position of head
 >     Worm move(String ke) {
 >     if (this.head.move(ke).equal(this.head))
 >        return this; // the key was not a directional change
 >         else
 >        return new Worm(this.head.move(ke),this.body.move(this.head));
 >     }
 >
 >     Worm step() {
 >       return new Worm(this.head.move(this.whereTo()),this.body.move 
 > (this.head));
 >     }
 >
 >     // did this worm run into itself after a move?
 >     boolean ateItself() {
 >     return this.body.overlap(this.head);
 >     }
 >
 >     // can the head of this worm eat the food?
 >     boolean canEat(Food f) {
 >     return this.head.canEat(f);
 >     }
 >
 >     // move the head into the direction into which it is going already
 >     // the old head becomes part of the body
 >     // @pre: canEat(f)
 >     // @post: !ateItself()
 >     Worm eat(Food f) {
 >     return new Worm(this.head.move(this.whereTo()),
 >             new ConsSegment(this.head,this.body));
 >     }
 >
 >     // how long is the worm
 >     int length() {
 >     return 1 + this.body.length();
 >     }
 >
 >     // draw this worm into c
 >     boolean draw(World c) {
 >     return this.head.draw(c) && this.body.draw(c);
 >     }
 >
 >     // erase this worm from c
 >     boolean erase(World c) {
 >     return this.head.erase(c) && this.body.erase(c);
 >     }
 > }
 >
 > //  
 > ---------------------------------------------------------------------- 
 > -------
 > // a list of worm segments that represent the worm's body
 > // composite pattern: it is a composite because every segment  
 > behaves the same way
 > abstract class ListSegment {
 >     // does s overlap with any of the segments in _this_ body
 >     abstract boolean overlap(Segment s);
 >
 >     // move each segment in this list of segments into the position  
 > of its
 >     // predecessor, given the new position for the predecessor  
 > (head originally)
 >     abstract ListSegment move(Segment pred);
 >
 >     // count the number of segments
 >     abstract int length();
 >
 >     // draw the list of segments on c
 >     abstract boolean draw(World c);
 >
 >     // erase the list of segments from c
 >     abstract boolean erase(World c);
 > }
 >
 > class MtSegment extends ListSegment {
 >     MtSegment() {}
 >
 >     boolean overlap(Segment s) { return false; }
 >
 >     ListSegment move(Segment pred) { return new MtSegment(); }
 >
 >     int length() { return 0; }
 >
 >     boolean draw(World c) { return true; }
 >
 >     boolean erase(World c) { return true; }
 > }
 >
 > class ConsSegment extends ListSegment {
 >     Segment first;
 >     ListSegment rest;
 >     ConsSegment(Segment first, ListSegment rest) {
 >     this.first = first;
 >     this.rest = rest;
 >     }
 >
 >     boolean overlap(Segment s) {
 >     return this.first.overlap(s) || this.rest.overlap(s);
 >     }
 >
 >     ListSegment move(Segment pred) {
 >     return new ConsSegment(pred,this.rest.move(this.first));
 >     }
 >
 >     int length() {
 >     return 1 + this.rest.length();
 >     }
 >
 >     boolean draw(World c) {
 >     return this.first.draw(c) && this.rest.draw(c);
 >     }
 >
 >     boolean erase(World c) {
 >     return this.first.erase(c) && this.rest.erase(c);
 >     }
 > }
 >
 > //  
 > ---------------------------------------------------------------------- 
 > -------
 > // represents a segment of the worm, represented as solid disk  
 > located at (x,y)
 > class Segment {
 >     int x;
 >     int y;
 >     String direction;
 >
 >     int radius;
 >     Color color;
 >     int DX;
 >     int DY;
 >
 >     Segment(int x, int y, String d) {
 >     this.x = x;
 >     this.y = y;
 >         this.radius = 5;
 >         this.color = new Red();
 >         this.DX = 2 * this.radius;
 >         this.DY = 2 * this.radius;
 >         this.direction = d;
 >     }
 >
 >     // where is it?
 >     Posn posn() {
 >     return new Posn(this.x,this.y);
 >     }
 >
 >     // where is it going?
 >     String whereTo() {
 >       return this.direction;
 >     }
 >
 >     // is this segment equal to that?
 >     boolean equal(Segment that) {
 >        return this.x == that.x && this.y == that.y &&  
 > this.direction == that.direction;
 >     }
 >
 >     // move in the direction of ke as specified if ke is in left,  
 > right, up, down
 >     Segment move(String ke) {
 >     if (ke.equals("left"))
 >         return new Segment(this.x-this.DX,this.y,ke);
 >     else if (ke.equals("right"))
 >         return new Segment(this.x+this.DX,this.y,ke);
 >     else if (ke.equals("up"))
 >         return new Segment(this.x,this.y-this.DY,ke);
 >     else if (ke.equals("down"))
 >         return new Segment(this.x,this.y+this.DY,ke);
 >     else // don't move
 >         return this;
 >     }
 >
 >     // does _this_ segment overlap with segment s
 >     boolean overlap(Segment s) {
 >     return this.distance(this.x-s.x,this.y-s.y) < 2 * this.radius;
 >     }
 >
 >     // can this (head) segment eat the food if it moves in the  
 > direction of ke
 >     boolean canEat(Food f) {
 >     // is there an overlap of the two geometric shapes
 >     // approximation: is any of the four corners of the food inside s?
 >     return f.inside(this.posn());
 >     }
 >
 >     // draw a worm segment
 >     boolean draw(World c) {
 >     return c.drawDisk(new Posn(this.x,this.y),this.radius,this.color);
 >     }
 >
 >     // erase a worm segment
 >     boolean erase(World c) {
 >     return c.clearDisk(new Posn 
 > (this.x,this.y),this.radius,this.color);
 >     }
 >
 >     // --- auxiliaries that are only needed for this class:  
 > motivate private ---
 >
 >     // is the Posn inside the disk represented by this segment
 >     boolean inside(Posn p) {
 >     return this.distance(this.x-p.x,this.y-p.y) <= this.radius;
 >     }
 >
 >     // how far is (x,y) from the origin
 >     double distance(int x, int y) {
 >     return Math.sqrt(x*x+y*y);
 >     }
 > }
 >
 >
 > class Examples {
 >   Segment h;
 >   Worm w;
 >   Food f;
 >   Box b;
 >
 >   Examples() {
 >     this.h = new Segment(30,10,"left");
 >     this.w = new Worm(this.h,new ConsSegment(new Segment 
 > (40,10,"left"),new MtSegment()));
 >     this.f = new Food(0,0);
 >     this.b = new Box(300,300);
 >   }
 >
 >   boolean test() {
 >     // return this.h.canEat(this.f);
 >     // return !this.w.eat(this.f).body.isMt();
 >     // return this.w.eat(this.f).move("left").move("up").move 
 > ("down").ateItself();
 >     return this.w.move("left").eat(this.f).ranIntoWall(this.b);
 >   }
 > }
 >
 > *** Environment:
 > macosx "Darwin europe.local 7.9.0 Darwin Kernel Version 7.9.0: Wed  
 > Mar 30 20:11:17 PST 2005; root:xnu/xnu-517.12.7.obj~1/RELEASE_PPC   
 > Power Macintosh powerpc" (ppc-macosx) (get-display-depth) = 32
 > Docs Installed:
 > (#<path:/Users/matthias/plt/collects/doc/help>)
 > Collections:
 > ((#<path:/Users/matthias/Library/PLT Scheme/299.107/collects> "non- 
 > existent path") (#<path:/Users/matthias/plt/collects> (#<path:.svn>  
 > #<path:afm> #<path:algol60> #<path:browser> #<path:compiler>  
 > #<path:defaults> #<path:doc> #<path:drscheme> #<path:dynext>  
 > #<path:embedded-gui> #<path:eopl> #<path:errortrace> #<path:ffi>  
 > #<path:finish-install> #<path:framework> #<path:frtime>  
 > #<path:games> #<path:graphics> #<path:guibuilder> #<path:handin- 
 > client> #<path:handin-server> #<path:help> #<path:hierlist>  
 > #<path:honu> #<path:honu-module> #<path:htdch> #<path:htdp>  
 > #<path:html> #<path:icons> #<path:info-domain> #<path:lang>  
 > #<path:launcher> #<path:make> #<path:mred> #<path:mrflow>  
 > #<path:mrlib> #<path:mysterx> #<path:mzcom> #<path:mzlib>  
 > #<path:mzscheme> #<path:mztake> #<path:net> #<path:openssl>  
 > #<path:parser-tools> #<path:planet> #<path:plot>  
 > #<path:preprocessor> #<path:profj> #<path:profjBoxes>  
 > #<path:profjWizard> #<path:readline> #<path:reduction-semantics>  
 > #<path:repos-time-stamp!
 >
 >> #<path:setup> #<path:sgl> #<path:sirmail> #<path:skipper>  
 >> #<path:slatex> #<path:slibinit> #<path:slideshow> #<path:srfi>  
 >> #<path:srpersist> #<path:ssax> #<path:stepper> #<path:string- 
 >> constants> #<path:swindle> #<path:syntax> #<path:syntax-color>  
 >> #<path:test-suite> #<path:tests> #<path:tex2page> #<path:texpict>  
 >> #<path:trace> #<path:version> #<path:waterworld> #<path:web- 
 >> server> #<path:xelda> #<path:xml>)))
 >>
 > Human Language: english
 > Teachpack filenames: ()
 > Computer Language: (("Experimental Languages" "ProfessorJ"  
 > "Intermediate") ((field) (#f)))
 >
 
From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Kathy Gray <kathyg@cs.utah.edu>
Cc: bugs@plt-scheme.org
Subject: Re: all/7484: professorJ mentions guard-convert-Color in strange error report
Date: Mon, 4 Jul 2005 15:30:51 -0400

 I am getting more things like that. I thought I'd reinstall profJ but  
 to no avail :-(
 
 Pls, pretty pls! I want to work on the book in 299. 209 is way too old.
 
 On Jul 4, 2005, at 3:23 PM, Kathy Gray wrote:
 
 > I see what's wrong, but the fix isn't a quick one.
 >
 > Putting a temporary additional Color field into WormWorld gets the  
 > program working for me.
 >
 > -Kathy
 >
 >
 > On Jul 4, 2005, at 11:45 AM, matthias@ccs.neu.edu wrote:
 >
 >> A new problem report is waiting at
 >>   http://bugs.plt-scheme.org/query/?cmd=view&pr=7484
 >>
 >> Reported by matthias for release: 299.107-svn4jul2005
 >>
 >> *** Description:
 >> I ran the program in "steps to reproduce" just fine for an hour.
 >> After deleting some comments I get this:
 >>
 >> Welcome to DrScheme, version 299.107-svn4jul2005.
 >> Language: ProfessorJ: Intermediate.
 >> expand: unbound variable in module in: guard-convert-Color
 >>
 >>>
 >>>
 >>
 >> I can't get it to work anymore either. ARGH!
 >>
 >> *** How to repeat:
 >> excuse the indentation but see previous bug report
 >>
 >> import draw.*;
 >>
 >> import java.util.Random;
 >>
 >> class Game {
 >>   WormWorld w;
 >>
 >>   Game() {
 >>    this.w = new WormWorld(
 >>         new Worm(new Segment(100,100,"left"),new MtSegment()),
 >>             new Food(100,100),
 >>             new Box(300,300));
 >>   }
 >>
 >>   // set up the world, draw it, and go
 >>   boolean go(double speed) {
 >>     return (this.w.start(300,300) && this.w.bigBang(speed) &&  
 >> this.w.draw());
 >>    }
 >> }
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> --------
 >> // represent the world of a Worm Game: Worm, Food, and the Bounding  
 >> Box
 >> class WormWorld extends World {
 >>
 >>    Worm w;
 >>    Food f;
 >>    Box  b;
 >>
 >>    WormWorld(Worm w, Food f, Box b) {
 >>      this.w = w;
 >>      this.f = f;
 >>      this.b = b;
 >>    }
 >>
 >>    // what happens when the clock ticks
 >>    World onTick() {
 >>      return this.move(this.w.step());
 >>    }
 >>
 >>    // what happens when the palyer presses a key
 >>    World onKeyEvent(String ke) {
 >>      return this.move(this.w.move(ke));
 >>    }
 >>
 >>    // move the world
 >>    WormWorld move(Worm newWorm) {
 >>      if (newWorm.ateItself()
 >>          && this.finish("Your worm ate itself:  
 >> ".concat(String.valueOf(newWorm.length()))))
 >>         return this;
 >>      else if (newWorm.ranIntoWall(this.b)
 >>           && this.finish("Your worm ran into a wall:  
 >> ".concat(String.valueOf(newWorm.length()))))
 >>     return this;
 >>      else if (newWorm.canEat(this.f)
 >>           && this.announce("Your worm just ate:  
 >> ".concat(String.valueOf(newWorm.length()))))
 >>         return new  
 >> WormWorld(newWorm.eat(this.f),this.f.create(this.b),this.b);
 >>      else // move the worm
 >>         return new WormWorld(newWorm,this.f,this.b);
 >>    }
 >>
 >>    // announce something and stop this world
 >>    boolean finish(String s) {
 >>      return this.write(s) && this.endOfTime();
 >>    }
 >>
 >>    // announce something and stop this world
 >>    boolean announce(String s) {
 >>      return this.write(s);
 >>    }
 >>
 >>    // write a string to this worm world
 >>    boolean write(String s) {
 >>      return (   this.drawRect(new Posn(10,280),150,20,new White())
 >>          && this.drawString(new Posn(10,290),s));
 >>    }
 >>
 >>    // draw this world
 >>    boolean draw() { return this.w.draw(this) && this.f.draw(this); }
 >>
 >>    // erase this world
 >>    boolean erase() { return this.w.erase(this) && this.f.erase(this);  
 >> }
 >> }
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> -------
 >> // Box: represents the playing field for the worm game
 >>
 >> class Box {
 >>     int width;
 >>     int height;
 >>
 >>     Box(int width, int height) {
 >>     this.width = width;
 >>     this.height = height;
 >>     }
 >>
 >>     // is p inside of _this_ box?
 >>     boolean inside(Posn p) {
 >>     return
 >>         (0 <= p.x && p.x <= this.width) &&
 >>         (0 <= p.y && p.y <= this.height);
 >>     }
 >> }
 >>
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> -------
 >> // represents a piece of food as a solid rectangle with northwest  
 >> corner at (x,y)
 >> class Food {
 >>     int x;
 >>     int y;
 >>
 >>     int width = 20;
 >>     int height = 10;
 >>     Color color = new Green();
 >>
 >>     Random foodPlace = new Random();
 >>
 >>     Food(int x, int y) {
 >>        this.x = x;
 >>        this.y = y;
 >>     }
 >>
 >>     // is p inside of this Food shape
 >>     boolean inside(Posn p) {
 >>        return
 >>         (this.x <= p.x && p.x <= this.x+this.width) &&
 >>         (this.y <= p.y && p.y <= this.y+this.width);
 >>     }
 >>
 >>     // create a food pile that is at a different location than this
 >>     // use trial and error
 >>     Food create(Box b) {
 >>        int x = new Random().nextInt(b.width-1); // -1 to stay within  
 >> boundaries
 >>         int y = new Random().nextInt(b.height-1);
 >>
 >>         if ((this.x != x) && this.y != y)
 >>         return new Food(x,y);
 >>        else
 >>         return this.create(b);
 >>     }
 >>
 >>     boolean draw(World w) {
 >>        return w.drawRect(new  
 >> Posn(this.x,this.y),this.width,this.height,this.color);
 >>     }
 >>
 >>     boolean erase(World w) {
 >>        return w.clearRect(new  
 >> Posn(this.x,this.y),this.width,this.height,this.color);
 >>     }
 >> }
 >>
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> -------
 >> // Worm is a head segment plus a potentially empty sequence of  
 >> segments
 >>
 >> class Worm {
 >>     Segment head;
 >>     ListSegment body;
 >>     Worm(Segment head, ListSegment body) {
 >>        this.head = head;
 >>        this.body = body;
 >>     }
 >>
 >>     // where is the head of the worm?
 >>     Posn posn() {
 >>        return new Posn(this.head.x,this.head.y);
 >>     }
 >>
 >>     // where is this going?
 >>     String whereTo() {
 >>         return this.head.whereTo();
 >>     }
 >>
 >>     // did this worm run into the wall?
 >>     boolean ranIntoWall(Box b) {
 >>       return !b.inside(this.posn());
 >>     }
 >>
 >>     // move this worm in the direction of the keyevent
 >>     //   if ke is in left, right, up, down
 >>     // head moves in the direction of the predecessor
 >>     // body element n+1 moves into the position of element n
 >>     // body element 0 moves into the position of head
 >>     Worm move(String ke) {
 >>     if (this.head.move(ke).equal(this.head))
 >>        return this; // the key was not a directional change
 >>         else
 >>        return new Worm(this.head.move(ke),this.body.move(this.head));
 >>     }
 >>
 >>     Worm step() {
 >>       return new  
 >> Worm(this.head.move(this.whereTo()),this.body.move(this.head));
 >>     }
 >>
 >>     // did this worm run into itself after a move?
 >>     boolean ateItself() {
 >>     return this.body.overlap(this.head);
 >>     }
 >>
 >>     // can the head of this worm eat the food?
 >>     boolean canEat(Food f) {
 >>     return this.head.canEat(f);
 >>     }
 >>
 >>     // move the head into the direction into which it is going already
 >>     // the old head becomes part of the body
 >>     // @pre: canEat(f)
 >>     // @post: !ateItself()
 >>     Worm eat(Food f) {
 >>     return new Worm(this.head.move(this.whereTo()),
 >>             new ConsSegment(this.head,this.body));
 >>     }
 >>
 >>     // how long is the worm
 >>     int length() {
 >>     return 1 + this.body.length();
 >>     }
 >>
 >>     // draw this worm into c
 >>     boolean draw(World c) {
 >>     return this.head.draw(c) && this.body.draw(c);
 >>     }
 >>
 >>     // erase this worm from c
 >>     boolean erase(World c) {
 >>     return this.head.erase(c) && this.body.erase(c);
 >>     }
 >> }
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> -------
 >> // a list of worm segments that represent the worm's body
 >> // composite pattern: it is a composite because every segment behaves  
 >> the same way
 >> abstract class ListSegment {
 >>     // does s overlap with any of the segments in _this_ body
 >>     abstract boolean overlap(Segment s);
 >>
 >>     // move each segment in this list of segments into the position  
 >> of its
 >>     // predecessor, given the new position for the predecessor (head  
 >> originally)
 >>     abstract ListSegment move(Segment pred);
 >>
 >>     // count the number of segments
 >>     abstract int length();
 >>
 >>     // draw the list of segments on c
 >>     abstract boolean draw(World c);
 >>
 >>     // erase the list of segments from c
 >>     abstract boolean erase(World c);
 >> }
 >>
 >> class MtSegment extends ListSegment {
 >>     MtSegment() {}
 >>
 >>     boolean overlap(Segment s) { return false; }
 >>
 >>     ListSegment move(Segment pred) { return new MtSegment(); }
 >>
 >>     int length() { return 0; }
 >>
 >>     boolean draw(World c) { return true; }
 >>
 >>     boolean erase(World c) { return true; }
 >> }
 >>
 >> class ConsSegment extends ListSegment {
 >>     Segment first;
 >>     ListSegment rest;
 >>     ConsSegment(Segment first, ListSegment rest) {
 >>     this.first = first;
 >>     this.rest = rest;
 >>     }
 >>
 >>     boolean overlap(Segment s) {
 >>     return this.first.overlap(s) || this.rest.overlap(s);
 >>     }
 >>
 >>     ListSegment move(Segment pred) {
 >>     return new ConsSegment(pred,this.rest.move(this.first));
 >>     }
 >>
 >>     int length() {
 >>     return 1 + this.rest.length();
 >>     }
 >>
 >>     boolean draw(World c) {
 >>     return this.first.draw(c) && this.rest.draw(c);
 >>     }
 >>
 >>     boolean erase(World c) {
 >>     return this.first.erase(c) && this.rest.erase(c);
 >>     }
 >> }
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> -------
 >> // represents a segment of the worm, represented as solid disk  
 >> located at (x,y)
 >> class Segment {
 >>     int x;
 >>     int y;
 >>     String direction;
 >>
 >>     int radius;
 >>     Color color;
 >>     int DX;
 >>     int DY;
 >>
 >>     Segment(int x, int y, String d) {
 >>     this.x = x;
 >>     this.y = y;
 >>         this.radius = 5;
 >>         this.color = new Red();
 >>         this.DX = 2 * this.radius;
 >>         this.DY = 2 * this.radius;
 >>         this.direction = d;
 >>     }
 >>
 >>     // where is it?
 >>     Posn posn() {
 >>     return new Posn(this.x,this.y);
 >>     }
 >>
 >>     // where is it going?
 >>     String whereTo() {
 >>       return this.direction;
 >>     }
 >>
 >>     // is this segment equal to that?
 >>     boolean equal(Segment that) {
 >>        return this.x == that.x && this.y == that.y && this.direction  
 >> == that.direction;
 >>     }
 >>
 >>     // move in the direction of ke as specified if ke is in left,  
 >> right, up, down
 >>     Segment move(String ke) {
 >>     if (ke.equals("left"))
 >>         return new Segment(this.x-this.DX,this.y,ke);
 >>     else if (ke.equals("right"))
 >>         return new Segment(this.x+this.DX,this.y,ke);
 >>     else if (ke.equals("up"))
 >>         return new Segment(this.x,this.y-this.DY,ke);
 >>     else if (ke.equals("down"))
 >>         return new Segment(this.x,this.y+this.DY,ke);
 >>     else // don't move
 >>         return this;
 >>     }
 >>
 >>     // does _this_ segment overlap with segment s
 >>     boolean overlap(Segment s) {
 >>     return this.distance(this.x-s.x,this.y-s.y) < 2 * this.radius;
 >>     }
 >>
 >>     // can this (head) segment eat the food if it moves in the  
 >> direction of ke
 >>     boolean canEat(Food f) {
 >>     // is there an overlap of the two geometric shapes
 >>     // approximation: is any of the four corners of the food inside s?
 >>     return f.inside(this.posn());
 >>     }
 >>
 >>     // draw a worm segment
 >>     boolean draw(World c) {
 >>     return c.drawDisk(new Posn(this.x,this.y),this.radius,this.color);
 >>     }
 >>
 >>     // erase a worm segment
 >>     boolean erase(World c) {
 >>     return c.clearDisk(new  
 >> Posn(this.x,this.y),this.radius,this.color);
 >>     }
 >>
 >>     // --- auxiliaries that are only needed for this class: motivate  
 >> private ---
 >>
 >>     // is the Posn inside the disk represented by this segment
 >>     boolean inside(Posn p) {
 >>     return this.distance(this.x-p.x,this.y-p.y) <= this.radius;
 >>     }
 >>
 >>     // how far is (x,y) from the origin
 >>     double distance(int x, int y) {
 >>     return Math.sqrt(x*x+y*y);
 >>     }
 >> }
 >>
 >>
 >> class Examples {
 >>   Segment h;
 >>   Worm w;
 >>   Food f;
 >>   Box b;
 >>
 >>   Examples() {
 >>     this.h = new Segment(30,10,"left");
 >>     this.w = new Worm(this.h,new ConsSegment(new  
 >> Segment(40,10,"left"),new MtSegment()));
 >>     this.f = new Food(0,0);
 >>     this.b = new Box(300,300);
 >>   }
 >>
 >>   boolean test() {
 >>     // return this.h.canEat(this.f);
 >>     // return !this.w.eat(this.f).body.isMt();
 >>     // return  
 >> this.w.eat(this.f).move("left").move("up").move("down").ateItself();
 >>     return this.w.move("left").eat(this.f).ranIntoWall(this.b);
 >>   }
 >> }
 >>
 >> *** Environment:
 >> macosx "Darwin europe.local 7.9.0 Darwin Kernel Version 7.9.0: Wed  
 >> Mar 30 20:11:17 PST 2005; root:xnu/xnu-517.12.7.obj~1/RELEASE_PPC   
 >> Power Macintosh powerpc" (ppc-macosx) (get-display-depth) = 32
 >> Docs Installed:
 >> (#<path:/Users/matthias/plt/collects/doc/help>)
 >> Collections:
 >> ((#<path:/Users/matthias/Library/PLT Scheme/299.107/collects>  
 >> "non-existent path") (#<path:/Users/matthias/plt/collects>  
 >> (#<path:.svn> #<path:afm> #<path:algol60> #<path:browser>  
 >> #<path:compiler> #<path:defaults> #<path:doc> #<path:drscheme>  
 >> #<path:dynext> #<path:embedded-gui> #<path:eopl> #<path:errortrace>  
 >> #<path:ffi> #<path:finish-install> #<path:framework> #<path:frtime>  
 >> #<path:games> #<path:graphics> #<path:guibuilder>  
 >> #<path:handin-client> #<path:handin-server> #<path:help>  
 >> #<path:hierlist> #<path:honu> #<path:honu-module> #<path:htdch>  
 >> #<path:htdp> #<path:html> #<path:icons> #<path:info-domain>  
 >> #<path:lang> #<path:launcher> #<path:make> #<path:mred>  
 >> #<path:mrflow> #<path:mrlib> #<path:mysterx> #<path:mzcom>  
 >> #<path:mzlib> #<path:mzscheme> #<path:mztake> #<path:net>  
 >> #<path:openssl> #<path:parser-tools> #<path:planet> #<path:plot>  
 >> #<path:preprocessor> #<path:profj> #<path:profjBoxes>  
 >> #<path:profjWizard> #<path:readline> #<path:reduction-semantics>  
 >> #<path:repos-time-stamp!
 >>
 >>> #<path:setup> #<path:sgl> #<path:sirmail> #<path:skipper>  
 >>> #<path:slatex> #<path:slibinit> #<path:slideshow> #<path:srfi>  
 >>> #<path:srpersist> #<path:ssax> #<path:stepper>  
 >>> #<path:string-constants> #<path:swindle> #<path:syntax>  
 >>> #<path:syntax-color> #<path:test-suite> #<path:tests>  
 >>> #<path:tex2page> #<path:texpict> #<path:trace> #<path:version>  
 >>> #<path:waterworld> #<path:web-server> #<path:xelda> #<path:xml>)))
 >>>
 >> Human Language: english
 >> Teachpack filenames: ()
 >> Computer Language: (("Experimental Languages" "ProfessorJ"  
 >> "Intermediate") ((field) (#f)))
 >>
 >
 
From: Kathy Gray <kathyg@cs.utah.edu>
To: Matthias Felleisen <matthias@ccs.neu.edu>
Cc: bugs@plt-scheme.org
Subject: Re: all/7484: professorJ mentions guard-convert-Color in strange error report
Date: Mon, 4 Jul 2005 14:44:44 -0500

 I'm working on it, I'll let you know when it's fixed. Hopefully  
 within a few hours
 
 -Kathy
 
 
 On Jul 4, 2005, at 2:30 PM, Matthias Felleisen wrote:
 
 > I am getting more things like that. I thought I'd reinstall profJ  
 > but to no avail :-(
 >
 > Pls, pretty pls! I want to work on the book in 299. 209 is way too  
 > old.
 >
 > On Jul 4, 2005, at 3:23 PM, Kathy Gray wrote:
 >
 >
 >> I see what's wrong, but the fix isn't a quick one.
 >>
 >> Putting a temporary additional Color field into WormWorld gets the  
 >> program working for me.
 >>
 >> -Kathy
 >>
 >>
 >> On Jul 4, 2005, at 11:45 AM, matthias@ccs.neu.edu wrote:
 >>
 >>
 >>> A new problem report is waiting at
 >>>   http://bugs.plt-scheme.org/query/?cmd=view&pr=7484
 >>>
 >>> Reported by matthias for release: 299.107-svn4jul2005
 >>>
 >>> *** Description:
 >>> I ran the program in "steps to reproduce" just fine for an hour.
 >>> After deleting some comments I get this:
 >>>
 >>> Welcome to DrScheme, version 299.107-svn4jul2005.
 >>> Language: ProfessorJ: Intermediate.
 >>> expand: unbound variable in module in: guard-convert-Color
 >>>
 >>>
 >>>>
 >>>>
 >>>>
 >>>
 >>> I can't get it to work anymore either. ARGH!
 >>>
 >>> *** How to repeat:
 >>> excuse the indentation but see previous bug report
 >>>
 >>> import draw.*;
 >>>
 >>> import java.util.Random;
 >>>
 >>> class Game {
 >>>   WormWorld w;
 >>>
 >>>   Game() {
 >>>    this.w = new WormWorld(
 >>>         new Worm(new Segment(100,100,"left"),new MtSegment()),
 >>>             new Food(100,100),
 >>>             new Box(300,300));
 >>>   }
 >>>
 >>>   // set up the world, draw it, and go
 >>>   boolean go(double speed) {
 >>>     return (this.w.start(300,300) && this.w.bigBang(speed) &&  
 >>> this.w.draw());
 >>>    }
 >>> }
 >>>
 >>> //  
 >>> -------------------------------------------------------------------- 
 >>> ----------
 >>> // represent the world of a Worm Game: Worm, Food, and the  
 >>> Bounding Box
 >>> class WormWorld extends World {
 >>>
 >>>    Worm w;
 >>>    Food f;
 >>>    Box  b;
 >>>
 >>>    WormWorld(Worm w, Food f, Box b) {
 >>>      this.w = w;
 >>>      this.f = f;
 >>>      this.b = b;
 >>>    }
 >>>
 >>>    // what happens when the clock ticks
 >>>    World onTick() {
 >>>      return this.move(this.w.step());
 >>>    }
 >>>
 >>>    // what happens when the palyer presses a key
 >>>    World onKeyEvent(String ke) {
 >>>      return this.move(this.w.move(ke));
 >>>    }
 >>>
 >>>    // move the world
 >>>    WormWorld move(Worm newWorm) {
 >>>      if (newWorm.ateItself()
 >>>          && this.finish("Your worm ate itself: ".concat 
 >>> (String.valueOf(newWorm.length()))))
 >>>         return this;
 >>>      else if (newWorm.ranIntoWall(this.b)
 >>>           && this.finish("Your worm ran into a wall: ".concat 
 >>> (String.valueOf(newWorm.length()))))
 >>>     return this;
 >>>      else if (newWorm.canEat(this.f)
 >>>           && this.announce("Your worm just ate: ".concat 
 >>> (String.valueOf(newWorm.length()))))
 >>>         return new WormWorld(newWorm.eat(this.f),this.f.create 
 >>> (this.b),this.b);
 >>>      else // move the worm
 >>>         return new WormWorld(newWorm,this.f,this.b);
 >>>    }
 >>>
 >>>    // announce something and stop this world
 >>>    boolean finish(String s) {
 >>>      return this.write(s) && this.endOfTime();
 >>>    }
 >>>
 >>>    // announce something and stop this world
 >>>    boolean announce(String s) {
 >>>      return this.write(s);
 >>>    }
 >>>
 >>>    // write a string to this worm world
 >>>    boolean write(String s) {
 >>>      return (   this.drawRect(new Posn(10,280),150,20,new White())
 >>>          && this.drawString(new Posn(10,290),s));
 >>>    }
 >>>
 >>>    // draw this world
 >>>    boolean draw() { return this.w.draw(this) && this.f.draw(this); }
 >>>
 >>>    // erase this world
 >>>    boolean erase() { return this.w.erase(this) && this.f.erase 
 >>> (this); }
 >>> }
 >>>
 >>> //  
 >>> -------------------------------------------------------------------- 
 >>> ---------
 >>> // Box: represents the playing field for the worm game
 >>>
 >>> class Box {
 >>>     int width;
 >>>     int height;
 >>>
 >>>     Box(int width, int height) {
 >>>     this.width = width;
 >>>     this.height = height;
 >>>     }
 >>>
 >>>     // is p inside of _this_ box?
 >>>     boolean inside(Posn p) {
 >>>     return
 >>>         (0 <= p.x && p.x <= this.width) &&
 >>>         (0 <= p.y && p.y <= this.height);
 >>>     }
 >>> }
 >>>
 >>>
 >>> //  
 >>> -------------------------------------------------------------------- 
 >>> ---------
 >>> // represents a piece of food as a solid rectangle with northwest  
 >>> corner at (x,y)
 >>> class Food {
 >>>     int x;
 >>>     int y;
 >>>
 >>>     int width = 20;
 >>>     int height = 10;
 >>>     Color color = new Green();
 >>>
 >>>     Random foodPlace = new Random();
 >>>
 >>>     Food(int x, int y) {
 >>>        this.x = x;
 >>>        this.y = y;
 >>>     }
 >>>
 >>>     // is p inside of this Food shape
 >>>     boolean inside(Posn p) {
 >>>        return
 >>>         (this.x <= p.x && p.x <= this.x+this.width) &&
 >>>         (this.y <= p.y && p.y <= this.y+this.width);
 >>>     }
 >>>
 >>>     // create a food pile that is at a different location than this
 >>>     // use trial and error
 >>>     Food create(Box b) {
 >>>        int x = new Random().nextInt(b.width-1); // -1 to stay  
 >>> within boundaries
 >>>         int y = new Random().nextInt(b.height-1);
 >>>
 >>>         if ((this.x != x) && this.y != y)
 >>>         return new Food(x,y);
 >>>        else
 >>>         return this.create(b);
 >>>     }
 >>>
 >>>     boolean draw(World w) {
 >>>        return w.drawRect(new Posn 
 >>> (this.x,this.y),this.width,this.height,this.color);
 >>>     }
 >>>
 >>>     boolean erase(World w) {
 >>>        return w.clearRect(new Posn 
 >>> (this.x,this.y),this.width,this.height,this.color);
 >>>     }
 >>> }
 >>>
 >>>
 >>> //  
 >>> -------------------------------------------------------------------- 
 >>> ---------
 >>> // Worm is a head segment plus a potentially empty sequence of  
 >>> segments
 >>>
 >>> class Worm {
 >>>     Segment head;
 >>>     ListSegment body;
 >>>     Worm(Segment head, ListSegment body) {
 >>>        this.head = head;
 >>>        this.body = body;
 >>>     }
 >>>
 >>>     // where is the head of the worm?
 >>>     Posn posn() {
 >>>        return new Posn(this.head.x,this.head.y);
 >>>     }
 >>>
 >>>     // where is this going?
 >>>     String whereTo() {
 >>>         return this.head.whereTo();
 >>>     }
 >>>
 >>>     // did this worm run into the wall?
 >>>     boolean ranIntoWall(Box b) {
 >>>       return !b.inside(this.posn());
 >>>     }
 >>>
 >>>     // move this worm in the direction of the keyevent
 >>>     //   if ke is in left, right, up, down
 >>>     // head moves in the direction of the predecessor
 >>>     // body element n+1 moves into the position of element n
 >>>     // body element 0 moves into the position of head
 >>>     Worm move(String ke) {
 >>>     if (this.head.move(ke).equal(this.head))
 >>>        return this; // the key was not a directional change
 >>>         else
 >>>        return new Worm(this.head.move(ke),this.body.move 
 >>> (this.head));
 >>>     }
 >>>
 >>>     Worm step() {
 >>>       return new Worm(this.head.move(this.whereTo 
 >>> ()),this.body.move(this.head));
 >>>     }
 >>>
 >>>     // did this worm run into itself after a move?
 >>>     boolean ateItself() {
 >>>     return this.body.overlap(this.head);
 >>>     }
 >>>
 >>>     // can the head of this worm eat the food?
 >>>     boolean canEat(Food f) {
 >>>     return this.head.canEat(f);
 >>>     }
 >>>
 >>>     // move the head into the direction into which it is going  
 >>> already
 >>>     // the old head becomes part of the body
 >>>     // @pre: canEat(f)
 >>>     // @post: !ateItself()
 >>>     Worm eat(Food f) {
 >>>     return new Worm(this.head.move(this.whereTo()),
 >>>             new ConsSegment(this.head,this.body));
 >>>     }
 >>>
 >>>     // how long is the worm
 >>>     int length() {
 >>>     return 1 + this.body.length();
 >>>     }
 >>>
 >>>     // draw this worm into c
 >>>     boolean draw(World c) {
 >>>     return this.head.draw(c) && this.body.draw(c);
 >>>     }
 >>>
 >>>     // erase this worm from c
 >>>     boolean erase(World c) {
 >>>     return this.head.erase(c) && this.body.erase(c);
 >>>     }
 >>> }
 >>>
 >>> //  
 >>> -------------------------------------------------------------------- 
 >>> ---------
 >>> // a list of worm segments that represent the worm's body
 >>> // composite pattern: it is a composite because every segment  
 >>> behaves the same way
 >>> abstract class ListSegment {
 >>>     // does s overlap with any of the segments in _this_ body
 >>>     abstract boolean overlap(Segment s);
 >>>
 >>>     // move each segment in this list of segments into the  
 >>> position of its
 >>>     // predecessor, given the new position for the predecessor  
 >>> (head originally)
 >>>     abstract ListSegment move(Segment pred);
 >>>
 >>>     // count the number of segments
 >>>     abstract int length();
 >>>
 >>>     // draw the list of segments on c
 >>>     abstract boolean draw(World c);
 >>>
 >>>     // erase the list of segments from c
 >>>     abstract boolean erase(World c);
 >>> }
 >>>
 >>> class MtSegment extends ListSegment {
 >>>     MtSegment() {}
 >>>
 >>>     boolean overlap(Segment s) { return false; }
 >>>
 >>>     ListSegment move(Segment pred) { return new MtSegment(); }
 >>>
 >>>     int length() { return 0; }
 >>>
 >>>     boolean draw(World c) { return true; }
 >>>
 >>>     boolean erase(World c) { return true; }
 >>> }
 >>>
 >>> class ConsSegment extends ListSegment {
 >>>     Segment first;
 >>>     ListSegment rest;
 >>>     ConsSegment(Segment first, ListSegment rest) {
 >>>     this.first = first;
 >>>     this.rest = rest;
 >>>     }
 >>>
 >>>     boolean overlap(Segment s) {
 >>>     return this.first.overlap(s) || this.rest.overlap(s);
 >>>     }
 >>>
 >>>     ListSegment move(Segment pred) {
 >>>     return new ConsSegment(pred,this.rest.move(this.first));
 >>>     }
 >>>
 >>>     int length() {
 >>>     return 1 + this.rest.length();
 >>>     }
 >>>
 >>>     boolean draw(World c) {
 >>>     return this.first.draw(c) && this.rest.draw(c);
 >>>     }
 >>>
 >>>     boolean erase(World c) {
 >>>     return this.first.erase(c) && this.rest.erase(c);
 >>>     }
 >>> }
 >>>
 >>> //  
 >>> -------------------------------------------------------------------- 
 >>> ---------
 >>> // represents a segment of the worm, represented as solid disk  
 >>> located at (x,y)
 >>> class Segment {
 >>>     int x;
 >>>     int y;
 >>>     String direction;
 >>>
 >>>     int radius;
 >>>     Color color;
 >>>     int DX;
 >>>     int DY;
 >>>
 >>>     Segment(int x, int y, String d) {
 >>>     this.x = x;
 >>>     this.y = y;
 >>>         this.radius = 5;
 >>>         this.color = new Red();
 >>>         this.DX = 2 * this.radius;
 >>>         this.DY = 2 * this.radius;
 >>>         this.direction = d;
 >>>     }
 >>>
 >>>     // where is it?
 >>>     Posn posn() {
 >>>     return new Posn(this.x,this.y);
 >>>     }
 >>>
 >>>     // where is it going?
 >>>     String whereTo() {
 >>>       return this.direction;
 >>>     }
 >>>
 >>>     // is this segment equal to that?
 >>>     boolean equal(Segment that) {
 >>>        return this.x == that.x && this.y == that.y &&  
 >>> this.direction == that.direction;
 >>>     }
 >>>
 >>>     // move in the direction of ke as specified if ke is in left,  
 >>> right, up, down
 >>>     Segment move(String ke) {
 >>>     if (ke.equals("left"))
 >>>         return new Segment(this.x-this.DX,this.y,ke);
 >>>     else if (ke.equals("right"))
 >>>         return new Segment(this.x+this.DX,this.y,ke);
 >>>     else if (ke.equals("up"))
 >>>         return new Segment(this.x,this.y-this.DY,ke);
 >>>     else if (ke.equals("down"))
 >>>         return new Segment(this.x,this.y+this.DY,ke);
 >>>     else // don't move
 >>>         return this;
 >>>     }
 >>>
 >>>     // does _this_ segment overlap with segment s
 >>>     boolean overlap(Segment s) {
 >>>     return this.distance(this.x-s.x,this.y-s.y) < 2 * this.radius;
 >>>     }
 >>>
 >>>     // can this (head) segment eat the food if it moves in the  
 >>> direction of ke
 >>>     boolean canEat(Food f) {
 >>>     // is there an overlap of the two geometric shapes
 >>>     // approximation: is any of the four corners of the food  
 >>> inside s?
 >>>     return f.inside(this.posn());
 >>>     }
 >>>
 >>>     // draw a worm segment
 >>>     boolean draw(World c) {
 >>>     return c.drawDisk(new Posn 
 >>> (this.x,this.y),this.radius,this.color);
 >>>     }
 >>>
 >>>     // erase a worm segment
 >>>     boolean erase(World c) {
 >>>     return c.clearDisk(new Posn 
 >>> (this.x,this.y),this.radius,this.color);
 >>>     }
 >>>
 >>>     // --- auxiliaries that are only needed for this class:  
 >>> motivate private ---
 >>>
 >>>     // is the Posn inside the disk represented by this segment
 >>>     boolean inside(Posn p) {
 >>>     return this.distance(this.x-p.x,this.y-p.y) <= this.radius;
 >>>     }
 >>>
 >>>     // how far is (x,y) from the origin
 >>>     double distance(int x, int y) {
 >>>     return Math.sqrt(x*x+y*y);
 >>>     }
 >>> }
 >>>
 >>>
 >>> class Examples {
 >>>   Segment h;
 >>>   Worm w;
 >>>   Food f;
 >>>   Box b;
 >>>
 >>>   Examples() {
 >>>     this.h = new Segment(30,10,"left");
 >>>     this.w = new Worm(this.h,new ConsSegment(new Segment 
 >>> (40,10,"left"),new MtSegment()));
 >>>     this.f = new Food(0,0);
 >>>     this.b = new Box(300,300);
 >>>   }
 >>>
 >>>   boolean test() {
 >>>     // return this.h.canEat(this.f);
 >>>     // return !this.w.eat(this.f).body.isMt();
 >>>     // return this.w.eat(this.f).move("left").move("up").move 
 >>> ("down").ateItself();
 >>>     return this.w.move("left").eat(this.f).ranIntoWall(this.b);
 >>>   }
 >>> }
 >>>
 >>> *** Environment:
 >>> macosx "Darwin europe.local 7.9.0 Darwin Kernel Version 7.9.0:  
 >>> Wed Mar 30 20:11:17 PST 2005; root:xnu/xnu-517.12.7.obj~1/ 
 >>> RELEASE_PPC  Power Macintosh powerpc" (ppc-macosx) (get-display- 
 >>> depth) = 32
 >>> Docs Installed:
 >>> (#<path:/Users/matthias/plt/collects/doc/help>)
 >>> Collections:
 >>> ((#<path:/Users/matthias/Library/PLT Scheme/299.107/collects>  
 >>> "non-existent path") (#<path:/Users/matthias/plt/collects>  
 >>> (#<path:.svn> #<path:afm> #<path:algol60> #<path:browser>  
 >>> #<path:compiler> #<path:defaults> #<path:doc> #<path:drscheme>  
 >>> #<path:dynext> #<path:embedded-gui> #<path:eopl>  
 >>> #<path:errortrace> #<path:ffi> #<path:finish-install>  
 >>> #<path:framework> #<path:frtime> #<path:games> #<path:graphics>  
 >>> #<path:guibuilder> #<path:handin-client> #<path:handin-server>  
 >>> #<path:help> #<path:hierlist> #<path:honu> #<path:honu-module>  
 >>> #<path:htdch> #<path:htdp> #<path:html> #<path:icons> #<path:info- 
 >>> domain> #<path:lang> #<path:launcher> #<path:make> #<path:mred>  
 >>> #<path:mrflow> #<path:mrlib> #<path:mysterx> #<path:mzcom>  
 >>> #<path:mzlib> #<path:mzscheme> #<path:mztake> #<path:net>  
 >>> #<path:openssl> #<path:parser-tools> #<path:planet> #<path:plot>  
 >>> #<path:preprocessor> #<path:profj> #<path:profjBoxes>  
 >>> #<path:profjWizard> #<path:readline> #<path:reduction-semantics>  
 >>> #<path:repos-time-stamp!
 >>>
 >>>
 >>>> #<path:setup> #<path:sgl> #<path:sirmail> #<path:skipper>  
 >>>> #<path:slatex> #<path:slibinit> #<path:slideshow> #<path:srfi>  
 >>>> #<path:srpersist> #<path:ssax> #<path:stepper> #<path:string- 
 >>>> constants> #<path:swindle> #<path:syntax> #<path:syntax-color>  
 >>>> #<path:test-suite> #<path:tests> #<path:tex2page>  
 >>>> #<path:texpict> #<path:trace> #<path:version> #<path:waterworld>  
 >>>> #<path:web-server> #<path:xelda> #<path:xml>)))
 >>>>
 >>>>
 >>> Human Language: english
 >>> Teachpack filenames: ()
 >>> Computer Language: (("Experimental Languages" "ProfessorJ"  
 >>> "Intermediate") ((field) (#f)))
 >>>
 >>>
 >>
 >
 

Responsible changed from "nobody" to "kathyg" by kathyg at Mon, 04 Jul 2005 17:33:47 -0400
Reason>>> ProfJ bug

State changed from "open" to "closed" by kathyg at Mon, 04 Jul 2005 17:33:47 -0400
Reason>>> Corrected in repository

From: Matthias Felleisen <matthias@ccs.neu.edu>
To: Kathy Gray <kathyg@cs.utah.edu>
Cc: bugs@plt-scheme.org
Subject: Re: all/7484: professorJ mentions guard-convert-Color in strange error report
Date: Mon, 4 Jul 2005 17:59:21 -0400

 Thanks! It's working now. -- Matthias
 
 
 On Jul 4, 2005, at 3:23 PM, Kathy Gray wrote:
 
 > I see what's wrong, but the fix isn't a quick one.
 >
 > Putting a temporary additional Color field into WormWorld gets the  
 > program working for me.
 >
 > -Kathy
 >
 >
 > On Jul 4, 2005, at 11:45 AM, matthias@ccs.neu.edu wrote:
 >
 >> A new problem report is waiting at
 >>   http://bugs.plt-scheme.org/query/?cmd=view&pr=7484
 >>
 >> Reported by matthias for release: 299.107-svn4jul2005
 >>
 >> *** Description:
 >> I ran the program in "steps to reproduce" just fine for an hour.
 >> After deleting some comments I get this:
 >>
 >> Welcome to DrScheme, version 299.107-svn4jul2005.
 >> Language: ProfessorJ: Intermediate.
 >> expand: unbound variable in module in: guard-convert-Color
 >>
 >>>
 >>>
 >>
 >> I can't get it to work anymore either. ARGH!
 >>
 >> *** How to repeat:
 >> excuse the indentation but see previous bug report
 >>
 >> import draw.*;
 >>
 >> import java.util.Random;
 >>
 >> class Game {
 >>   WormWorld w;
 >>
 >>   Game() {
 >>    this.w = new WormWorld(
 >>         new Worm(new Segment(100,100,"left"),new MtSegment()),
 >>             new Food(100,100),
 >>             new Box(300,300));
 >>   }
 >>
 >>   // set up the world, draw it, and go
 >>   boolean go(double speed) {
 >>     return (this.w.start(300,300) && this.w.bigBang(speed) &&  
 >> this.w.draw());
 >>    }
 >> }
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> --------
 >> // represent the world of a Worm Game: Worm, Food, and the Bounding  
 >> Box
 >> class WormWorld extends World {
 >>
 >>    Worm w;
 >>    Food f;
 >>    Box  b;
 >>
 >>    WormWorld(Worm w, Food f, Box b) {
 >>      this.w = w;
 >>      this.f = f;
 >>      this.b = b;
 >>    }
 >>
 >>    // what happens when the clock ticks
 >>    World onTick() {
 >>      return this.move(this.w.step());
 >>    }
 >>
 >>    // what happens when the palyer presses a key
 >>    World onKeyEvent(String ke) {
 >>      return this.move(this.w.move(ke));
 >>    }
 >>
 >>    // move the world
 >>    WormWorld move(Worm newWorm) {
 >>      if (newWorm.ateItself()
 >>          && this.finish("Your worm ate itself:  
 >> ".concat(String.valueOf(newWorm.length()))))
 >>         return this;
 >>      else if (newWorm.ranIntoWall(this.b)
 >>           && this.finish("Your worm ran into a wall:  
 >> ".concat(String.valueOf(newWorm.length()))))
 >>     return this;
 >>      else if (newWorm.canEat(this.f)
 >>           && this.announce("Your worm just ate:  
 >> ".concat(String.valueOf(newWorm.length()))))
 >>         return new  
 >> WormWorld(newWorm.eat(this.f),this.f.create(this.b),this.b);
 >>      else // move the worm
 >>         return new WormWorld(newWorm,this.f,this.b);
 >>    }
 >>
 >>    // announce something and stop this world
 >>    boolean finish(String s) {
 >>      return this.write(s) && this.endOfTime();
 >>    }
 >>
 >>    // announce something and stop this world
 >>    boolean announce(String s) {
 >>      return this.write(s);
 >>    }
 >>
 >>    // write a string to this worm world
 >>    boolean write(String s) {
 >>      return (   this.drawRect(new Posn(10,280),150,20,new White())
 >>          && this.drawString(new Posn(10,290),s));
 >>    }
 >>
 >>    // draw this world
 >>    boolean draw() { return this.w.draw(this) && this.f.draw(this); }
 >>
 >>    // erase this world
 >>    boolean erase() { return this.w.erase(this) && this.f.erase(this);  
 >> }
 >> }
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> -------
 >> // Box: represents the playing field for the worm game
 >>
 >> class Box {
 >>     int width;
 >>     int height;
 >>
 >>     Box(int width, int height) {
 >>     this.width = width;
 >>     this.height = height;
 >>     }
 >>
 >>     // is p inside of _this_ box?
 >>     boolean inside(Posn p) {
 >>     return
 >>         (0 <= p.x && p.x <= this.width) &&
 >>         (0 <= p.y && p.y <= this.height);
 >>     }
 >> }
 >>
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> -------
 >> // represents a piece of food as a solid rectangle with northwest  
 >> corner at (x,y)
 >> class Food {
 >>     int x;
 >>     int y;
 >>
 >>     int width = 20;
 >>     int height = 10;
 >>     Color color = new Green();
 >>
 >>     Random foodPlace = new Random();
 >>
 >>     Food(int x, int y) {
 >>        this.x = x;
 >>        this.y = y;
 >>     }
 >>
 >>     // is p inside of this Food shape
 >>     boolean inside(Posn p) {
 >>        return
 >>         (this.x <= p.x && p.x <= this.x+this.width) &&
 >>         (this.y <= p.y && p.y <= this.y+this.width);
 >>     }
 >>
 >>     // create a food pile that is at a different location than this
 >>     // use trial and error
 >>     Food create(Box b) {
 >>        int x = new Random().nextInt(b.width-1); // -1 to stay within  
 >> boundaries
 >>         int y = new Random().nextInt(b.height-1);
 >>
 >>         if ((this.x != x) && this.y != y)
 >>         return new Food(x,y);
 >>        else
 >>         return this.create(b);
 >>     }
 >>
 >>     boolean draw(World w) {
 >>        return w.drawRect(new  
 >> Posn(this.x,this.y),this.width,this.height,this.color);
 >>     }
 >>
 >>     boolean erase(World w) {
 >>        return w.clearRect(new  
 >> Posn(this.x,this.y),this.width,this.height,this.color);
 >>     }
 >> }
 >>
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> -------
 >> // Worm is a head segment plus a potentially empty sequence of  
 >> segments
 >>
 >> class Worm {
 >>     Segment head;
 >>     ListSegment body;
 >>     Worm(Segment head, ListSegment body) {
 >>        this.head = head;
 >>        this.body = body;
 >>     }
 >>
 >>     // where is the head of the worm?
 >>     Posn posn() {
 >>        return new Posn(this.head.x,this.head.y);
 >>     }
 >>
 >>     // where is this going?
 >>     String whereTo() {
 >>         return this.head.whereTo();
 >>     }
 >>
 >>     // did this worm run into the wall?
 >>     boolean ranIntoWall(Box b) {
 >>       return !b.inside(this.posn());
 >>     }
 >>
 >>     // move this worm in the direction of the keyevent
 >>     //   if ke is in left, right, up, down
 >>     // head moves in the direction of the predecessor
 >>     // body element n+1 moves into the position of element n
 >>     // body element 0 moves into the position of head
 >>     Worm move(String ke) {
 >>     if (this.head.move(ke).equal(this.head))
 >>        return this; // the key was not a directional change
 >>         else
 >>        return new Worm(this.head.move(ke),this.body.move(this.head));
 >>     }
 >>
 >>     Worm step() {
 >>       return new  
 >> Worm(this.head.move(this.whereTo()),this.body.move(this.head));
 >>     }
 >>
 >>     // did this worm run into itself after a move?
 >>     boolean ateItself() {
 >>     return this.body.overlap(this.head);
 >>     }
 >>
 >>     // can the head of this worm eat the food?
 >>     boolean canEat(Food f) {
 >>     return this.head.canEat(f);
 >>     }
 >>
 >>     // move the head into the direction into which it is going already
 >>     // the old head becomes part of the body
 >>     // @pre: canEat(f)
 >>     // @post: !ateItself()
 >>     Worm eat(Food f) {
 >>     return new Worm(this.head.move(this.whereTo()),
 >>             new ConsSegment(this.head,this.body));
 >>     }
 >>
 >>     // how long is the worm
 >>     int length() {
 >>     return 1 + this.body.length();
 >>     }
 >>
 >>     // draw this worm into c
 >>     boolean draw(World c) {
 >>     return this.head.draw(c) && this.body.draw(c);
 >>     }
 >>
 >>     // erase this worm from c
 >>     boolean erase(World c) {
 >>     return this.head.erase(c) && this.body.erase(c);
 >>     }
 >> }
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> -------
 >> // a list of worm segments that represent the worm's body
 >> // composite pattern: it is a composite because every segment behaves  
 >> the same way
 >> abstract class ListSegment {
 >>     // does s overlap with any of the segments in _this_ body
 >>     abstract boolean overlap(Segment s);
 >>
 >>     // move each segment in this list of segments into the position  
 >> of its
 >>     // predecessor, given the new position for the predecessor (head  
 >> originally)
 >>     abstract ListSegment move(Segment pred);
 >>
 >>     // count the number of segments
 >>     abstract int length();
 >>
 >>     // draw the list of segments on c
 >>     abstract boolean draw(World c);
 >>
 >>     // erase the list of segments from c
 >>     abstract boolean erase(World c);
 >> }
 >>
 >> class MtSegment extends ListSegment {
 >>     MtSegment() {}
 >>
 >>     boolean overlap(Segment s) { return false; }
 >>
 >>     ListSegment move(Segment pred) { return new MtSegment(); }
 >>
 >>     int length() { return 0; }
 >>
 >>     boolean draw(World c) { return true; }
 >>
 >>     boolean erase(World c) { return true; }
 >> }
 >>
 >> class ConsSegment extends ListSegment {
 >>     Segment first;
 >>     ListSegment rest;
 >>     ConsSegment(Segment first, ListSegment rest) {
 >>     this.first = first;
 >>     this.rest = rest;
 >>     }
 >>
 >>     boolean overlap(Segment s) {
 >>     return this.first.overlap(s) || this.rest.overlap(s);
 >>     }
 >>
 >>     ListSegment move(Segment pred) {
 >>     return new ConsSegment(pred,this.rest.move(this.first));
 >>     }
 >>
 >>     int length() {
 >>     return 1 + this.rest.length();
 >>     }
 >>
 >>     boolean draw(World c) {
 >>     return this.first.draw(c) && this.rest.draw(c);
 >>     }
 >>
 >>     boolean erase(World c) {
 >>     return this.first.erase(c) && this.rest.erase(c);
 >>     }
 >> }
 >>
 >> //  
 >> ---------------------------------------------------------------------- 
 >> -------
 >> // represents a segment of the worm, represented as solid disk  
 >> located at (x,y)
 >> class Segment {
 >>     int x;
 >>     int y;
 >>     String direction;
 >>
 >>     int radius;
 >>     Color color;
 >>     int DX;
 >>     int DY;
 >>
 >>     Segment(int x, int y, String d) {
 >>     this.x = x;
 >>     this.y = y;
 >>         this.radius = 5;
 >>         this.color = new Red();
 >>         this.DX = 2 * this.radius;
 >>         this.DY = 2 * this.radius;
 >>         this.direction = d;
 >>     }
 >>
 >>     // where is it?
 >>     Posn posn() {
 >>     return new Posn(this.x,this.y);
 >>     }
 >>
 >>     // where is it going?
 >>     String whereTo() {
 >>       return this.direction;
 >>     }
 >>
 >>     // is this segment equal to that?
 >>     boolean equal(Segment that) {
 >>        return this.x == that.x && this.y == that.y && this.direction  
 >> == that.direction;
 >>     }
 >>
 >>     // move in the direction of ke as specified if ke is in left,  
 >> right, up, down
 >>     Segment move(String ke) {
 >>     if (ke.equals("left"))
 >>         return new Segment(this.x-this.DX,this.y,ke);
 >>     else if (ke.equals("right"))
 >>         return new Segment(this.x+this.DX,this.y,ke);
 >>     else if (ke.equals("up"))
 >>         return new Segment(this.x,this.y-this.DY,ke);
 >>     else if (ke.equals("down"))
 >>         return new Segment(this.x,this.y+this.DY,ke);
 >>     else // don't move
 >>         return this;
 >>     }
 >>
 >>     // does _this_ segment overlap with segment s
 >>     boolean overlap(Segment s) {
 >>     return this.distance(this.x-s.x,this.y-s.y) < 2 * this.radius;
 >>     }
 >>
 >>     // can this (head) segment eat the food if it moves in the  
 >> direction of ke
 >>     boolean canEat(Food f) {
 >>     // is there an overlap of the two geometric shapes
 >>     // approximation: is any of the four corners of the food inside s?
 >>     return f.inside(this.posn());
 >>     }
 >>
 >>     // draw a worm segment
 >>     boolean draw(World c) {
 >>     return c.drawDisk(new Posn(this.x,this.y),this.radius,this.color);
 >>     }
 >>
 >>     // erase a worm segment
 >>     boolean erase(World c) {
 >>     return c.clearDisk(new  
 >> Posn(this.x,this.y),this.radius,this.color);
 >>     }
 >>
 >>     // --- auxiliaries that are only needed for this class: motivate  
 >> private ---
 >>
 >>     // is the Posn inside the disk represented by this segment
 >>     boolean inside(Posn p) {
 >>     return this.distance(this.x-p.x,this.y-p.y) <= this.radius;
 >>     }
 >>
 >>     // how far is (x,y) from the origin
 >>     double distance(int x, int y) {
 >>     return Math.sqrt(x*x+y*y);
 >>     }
 >> }
 >>
 >>
 >> class Examples {
 >>   Segment h;
 >>   Worm w;
 >>   Food f;
 >>   Box b;
 >>
 >>   Examples() {
 >>     this.h = new Segment(30,10,"left");
 >>     this.w = new Worm(this.h,new ConsSegment(new  
 >> Segment(40,10,"left"),new MtSegment()));
 >>     this.f = new Food(0,0);
 >>     this.b = new Box(300,300);
 >>   }
 >>
 >>   boolean test() {
 >>     // return this.h.canEat(this.f);
 >>     // return !this.w.eat(this.f).body.isMt();
 >>     // return  
 >> this.w.eat(this.f).move("left").move("up").move("down").ateItself();
 >>     return this.w.move("left").eat(this.f).ranIntoWall(this.b);
 >>   }
 >> }
 >>
 >> *** Environment:
 >> macosx "Darwin europe.local 7.9.0 Darwin Kernel Version 7.9.0: Wed  
 >> Mar 30 20:11:17 PST 2005; root:xnu/xnu-517.12.7.obj~1/RELEASE_PPC   
 >> Power Macintosh powerpc" (ppc-macosx) (get-display-depth) = 32
 >> Docs Installed:
 >> (#<path:/Users/matthias/plt/collects/doc/help>)
 >> Collections:
 >> ((#<path:/Users/matthias/Library/PLT Scheme/299.107/collects>  
 >> "non-existent path") (#<path:/Users/matthias/plt/collects>  
 >> (#<path:.svn> #<path:afm> #<path:algol60> #<path:browser>  
 >> #<path:compiler> #<path:defaults> #<path:doc> #<path:drscheme>  
 >> #<path:dynext> #<path:embedded-gui> #<path:eopl> #<path:errortrace>  
 >> #<path:ffi> #<path:finish-install> #<path:framework> #<path:frtime>  
 >> #<path:games> #<path:graphics> #<path:guibuilder>  
 >> #<path:handin-client> #<path:handin-server> #<path:help>  
 >> #<path:hierlist> #<path:honu> #<path:honu-module> #<path:htdch>  
 >> #<path:htdp> #<path:html> #<path:icons> #<path:info-domain>  
 >> #<path:lang> #<path:launcher> #<path:make> #<path:mred>  
 >> #<path:mrflow> #<path:mrlib> #<path:mysterx> #<path:mzcom>  
 >> #<path:mzlib> #<path:mzscheme> #<path:mztake> #<path:net>  
 >> #<path:openssl> #<path:parser-tools> #<path:planet> #<path:plot>  
 >> #<path:preprocessor> #<path:profj> #<path:profjBoxes>  
 >> #<path:profjWizard> #<path:readline> #<path:reduction-semantics>  
 >> #<path:repos-time-stamp!
 >>
 >>> #<path:setup> #<path:sgl> #<path:sirmail> #<path:skipper>  
 >>> #<path:slatex> #<path:slibinit> #<path:slideshow> #<path:srfi>  
 >>> #<path:srpersist> #<path:ssax> #<path:stepper>  
 >>> #<path:string-constants> #<path:swindle> #<path:syntax>  
 >>> #<path:syntax-color> #<path:test-suite> #<path:tests>  
 >>> #<path:tex2page> #<path:texpict> #<path:trace> #<path:version>  
 >>> #<path:waterworld> #<path:web-server> #<path:xelda> #<path:xml>)))
 >>>
 >> Human Language: english
 >> Teachpack filenames: ()
 >> Computer Language: (("Experimental Languages" "ProfessorJ"  
 >> "Intermediate") ((field) (#f)))
 >>
 >
 
