From bugs+caf_=bugs=bugs.plt-scheme.org@plt-scheme.org Mon Jul  7 15:45:31 2008
Received: from gv-out-0910.google.com (gv-out-0910.google.com [216.239.58.191])
	by champlain.ccs.neu.edu (8.14.2/8.14.2) with ESMTP id m67JjS7Z027147
	for <bugs@bugs.plt-scheme.org>; Mon, 7 Jul 2008 15:45:28 -0400
Message-Id: <200807071945.m67JjCiH027141@champlain.ccs.neu.edu>
Date: Mon, 7 Jul 2008 15:45:12 -0400
From: samth@ccs.neu.edu
To: bugs@plt-scheme.org
Subject: macro stepper completely broken

>Number:         9586
>Category:       macro-stepper
>Synopsis:       macro stepper completely broken
>Class:          sw-bug
>Responsible:    ryanc
>Severity:       serious
>Priority:       medium
>State:          closed
>Confidential:   no
>Arrival-Date:   Mon Jul 07 15:48:01 -0400 2008
>Last-Modified:  Mon Mar 16 00:24:48 -0400 2009
>Originator:     Sam TH
>Organization:
plt
>Submitter-Id:   unknown
>Release:        4.0.2.3-svn7jul2008
>Environment:
unix "Linux punge 2.6.22-14-386 #1 Tue Feb 12 07:12:19 UTC 2008 i686 GNU/Linux" (i386-linux/3m) (get-display-depth) = 24
Human Language: english
(current-memory-use) 181611680

Collections:
(("/home/samth/scheme" "infix4.diff" "info-domain" "match" "perf" "foo" "ifc" "beamer") ("/home/samth/.plt-scheme/4.0.2.3/collects" non-existent-path) ("/home/samth/sw/plt4/collects" ".svn" "tex2page" "string-constants" "wxme" "planet" "mzcom" "drscheme" "s-exp" "r6rs" "framework" "srpersist" "sirmail" "slideshow" "scribblings" "test-box-recovery" "syntax-color" "srfi" "algol60" "dynext" "make" "plot" "file" "lang" "web-server" "openssl" "macro-debugger" "scribble" "frtime" "mred" "combinator-parser" "guibuilder" "htdp" "setup" "graphics" "profjWizard" "afm" "scheme" "config" "gui-debugger" "defaults" "icons" "handin-client" "lazy" "texpict" "browser" "teachpack" "rnrs" "parser-tools" "waterworld" "r5rs" "games" "eopl" "tests" "html" "handin-server" "swindle" "repos-time-stamp" "little-helper" "compiler" "embedded-gui" "profj" "stepper" "readline" "hierlist" "sgl" "version" "preprocessor" "net" "syntax" "help" "htdch" "trace" "slatex" "xml" "launcher" "ffi" "mrlib" "errortra!
 ce" "mzscheme" "mysterx" "mzlib" "info-domain" "typed-scheme" "test-engine" "honu"))
Computer Language: (("Module") (#(#t write mixed-fraction-e #f #t debug) (default) #() "#lang scheme/base\n"))
>Description:
The macro stepper is now completely broken.

If there is an error in expansion, then only the module (module scheme/base (void)) is presented, fully expanded.  If there is no error, then the full expansion is presented, with no steps available, regardless of the hiding policy.  

At this point, the macro stepper shows basically no more information that calling `expand' on the syntax in the defintions window.  
>How-To-Repeat:
>Fix:
>Audit-Trail:
From: Eli Barzilay <eli@barzilay.org>
To: samth@ccs.neu.edu, bugs@plt-scheme.org
Cc: robby@plt-scheme.org, ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Mon, 7 Jul 2008 17:01:55 -0400

 On Jul  7, samth@ccs.neu.edu wrote:
 > 
 > If there is an error in expansion, then only the module (module
 > scheme/base (void)) is presented, fully expanded.
 
 Robby: is there a way to know (in `front-end/complete-program')
 whether it's being used for execution or for something else?
 
 
 > If there is no error, then the full expansion is presented, with no
 > steps available, regardless of the hiding policy.
 
 (I have no idea why this happens.)
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                   http://www.barzilay.org/                 Maze is Life!
From: "Robby Findler" <robby@cs.uchicago.edu>
To: "Eli Barzilay" <eli@barzilay.org>
Cc: samth@ccs.neu.edu, bugs@plt-scheme.org, ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Mon, 7 Jul 2008 16:06:41 -0500

 On Mon, Jul 7, 2008 at 4:01 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > On Jul  7, samth@ccs.neu.edu wrote:
 >>
 >> If there is an error in expansion, then only the module (module
 >> scheme/base (void)) is presented, fully expanded.
 >
 > Robby: is there a way to know (in `front-end/complete-program')
 > whether it's being used for execution or for something else?
 
 No .... if you need to know that, then something else is wrong --
 probably the tools interface needs to be wider somehow.
 
 Can you tell me in a little more detail how that is related to the
 problem at hand?
 
 Robby
From: Eli Barzilay <eli@barzilay.org>
To: "Robby Findler" <robby@cs.uchicago.edu>
Cc: samth@ccs.neu.edu, bugs@plt-scheme.org, ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Mon, 7 Jul 2008 17:21:57 -0400

 Actually, I know also why the second part of the problem happens --
 because the module-language hands out a fully expanded code, so that's
 what the macro stepper will see.
 
 
 On Jul  7, Robby Findler wrote:
 > On Mon, Jul 7, 2008 at 4:01 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > > On Jul  7, samth@ccs.neu.edu wrote:
 > >>
 > >> If there is an error in expansion, then only the module (module
 > >> scheme/base (void)) is presented, fully expanded.
 > >
 > > Robby: is there a way to know (in `front-end/complete-program')
 > > whether it's being used for execution or for something else?
 > 
 > No .... if you need to know that, then something else is wrong --
 > probably the tools interface needs to be wider somehow.
 > 
 > Can you tell me in a little more detail how that is related to the
 > problem at hand?
 
 The problem results from catching expand errors in the code, and
 replacing it with an empty (module foo language) when that happens.
 This whole thing (uncluding the expansion) shouldn't happen when the
 macro debugger is used (or when check-syntax is, etc).
 
 * I'm not sure how to fix this -- extending the tool interface sounds
   wrong.  Maybe there is someplace else in the interface that can be
   used to do the test-expand thing?
 
 * Maybe it's better to change replacing the module with a minimal one
   by using it to initialize the namespace.  This makes me less
   comfortable -- what if something behaves differently when the
   current namespace is empty or not?
 
 * Finally, it makes me worry about the other parts of
   `front-end/complete-program' -- and when I tried adding some
   debugging printouts, I did get the macro stepper to show some of
   these extra expressions, which is completely bogus, of course.  I
   have no idea how they're usually hidden.
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                   http://www.barzilay.org/                 Maze is Life!
From: "Robby Findler" <robby@cs.uchicago.edu>
To: "Eli Barzilay" <eli@barzilay.org>
Cc: samth@ccs.neu.edu, bugs@plt-scheme.org, ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Mon, 7 Jul 2008 19:53:15 -0500

 Your description below sounds to me like the classic case for
 extending the tools interface. That interface's job is to mediate
 between things that produce programs (languages) and things that
 process them (tools, but this word is overloaded in drscheme speak --
 I should have called them plugins or something).
 
 Anyways, the macro stepper wants unexpanded programs, but the module
 language has to expand the program in order to find out what the
 program actually is (which is kind of a strange property, if you think
 about it like that) when it is running the program. Another way to put
 this is that Eli's initial instinct "can I find out when
 front-end/program is being called for execution?" is right, but to
 make that work it has to be codified in the language interface. This
 has already happened once and that's why we have two different
 front-end methods.
 
 Does that make sense?
 
 Robby
 
 On Mon, Jul 7, 2008 at 4:21 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > Actually, I know also why the second part of the problem happens --
 > because the module-language hands out a fully expanded code, so that's
 > what the macro stepper will see.
 >
 >
 > On Jul  7, Robby Findler wrote:
 >> On Mon, Jul 7, 2008 at 4:01 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> > On Jul  7, samth@ccs.neu.edu wrote:
 >> >>
 >> >> If there is an error in expansion, then only the module (module
 >> >> scheme/base (void)) is presented, fully expanded.
 >> >
 >> > Robby: is there a way to know (in `front-end/complete-program')
 >> > whether it's being used for execution or for something else?
 >>
 >> No .... if you need to know that, then something else is wrong --
 >> probably the tools interface needs to be wider somehow.
 >>
 >> Can you tell me in a little more detail how that is related to the
 >> problem at hand?
 >
 > The problem results from catching expand errors in the code, and
 > replacing it with an empty (module foo language) when that happens.
 > This whole thing (uncluding the expansion) shouldn't happen when the
 > macro debugger is used (or when check-syntax is, etc).
 >
 > * I'm not sure how to fix this -- extending the tool interface sounds
 >  wrong.  Maybe there is someplace else in the interface that can be
 >  used to do the test-expand thing?
 >
 > * Maybe it's better to change replacing the module with a minimal one
 >  by using it to initialize the namespace.  This makes me less
 >  comfortable -- what if something behaves differently when the
 >  current namespace is empty or not?
 >
 > * Finally, it makes me worry about the other parts of
 >  `front-end/complete-program' -- and when I tried adding some
 >  debugging printouts, I did get the macro stepper to show some of
 >  these extra expressions, which is completely bogus, of course.  I
 >  have no idea how they're usually hidden.
 >
 > --
 >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                  http://www.barzilay.org/                 Maze is Life!
 >
 >
From: Eli Barzilay <eli@barzilay.org>
To: "Robby Findler" <robby@cs.uchicago.edu>
Cc: samth@ccs.neu.edu, bugs@plt-scheme.org, ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Mon, 7 Jul 2008 21:05:18 -0400

 On Jul  7, Robby Findler wrote:
 > Your description below sounds to me like the classic case for
 > extending the tools interface. That interface's job is to mediate
 > between things that produce programs (languages) and things that
 > process them (tools, but this word is overloaded in drscheme speak
 > -- I should have called them plugins or something).
 > 
 > Anyways, the macro stepper wants unexpanded programs, but the module
 > language has to expand the program in order to find out what the
 > program actually is (which is kind of a strange property, if you
 > think about it like that) when it is running the program. Another
 > way to put this is that Eli's initial instinct "can I find out when
 > front-end/program is being called for execution?" is right, but to
 > make that work it has to be codified in the language interface. This
 > has already happened once and that's why we have two different
 > front-end methods.
 > 
 > Does that make sense?
 
 Sort of.  Does this mean that that the using the other front-end
 method is the solution, or does it mean that you think that a new one
 is needed?
 
 
 > On Mon, Jul 7, 2008 at 4:21 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > > Actually, I know also why the second part of the problem happens --
 > > because the module-language hands out a fully expanded code, so that's
 > > what the macro stepper will see.
 > >
 > >
 > > On Jul  7, Robby Findler wrote:
 > >> On Mon, Jul 7, 2008 at 4:01 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > >> > On Jul  7, samth@ccs.neu.edu wrote:
 > >> >>
 > >> >> If there is an error in expansion, then only the module (module
 > >> >> scheme/base (void)) is presented, fully expanded.
 > >> >
 > >> > Robby: is there a way to know (in `front-end/complete-program')
 > >> > whether it's being used for execution or for something else?
 > >>
 > >> No .... if you need to know that, then something else is wrong --
 > >> probably the tools interface needs to be wider somehow.
 > >>
 > >> Can you tell me in a little more detail how that is related to the
 > >> problem at hand?
 > >
 > > The problem results from catching expand errors in the code, and
 > > replacing it with an empty (module foo language) when that happens.
 > > This whole thing (uncluding the expansion) shouldn't happen when the
 > > macro debugger is used (or when check-syntax is, etc).
 > >
 > > * I'm not sure how to fix this -- extending the tool interface sounds
 > >  wrong.  Maybe there is someplace else in the interface that can be
 > >  used to do the test-expand thing?
 > >
 > > * Maybe it's better to change replacing the module with a minimal one
 > >  by using it to initialize the namespace.  This makes me less
 > >  comfortable -- what if something behaves differently when the
 > >  current namespace is empty or not?
 > >
 > > * Finally, it makes me worry about the other parts of
 > >  `front-end/complete-program' -- and when I tried adding some
 > >  debugging printouts, I did get the macro stepper to show some of
 > >  these extra expressions, which is completely bogus, of course.  I
 > >  have no idea how they're usually hidden.
 > >
 > > --
 > >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 > >                  http://www.barzilay.org/                 Maze is Life!
 > >
 > >
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                   http://www.barzilay.org/                 Maze is Life!
From: "Robby Findler" <robby@cs.uchicago.edu>
To: "Eli Barzilay" <eli@barzilay.org>
Cc: samth@ccs.neu.edu, bugs@plt-scheme.org, ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Mon, 7 Jul 2008 20:11:07 -0500

 I don't think that either of them is the right thing for this
 situation. It sounds like some tools really want an unexpanded version
 of the program (the macro stepper) and other tools want something they
 can run to prepare the REPL (the run button).
 
 If I added a new method (whose default value was to call
 front-end/complete-program) then the macro stepper would be back in
 shape, right?
 
 (Ryan, sound right to you?)
 
 Robby
 
 On Mon, Jul 7, 2008 at 8:05 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > On Jul  7, Robby Findler wrote:
 >> Your description below sounds to me like the classic case for
 >> extending the tools interface. That interface's job is to mediate
 >> between things that produce programs (languages) and things that
 >> process them (tools, but this word is overloaded in drscheme speak
 >> -- I should have called them plugins or something).
 >>
 >> Anyways, the macro stepper wants unexpanded programs, but the module
 >> language has to expand the program in order to find out what the
 >> program actually is (which is kind of a strange property, if you
 >> think about it like that) when it is running the program. Another
 >> way to put this is that Eli's initial instinct "can I find out when
 >> front-end/program is being called for execution?" is right, but to
 >> make that work it has to be codified in the language interface. This
 >> has already happened once and that's why we have two different
 >> front-end methods.
 >>
 >> Does that make sense?
 >
 > Sort of.  Does this mean that that the using the other front-end
 > method is the solution, or does it mean that you think that a new one
 > is needed?
 >
 >
 >> On Mon, Jul 7, 2008 at 4:21 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> > Actually, I know also why the second part of the problem happens --
 >> > because the module-language hands out a fully expanded code, so that's
 >> > what the macro stepper will see.
 >> >
 >> >
 >> > On Jul  7, Robby Findler wrote:
 >> >> On Mon, Jul 7, 2008 at 4:01 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> >> > On Jul  7, samth@ccs.neu.edu wrote:
 >> >> >>
 >> >> >> If there is an error in expansion, then only the module (module
 >> >> >> scheme/base (void)) is presented, fully expanded.
 >> >> >
 >> >> > Robby: is there a way to know (in `front-end/complete-program')
 >> >> > whether it's being used for execution or for something else?
 >> >>
 >> >> No .... if you need to know that, then something else is wrong --
 >> >> probably the tools interface needs to be wider somehow.
 >> >>
 >> >> Can you tell me in a little more detail how that is related to the
 >> >> problem at hand?
 >> >
 >> > The problem results from catching expand errors in the code, and
 >> > replacing it with an empty (module foo language) when that happens.
 >> > This whole thing (uncluding the expansion) shouldn't happen when the
 >> > macro debugger is used (or when check-syntax is, etc).
 >> >
 >> > * I'm not sure how to fix this -- extending the tool interface sounds
 >> >  wrong.  Maybe there is someplace else in the interface that can be
 >> >  used to do the test-expand thing?
 >> >
 >> > * Maybe it's better to change replacing the module with a minimal one
 >> >  by using it to initialize the namespace.  This makes me less
 >> >  comfortable -- what if something behaves differently when the
 >> >  current namespace is empty or not?
 >> >
 >> > * Finally, it makes me worry about the other parts of
 >> >  `front-end/complete-program' -- and when I tried adding some
 >> >  debugging printouts, I did get the macro stepper to show some of
 >> >  these extra expressions, which is completely bogus, of course.  I
 >> >  have no idea how they're usually hidden.
 >> >
 >> > --
 >> >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >> >                  http://www.barzilay.org/                 Maze is Life!
 >> >
 >> >
 >
 > --
 >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                  http://www.barzilay.org/                 Maze is Life!
 >
 >
From: Eli Barzilay <eli@barzilay.org>
To: "Robby Findler" <robby@cs.uchicago.edu>
Cc: samth@ccs.neu.edu, bugs@plt-scheme.org, ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Mon, 7 Jul 2008 21:26:28 -0400

 On Jul  7, Robby Findler wrote:
 > I don't think that either of them is the right thing for this
 > situation. It sounds like some tools really want an unexpanded
 > version of the program (the macro stepper) and other tools want
 > something they can run to prepare the REPL (the run button).
 
 That makes sense to me, I was just trying to avoid a change (or an
 extension) of the tools interface.  But perhaps this is not something
 that can be avoided -- IIUC, there were already potential problems
 with the other expressions that the module language spits out.
 (That's why I said that I don't know how the macro stepper knows to
 ignore them.)
 
 
 > If I added a new method (whose default value was to call
 > front-end/complete-program) then the macro stepper would be back in
 > shape, right?
 
 IIUC, you're suggesting some new `front-end/for-interactions' method
 which returns the expressions to evaluate to setup a repl, and this
 method will just call `front-end/complete-program'.  This means that
 after that's added, the module language will override this new method
 to add all the extra stuff that is currently added in
 `front-end/complete-program' right now -- and otherwise there are no
 changes to any existing tools, right?
 
 If this is correct, it sounds right to me -- and whatever hacks Ryan
 has to avoid seeing these extra expressions in the macro stepper could
 be removed (assuming that he has such hack), so it sounds like a good
 improvement.
 
 
 > (Ryan, sound right to you?)
 > 
 > Robby
 > 
 > On Mon, Jul 7, 2008 at 8:05 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > > On Jul  7, Robby Findler wrote:
 > >> Your description below sounds to me like the classic case for
 > >> extending the tools interface. That interface's job is to mediate
 > >> between things that produce programs (languages) and things that
 > >> process them (tools, but this word is overloaded in drscheme speak
 > >> -- I should have called them plugins or something).
 > >>
 > >> Anyways, the macro stepper wants unexpanded programs, but the module
 > >> language has to expand the program in order to find out what the
 > >> program actually is (which is kind of a strange property, if you
 > >> think about it like that) when it is running the program. Another
 > >> way to put this is that Eli's initial instinct "can I find out when
 > >> front-end/program is being called for execution?" is right, but to
 > >> make that work it has to be codified in the language interface. This
 > >> has already happened once and that's why we have two different
 > >> front-end methods.
 > >>
 > >> Does that make sense?
 > >
 > > Sort of.  Does this mean that that the using the other front-end
 > > method is the solution, or does it mean that you think that a new one
 > > is needed?
 > >
 > >
 > >> On Mon, Jul 7, 2008 at 4:21 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > >> > Actually, I know also why the second part of the problem happens --
 > >> > because the module-language hands out a fully expanded code, so that's
 > >> > what the macro stepper will see.
 > >> >
 > >> >
 > >> > On Jul  7, Robby Findler wrote:
 > >> >> On Mon, Jul 7, 2008 at 4:01 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > >> >> > On Jul  7, samth@ccs.neu.edu wrote:
 > >> >> >>
 > >> >> >> If there is an error in expansion, then only the module (module
 > >> >> >> scheme/base (void)) is presented, fully expanded.
 > >> >> >
 > >> >> > Robby: is there a way to know (in `front-end/complete-program')
 > >> >> > whether it's being used for execution or for something else?
 > >> >>
 > >> >> No .... if you need to know that, then something else is wrong --
 > >> >> probably the tools interface needs to be wider somehow.
 > >> >>
 > >> >> Can you tell me in a little more detail how that is related to the
 > >> >> problem at hand?
 > >> >
 > >> > The problem results from catching expand errors in the code, and
 > >> > replacing it with an empty (module foo language) when that happens.
 > >> > This whole thing (uncluding the expansion) shouldn't happen when the
 > >> > macro debugger is used (or when check-syntax is, etc).
 > >> >
 > >> > * I'm not sure how to fix this -- extending the tool interface sounds
 > >> >  wrong.  Maybe there is someplace else in the interface that can be
 > >> >  used to do the test-expand thing?
 > >> >
 > >> > * Maybe it's better to change replacing the module with a minimal one
 > >> >  by using it to initialize the namespace.  This makes me less
 > >> >  comfortable -- what if something behaves differently when the
 > >> >  current namespace is empty or not?
 > >> >
 > >> > * Finally, it makes me worry about the other parts of
 > >> >  `front-end/complete-program' -- and when I tried adding some
 > >> >  debugging printouts, I did get the macro stepper to show some of
 > >> >  these extra expressions, which is completely bogus, of course.  I
 > >> >  have no idea how they're usually hidden.
 > >> >
 > >> > --
 > >> >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 > >> >                  http://www.barzilay.org/                 Maze is Life!
 > >> >
 > >> >
 > >
 > > --
 > >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 > >                  http://www.barzilay.org/                 Maze is Life!
 > >
 > >
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                   http://www.barzilay.org/                 Maze is Life!
From: "Robby Findler" <robby@cs.uchicago.edu>
To: "Eli Barzilay" <eli@barzilay.org>
Cc: samth@ccs.neu.edu, bugs@plt-scheme.org, ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Mon, 7 Jul 2008 20:30:44 -0500

 On Mon, Jul 7, 2008 at 8:26 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > On Jul  7, Robby Findler wrote:
 >> I don't think that either of them is the right thing for this
 >> situation. It sounds like some tools really want an unexpanded
 >> version of the program (the macro stepper) and other tools want
 >> something they can run to prepare the REPL (the run button).
 >
 > That makes sense to me, I was just trying to avoid a change (or an
 > extension) of the tools interface.  But perhaps this is not something
 > that can be avoided -- IIUC, there were already potential problems
 > with the other expressions that the module language spits out.
 > (That's why I said that I don't know how the macro stepper knows to
 > ignore them.)
 >
 >
 >> If I added a new method (whose default value was to call
 >> front-end/complete-program) then the macro stepper would be back in
 >> shape, right?
 >
 > IIUC, you're suggesting some new `front-end/for-interactions' method
 > which returns the expressions to evaluate to setup a repl, and this
 > method will just call `front-end/complete-program'.  This means that
 > after that's added, the module language will override this new method
 > to add all the extra stuff that is currently added in
 > `front-end/complete-program' right now -- and otherwise there are no
 > changes to any existing tools, right?
 >
 > If this is correct, it sounds right to me -- and whatever hacks Ryan
 > has to avoid seeing these extra expressions in the macro stepper could
 > be removed (assuming that he has such hack), so it sounds like a good
 > improvement.
 
 That will be correct for some tools (those that use the
 language-building mixins) but probably a few tools (those that build
 implementations of drscheme:language:language<%> themselves) will have
 to get one new line each.
 
 But yes, this will be a bonus for tools that want to just process the
 source -- I think many tools fit into this category already and we've
 just been lucky enough that we can work around the issues, but not
 anymore. Check Syntax, for example, already forced me to change the
 module language to avoid source locations in
 front-end/complete-program, IIRC (for example).
 
 Robby
 
 >
 >> (Ryan, sound right to you?)
 >>
 >> Robby
 >>
 >> On Mon, Jul 7, 2008 at 8:05 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> > On Jul  7, Robby Findler wrote:
 >> >> Your description below sounds to me like the classic case for
 >> >> extending the tools interface. That interface's job is to mediate
 >> >> between things that produce programs (languages) and things that
 >> >> process them (tools, but this word is overloaded in drscheme speak
 >> >> -- I should have called them plugins or something).
 >> >>
 >> >> Anyways, the macro stepper wants unexpanded programs, but the module
 >> >> language has to expand the program in order to find out what the
 >> >> program actually is (which is kind of a strange property, if you
 >> >> think about it like that) when it is running the program. Another
 >> >> way to put this is that Eli's initial instinct "can I find out when
 >> >> front-end/program is being called for execution?" is right, but to
 >> >> make that work it has to be codified in the language interface. This
 >> >> has already happened once and that's why we have two different
 >> >> front-end methods.
 >> >>
 >> >> Does that make sense?
 >> >
 >> > Sort of.  Does this mean that that the using the other front-end
 >> > method is the solution, or does it mean that you think that a new one
 >> > is needed?
 >> >
 >> >
 >> >> On Mon, Jul 7, 2008 at 4:21 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> >> > Actually, I know also why the second part of the problem happens --
 >> >> > because the module-language hands out a fully expanded code, so that's
 >> >> > what the macro stepper will see.
 >> >> >
 >> >> >
 >> >> > On Jul  7, Robby Findler wrote:
 >> >> >> On Mon, Jul 7, 2008 at 4:01 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> >> >> > On Jul  7, samth@ccs.neu.edu wrote:
 >> >> >> >>
 >> >> >> >> If there is an error in expansion, then only the module (module
 >> >> >> >> scheme/base (void)) is presented, fully expanded.
 >> >> >> >
 >> >> >> > Robby: is there a way to know (in `front-end/complete-program')
 >> >> >> > whether it's being used for execution or for something else?
 >> >> >>
 >> >> >> No .... if you need to know that, then something else is wrong --
 >> >> >> probably the tools interface needs to be wider somehow.
 >> >> >>
 >> >> >> Can you tell me in a little more detail how that is related to the
 >> >> >> problem at hand?
 >> >> >
 >> >> > The problem results from catching expand errors in the code, and
 >> >> > replacing it with an empty (module foo language) when that happens.
 >> >> > This whole thing (uncluding the expansion) shouldn't happen when the
 >> >> > macro debugger is used (or when check-syntax is, etc).
 >> >> >
 >> >> > * I'm not sure how to fix this -- extending the tool interface sounds
 >> >> >  wrong.  Maybe there is someplace else in the interface that can be
 >> >> >  used to do the test-expand thing?
 >> >> >
 >> >> > * Maybe it's better to change replacing the module with a minimal one
 >> >> >  by using it to initialize the namespace.  This makes me less
 >> >> >  comfortable -- what if something behaves differently when the
 >> >> >  current namespace is empty or not?
 >> >> >
 >> >> > * Finally, it makes me worry about the other parts of
 >> >> >  `front-end/complete-program' -- and when I tried adding some
 >> >> >  debugging printouts, I did get the macro stepper to show some of
 >> >> >  these extra expressions, which is completely bogus, of course.  I
 >> >> >  have no idea how they're usually hidden.
 >> >> >
 >> >> > --
 >> >> >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >> >> >                  http://www.barzilay.org/                 Maze is Life!
 >> >> >
 >> >> >
 >> >
 >> > --
 >> >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >> >                  http://www.barzilay.org/                 Maze is Life!
 >> >
 >> >
 >
 > --
 >          ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
 >                  http://www.barzilay.org/                 Maze is Life!
 >
 >
From: Eli Barzilay <eli@barzilay.org>
To: "Robby Findler" <robby@cs.uchicago.edu>
Cc: samth@ccs.neu.edu, bugs@plt-scheme.org, ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Mon, 7 Jul 2008 21:39:43 -0400

 On Jul  7, Robby Findler wrote:
 > On Mon, Jul 7, 2008 at 8:26 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > > On Jul  7, Robby Findler wrote:
 > >> If I added a new method (whose default value was to call
 > >> front-end/complete-program) then the macro stepper would be back
 > >> in shape, right?
 > >
 > > IIUC, you're suggesting some new `front-end/for-interactions'
 > > method which returns the expressions to evaluate to setup a repl,
 > > and this method will just call `front-end/complete-program'.  This
 > > means that after that's added, the module language will override
 > > this new method to add all the extra stuff that is currently added
 > > in `front-end/complete-program' right now -- and otherwise there
 > > are no changes to any existing tools, right?
 > >
 > > If this is correct, it sounds right to me -- and whatever hacks
 > > Ryan has to avoid seeing these extra expressions in the macro
 > > stepper could be removed (assuming that he has such hack), so it
 > > sounds like a good improvement.
 > 
 > That will be correct for some tools (those that use the
 > language-building mixins) but probably a few tools (those that build
 > implementations of drscheme:language:language<%> themselves) will
 > have to get one new line each.
 
 This is something that I missed last time too (when you commented that
 this is how interfaces and classes work): whenever you create a new
 language, why isn't it possible to inherit from some default language
 object that will fill in the default behavior for the many methods
 that you don't want to modify (and there's a good number of them now).
 Or if it's possible, why was it decided not to do so?
 
 
 > But yes, this will be a bonus for tools that want to just process
 > the source -- I think many tools fit into this category already and
 > we've just been lucky enough that we can work around the issues, but
 > not anymore. Check Syntax, for example, already forced me to change
 > the module language to avoid source locations in
 > front-end/complete-program, IIRC (for example).
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                   http://www.barzilay.org/                 Maze is Life!
From: "Robby Findler" <robby@cs.uchicago.edu>
To: "Eli Barzilay" <eli@barzilay.org>
Cc: samth@ccs.neu.edu, bugs@plt-scheme.org, ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Mon, 7 Jul 2008 20:44:13 -0500

 On Mon, Jul 7, 2008 at 8:39 PM, Eli Barzilay <eli@barzilay.org> wrote:
 > On Jul  7, Robby Findler wrote:
 >> On Mon, Jul 7, 2008 at 8:26 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> > On Jul  7, Robby Findler wrote:
 >> >> If I added a new method (whose default value was to call
 >> >> front-end/complete-program) then the macro stepper would be back
 >> >> in shape, right?
 >> >
 >> > IIUC, you're suggesting some new `front-end/for-interactions'
 >> > method which returns the expressions to evaluate to setup a repl,
 >> > and this method will just call `front-end/complete-program'.  This
 >> > means that after that's added, the module language will override
 >> > this new method to add all the extra stuff that is currently added
 >> > in `front-end/complete-program' right now -- and otherwise there
 >> > are no changes to any existing tools, right?
 >> >
 >> > If this is correct, it sounds right to me -- and whatever hacks
 >> > Ryan has to avoid seeing these extra expressions in the macro
 >> > stepper could be removed (assuming that he has such hack), so it
 >> > sounds like a good improvement.
 >>
 >> That will be correct for some tools (those that use the
 >> language-building mixins) but probably a few tools (those that build
 >> implementations of drscheme:language:language<%> themselves) will
 >> have to get one new line each.
 >
 > This is something that I missed last time too (when you commented that
 > this is how interfaces and classes work): whenever you create a new
 > language, why isn't it possible to inherit from some default language
 > object that will fill in the default behavior for the many methods
 > that you don't want to modify (and there's a good number of them now).
 > Or if it's possible, why was it decided not to do so?
 
 That is possible, but not required. I think I didn't do a good job
 setting up the default mixins (to be fair I didn't really know how the
 interface would take shape) and perhaps it is now time to revisit
 those mixins and make different ones.
 
 Did you get a chance to read that APLAS paper yet?
 
 Robby
From: "Sam TH" <samth@ccs.neu.edu>
To: "Robby Findler" <robby@cs.uchicago.edu>
Cc: "Eli Barzilay" <eli@barzilay.org>, bugs@plt-scheme.org,
        ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Sun, 13 Jul 2008 17:28:36 -0400

 So, I appreciate that there are hard problems here, which need good
 solutions.  But right now, the macro stepper doesn't work at all, and
 I'd like to debug some macros.  Is there some way we can fix this
 problem in the short term?
 
 Thanks,
 sam th
 
 On Mon, Jul 7, 2008 at 9:44 PM, Robby Findler <robby@cs.uchicago.edu> wrote:
 > On Mon, Jul 7, 2008 at 8:39 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >> On Jul  7, Robby Findler wrote:
 >>> On Mon, Jul 7, 2008 at 8:26 PM, Eli Barzilay <eli@barzilay.org> wrote:
 >>> > On Jul  7, Robby Findler wrote:
 >>> >> If I added a new method (whose default value was to call
 >>> >> front-end/complete-program) then the macro stepper would be back
 >>> >> in shape, right?
 >>> >
 >>> > IIUC, you're suggesting some new `front-end/for-interactions'
 >>> > method which returns the expressions to evaluate to setup a repl,
 >>> > and this method will just call `front-end/complete-program'.  This
 >>> > means that after that's added, the module language will override
 >>> > this new method to add all the extra stuff that is currently added
 >>> > in `front-end/complete-program' right now -- and otherwise there
 >>> > are no changes to any existing tools, right?
 >>> >
 >>> > If this is correct, it sounds right to me -- and whatever hacks
 >>> > Ryan has to avoid seeing these extra expressions in the macro
 >>> > stepper could be removed (assuming that he has such hack), so it
 >>> > sounds like a good improvement.
 >>>
 >>> That will be correct for some tools (those that use the
 >>> language-building mixins) but probably a few tools (those that build
 >>> implementations of drscheme:language:language<%> themselves) will
 >>> have to get one new line each.
 >>
 >> This is something that I missed last time too (when you commented that
 >> this is how interfaces and classes work): whenever you create a new
 >> language, why isn't it possible to inherit from some default language
 >> object that will fill in the default behavior for the many methods
 >> that you don't want to modify (and there's a good number of them now).
 >> Or if it's possible, why was it decided not to do so?
 >
 > That is possible, but not required. I think I didn't do a good job
 > setting up the default mixins (to be fair I didn't really know how the
 > interface would take shape) and perhaps it is now time to revisit
 > those mixins and make different ones.
 >
 > Did you get a chance to read that APLAS paper yet?
 >
 > Robby
 >
 
 
 
 -- 
 sam th
 samth@ccs.neu.edu
From: Eli Barzilay <eli@barzilay.org>
To: "Sam TH" <samth@ccs.neu.edu>
Cc: "Robby Findler" <robby@cs.uchicago.edu>, bugs@plt-scheme.org,
        ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Sun, 13 Jul 2008 17:43:57 -0400

 On Jul 13, Sam TH wrote:
 > So, I appreciate that there are hard problems here, which need good
 > solutions.  But right now, the macro stepper doesn't work at all,
 > and I'd like to debug some macros.  Is there some way we can fix
 > this problem in the short term?
 
 As a very-short-term quick & dirty solution, open your
 drscheme/private/module-language.ss, and look for
 
         (let* ([lang-only (datum->syntax stx `(,mod ,name ,lang) stx)]
                [lang-only (with-handlers ([void (? (e) #f)])
                             (expand lang-only))])
 
 and just remove the second rebinding of `lang-only'.
 
 I've talked about it with Robby, and he prefers to leave the feature
 on, so people will experience it more.  "The feature" being detecting
 when you have a syntax error and still leaving you with a working repl
 in your language.  This is until he gets to extend the interface in a
 way that has a distinction between tools that want just the program
 (syncheck and macro-stepper) and tools that want to execute it.
 
 [Robby: actually, here's another suggested stop-gap -- if the
 expansion was fine, then still return the unexpanded module code.
 This way the macro stepper continues to work, and until you do the
 above the "only" problem is that the code will be expanded twice.
 This will be slower, of course, but not suffer from the disfunctional
 macro stepper.]
 
 -- 
           ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                   http://www.barzilay.org/                 Maze is Life!
From: "Robby Findler" <robby@cs.uchicago.edu>
To: "Eli Barzilay" <eli@barzilay.org>
Cc: "Sam TH" <samth@ccs.neu.edu>, bugs@plt-scheme.org, ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Sun, 13 Jul 2008 16:45:12 -0500

 Where is Ryan?
 
 Robby
From: "Sam TH" <samth@ccs.neu.edu>
To: "Robby Findler" <robby@cs.uchicago.edu>
Cc: "Eli Barzilay" <eli@barzilay.org>, bugs@plt-scheme.org,
        ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Sun, 13 Jul 2008 18:12:26 -0400

 Ryan is working at Sun for the summer, and is (I think) unlikely to do
 much work on the macro stepper in the near future.  Obviously Ryan can
 answer that better than me though.
 
 2008/7/13 Robby Findler <robby@cs.uchicago.edu>:
 > Where is Ryan?
 >
 > Robby
 >
 
 
 
 -- 
 sam th
 samth@ccs.neu.edu
From: "Robby Findler" <robby@cs.uchicago.edu>
To: "Sam TH" <samth@ccs.neu.edu>
Cc: "Eli Barzilay" <eli@barzilay.org>, bugs@plt-scheme.org,
        ryanc@plt-scheme.org
Subject: Re: [plt-bug] all/9586: macro stepper completely broken
Date: Sun, 13 Jul 2008 17:15:54 -0500

 Well, he hasn't responded to email, so I'm kind of stuck for asking him. :)
 
 Thanks, tho. I didn't realize he was gone.
 
 Eli: this suggests to me that we go with adding a new method to the
 language interface and change the macro stepper and check syntax to
 use it. Perhaps also the debugger, I'm not sure.
 
 Do you have time for that?
 
 Robby
 
 On Sun, Jul 13, 2008 at 5:12 PM, Sam TH <samth@ccs.neu.edu> wrote:
 > Ryan is working at Sun for the summer, and is (I think) unlikely to do
 > much work on the macro stepper in the near future.  Obviously Ryan can
 > answer that better than me though.
 >
 > 2008/7/13 Robby Findler <robby@cs.uchicago.edu>:
 >> Where is Ryan?
 >>
 >> Robby
 >>
 >
 >
 >
 > --
 > sam th
 > samth@ccs.neu.edu
 >
 >

State changed from "open" to "closed" by ryanc at Sun, 15 Mar 2009 21:27:17 -0400
Reason>>> Old bug, long since fixed.


